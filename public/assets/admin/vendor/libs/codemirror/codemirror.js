/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/codemirror.js":
/*!***************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/codemirror.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict'; // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.\n\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\n  if (presto_version) {\n    presto_version = Number(presto_version[1]);\n  }\n\n  if (presto_version && presto_version >= 15) {\n    presto = false;\n    webkit = true;\n  } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\n\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || ie && ie_version >= 9;\n\n  function classTest(cls) {\n    return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n  }\n\n  var rmClass = function rmClass(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count) {\n      e.removeChild(e.firstChild);\n    }\n\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n\n    if (className) {\n      e.className = className;\n    }\n\n    if (style) {\n      e.style.cssText = style;\n    }\n\n    if (typeof content == \"string\") {\n      e.appendChild(document.createTextNode(content));\n    } else if (content) {\n      for (var i = 0; i < content.length; ++i) {\n        e.appendChild(content[i]);\n      }\n    }\n\n    return e;\n  } // wrapper for elt, which removes the elt from the accessibility tree\n\n\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e;\n  }\n\n  var range;\n\n  if (document.createRange) {\n    range = function range(node, start, end, endNode) {\n      var r = document.createRange();\n      r.setEnd(endNode || node, end);\n      r.setStart(node, start);\n      return r;\n    };\n  } else {\n    range = function range(node, start, end) {\n      var r = document.body.createTextRange();\n\n      try {\n        r.moveToElementText(node.parentNode);\n      } catch (e) {\n        return r;\n      }\n\n      r.collapse(true);\n      r.moveEnd(\"character\", end);\n      r.moveStart(\"character\", start);\n      return r;\n    };\n  }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      {\n        child = child.parentNode;\n      }\n\n    if (parent.contains) {\n      return parent.contains(child);\n    }\n\n    do {\n      if (child.nodeType == 11) {\n        child = child.host;\n      }\n\n      if (child == parent) {\n        return true;\n      }\n    } while (child = child.parentNode);\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n\n    try {\n      activeElement = document.activeElement;\n    } catch (e) {\n      activeElement = document.body || null;\n    }\n\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n      activeElement = activeElement.shadowRoot.activeElement;\n    }\n\n    return activeElement;\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n\n    if (!classTest(cls).test(current)) {\n      node.className += (current ? \" \" : \"\") + cls;\n    }\n  }\n\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n\n    for (var i = 0; i < as.length; i++) {\n      if (as[i] && !classTest(as[i]).test(b)) {\n        b += \" \" + as[i];\n      }\n    }\n\n    return b;\n  }\n\n  var selectInput = function selectInput(node) {\n    node.select();\n  };\n\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    {\n      selectInput = function selectInput(node) {\n        node.selectionStart = 0;\n        node.selectionEnd = node.value.length;\n      };\n    } else if (ie) // Suppress mysterious IE10 errors\n    {\n      selectInput = function selectInput(node) {\n        try {\n          node.select();\n        } catch (_e) {}\n      };\n    }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return f.apply(null, args);\n    };\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) {\n      target = {};\n    }\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n        target[prop] = obj[prop];\n      }\n    }\n\n    return target;\n  } // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n\n\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n\n      if (end == -1) {\n        end = string.length;\n      }\n    }\n\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n\n      if (nextTab < 0 || nextTab >= end) {\n        return n + (end - i);\n      }\n\n      n += nextTab - i;\n      n += tabSize - n % tabSize;\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function Delayed() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n\n    if (self.time <= +new Date()) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date());\n    }\n  };\n\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date() + ms;\n\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i) {\n      if (array[i] == elt) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // Number of pixels added to scroller and sizer to hide scrollbar\n\n\n  var scrollerGap = 50; // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n\n  var Pass = {\n    toString: function toString() {\n      return \"CodeMirror.Pass\";\n    }\n  }; // Reused option objects for setSelection & friends\n\n  var sel_dontScroll = {\n    scroll: false\n  },\n      sel_mouse = {\n    origin: \"*mouse\"\n  },\n      sel_move = {\n    origin: \"+move\"\n  }; // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n\n      if (nextTab == -1) {\n        nextTab = string.length;\n      }\n\n      var skipped = nextTab - pos;\n\n      if (nextTab == string.length || col + skipped >= goal) {\n        return pos + Math.min(skipped, goal - col);\n      }\n\n      col += nextTab - pos;\n      col += tabSize - col % tabSize;\n      pos = nextTab + 1;\n\n      if (col >= goal) {\n        return pos;\n      }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n\n  function spaceStr(n) {\n    while (spaceStrs.length <= n) {\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    }\n\n    return spaceStrs[n];\n  }\n\n  function lst(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function map(array, f) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = f(array[i], i);\n    }\n\n    return out;\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0,\n        priority = score(value);\n\n    while (pos < array.length && score(array[pos]) <= priority) {\n      pos++;\n    }\n\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n\n    if (props) {\n      copyObj(props, inst);\n    }\n\n    return inst;\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isWordChar(ch, helper) {\n    if (!helper) {\n      return isWordCharBasic(ch);\n    }\n\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) {\n      return true;\n    }\n\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) {\n      if (obj.hasOwnProperty(n) && obj[n]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\n  function isExtendingChar(ch) {\n    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n  } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n\n\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n      pos += dir;\n    }\n\n    return pos;\n  } // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n\n\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n\n    for (;;) {\n      if (from == to) {\n        return from;\n      }\n\n      var midF = (from + to) / 2,\n          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n\n      if (mid == from) {\n        return pred(mid) ? from : to;\n      }\n\n      if (pred(mid)) {\n        to = mid;\n      } else {\n        from = mid + dir;\n      }\n    }\n  } // BIDI HELPERS\n\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) {\n      return f(from, to, \"ltr\", 0);\n    }\n\n    var found = false;\n\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n\n    if (!found) {\n      f(from, to, \"ltr\");\n    }\n  }\n\n  var bidiOther = null;\n\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n\n      if (cur.from < ch && cur.to > ch) {\n        return i;\n      }\n\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n    }\n\n    return found != null ? found : bidiOther;\n  } // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n\n\n  var bidiOrdering = function () {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\"; // Character types for codepoints 0x600 to 0x6f9\n\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n\n    function charType(code) {\n      if (code <= 0xf7) {\n        return lowTypes.charAt(code);\n      } else if (0x590 <= code && code <= 0x5f4) {\n        return \"R\";\n      } else if (0x600 <= code && code <= 0x6f9) {\n        return arabicTypes.charAt(code - 0x600);\n      } else if (0x6ee <= code && code <= 0x8ac) {\n        return \"r\";\n      } else if (0x2000 <= code && code <= 0x200b) {\n        return \"w\";\n      } else if (code == 0x200c) {\n        return \"b\";\n      } else {\n        return \"L\";\n      }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/,\n        isStrong = /[LRr]/,\n        countsAsLeft = /[Lb1n]/,\n        countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from;\n      this.to = to;\n    }\n\n    return function (str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) {\n        return false;\n      }\n\n      var len = str.length,\n          types = [];\n\n      for (var i = 0; i < len; ++i) {\n        types.push(charType(str.charCodeAt(i)));\n      } // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n\n\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n\n        if (type == \"m\") {\n          types[i$1] = prev;\n        } else {\n          prev = type;\n        }\n      } // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n\n\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n\n        if (type$1 == \"1\" && cur == \"r\") {\n          types[i$2] = \"n\";\n        } else if (isStrong.test(type$1)) {\n          cur = type$1;\n\n          if (type$1 == \"r\") {\n            types[i$2] = \"R\";\n          }\n        }\n      } // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n\n\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3 + 1] == \"1\") {\n          types[i$3] = \"1\";\n        } else if (type$2 == \",\" && prev$1 == types[i$3 + 1] && (prev$1 == \"1\" || prev$1 == \"n\")) {\n          types[i$3] = prev$1;\n        }\n\n        prev$1 = type$2;\n      } // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n\n\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n\n        if (type$3 == \",\") {\n          types[i$4] = \"N\";\n        } else if (type$3 == \"%\") {\n          var end = void 0;\n\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n\n          var replace = i$4 && types[i$4 - 1] == \"!\" || end < len && types[end] == \"1\" ? \"1\" : \"N\";\n\n          for (var j = i$4; j < end; ++j) {\n            types[j] = replace;\n          }\n\n          i$4 = end - 1;\n        }\n      } // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n\n\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n\n        if (cur$1 == \"L\" && type$4 == \"1\") {\n          types[i$5] = \"L\";\n        } else if (isStrong.test(type$4)) {\n          cur$1 = type$4;\n        }\n      } // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n\n\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = void 0;\n\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n\n          var before = (i$6 ? types[i$6 - 1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? before ? \"L\" : \"R\" : outerType;\n\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n            types[j$1] = replace$1;\n          }\n\n          i$6 = end$1 - 1;\n        }\n      } // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n\n\n      var order = [],\n          m;\n\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7,\n              at = order.length,\n              isRTL = direction == \"rtl\" ? 1 : 0;\n\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) {\n                order.splice(at, 0, new BidiSpan(1, pos, j$2));\n                at += isRTL;\n              }\n\n              var nstart = j$2;\n\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else {\n              ++j$2;\n            }\n          }\n\n          if (pos < i$7) {\n            order.splice(at, 0, new BidiSpan(1, pos, i$7));\n          }\n        }\n      }\n\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order;\n    };\n  }(); // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n\n\n  function getOrder(line, direction) {\n    var order = line.order;\n\n    if (order == null) {\n      order = line.order = bidiOrdering(line.text, direction);\n    }\n\n    return order;\n  } // EVENT HANDLING\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n\n  var noHandlers = [];\n\n  var on = function on(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers;\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers,\n          arr = map && map[type];\n\n      if (arr) {\n        var index = indexOf(arr, f);\n\n        if (index > -1) {\n          map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n        }\n      }\n    }\n  }\n\n  function signal(emitter, type\n  /*, values...*/\n  ) {\n    var handlers = getHandlers(emitter, type);\n\n    if (!handlers.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    for (var i = 0; i < handlers.length; ++i) {\n      handlers[i].apply(null, args);\n    }\n  } // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n\n\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\") {\n      e = {\n        type: e,\n        preventDefault: function preventDefault() {\n          this.defaultPrevented = true;\n        }\n      };\n    }\n\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n\n    if (!arr) {\n      return;\n    }\n\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\n    for (var i = 0; i < arr.length; ++i) {\n      if (indexOf(set, arr[i]) == -1) {\n        set.push(arr[i]);\n      }\n    }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0;\n  } // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function (type, f) {\n      on(this, type, f);\n    };\n\n    ctor.prototype.off = function (type, f) {\n      off(this, type, f);\n    };\n  } // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n  }\n\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  }\n\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n\n  function e_stop(e) {\n    e_preventDefault(e);\n    e_stopPropagation(e);\n  }\n\n  function e_target(e) {\n    return e.target || e.srcElement;\n  }\n\n  function e_button(e) {\n    var b = e.which;\n\n    if (b == null) {\n      if (e.button & 1) {\n        b = 1;\n      } else if (e.button & 2) {\n        b = 3;\n      } else if (e.button & 4) {\n        b = 2;\n      }\n    }\n\n    if (mac && e.ctrlKey && b == 1) {\n      b = 3;\n    }\n\n    return b;\n  } // Detect drag-and-drop\n\n\n  var dragAndDrop = function () {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) {\n      return false;\n    }\n\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200B\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\n      if (measure.firstChild.offsetHeight != 0) {\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n      }\n    }\n\n    var node = zwspSupported ? elt(\"span\", \"\\u200B\") : elt(\"span\", \"\\xA0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  } // Feature-detect IE's crummy client rect reporting for bidi text\n\n\n  var badBidiRects;\n\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) {\n      return badBidiRects;\n    }\n\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062EA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n\n    if (!r0 || r0.left == r0.right) {\n      return false;\n    } // Safari returns null in some cases (#2780)\n\n\n    return badBidiRects = r1.right - r0.right < 3;\n  } // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n\n\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0,\n        result = [],\n        l = string.length;\n\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n\n      if (nl == -1) {\n        nl = string.length;\n      }\n\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n\n    return result;\n  } : function (string) {\n    return string.split(/\\r\\n?|\\n/);\n  };\n  var hasSelection = window.getSelection ? function (te) {\n    try {\n      return te.selectionStart != te.selectionEnd;\n    } catch (e) {\n      return false;\n    }\n  } : function (te) {\n    var range;\n\n    try {\n      range = te.ownerDocument.selection.createRange();\n    } catch (e) {}\n\n    if (!range || range.parentElement() != te) {\n      return false;\n    }\n\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = function () {\n    var e = elt(\"div\");\n\n    if (\"oncopy\" in e) {\n      return true;\n    }\n\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  }();\n\n  var badZoomedRects = null;\n\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) {\n      return badZoomedRects;\n    }\n\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  } // Known modes, by name and by MIME\n\n\n  var modes = {},\n      mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  function defineMode(name, mode) {\n    if (arguments.length > 2) {\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    }\n\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  } // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n\n\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n\n      if (typeof found == \"string\") {\n        found = {\n          name: found\n        };\n      }\n\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\");\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\");\n    }\n\n    if (typeof spec == \"string\") {\n      return {\n        name: spec\n      };\n    } else {\n      return spec || {\n        name: \"null\"\n      };\n    }\n  } // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n\n\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n\n    if (!mfactory) {\n      return getMode(options, \"text/plain\");\n    }\n\n    var modeObj = mfactory(options, spec);\n\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (modeObj.hasOwnProperty(prop)) {\n          modeObj[\"_\" + prop] = modeObj[prop];\n        }\n\n        modeObj[prop] = exts[prop];\n      }\n    }\n\n    modeObj.name = spec.name;\n\n    if (spec.helperType) {\n      modeObj.helperType = spec.helperType;\n    }\n\n    if (spec.modeProps) {\n      for (var prop$1 in spec.modeProps) {\n        modeObj[prop$1] = spec.modeProps[prop$1];\n      }\n    }\n\n    return modeObj;\n  } // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n\n\n  var modeExtensions = {};\n\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) {\n      return state;\n    }\n\n    if (mode.copyState) {\n      return mode.copyState(state);\n    }\n\n    var nstate = {};\n\n    for (var n in state) {\n      var val = state[n];\n\n      if (val instanceof Array) {\n        val = val.concat([]);\n      }\n\n      nstate[n] = val;\n    }\n\n    return nstate;\n  } // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n\n\n  function innerMode(mode, state) {\n    var info;\n\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n\n      if (!info || info.mode == mode) {\n        break;\n      }\n\n      state = info.state;\n      mode = info.mode;\n    }\n\n    return info || {\n      mode: mode,\n      state: state\n    };\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  } // STRING STREAM\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n\n  var StringStream = function StringStream(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {\n    return this.pos >= this.string.length;\n  };\n\n  StringStream.prototype.sol = function () {\n    return this.pos == this.lineStart;\n  };\n\n  StringStream.prototype.peek = function () {\n    return this.string.charAt(this.pos) || undefined;\n  };\n\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length) {\n      return this.string.charAt(this.pos++);\n    }\n  };\n\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n\n    if (typeof match == \"string\") {\n      ok = ch == match;\n    } else {\n      ok = ch && (match.test ? match.test(ch) : match(ch));\n    }\n\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  };\n\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n\n    while (this.eat(match)) {}\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n      ++this.pos;\n    }\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.skipToEnd = function () {\n    this.pos = this.string.length;\n  };\n\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  };\n\n  StringStream.prototype.backUp = function (n) {\n    this.pos -= n;\n  };\n\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function cased(str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n\n      var substr = this.string.substr(this.pos, pattern.length);\n\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) {\n          this.pos += pattern.length;\n        }\n\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n\n      if (match && match.index > 0) {\n        return null;\n      }\n\n      if (match && consume !== false) {\n        this.pos += match[0].length;\n      }\n\n      return match;\n    }\n  };\n\n  StringStream.prototype.current = function () {\n    return this.string.slice(this.start, this.pos);\n  };\n\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  };\n\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n);\n  };\n\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos);\n  }; // Find the line object corresponding to the given line number.\n\n\n  function getLine(doc, n) {\n    n -= doc.first;\n\n    if (n < 0 || n >= doc.size) {\n      throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    }\n\n    var chunk = doc;\n\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i],\n            sz = child.chunkSize();\n\n        if (n < sz) {\n          chunk = child;\n          break;\n        }\n\n        n -= sz;\n      }\n    }\n\n    return chunk.lines[n];\n  } // Get the part of a document between two positions, as an array of\n  // strings.\n\n\n  function getBetween(doc, start, end) {\n    var out = [],\n        n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n\n      if (n == end.line) {\n        text = text.slice(0, end.ch);\n      }\n\n      if (n == start.line) {\n        text = text.slice(start.ch);\n      }\n\n      out.push(text);\n      ++n;\n    });\n    return out;\n  } // Get the lines between from and to, as array of strings.\n\n\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) {\n      out.push(line.text);\n    }); // iter aborts when callback returns truthy value\n\n    return out;\n  } // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n\n    if (diff) {\n      for (var n = line; n; n = n.parent) {\n        n.height += diff;\n      }\n    }\n  } // Given a line object, find its line number by walking up through\n  // its parent links.\n\n\n  function lineNo(line) {\n    if (line.parent == null) {\n      return null;\n    }\n\n    var cur = line.parent,\n        no = indexOf(cur.lines, line);\n\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) {\n          break;\n        }\n\n        no += chunk.children[i].chunkSize();\n      }\n    }\n\n    return no + cur.first;\n  } // Find the line at the given vertical position, using the height\n  // information in the document tree.\n\n\n  function _lineAtHeight(chunk, h) {\n    var n = chunk.first;\n\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1],\n            ch = child.height;\n\n        if (h < ch) {\n          chunk = child;\n          continue outer;\n        }\n\n        h -= ch;\n        n += child.chunkSize();\n      }\n\n      return n;\n    } while (!chunk.lines);\n\n    var i = 0;\n\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i],\n          lh = line.height;\n\n      if (h < lh) {\n        break;\n      }\n\n      h -= lh;\n    }\n\n    return n + i;\n  }\n\n  function isLine(doc, l) {\n    return l >= doc.first && l < doc.first + doc.size;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  } // A Pos instance represents a position within the text.\n\n\n  function Pos(line, ch, sticky) {\n    if (sticky === void 0) sticky = null;\n\n    if (!(this instanceof Pos)) {\n      return new Pos(line, ch, sticky);\n    }\n\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  } // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n\n\n  function cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n  }\n\n  function equalCursorPos(a, b) {\n    return a.sticky == b.sticky && cmp(a, b) == 0;\n  }\n\n  function copyPos(x) {\n    return Pos(x.line, x.ch);\n  }\n\n  function maxPos(a, b) {\n    return cmp(a, b) < 0 ? b : a;\n  }\n\n  function minPos(a, b) {\n    return cmp(a, b) < 0 ? a : b;\n  } // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n\n\n  function clipLine(doc, n) {\n    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n  }\n\n  function _clipPos(doc, pos) {\n    if (pos.line < doc.first) {\n      return Pos(doc.first, 0);\n    }\n\n    var last = doc.first + doc.size - 1;\n\n    if (pos.line > last) {\n      return Pos(last, getLine(doc, last).text.length);\n    }\n\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n\n    if (ch == null || ch > linelen) {\n      return Pos(pos.line, linelen);\n    } else if (ch < 0) {\n      return Pos(pos.line, 0);\n    } else {\n      return pos;\n    }\n  }\n\n  function clipPosArray(doc, array) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = _clipPos(doc, array[i]);\n    }\n\n    return out;\n  }\n\n  var SavedContext = function SavedContext(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function Context(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n\n    if (line != null && n > this.maxLookAhead) {\n      this.maxLookAhead = n;\n    }\n\n    return line;\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) {\n      return null;\n    }\n\n    while (this.baseTokens[this.baseTokenPos] <= n) {\n      this.baseTokenPos += 2;\n    }\n\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {\n      type: type && type.replace(/( |^)overlay .*/, \"\"),\n      size: this.baseTokens[this.baseTokenPos] - n\n    };\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n\n    if (this.maxLookAhead > 0) {\n      this.maxLookAhead--;\n    }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext) {\n      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n    } else {\n      return new Context(doc, copyState(doc.mode, saved), line);\n    }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n  }; // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n\n\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen],\n        lineClasses = {}; // Compute the base array of styles\n\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {\n      return st.push(end, style);\n    }, lineClasses, forceToEnd);\n    var state = context.state; // Run overlays, adjust style array.\n\n    var loop = function loop(o) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o],\n          i = 1,\n          at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i; // Ensure there's a token end at the current position, and that i points at it\n\n        while (at < end) {\n          var i_end = st[i];\n\n          if (i_end > end) {\n            st.splice(i, 1, end, st[i + 1], i_end);\n          }\n\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n\n        if (!style) {\n          return;\n        }\n\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start + 1];\n            st[start + 1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      loop(o);\n    }\n\n    return {\n      styles: st,\n      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n    };\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n\n      if (resetState) {\n        context.state = resetState;\n      }\n\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n\n      if (result.classes) {\n        line.styleClasses = result.classes;\n      } else if (line.styleClasses) {\n        line.styleClasses = null;\n      }\n\n      if (updateFrontier === cm.doc.highlightFrontier) {\n        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n      }\n    }\n\n    return line.styles;\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc,\n        display = cm.display;\n\n    if (!doc.mode.startState) {\n      return new Context(doc, true, n);\n    }\n\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n\n    if (precise) {\n      doc.modeFrontier = context.line;\n    }\n\n    return context;\n  } // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n\n\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n\n    if (text == \"\") {\n      callBlankLine(mode, context.state);\n    }\n\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) {\n      return mode.blankLine(state);\n    }\n\n    if (!mode.innerMode) {\n      return;\n    }\n\n    var inner = innerMode(mode, state);\n\n    if (inner.mode.blankLine) {\n      return inner.mode.blankLine(inner.state);\n    }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) {\n        inner[0] = innerMode(mode, state).mode;\n      }\n\n      var style = mode.token(stream, state);\n\n      if (stream.pos > stream.start) {\n        return style;\n      }\n    }\n\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  var Token = function Token(stream, type, state) {\n    this.start = stream.start;\n    this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  }; // Utility for getTokenAt and getLineTokens\n\n\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc,\n        mode = doc.mode,\n        style;\n    pos = _clipPos(doc, pos);\n    var line = getLine(doc, pos.line),\n        context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context),\n        tokens;\n\n    if (asArray) {\n      tokens = [];\n    }\n\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n\n      if (asArray) {\n        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n      }\n    }\n\n    return asArray ? tokens : new Token(stream, style, context.state);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) {\n      for (;;) {\n        var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\n        if (!lineClass) {\n          break;\n        }\n\n        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n        var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\n        if (output[prop] == null) {\n          output[prop] = lineClass[2];\n        } else if (!new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\").test(output[prop])) {\n          output[prop] += \" \" + lineClass[2];\n        }\n      }\n    }\n\n    return type;\n  } // Run the given mode's parser over a line, calling f for each token.\n\n\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n\n    if (flattenSpans == null) {\n      flattenSpans = cm.options.flattenSpans;\n    }\n\n    var curStart = 0,\n        curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context),\n        style;\n    var inner = cm.options.addModeClass && [null];\n\n    if (text == \"\") {\n      extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n    }\n\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n\n        if (forceToEnd) {\n          processLine(cm, text, context, stream.pos);\n        }\n\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n\n      if (inner) {\n        var mName = inner[0].name;\n\n        if (mName) {\n          style = \"m-\" + (style ? mName + \" \" + style : mName);\n        }\n      }\n\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n\n        curStyle = style;\n      }\n\n      stream.start = stream.pos;\n    }\n\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  } // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n\n\n  function findStartLine(cm, n, precise) {\n    var minindent,\n        minline,\n        doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) {\n        return doc.first;\n      }\n\n      var line = getLine(doc, search - 1),\n          after = line.stateAfter;\n\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n        return search;\n      }\n\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n\n    return minline;\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n\n    if (doc.highlightFrontier < n - 10) {\n      return;\n    }\n\n    var start = doc.first;\n\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter; // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break;\n      }\n    }\n\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  } // Optimize some code when these features are not used.\n\n\n  var sawReadOnlySpans = false,\n      sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  } // TEXTMARKER SPANS\n\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from;\n    this.to = to;\n  } // Search an array of spans for a span matching the given marker.\n\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) {\n      for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n\n        if (span.marker == marker) {\n          return span;\n        }\n      }\n    }\n  } // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n\n\n  function removeMarkedSpan(spans, span) {\n    var r;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i] != span) {\n        (r || (r = [])).push(spans[i]);\n      }\n    }\n\n    return r;\n  } // Add a span to a line.\n\n\n  function addMarkedSpan(line, span, op) {\n    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));\n\n    if (inThisOp && inThisOp.has(line.markedSpans)) {\n      line.markedSpans.push(span);\n    } else {\n      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\n      if (inThisOp) {\n        inThisOp.add(line.markedSpans);\n      }\n    }\n\n    span.marker.attachLine(line);\n  } // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\n        if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n        }\n      }\n    }\n\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\n        if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n        }\n      }\n    }\n\n    return nw;\n  } // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n\n\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) {\n      return null;\n    }\n\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\n    if (!oldFirst && !oldLast) {\n      return null;\n    }\n\n    var startCh = change.from.ch,\n        endCh = change.to.ch,\n        isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides\n\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends\n\n    var sameLine = change.text.length == 1,\n        offset = lst(change.text).length + (sameLine ? startCh : 0);\n\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n\n          if (!found) {\n            span.to = startCh;\n          } else if (sameLine) {\n            span.to = found.to == null ? null : found.to + offset;\n          }\n        }\n      }\n    }\n\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n\n        if (span$1.to != null) {\n          span$1.to += offset;\n        }\n\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n\n          if (!found$1) {\n            span$1.from = offset;\n\n            if (sameLine) {\n              (first || (first = [])).push(span$1);\n            }\n          }\n        } else {\n          span$1.from += offset;\n\n          if (sameLine) {\n            (first || (first = [])).push(span$1);\n          }\n        }\n      }\n    } // Make sure we didn't create any zero-length spans\n\n\n    if (first) {\n      first = clearEmptySpans(first);\n    }\n\n    if (last && last != first) {\n      last = clearEmptySpans(last);\n    }\n\n    var newMarkers = [first];\n\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2,\n          gapMarkers;\n\n      if (gap > 0 && first) {\n        for (var i$2 = 0; i$2 < first.length; ++i$2) {\n          if (first[i$2].to == null) {\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));\n          }\n        }\n      }\n\n      for (var i$3 = 0; i$3 < gap; ++i$3) {\n        newMarkers.push(gapMarkers);\n      }\n\n      newMarkers.push(last);\n    }\n\n    return newMarkers;\n  } // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n        spans.splice(i--, 1);\n      }\n    }\n\n    if (!spans.length) {\n      return null;\n    }\n\n    return spans;\n  } // Used to 'clip' out readOnly ranges when making a change.\n\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var mark = line.markedSpans[i].marker;\n\n          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n            (markers || (markers = [])).push(mark);\n          }\n        }\n      }\n    });\n\n    if (!markers) {\n      return null;\n    }\n\n    var parts = [{\n      from: from,\n      to: to\n    }];\n\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i],\n          m = mk.find(0);\n\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n          continue;\n        }\n\n        var newParts = [j, 1],\n            dfrom = cmp(p.from, m.from),\n            dto = cmp(p.to, m.to);\n\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n          newParts.push({\n            from: p.from,\n            to: m.from\n          });\n        }\n\n        if (dto > 0 || !mk.inclusiveRight && !dto) {\n          newParts.push({\n            from: m.to,\n            to: p.to\n          });\n        }\n\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n\n    return parts;\n  } // Connect or disconnect spans from a line.\n\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.detachLine(line);\n    }\n\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.attachLine(line);\n    }\n\n    line.markedSpans = spans;\n  } // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n\n\n  function extraLeft(marker) {\n    return marker.inclusiveLeft ? -1 : 0;\n  }\n\n  function extraRight(marker) {\n    return marker.inclusiveRight ? 1 : 0;\n  } // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n\n    if (lenDiff != 0) {\n      return lenDiff;\n    }\n\n    var aPos = a.find(),\n        bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\n    if (fromCmp) {\n      return -fromCmp;\n    }\n\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\n    if (toCmp) {\n      return toCmp;\n    }\n\n    return b.id - a.id;\n  } // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  function collapsedSpanAtStart(line) {\n    return collapsedSpanAtSide(line, true);\n  }\n\n  function collapsedSpanAtEnd(line) {\n    return collapsedSpanAtSide(line, false);\n  }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  } // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        var found = sp.marker.find(0);\n        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\n        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n          continue;\n        }\n\n        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n          return true;\n        }\n      }\n    }\n  } // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n\n\n  function visualLine(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtStart(line)) {\n      line = merged.find(-1, true).line;\n    }\n\n    return line;\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return line;\n  } // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n\n\n  function visualLineContinued(line) {\n    var merged, lines;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n\n    return lines;\n  } // Get the line number of the start of the visual line that the\n  // given line number is part of.\n\n\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN),\n        vis = visualLine(line);\n\n    if (line == vis) {\n      return lineN;\n    }\n\n    return lineNo(vis);\n  } // Get the line number of the start of the next visual line after\n  // the given line.\n\n\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) {\n      return lineN;\n    }\n\n    var line = getLine(doc, lineN),\n        merged;\n\n    if (!lineIsHidden(doc, line)) {\n      return lineN;\n    }\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return lineNo(line) + 1;\n  } // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        if (sp.from == null) {\n          return true;\n        }\n\n        if (sp.marker.widgetNode) {\n          continue;\n        }\n\n        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n\n    if (span.marker.inclusiveRight && span.to == line.text.length) {\n      return true;\n    }\n\n    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n        return true;\n      }\n    }\n  } // Find the height above the given line.\n\n\n  function _heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n    var h = 0,\n        chunk = lineObj.parent;\n\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n\n      if (line == lineObj) {\n        break;\n      } else {\n        h += line.height;\n      }\n    }\n\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n\n        if (cur == chunk) {\n          break;\n        } else {\n          h += cur.height;\n        }\n      }\n    }\n\n    return h;\n  } // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n\n\n  function lineLength(line) {\n    if (line.height == 0) {\n      return 0;\n    }\n\n    var len = line.text.length,\n        merged,\n        cur = line;\n\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n\n    cur = line;\n\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n\n    return len;\n  } // Find the longest line in the document.\n\n\n  function findMaxLine(cm) {\n    var d = cm.display,\n        doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  } // LINE DATA STRUCTURE\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n\n\n  var Line = function Line(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () {\n    return lineNo(this);\n  };\n\n  eventMixin(Line); // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    if (line.styles) {\n      line.styles = null;\n    }\n\n    if (line.order != null) {\n      line.order = null;\n    }\n\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\n    if (estHeight != line.height) {\n      updateLineHeight(line, estHeight);\n    }\n  } // Detach a line from the document tree and its markers.\n\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  } // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n\n\n  var styleToClassCache = {},\n      styleToClassCacheWithMode = {};\n\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) {\n      return null;\n    }\n\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] || (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  } // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n\n\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {\n      pre: eltP(\"pre\", [content], \"CodeMirror-line\"),\n      content: content,\n      col: 0,\n      pos: 0,\n      cm: cm,\n      trailingSpace: false,\n      splitSpaces: cm.getOption(\"lineWrapping\")\n    };\n    lineView.measure = {}; // Iterate over the logical lines that make up this visual line.\n\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line,\n          order = void 0;\n      builder.pos = 0;\n      builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      }\n\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass) {\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        }\n\n        if (line.styleClasses.textClass) {\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n        }\n      } // Ensure at least a single node is present, for measuring.\n\n\n      if (builder.map.length == 0) {\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n      } // Store the map and a cache object for the current logical line\n\n\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    } // See issue #2901\n\n\n    if (webkit) {\n      var last = builder.content.lastChild;\n\n      if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(\".cm-tab\")) {\n        builder.content.className = \"cm-tab-wrap-hack\";\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\n    if (builder.pre.className) {\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n    }\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  } // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n\n\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) {\n      return;\n    }\n\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars,\n        mustWrap = false;\n    var content;\n\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n\n      if (ie && ie_version < 9) {\n        mustWrap = true;\n      }\n\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt]));\n          } else {\n            content.appendChild(txt);\n          }\n\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n\n        if (!m) {\n          break;\n        }\n\n        pos += skipped + 1;\n        var txt$1 = void 0;\n\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize,\n              tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240D\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt$1]));\n          } else {\n            content.appendChild(txt$1);\n          }\n\n          builder.col += 1;\n        }\n\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n\n      if (startStyle) {\n        fullStyle += startStyle;\n      }\n\n      if (endStyle) {\n        fullStyle += endStyle;\n      }\n\n      var token = elt(\"span\", [content], fullStyle, css);\n\n      if (attributes) {\n        for (var attr in attributes) {\n          if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\") {\n            token.setAttribute(attr, attributes[attr]);\n          }\n        }\n      }\n\n      return builder.content.appendChild(token);\n    }\n\n    builder.content.appendChild(content);\n  } // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n\n\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) {\n      return text;\n    }\n\n    var spaceBefore = trailingBefore,\n        result = \"\";\n\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {\n        ch = \"\\xA0\";\n      }\n\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n\n    return result;\n  } // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n\n\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos,\n          end = start + text.length;\n\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = void 0;\n\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n\n          if (part.to > start && part.from <= start) {\n            break;\n          }\n        }\n\n        if (part.to >= end) {\n          return inner(builder, text, style, startStyle, endStyle, css, attributes);\n        }\n\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n\n    if (widget) {\n      builder.map.push(builder.pos, builder.pos + size, widget);\n    }\n\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget) {\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      }\n\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n\n    builder.pos += size;\n    builder.trailingSpace = false;\n  } // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n\n\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans,\n        allText = line.text,\n        at = 0;\n\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {\n        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));\n      }\n\n      return;\n    }\n\n    var len = allText.length,\n        pos = 0,\n        i = 1,\n        text = \"\",\n        style,\n        css;\n    var nextChange = 0,\n        spanStyle,\n        spanEndStyle,\n        spanStartStyle,\n        collapsed,\n        attributes;\n\n    for (;;) {\n      if (nextChange == pos) {\n        // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null;\n        nextChange = Infinity;\n        var foundBookmarks = [],\n            endStyles = void 0;\n\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j],\n              m = sp.marker;\n\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n\n            if (m.className) {\n              spanStyle += \" \" + m.className;\n            }\n\n            if (m.css) {\n              css = (css ? css + \";\" : \"\") + m.css;\n            }\n\n            if (m.startStyle && sp.from == pos) {\n              spanStartStyle += \" \" + m.startStyle;\n            }\n\n            if (m.endStyle && sp.to == nextChange) {\n              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n            } // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n\n\n            if (m.title) {\n              (attributes || (attributes = {})).title = m.title;\n            }\n\n            if (m.attributes) {\n              for (var attr in m.attributes) {\n                (attributes || (attributes = {}))[attr] = m.attributes[attr];\n              }\n            }\n\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n              collapsed = sp;\n            }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n\n        if (endStyles) {\n          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n            if (endStyles[j$1 + 1] == nextChange) {\n              spanEndStyle += \" \" + endStyles[j$1];\n            }\n          }\n        }\n\n        if (!collapsed || collapsed.from == pos) {\n          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n          }\n        }\n\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n\n          if (collapsed.to == null) {\n            return;\n          }\n\n          if (collapsed.to == pos) {\n            collapsed = false;\n          }\n        }\n      }\n\n      if (pos >= len) {\n        break;\n      }\n\n      var upto = Math.min(len, nextChange);\n\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n\n          if (end >= upto) {\n            text = text.slice(upto - pos);\n            pos = upto;\n            break;\n          }\n\n          pos = end;\n          spanStartStyle = \"\";\n        }\n\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  } // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n\n\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line; // Continuing lines, if any\n\n    this.rest = visualLineContinued(line); // Number of logical lines in this visual line\n\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  } // Create a range of LineView objects for the given lines.\n\n\n  function buildViewArray(cm, from, to) {\n    var array = [],\n        nextPos;\n\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n\n    return array;\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks,\n        i = 0;\n\n    do {\n      for (; i < callbacks.length; i++) {\n        callbacks[i].call(null);\n      }\n\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n\n        if (op.cursorActivityHandlers) {\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n          }\n        }\n      }\n    } while (i < callbacks.length);\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n\n    if (!group) {\n      return;\n    }\n\n    try {\n      fireCallbacksForOps(group);\n    } finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n\n  function signalLater(emitter, type\n  /*, values...*/\n  ) {\n    var arr = getHandlers(emitter, type);\n\n    if (!arr.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2),\n        list;\n\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n\n    var loop = function loop(i) {\n      list.push(function () {\n        return arr[i].apply(null, args);\n      });\n    };\n\n    for (var i = 0; i < arr.length; ++i) {\n      loop(i);\n    }\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n\n    for (var i = 0; i < delayed.length; ++i) {\n      delayed[i]();\n    }\n  } // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n\n\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n\n      if (type == \"text\") {\n        updateLineText(cm, lineView);\n      } else if (type == \"gutter\") {\n        updateLineGutter(cm, lineView, lineN, dims);\n      } else if (type == \"class\") {\n        updateLineClasses(cm, lineView);\n      } else if (type == \"widget\") {\n        updateLineWidgets(cm, lineView, dims);\n      }\n    }\n\n    lineView.changes = null;\n  } // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n\n\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\n      if (lineView.text.parentNode) {\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      }\n\n      lineView.node.appendChild(lineView.text);\n\n      if (ie && ie_version < 8) {\n        lineView.node.style.zIndex = 2;\n      }\n    }\n\n    return lineView.node;\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\n    if (cls) {\n      cls += \" CodeMirror-linebackground\";\n    }\n\n    if (lineView.background) {\n      if (cls) {\n        lineView.background.className = cls;\n      } else {\n        lineView.background.parentNode.removeChild(lineView.background);\n        lineView.background = null;\n      }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  } // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n\n\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n\n    return buildLineContent(cm, lineView);\n  } // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n\n\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n\n    if (lineView.text == lineView.node) {\n      lineView.node = built.pre;\n    }\n\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n\n    if (lineView.line.wrapClass) {\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    } else if (lineView.node != lineView.text) {\n      lineView.node.className = \"\";\n    }\n\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass, \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n\n    var markers = lineView.line.gutterMarkers;\n\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n\n      if (lineView.line.gutterClass) {\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      }\n\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) {\n        lineView.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineN), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + cm.display.lineNumInnerWidth + \"px\"));\n      }\n\n      if (markers) {\n        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n          var id = cm.display.gutterSpecs[k].className,\n              found = markers.hasOwnProperty(id) && markers[id];\n\n          if (found) {\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n          }\n        }\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) {\n      lineView.alignable = null;\n    }\n\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n\n    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n      next = node.nextSibling;\n\n      if (isWidget.test(node.className)) {\n        lineView.node.removeChild(node);\n      }\n    }\n\n    insertLineWidgets(cm, lineView, dims);\n  } // Build a line's DOM representation from scratch\n\n\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n\n    if (built.bgClass) {\n      lineView.bgClass = built.bgClass;\n    }\n\n    if (built.textClass) {\n      lineView.textClass = built.textClass;\n    }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  } // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n\n\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++) {\n        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n      }\n    }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) {\n      return;\n    }\n\n    var wrap = ensureLineWrapped(lineView);\n\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i],\n          node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n\n      if (!widget.handleMouseEvents) {\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n\n      if (allowAbove && widget.above) {\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      } else {\n        wrap.appendChild(node);\n      }\n\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n\n      node.style.width = width + \"px\";\n    }\n\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n\n      if (!widget.noHScroll) {\n        node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n      }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) {\n      return widget.height;\n    }\n\n    var cm = widget.doc.cm;\n\n    if (!cm) {\n      return 0;\n    }\n\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n\n      if (widget.coverGutter) {\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      }\n\n      if (widget.noHScroll) {\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      }\n\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n\n    return widget.height = widget.node.parentNode.offsetHeight;\n  } // Return true when the given mouse event happened in a widget\n\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\" || n.parentNode == display.sizer && n != display.mover) {\n        return true;\n      }\n    }\n  } // POSITION MEASUREMENT\n\n\n  function paddingTop(display) {\n    return display.lineSpace.offsetTop;\n  }\n\n  function paddingVert(display) {\n    return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n  }\n\n  function paddingH(display) {\n    if (display.cachedPaddingH) {\n      return display.cachedPaddingH;\n    }\n\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {\n      left: parseInt(style.paddingLeft),\n      right: parseInt(style.paddingRight)\n    };\n\n    if (!isNaN(data.left) && !isNaN(data.right)) {\n      display.cachedPaddingH = data;\n    }\n\n    return data;\n  }\n\n  function scrollGap(cm) {\n    return scrollerGap - cm.display.nativeBarWidth;\n  }\n\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  } // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n\n\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i],\n              next = rects[i + 1];\n\n          if (Math.abs(cur.bottom - next.bottom) > 2) {\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n          }\n        }\n      }\n\n      heights.push(rect.bottom - rect.top);\n    }\n  } // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n\n\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line) {\n      return {\n        map: lineView.measure.map,\n        cache: lineView.measure.cache\n      };\n    }\n\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++) {\n        if (lineView.rest[i] == line) {\n          return {\n            map: lineView.measure.maps[i],\n            cache: lineView.measure.caches[i]\n          };\n        }\n      }\n\n      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {\n        if (lineNo(lineView.rest[i$1]) > lineN) {\n          return {\n            map: lineView.measure.maps[i$1],\n            cache: lineView.measure.caches[i$1],\n            before: true\n          };\n        }\n      }\n    }\n  } // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n\n\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  } // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n\n\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  } // Find a line view that corresponds to the given line number.\n\n\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n      return cm.display.view[findViewIndex(cm, lineN)];\n    }\n\n    var ext = cm.display.externalMeasured;\n\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n      return ext;\n    }\n  } // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n\n\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n\n    if (!view) {\n      view = updateExternalMeasurement(cm, line);\n    }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line,\n      view: view,\n      rect: null,\n      map: info.map,\n      cache: info.cache,\n      before: info.before,\n      hasHeights: false\n    };\n  } // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n\n\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) {\n      ch = -1;\n    }\n\n    var key = ch + (bias || \"\"),\n        found;\n\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect) {\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      }\n\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n\n      found = measureCharInner(cm, prepared, ch, bias);\n\n      if (!found.bogus) {\n        prepared.cache[key] = found;\n      }\n    }\n\n    return {\n      left: found.left,\n      right: found.right,\n      top: varHeight ? found.rtop : found.top,\n      bottom: varHeight ? found.rbottom : found.bottom\n    };\n  }\n\n  var nullRect = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n\n      if (ch < mStart) {\n        start = 0;\n        end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n\n        if (ch >= mEnd) {\n          collapse = \"right\";\n        }\n      }\n\n      if (start != null) {\n        node = map[i + 2];\n\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\")) {\n          collapse = bias;\n        }\n\n        if (bias == \"left\" && start == 0) {\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        }\n\n        if (bias == \"right\" && start == mEnd - mStart) {\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        }\n\n        break;\n      }\n    }\n\n    return {\n      node: node,\n      start: start,\n      end: end,\n      collapse: collapse,\n      coverStart: mStart,\n      coverEnd: mEnd\n    };\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n\n    if (bias == \"left\") {\n      for (var i = 0; i < rects.length; i++) {\n        if ((rect = rects[i]).left != rect.right) {\n          break;\n        }\n      }\n    } else {\n      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n        if ((rect = rects[i$1]).left != rect.right) {\n          break;\n        }\n      }\n    }\n\n    return rect;\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node,\n        start = place.start,\n        end = place.end,\n        collapse = place.collapse;\n    var rect;\n\n    if (node.nodeType == 3) {\n      // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n          --start;\n        }\n\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n          ++end;\n        }\n\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else {\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n        }\n\n        if (rect.left || rect.right || start == 0) {\n          break;\n        }\n\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n\n      if (ie && ie_version < 11) {\n        rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n      }\n    } else {\n      // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) {\n        collapse = bias = \"right\";\n      }\n\n      var rects;\n\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      } else {\n        rect = node.getBoundingClientRect();\n      }\n    }\n\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n\n      if (rSpan) {\n        rect = {\n          left: rSpan.left,\n          right: rSpan.left + charWidth(cm.display),\n          top: rSpan.top,\n          bottom: rSpan.bottom\n        };\n      } else {\n        rect = nullRect;\n      }\n    }\n\n    var rtop = rect.top - prepared.rect.top,\n        rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n\n    for (; i < heights.length - 1; i++) {\n      if (mid < heights[i]) {\n        break;\n      }\n    }\n\n    var top = i ? heights[i - 1] : 0,\n        bot = heights[i];\n    var result = {\n      left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n      right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n      top: top,\n      bottom: bot\n    };\n\n    if (!rect.left && !rect.right) {\n      result.bogus = true;\n    }\n\n    if (!cm.options.singleCursorHeightPerLine) {\n      result.rtop = rtop;\n      result.rbottom = rbot;\n    }\n\n    return result;\n  } // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n\n\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n      return rect;\n    }\n\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {\n      left: rect.left * scaleX,\n      right: rect.right * scaleX,\n      top: rect.top * scaleY,\n      bottom: rect.bottom * scaleY\n    };\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n\n      if (lineView.rest) {\n        for (var i = 0; i < lineView.rest.length; i++) {\n          lineView.measure.caches[i] = {};\n        }\n      }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n    }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\n    if (!cm.options.lineWrapping) {\n      cm.display.maxLineChanged = true;\n    }\n\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n    }\n\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n  }\n\n  function pageScrollY() {\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n    }\n\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n  }\n\n  function widgetTopHeight(lineObj) {\n    var ref = visualLine(lineObj);\n    var widgets = ref.widgets;\n    var height = 0;\n\n    if (widgets) {\n      for (var i = 0; i < widgets.length; ++i) {\n        if (widgets[i].above) {\n          height += widgetHeight(widgets[i]);\n        }\n      }\n    }\n\n    return height;\n  } // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n\n\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height;\n      rect.bottom += height;\n    }\n\n    if (context == \"line\") {\n      return rect;\n    }\n\n    if (!context) {\n      context = \"local\";\n    }\n\n    var yOff = _heightAtLine(lineObj);\n\n    if (context == \"local\") {\n      yOff += paddingTop(cm.display);\n    } else {\n      yOff -= cm.display.viewOffset;\n    }\n\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff;\n      rect.right += xOff;\n    }\n\n    rect.top += yOff;\n    rect.bottom += yOff;\n    return rect;\n  } // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n\n\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") {\n      return coords;\n    }\n\n    var left = coords.left,\n        top = coords.top; // First move into \"page\" coordinate system\n\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {\n      left: left - lineSpaceBox.left,\n      top: top - lineSpaceBox.top\n    };\n  }\n\n  function _charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) {\n      lineObj = getLine(cm.doc, pos.line);\n    }\n\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  } // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n\n\n  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\n      if (right) {\n        m.left = m.right;\n      } else {\n        m.right = m.left;\n      }\n\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n\n    var order = getOrder(lineObj, cm.doc.direction),\n        ch = pos.ch,\n        sticky = pos.sticky;\n\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n\n    if (!order) {\n      return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\");\n    }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos],\n          right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert);\n    }\n\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n\n    if (other != null) {\n      val.other = getBidi(ch, other, sticky != \"before\");\n    }\n\n    return val;\n  } // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n\n\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = _clipPos(cm.doc, pos);\n\n    if (!cm.options.lineWrapping) {\n      left = charWidth(cm.display) * pos.ch;\n    }\n\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = _heightAtLine(lineObj) + paddingTop(cm.display);\n    return {\n      left: left,\n      right: left,\n      top: top,\n      bottom: top + lineObj.height\n    };\n  } // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n\n\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n\n    if (outside) {\n      pos.outside = outside;\n    }\n\n    return pos;\n  } // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n\n\n  function _coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n\n    if (y < 0) {\n      return PosWithInfo(doc.first, 0, null, -1, -1);\n    }\n\n    var lineN = _lineAtHeight(doc, y),\n        last = doc.first + doc.size - 1;\n\n    if (lineN > last) {\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    var lineObj = getLine(doc, lineN);\n\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n\n      if (!collapsed) {\n        return found;\n      }\n\n      var rangeEnd = collapsed.find(1);\n\n      if (rangeEnd.line == lineN) {\n        return rangeEnd;\n      }\n\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n    }, end, 0);\n    end = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n    }, begin, end);\n    return {\n      begin: begin,\n      end: end\n    };\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n  } // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n\n\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= _heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0,\n        end = lineObj.text.length,\n        ltr = true;\n    var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    } // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n\n\n    var chAround = null,\n        boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight;\n      box.bottom += widgetHeight;\n\n      if (!boxIsAfter(box, x, y, false)) {\n        return false;\n      }\n\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n\n      return true;\n    }, begin, end);\n    var baseX,\n        sticky,\n        outside = false; // If a box around the coordinates was found, use that\n\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x,\n          atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) {\n        ch++;\n      } // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n\n\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? \"after\" : \"before\"; // Now get accurate coordinates for this place, in order to get a\n      // base X position\n\n      var coords = _cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i],\n          ltr = part.level != 1;\n      return boxIsAfter(_cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"), \"line\", lineObj, preparedMeasure), x, y, true);\n    }, 0, order.length - 1);\n    var part = order[index]; // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n\n    if (index > 0) {\n      var ltr = part.level != 1;\n\n      var start = _cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"), \"line\", lineObj, preparedMeasure);\n\n      if (boxIsAfter(start, x, y, true) && start.top > y) {\n        part = order[index - 1];\n      }\n    }\n\n    return part;\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n      end--;\n    }\n\n    var part = null,\n        closestDist = null;\n\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n\n      if (p.from >= end || p.to <= begin) {\n        continue;\n      }\n\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n\n    if (!part) {\n      part = order[order.length - 1];\n    } // Clip the part to the wrapped line.\n\n\n    if (part.from < begin) {\n      part = {\n        from: begin,\n        to: part.to,\n        level: part.level\n      };\n    }\n\n    if (part.to > end) {\n      part = {\n        from: part.from,\n        to: end,\n        level: part.level\n      };\n    }\n\n    return part;\n  }\n\n  var measureText; // Compute the default text height.\n\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) {\n      return display.cachedTextHeight;\n    }\n\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\"); // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n\n    if (height > 3) {\n      display.cachedTextHeight = height;\n    }\n\n    removeChildren(display.measure);\n    return height || 1;\n  } // Compute the default character width.\n\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) {\n      return display.cachedCharWidth;\n    }\n\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(),\n        width = (rect.right - rect.left) / 10;\n\n    if (width > 2) {\n      display.cachedCharWidth = width;\n    }\n\n    return width || 10;\n  } // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n\n\n  function getDimensions(cm) {\n    var d = cm.display,\n        left = {},\n        width = {};\n    var gutterLeft = d.gutters.clientLeft;\n\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n\n    return {\n      fixedPos: compensateForHScroll(d),\n      gutterTotalWidth: d.gutters.offsetWidth,\n      gutterLeft: left,\n      gutterWidth: width,\n      wrapperWidth: d.wrapper.clientWidth\n    };\n  } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n\n\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  } // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display),\n        wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) {\n        return 0;\n      }\n\n      var widgetsHeight = 0;\n\n      if (line.widgets) {\n        for (var i = 0; i < line.widgets.length; i++) {\n          if (line.widgets[i].height) {\n            widgetsHeight += line.widgets[i].height;\n          }\n        }\n      }\n\n      if (wrapping) {\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      } else {\n        return widgetsHeight + th;\n      }\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc,\n        est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n\n      if (estHeight != line.height) {\n        updateLineHeight(line, estHeight);\n      }\n    });\n  } // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n\n\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") {\n      return null;\n    }\n\n    var x,\n        y,\n        space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\n    try {\n      x = e.clientX - space.left;\n      y = e.clientY - space.top;\n    } catch (e$1) {\n      return null;\n    }\n\n    var coords = _coordsChar(cm, x, y),\n        line;\n\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n\n    return coords;\n  } // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n\n\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) {\n      return null;\n    }\n\n    n -= cm.display.viewFrom;\n\n    if (n < 0) {\n      return null;\n    }\n\n    var view = cm.display.view;\n\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n\n      if (n < 0) {\n        return i;\n      }\n    }\n  } // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) {\n      from = cm.doc.first;\n    }\n\n    if (to == null) {\n      to = cm.doc.first + cm.doc.size;\n    }\n\n    if (!lendiff) {\n      lendiff = 0;\n    }\n\n    var display = cm.display;\n\n    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n      display.updateLineNumbers = from;\n    }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) {\n      // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n        resetView(cm);\n      }\n    } else if (to <= display.viewFrom) {\n      // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) {\n      // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) {\n      // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) {\n      // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else {\n      // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n\n    if (ext) {\n      if (to < ext.lineN) {\n        ext.lineN += lendiff;\n      } else if (from < ext.lineN + ext.size) {\n        display.externalMeasured = null;\n      }\n    }\n  } // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n\n\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display,\n        ext = cm.display.externalMeasured;\n\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n      display.externalMeasured = null;\n    }\n\n    if (line < display.viewFrom || line >= display.viewTo) {\n      return;\n    }\n\n    var lineView = display.view[findViewIndex(cm, line)];\n\n    if (lineView.node == null) {\n      return;\n    }\n\n    var arr = lineView.changes || (lineView.changes = []);\n\n    if (indexOf(arr, type) == -1) {\n      arr.push(type);\n    }\n  } // Clear the view.\n\n\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN),\n        diff,\n        view = cm.display.view;\n\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n      return {\n        index: index,\n        lineN: newN\n      };\n    }\n\n    var n = cm.display.viewFrom;\n\n    for (var i = 0; i < index; i++) {\n      n += view[i].size;\n    }\n\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) {\n          return null;\n        }\n\n        diff = n + view[index].size - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n\n      oldN += diff;\n      newN += diff;\n    }\n\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) {\n        return null;\n      }\n\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n\n    return {\n      index: index,\n      lineN: newN\n    };\n  } // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n\n\n  function adjustView(cm, from, to) {\n    var display = cm.display,\n        view = display.view;\n\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from) {\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      } else if (display.viewFrom < from) {\n        display.view = display.view.slice(findViewIndex(cm, from));\n      }\n\n      display.viewFrom = from;\n\n      if (display.viewTo < to) {\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      } else if (display.viewTo > to) {\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n      }\n    }\n\n    display.viewTo = to;\n  } // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n\n\n  function countDirtyView(cm) {\n    var view = cm.display.view,\n        dirty = 0;\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n        ++dirty;\n      }\n    }\n\n    return dirty;\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if (primary === void 0) primary = true;\n    var doc = cm.doc,\n        result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n    var customCursor = cm.options.$customCursor;\n\n    if (customCursor) {\n      primary = true;\n    }\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) {\n        continue;\n      }\n\n      var range = doc.sel.ranges[i];\n\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {\n        continue;\n      }\n\n      var collapsed = range.empty();\n\n      if (customCursor) {\n        var head = customCursor(cm, range);\n\n        if (head) {\n          drawSelectionCursor(cm, head, curFragment);\n        }\n      } else if (collapsed || cm.options.showCursorWhenSelecting) {\n        drawSelectionCursor(cm, range.head, curFragment);\n      }\n\n      if (!collapsed) {\n        drawSelectionRange(cm, range, selFragment);\n      }\n    }\n\n    return result;\n  } // Draws a cursor for the given range\n\n\n  function drawSelectionCursor(cm, head, output) {\n    var pos = _cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n      var charPos = _charCoords(cm, head, \"div\", null, null);\n\n      var width = charPos.right - charPos.left;\n      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + \"px\";\n    }\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) {\n    return a.top - b.top || a.left - b.left;\n  } // Draws the given range as a highlighted selection\n\n\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display,\n        doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display),\n        leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) {\n        top = 0;\n      }\n\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n\n      function coords(ch, bias) {\n        return _charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = dir == \"ltr\" == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop];\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n        var openStart = fromArg == null && from == 0,\n            openEnd = toArg == null && to == lineLen;\n        var first = i == 0,\n            last = !order || i == order.length - 1;\n\n        if (toPos.top - fromPos.top <= 3) {\n          // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else {\n          // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n\n          if (fromPos.bottom < toPos.top) {\n            add(leftSide, fromPos.bottom, null, toPos.top);\n          }\n\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) {\n          start = fromPos;\n        }\n\n        if (cmpCoords(toPos, start) < 0) {\n          start = toPos;\n        }\n\n        if (!end || cmpCoords(fromPos, end) < 0) {\n          end = fromPos;\n        }\n\n        if (cmpCoords(toPos, end) < 0) {\n          end = toPos;\n        }\n      });\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    var sFrom = range.from(),\n        sTo = range.to();\n\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line),\n          toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n\n      if (leftEnd.bottom < rightStart.top) {\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n      }\n    }\n\n    output.appendChild(fragment);\n  } // Cursor-blinking\n\n\n  function restartBlink(cm) {\n    if (!cm.state.focused) {\n      return;\n    }\n\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n\n    if (cm.options.cursorBlinkRate > 0) {\n      display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) {\n          onBlur(cm);\n        }\n\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    } else if (cm.options.cursorBlinkRate < 0) {\n      display.cursorDiv.style.visibility = \"hidden\";\n    }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n\n      if (!cm.state.focused) {\n        onFocus(cm);\n      }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n\n        if (cm.state.focused) {\n          onBlur(cm);\n        }\n      }\n    }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n      cm.state.delayingBlurEvent = false;\n    }\n\n    if (cm.options.readOnly == \"nocursor\") {\n      return;\n    }\n\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\"); // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n\n        if (webkit) {\n          setTimeout(function () {\n            return cm.display.input.reset(true);\n          }, 20);\n        } // Issue #1730\n\n      }\n\n      cm.display.input.receivedFocus();\n    }\n\n    restartBlink(cm);\n  }\n\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) {\n      return;\n    }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n\n    clearInterval(cm.display.blinker);\n    setTimeout(function () {\n      if (!cm.state.focused) {\n        cm.display.shift = false;\n      }\n    }, 150);\n  } // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n    var oldHeight = display.lineDiv.getBoundingClientRect().top;\n    var mustScroll = 0;\n\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i],\n          wrapping = cm.options.lineWrapping;\n      var height = void 0,\n          width = 0;\n\n      if (cur.hidden) {\n        continue;\n      }\n\n      oldHeight += cur.line.height;\n\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top; // Check that lines don't extend past the right of the current\n        // editor width\n\n        if (!wrapping && cur.text.firstChild) {\n          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n        }\n      }\n\n      var diff = cur.line.height - height;\n\n      if (diff > .005 || diff < -.005) {\n        if (oldHeight < viewTop) {\n          mustScroll -= diff;\n        }\n\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n\n        if (cur.rest) {\n          for (var j = 0; j < cur.rest.length; j++) {\n            updateWidgetHeight(cur.rest[j]);\n          }\n        }\n      }\n\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n\n    if (Math.abs(mustScroll) > 2) {\n      display.scroller.scrollTop += mustScroll;\n    }\n  } // Read and store the height of line widgets associated with the\n  // given line.\n\n\n  function updateWidgetHeight(line) {\n    if (line.widgets) {\n      for (var i = 0; i < line.widgets.length; ++i) {\n        var w = line.widgets[i],\n            parent = w.node.parentNode;\n\n        if (parent) {\n          w.height = parent.offsetHeight;\n        }\n      }\n    }\n  } // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n\n\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = _lineAtHeight(doc, top),\n        to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n\n\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line,\n          ensureTo = viewport.ensure.to.line;\n\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n\n    return {\n      from: from,\n      to: Math.max(to, from + 1)\n    };\n  } // SCROLLING THINGS INTO VIEW\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n\n\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) {\n      return;\n    }\n\n    var display = cm.display,\n        box = display.sizer.getBoundingClientRect(),\n        doScroll = null;\n\n    if (rect.top + box.top < 0) {\n      doScroll = true;\n    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {\n      doScroll = false;\n    }\n\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200B\", null, \"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + rect.left + \"px; width: \" + Math.max(2, rect.right - rect.left) + \"px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  } // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) {\n      margin = 0;\n    }\n\n    var rect;\n\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    }\n\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n\n      var coords = _cursorCoords(cm, pos);\n\n      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);\n      rect = {\n        left: Math.min(coords.left, endCoords.left),\n        top: Math.min(coords.top, endCoords.top) - margin,\n        right: Math.max(coords.left, endCoords.left),\n        bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n      };\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop,\n          startLeft = cm.doc.scrollLeft;\n\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n          changed = true;\n        }\n      }\n\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n          changed = true;\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    return rect;\n  } // Scroll a given set of coordinates into view (immediately).\n\n\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n    }\n\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n    }\n  } // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n\n\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display,\n        snapMargin = textHeight(cm.display);\n\n    if (rect.top < 0) {\n      rect.top = 0;\n    }\n\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm),\n        result = {};\n\n    if (rect.bottom - rect.top > screen) {\n      rect.bottom = rect.top + screen;\n    }\n\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin,\n        atBottom = rect.bottom > docBottom - snapMargin;\n\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n\n      if (newTop != screentop) {\n        result.scrollTop = newTop;\n      }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n\n    if (tooWide) {\n      rect.right = rect.left + screenw;\n    }\n\n    if (rect.left < 10) {\n      result.scrollLeft = 0;\n    } else if (rect.left < screenleft) {\n      result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n    } else if (rect.right > screenw + screenleft - 3) {\n      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n    }\n\n    return result;\n  } // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n\n\n  function addToScrollTop(cm, top) {\n    if (top == null) {\n      return;\n    }\n\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  } // Make sure that at the end of the operation the current cursor is\n  // shown.\n\n\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {\n      from: cur,\n      to: cur,\n      margin: cm.options.cursorScrollMargin\n    };\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) {\n      resolveScrollToPos(cm);\n    }\n\n    if (x != null) {\n      cm.curOp.scrollLeft = x;\n    }\n\n    if (y != null) {\n      cm.curOp.scrollTop = y;\n    }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  } // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n\n\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from),\n          to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  } // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n\n\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) {\n      return;\n    }\n\n    if (!gecko) {\n      updateDisplaySimple(cm, {\n        top: val\n      });\n    }\n\n    setScrollTop(cm, val, true);\n\n    if (gecko) {\n      updateDisplaySimple(cm);\n    }\n\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n\n    if (cm.display.scroller.scrollTop == val && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n\n    if (cm.display.scroller.scrollTop != val) {\n      cm.display.scroller.scrollTop = val;\n    }\n  } // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n\n\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n\n    if (cm.display.scroller.scrollLeft != val) {\n      cm.display.scroller.scrollLeft = val;\n    }\n\n    cm.display.scrollbars.setScrollLeft(val);\n  } // SCROLLBARS\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n\n\n  function measureForScrollbars(cm) {\n    var d = cm.display,\n        gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth,\n      clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert);\n    place(horiz);\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) {\n        scroll(vert.scrollTop, \"vertical\");\n      }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) {\n        scroll(horiz.scrollLeft, \"horizontal\");\n      }\n    });\n    this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\n    if (ie && ie_version < 8) {\n      this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n    }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.\n\n      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.scrollTop = 0;\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) {\n        this.zeroWidthHack();\n      }\n\n      this.checkedZeroWidth = true;\n    }\n\n    return {\n      right: needsV ? sWidth : 0,\n      bottom: needsH ? sWidth : 0\n    };\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) {\n      this.horiz.scrollLeft = pos;\n    }\n\n    if (this.disableHoriz) {\n      this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n    }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) {\n      this.vert.scrollTop = pos;\n    }\n\n    if (this.disableVert) {\n      this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n    }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed();\n    this.disableVert = new Delayed();\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n\n      if (elt != bar) {\n        bar.style.pointerEvents = \"none\";\n      } else {\n        delay.set(1000, maybeDisable);\n      }\n    }\n\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function NullScrollbars() {};\n\n  NullScrollbars.prototype.update = function () {\n    return {\n      bottom: 0,\n      right: 0\n    };\n  };\n\n  NullScrollbars.prototype.setScrollLeft = function () {};\n\n  NullScrollbars.prototype.setScrollTop = function () {};\n\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) {\n      measure = measureForScrollbars(cm);\n    }\n\n    var startWidth = cm.display.barWidth,\n        startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n        updateHeightsInViewport(cm);\n      }\n\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth;\n      startHeight = cm.display.barHeight;\n    }\n  } // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n\n\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else {\n      d.scrollbarFiller.style.display = \"\";\n    }\n\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else {\n      d.gutterFiller.style.display = \"\";\n    }\n  }\n\n  var scrollbarModel = {\n    \"native\": NativeScrollbars,\n    \"null\": NullScrollbars\n  };\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n\n      if (cm.display.scrollbars.addClass) {\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n      }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus\n\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) {\n          setTimeout(function () {\n            return cm.display.input.focus();\n          }, 0);\n        }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") {\n        setScrollLeft(cm, pos);\n      } else {\n        updateScrollTop(cm, pos);\n      }\n    }, cm);\n\n    if (cm.display.scrollbars.addClass) {\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n  } // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n\n  var nextOpId = 0; // Start a new operation.\n\n  function _startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,\n      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height,\n      // Used to detect need to update scrollbar\n      forceUpdate: false,\n      // Used to force a redraw\n      updateInput: 0,\n      // Whether to reset the input textarea\n      typing: false,\n      // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,\n      // Accumulated changes, for firing change events\n      cursorActivityHandlers: null,\n      // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0,\n      // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false,\n      // Whether the selection needs to be redrawn\n      updateMaxLine: false,\n      // Set when the widest line needs to be determined anew\n      scrollLeft: null,\n      scrollTop: null,\n      // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,\n      // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId,\n      // Unique ID\n      markArrays: null // Used by addMarkedSpan\n\n    };\n    pushOperation(cm.curOp);\n  } // Finish an operation, updating the display and signalling delayed events\n\n\n  function _endOperation(cm) {\n    var op = cm.curOp;\n\n    if (op) {\n      finishOperation(op, function (group) {\n        for (var i = 0; i < group.ops.length; i++) {\n          group.ops[i].cm.curOp = null;\n        }\n\n        endOperations(group);\n      });\n    }\n  } // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n\n\n  function endOperations(group) {\n    var ops = group.ops;\n\n    for (var i = 0; i < ops.length; i++) // Read DOM\n    {\n      endOperation_R1(ops[i]);\n    }\n\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    {\n      endOperation_W1(ops[i$1]);\n    }\n\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    {\n      endOperation_R2(ops[i$2]);\n    }\n\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    {\n      endOperation_W2(ops[i$3]);\n    }\n\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    {\n      endOperation_finish(ops[i$4]);\n    }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm,\n        display = cm.display;\n    maybeClipScrollbars(cm);\n\n    if (op.updateMaxLine) {\n      findMaxLine(cm);\n    }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {\n      top: op.scrollTop,\n      ensure: op.scrollToPos\n    }, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm,\n        display = cm.display;\n\n    if (op.updatedDisplay) {\n      updateHeightsInViewport(cm);\n    }\n\n    op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged) {\n      op.preparedSelection = display.input.prepareSelection();\n    }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\n      if (op.maxScrollLeft < cm.doc.scrollLeft) {\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      }\n\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n\n    if (op.preparedSelection) {\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n    }\n\n    if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n      updateScrollbars(cm, op.barMeasure);\n    }\n\n    if (op.updatedDisplay) {\n      setDocumentHeight(cm, op.barMeasure);\n    }\n\n    if (op.selectionChanged) {\n      restartBlink(cm);\n    }\n\n    if (cm.state.focused && op.updateInput) {\n      cm.display.input.reset(op.typing);\n    }\n\n    if (takeFocus) {\n      ensureFocus(op.cm);\n    }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm,\n        display = cm.display,\n        doc = cm.doc;\n\n    if (op.updatedDisplay) {\n      postUpdateDisplay(cm, op.update);\n    } // Abort mouse wheel delta measurement, when scrolling explicitly\n\n\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n      display.wheelStartX = display.wheelStartY = null;\n    } // Propagate the scroll position to the actual DOM scroller\n\n\n    if (op.scrollTop != null) {\n      setScrollTop(cm, op.scrollTop, op.forceScroll);\n    }\n\n    if (op.scrollLeft != null) {\n      setScrollLeft(cm, op.scrollLeft, true, true);\n    } // If we need to scroll a specific position into view, do so.\n\n\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    } // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n\n\n    var hidden = op.maybeHiddenMarkers,\n        unhidden = op.maybeUnhiddenMarkers;\n\n    if (hidden) {\n      for (var i = 0; i < hidden.length; ++i) {\n        if (!hidden[i].lines.length) {\n          signal(hidden[i], \"hide\");\n        }\n      }\n    }\n\n    if (unhidden) {\n      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {\n        if (unhidden[i$1].lines.length) {\n          signal(unhidden[i$1], \"unhide\");\n        }\n      }\n    }\n\n    if (display.wrapper.offsetHeight) {\n      doc.scrollTop = cm.display.scroller.scrollTop;\n    } // Fire change events, and delayed event handlers\n\n\n    if (op.changeObjs) {\n      signal(cm, \"changes\", cm, op.changeObjs);\n    }\n\n    if (op.update) {\n      op.update.finish();\n    }\n  } // Run the given function in an operation\n\n\n  function runInOp(cm, f) {\n    if (cm.curOp) {\n      return f();\n    }\n\n    _startOperation(cm);\n\n    try {\n      return f();\n    } finally {\n      _endOperation(cm);\n    }\n  } // Wraps a function in an operation. Returns the wrapped function.\n\n\n  function operation(cm, f) {\n    return function () {\n      if (cm.curOp) {\n        return f.apply(cm, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(cm, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n\n\n  function methodOp(f) {\n    return function () {\n      if (this.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(this);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(this);\n      }\n    };\n  }\n\n  function docMethodOp(f) {\n    return function () {\n      var cm = this.cm;\n\n      if (!cm || cm.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // HIGHLIGHT WORKER\n\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo) {\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n    }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n\n    if (doc.highlightFrontier >= cm.display.viewTo) {\n      return;\n    }\n\n    var end = +new Date() + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) {\n        // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n\n        if (resetState) {\n          context.state = resetState;\n        }\n\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses,\n            newCls = highlighted.classes;\n\n        if (newCls) {\n          line.styleClasses = newCls;\n        } else if (oldCls) {\n          line.styleClasses = null;\n        }\n\n        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) {\n          ischange = oldStyles[i] != line.styles[i];\n        }\n\n        if (ischange) {\n          changedLines.push(context.line);\n        }\n\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength) {\n          processLine(cm, line.text, context);\n        }\n\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n\n      if (+new Date() > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n\n    if (changedLines.length) {\n      runInOp(cm, function () {\n        for (var i = 0; i < changedLines.length; i++) {\n          regLineChange(cm, changedLines[i], \"text\");\n        }\n      });\n    }\n  } // DISPLAY DRAWING\n\n\n  var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n    this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)\n\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type)) {\n      this.events.push(arguments);\n    }\n  };\n\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++) {\n      signal.apply(null, this.events[i]);\n    }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) {\n      return null;\n    }\n\n    var active = activeElt();\n\n    if (!active || !contains(cm.display.lineDiv, active)) {\n      return null;\n    }\n\n    var result = {\n      activeElt: active\n    };\n\n    if (window.getSelection) {\n      var sel = window.getSelection();\n\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n\n    return result;\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {\n      return;\n    }\n\n    snapshot.activeElt.focus();\n\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(),\n          range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  } // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n\n\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display,\n        doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    } // Bail out if the visible area is already rendered and nothing changed.\n\n\n    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n      return false;\n    }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    } // Compute a suitable new viewport (from & to)\n\n\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\n    if (display.viewFrom < from && from - display.viewFrom < 20) {\n      from = Math.max(doc.first, display.viewFrom);\n    }\n\n    if (display.viewTo > to && display.viewTo - to < 20) {\n      to = Math.min(end, display.viewTo);\n    }\n\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position\n\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n    var toUpdate = countDirtyView(cm);\n\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n      return false;\n    } // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n\n\n    var selSnapshot = selectionSnapshot(cm);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"none\";\n    }\n\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"\";\n    }\n\n    display.renderedView = display.view; // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n\n    restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null) {\n          viewport = {\n            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)\n          };\n        } // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n\n\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n          break;\n        }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n\n      if (!updateDisplayIfNeeded(cm, update)) {\n        break;\n      }\n\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom;\n      cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  } // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n\n\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display,\n        lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv,\n        cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit\n\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n      } else {\n        node.parentNode.removeChild(node);\n      }\n\n      return next;\n    }\n\n    var view = display.view,\n        lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {\n        // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else {\n        // Already drawn\n        while (cur != lineView.node) {\n          cur = rm(cur);\n        }\n\n        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) {\n            updateNumber = false;\n          }\n\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n\n    while (cur) {\n      cur = rm(cur);\n    }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\"; // Send an event to consumers responding to changes in gutter width.\n\n    signalLater(display, \"gutterChanged\", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + \"px\";\n  } // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n\n\n  function alignHorizontally(cm) {\n    var display = cm.display,\n        view = display.view;\n\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n      return;\n    }\n\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth,\n        left = comp + \"px\";\n\n    for (var i = 0; i < view.length; i++) {\n      if (!view[i].hidden) {\n        if (cm.options.fixedGutter) {\n          if (view[i].gutter) {\n            view[i].gutter.style.left = left;\n          }\n\n          if (view[i].gutterBackground) {\n            view[i].gutterBackground.style.left = left;\n          }\n        }\n\n        var align = view[i].alignable;\n\n        if (align) {\n          for (var j = 0; j < align.length; j++) {\n            align[j].style.left = left;\n          }\n        }\n      }\n    }\n\n    if (cm.options.fixedGutter) {\n      display.gutters.style.left = comp + gutterW + \"px\";\n    }\n  } // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) {\n      return false;\n    }\n\n    var doc = cm.doc,\n        last = lineNumberFor(cm.options, doc.first + doc.size - 1),\n        display = cm.display;\n\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth,\n          padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true;\n    }\n\n    return false;\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [],\n        sawLineNumbers = false;\n\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i],\n          style = null;\n\n      if (typeof name != \"string\") {\n        style = name.style;\n        name = name.className;\n      }\n\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) {\n          continue;\n        } else {\n          sawLineNumbers = true;\n        }\n      }\n\n      result.push({\n        className: name,\n        style: style\n      });\n    }\n\n    if (lineNumbers && !sawLineNumbers) {\n      result.push({\n        className: \"CodeMirror-linenumbers\",\n        style: null\n      });\n    }\n\n    return result;\n  } // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n\n\n  function renderGutters(display) {\n    var gutters = display.gutters,\n        specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n\n      if (style) {\n        gElt.style.cssText = style;\n      }\n\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  } // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input; // Covers bottom-right square when both scrollbars are present.\n\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\"); // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\"); // Will contain the actual code, positioned to cover the viewport.\n\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\"); // Elements are added to these to represent selection and cursors.\n\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\"); // A visibility: hidden element used to find the size of things.\n\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\"); // When lines outside of the viewport are measured, they are drawn in this.\n\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\"); // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\"); // Moved around its parent to cover visible view.\n\n    d.mover = elt(\"div\", [lines], null, \"position: relative\"); // Set to the height of the document, allowing scrolling.\n\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\"); // Will contain the gutters, if any.\n\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null; // Actual scrollable element.\n\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\"); // The element in which the editor lives.\n\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\"); // This attribute is respected by automatic translation systems such as Google Translate,\n    // and may also be respected by tools used by human translators.\n\n    d.wrapper.setAttribute('translate', 'no'); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\n    if (ie && ie_version < 8) {\n      d.gutters.style.zIndex = -1;\n      d.scroller.style.paddingRight = 0;\n    }\n\n    if (!webkit && !(gecko && mobile)) {\n      d.scroller.draggable = true;\n    }\n\n    if (place) {\n      if (place.appendChild) {\n        place.appendChild(d.wrapper);\n      } else {\n        place(d.wrapper);\n      }\n    } // Current rendered range (may be bigger than the view window).\n\n\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.\n\n    d.view = [];\n    d.renderedView = null; // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n\n    d.externalMeasured = null; // Empty space (in pixels) above the view\n\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n\n    d.alignWidgets = false;\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity\n\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.\n\n    d.shift = false; // Used to track whether anything happened since the context menu\n    // was opened.\n\n    d.selForContextMenu = null;\n    d.activeTouch = null;\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n    input.init(d);\n  } // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n\n  var wheelSamples = 0,\n      wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n\n  if (ie) {\n    wheelPixelsPerUnit = -.53;\n  } else if (gecko) {\n    wheelPixelsPerUnit = 15;\n  } else if (chrome) {\n    wheelPixelsPerUnit = -.7;\n  } else if (safari) {\n    wheelPixelsPerUnit = -1 / 3;\n  }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX,\n        dy = e.wheelDeltaY;\n\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n      dx = e.detail;\n    }\n\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n      dy = e.detail;\n    } else if (dy == null) {\n      dy = e.wheelDelta;\n    }\n\n    return {\n      x: dx,\n      y: dy\n    };\n  }\n\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e),\n        dx = delta.x,\n        dy = delta.y;\n    var pixelsPerUnit = wheelPixelsPerUnit;\n\n    if (e.deltaMode === 0) {\n      dx = e.deltaX;\n      dy = e.deltaY;\n      pixelsPerUnit = 1;\n    }\n\n    var display = cm.display,\n        scroll = display.scroller; // Quit if there's nothing to scroll here\n\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\n    if (!(dx && canScrollX || dy && canScrollY)) {\n      return;\n    } // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n\n\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    } // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n\n\n    if (dx && !gecko && !presto && pixelsPerUnit != null) {\n      if (dy && canScrollY) {\n        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n      }\n\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n\n      if (!dy || dy && canScrollY) {\n        e_preventDefault(e);\n      }\n\n      display.wheelStartX = null; // Abort measurement, if in progress\n\n      return;\n    } // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n\n\n    if (dy && pixelsPerUnit != null) {\n      var pixels = dy * pixelsPerUnit;\n      var top = cm.doc.scrollTop,\n          bot = top + display.wrapper.clientHeight;\n\n      if (pixels < 0) {\n        top = Math.max(0, top + pixels - 50);\n      } else {\n        bot = Math.min(cm.doc.height, bot + pixels + 50);\n      }\n\n      updateDisplaySimple(cm, {\n        top: top,\n        bottom: bot\n      });\n    }\n\n    if (wheelSamples < 20 && e.deltaMode !== 0) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft;\n        display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx;\n        display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) {\n            return;\n          }\n\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n          display.wheelStartX = display.wheelStartY = null;\n\n          if (!sample) {\n            return;\n          }\n\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx;\n        display.wheelDY += dy;\n      }\n    }\n  } // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n\n\n  var Selection = function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () {\n    return this.ranges[this.primIndex];\n  };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) {\n      return true;\n    }\n\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i],\n          there = other.ranges[i];\n\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n    }\n\n    return new Selection(out, this.primIndex);\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++) {\n      if (!this.ranges[i].empty()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) {\n      end = pos;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  var Range = function Range(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  };\n\n  Range.prototype.from = function () {\n    return minPos(this.anchor, this.head);\n  };\n\n  Range.prototype.to = function () {\n    return maxPos(this.anchor, this.head);\n  };\n\n  Range.prototype.empty = function () {\n    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n  }; // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n\n\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) {\n      return cmp(a.from(), b.from());\n    });\n    primIndex = indexOf(ranges, prim);\n\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i],\n          prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()),\n            to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\n        if (i <= primIndex) {\n          --primIndex;\n        }\n\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  } // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n\n\n  function changeEnd(change) {\n    if (!change.text) {\n      return change.to;\n    }\n\n    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  } // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n\n\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) {\n      return pos;\n    }\n\n    if (cmp(pos, change.to) <= 0) {\n      return changeEnd(change);\n    }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\n        ch = pos.ch;\n\n    if (pos.line == change.to.line) {\n      ch += changeEnd(change).ch - change.to.ch;\n    }\n\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n    }\n\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line) {\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    } else {\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n    }\n  } // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\n\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0),\n        newPrev = oldPrev;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i],\n            inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n\n    return new Selection(out, doc.sel.primIndex);\n  } // Used to get the editor into a consistent state again when options change.\n\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n\n      if (line.styles) {\n        line.styles = null;\n      }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n\n    if (cm.curOp) {\n      regChange(cm);\n    }\n  } // DOCUMENT DATA STRUCTURE\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n\n\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  } // Perform a change on the document data structure.\n\n\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {\n      return markedSpans ? markedSpans[n] : null;\n    }\n\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    function linesFor(start, end) {\n      var result = [];\n\n      for (var i = start; i < end; ++i) {\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      }\n\n      return result;\n    }\n\n    var from = change.from,\n        to = change.to,\n        text = change.text;\n    var firstLine = getLine(doc, from.line),\n        lastLine = getLine(doc, to.line);\n    var lastText = lst(text),\n        lastSpans = spansFor(text.length - 1),\n        nlines = to.line - from.line; // Adjust the line structure\n\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n\n      if (nlines) {\n        doc.remove(from.line, nlines);\n      }\n\n      if (added.length) {\n        doc.insert(from.line, added);\n      }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n\n      if (nlines > 1) {\n        doc.remove(from.line + 1, nlines - 1);\n      }\n\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  } // Call f for all linked documents.\n\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) {\n        for (var i = 0; i < doc.linked.length; ++i) {\n          var rel = doc.linked[i];\n\n          if (rel.doc == skip) {\n            continue;\n          }\n\n          var shared = sharedHist && rel.sharedHist;\n\n          if (sharedHistOnly && !shared) {\n            continue;\n          }\n\n          f(rel.doc, shared);\n          propagate(rel.doc, doc, shared);\n        }\n      }\n    }\n\n    propagate(doc, null, true);\n  } // Attach a document to an editor.\n\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) {\n      throw new Error(\"This document is already in use.\");\n    }\n\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    cm.options.direction = doc.direction;\n\n    if (!cm.options.lineWrapping) {\n      findMaxLine(cm);\n    }\n\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n    (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = [];\n    this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity; // Used to track when changes can be merged into a single undo\n    // event\n\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method\n\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  } // Create a history change event from an updateDoc-style change\n  // object.\n\n\n  function historyChangeFromChange(doc, change) {\n    var histChange = {\n      from: copyPos(change.from),\n      to: changeEnd(change),\n      text: getBetween(doc, change.from, change.to)\n    };\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) {\n      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    }, true);\n    return histChange;\n  } // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n\n\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n\n      if (last.ranges) {\n        array.pop();\n      } else {\n        break;\n      }\n    }\n  } // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n\n\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  } // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n\n\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date(),\n        cur;\n    var last;\n\n    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == \"*\")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n\n      if (!before || !before.ranges) {\n        pushSelectionToHistory(doc.sel, hist.done);\n      }\n\n      cur = {\n        changes: [historyChangeFromChange(doc, change)],\n        generation: hist.generation\n      };\n      hist.done.push(cur);\n\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n\n        if (!hist.done[0].ranges) {\n          hist.done.shift();\n        }\n      }\n    }\n\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) {\n      signal(doc, \"historyAdded\");\n    }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" || ch == \"+\" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  } // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n\n\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history,\n        origin = options && options.origin; // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n\n    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n      hist.done[hist.done.length - 1] = sel;\n    } else {\n      pushSelectionToHistory(sel, hist.done);\n    }\n\n    hist.lastSelTime = +new Date();\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n\n    if (options && options.clearRedo !== false) {\n      clearSelectionEvents(hist.undone);\n    }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n\n    if (!(top && top.ranges && top.equals(sel))) {\n      dest.push(sel);\n    }\n  } // Used to store marked span information in the history.\n\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id],\n        n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans) {\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      }\n\n      ++n;\n    });\n  } // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n\n\n  function removeClearedSpans(spans) {\n    if (!spans) {\n      return null;\n    }\n\n    var out;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) {\n        if (!out) {\n          out = spans.slice(0, i);\n        }\n      } else if (out) {\n        out.push(spans[i]);\n      }\n    }\n\n    return !out ? spans : out.length ? out : null;\n  } // Retrieve and filter the old marked spans stored in a change event.\n\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n\n    if (!found) {\n      return null;\n    }\n\n    var nw = [];\n\n    for (var i = 0; i < change.text.length; ++i) {\n      nw.push(removeClearedSpans(found[i]));\n    }\n\n    return nw;\n  } // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n\n    if (!old) {\n      return stretched;\n    }\n\n    if (!stretched) {\n      return old;\n    }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i],\n          stretchCur = stretched[i];\n\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n\n          for (var k = 0; k < oldCur.length; ++k) {\n            if (oldCur[k].marker == span.marker) {\n              continue spans;\n            }\n          }\n\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n\n    return old;\n  } // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n\n\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n\n      var changes = event.changes,\n          newChanges = [];\n      copy.push({\n        changes: newChanges\n      });\n\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j],\n            m = void 0;\n        newChanges.push({\n          from: change.from,\n          to: change.to,\n          text: change.text\n        });\n\n        if (newGroup) {\n          for (var prop in change) {\n            if (m = prop.match(/^spans_(\\d+)$/)) {\n              if (indexOf(newGroup, Number(m[1])) > -1) {\n                lst(newChanges)[prop] = change[prop];\n                delete change[prop];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return copy;\n  } // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n\n\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n\n        if (posBefore != cmp(other, anchor) < 0) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != cmp(head, other) < 0) {\n          head = other;\n        }\n      }\n\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  } // Extend the primary selection range, discard the rest.\n\n\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) {\n      extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    }\n\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  } // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n\n\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);\n    }\n\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  } // Updates a single range in the selection.\n\n\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  } // Reset the selection to a single range.\n\n\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  } // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n\n\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function update(ranges) {\n        this.ranges = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          this.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));\n        }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    }\n\n    if (obj.ranges != sel.ranges) {\n      return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n    } else {\n      return sel;\n    }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done,\n        last = lst(done);\n\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  } // Set a new selection.\n\n\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      sel = filterSelectionChange(doc, sel, options);\n    }\n\n    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\") {\n      ensureCursorVisible(doc.cm);\n    }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) {\n      return;\n    }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n\n    signalLater(doc, \"cursorActivity\", doc);\n  } // Verify that the selection does not partially select any atomic\n  // marked ranges.\n\n\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  } // Return a selection that does not partially select any atomic\n  // ranges.\n\n\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) {\n          out = sel.ranges.slice(0, i);\n        }\n\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n\n    if (line.markedSpans) {\n      for (var i = 0; i < line.markedSpans.length; ++i) {\n        var sp = line.markedSpans[i],\n            m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n        // is with selectLeft/Right\n\n        var preventCursorLeft = \"selectLeft\" in m ? !m.selectLeft : m.inclusiveLeft;\n        var preventCursorRight = \"selectRight\" in m ? !m.selectRight : m.inclusiveRight;\n\n        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n          if (mayClear) {\n            signal(m, \"beforeCursorEnter\");\n\n            if (m.explicitlyCleared) {\n              if (!line.markedSpans) {\n                break;\n              } else {\n                --i;\n                continue;\n              }\n            }\n          }\n\n          if (!m.atomic) {\n            continue;\n          }\n\n          if (oldPos) {\n            var near = m.find(dir < 0 ? 1 : -1),\n                diff = void 0;\n\n            if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n            }\n\n            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n              return skipAtomicInner(doc, near, pos, dir, mayClear);\n            }\n          }\n\n          var far = m.find(dir < 0 ? -1 : 1);\n\n          if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n            far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n          }\n\n          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n        }\n      }\n    }\n\n    return pos;\n  } // Ensure a given position is not inside an atomic range.\n\n\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) {\n        return _clipPos(doc, Pos(pos.line - 1));\n      } else {\n        return null;\n      }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) {\n        return Pos(pos.line + 1, 0);\n      } else {\n        return null;\n      }\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  } // UPDATING\n  // Allow \"beforeChange\" event handlers to influence a change\n\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function cancel() {\n        return obj.canceled = true;\n      }\n    };\n\n    if (update) {\n      obj.update = function (from, to, text, origin) {\n        if (from) {\n          obj.from = _clipPos(doc, from);\n        }\n\n        if (to) {\n          obj.to = _clipPos(doc, to);\n        }\n\n        if (text) {\n          obj.text = text;\n        }\n\n        if (origin !== undefined) {\n          obj.origin = origin;\n        }\n      };\n    }\n\n    signal(doc, \"beforeChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeChange\", doc.cm, obj);\n    }\n\n    if (obj.canceled) {\n      if (doc.cm) {\n        doc.cm.curOp.updateInput = 2;\n      }\n\n      return null;\n    }\n\n    return {\n      from: obj.from,\n      to: obj.to,\n      text: obj.text,\n      origin: obj.origin\n    };\n  } // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n\n\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) {\n        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      }\n\n      if (doc.cm.state.suppressEdits) {\n        return;\n      }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n\n      if (!change) {\n        return;\n      }\n    } // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n\n\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i) {\n        makeChangeInner(doc, {\n          from: split[i].from,\n          to: split[i].to,\n          text: i ? [\"\"] : change.text,\n          origin: change.origin\n        });\n      }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) {\n      return;\n    }\n\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  } // Revert a change stored in a document's history.\n\n\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n\n    if (suppress && !allowSelectionOnly) {\n      return;\n    }\n\n    var hist = doc.history,\n        event,\n        selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone,\n        dest = type == \"undo\" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n\n    var i = 0;\n\n    for (; i < source.length; i++) {\n      event = source[i];\n\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n        break;\n      }\n    }\n\n    if (i == source.length) {\n      return;\n    }\n\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {\n            clearRedo: false\n          });\n          return;\n        }\n\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return;\n      } else {\n        break;\n      }\n    } // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n\n\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({\n      changes: antiChanges,\n      generation: hist.generation\n    });\n    hist.generation = event.generation || ++hist.maxGeneration;\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function loop(i) {\n      var change = event.changes[i];\n      change.origin = type;\n\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {};\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\n      if (!i && doc.cm) {\n        doc.cm.scrollIntoView({\n          from: change.from,\n          to: changeEnd(change)\n        });\n      }\n\n      var rebased = []; // Propagate to the linked documents\n\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop(i$1);\n      if (returned) return returned.v;\n    }\n  } // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n\n\n  function shiftDoc(doc, distance) {\n    if (distance == 0) {\n      return;\n    }\n\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n        regLineChange(doc.cm, l, \"gutter\");\n      }\n    }\n  } // More lower-level change function, handling only a single document\n  // (not linked ones).\n\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n    }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n\n    if (change.from.line > doc.lastLine()) {\n      return;\n    } // Clip the change to the size of this doc\n\n\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {\n        from: Pos(doc.first, 0),\n        to: Pos(change.to.line + shift, change.to.ch),\n        text: [lst(change.text)],\n        origin: change.origin\n      };\n    }\n\n    var last = doc.lastLine();\n\n    if (change.to.line > last) {\n      change = {\n        from: change.from,\n        to: Pos(last, getLine(doc, last).text.length),\n        text: [change.text[0]],\n        origin: change.origin\n      };\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) {\n      selAfter = computeSelAfterChange(doc, change);\n    }\n\n    if (doc.cm) {\n      makeChangeSingleDocInEditor(doc.cm, change, spans);\n    } else {\n      updateDoc(doc, change, spans);\n    }\n\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n      doc.cantEdit = false;\n    }\n  } // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n\n\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc,\n        display = cm.display,\n        from = change.from,\n        to = change.to;\n    var recomputeMaxLength = false,\n        checkWidthStart = from.line;\n\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1) {\n      signalCursorActivity(cm);\n    }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n\n      if (recomputeMaxLength) {\n        cm.curOp.updateMaxLine = true;\n      }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display\n\n    if (change.full) {\n      regChange(cm);\n    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n      regLineChange(cm, from.line, \"text\");\n    } else {\n      regChange(cm, from.line, to.line + 1, lendiff);\n    }\n\n    var changesHandler = hasHandler(cm, \"changes\"),\n        changeHandler = hasHandler(cm, \"change\");\n\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from,\n        to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n\n      if (changeHandler) {\n        signalLater(cm, \"change\", cm, obj);\n      }\n\n      if (changesHandler) {\n        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n      }\n    }\n\n    cm.display.selForContextMenu = null;\n  }\n\n  function _replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) {\n      to = from;\n    }\n\n    if (cmp(to, from) < 0) {\n      assign = [to, from], from = assign[0], to = assign[1];\n    }\n\n    if (typeof code == \"string\") {\n      code = doc.splitLines(code);\n    }\n\n    makeChange(doc, {\n      from: from,\n      to: to,\n      text: code,\n      origin: origin\n    });\n  } // Rebasing/resetting history to deal with externally-sourced changes\n\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  } // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n\n\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i],\n          ok = true;\n\n      if (sub.ranges) {\n        if (!sub.copied) {\n          sub = array[i] = sub.deepCopy();\n          sub.copied = true;\n        }\n\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n\n        continue;\n      }\n\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line,\n        to = change.to.line,\n        diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  } // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n\n\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle,\n        line = handle;\n\n    if (typeof handle == \"number\") {\n      line = getLine(doc, clipLine(doc, handle));\n    } else {\n      no = lineNo(handle);\n    }\n\n    if (no == null) {\n      return null;\n    }\n\n    if (op(line, no) && doc.cm) {\n      regLineChange(doc.cm, no, changeType);\n    }\n\n    return line;\n  } // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.lines.length;\n    },\n    // Remove the n lines at offset 'at'.\n    removeInner: function removeInner(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function collapse(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function insertInner(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\n      for (var i = 0; i < lines.length; ++i) {\n        lines[i].parent = this;\n      }\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function iterN(at, n, op) {\n      for (var e = at + n; at < e; ++at) {\n        if (op(this.lines[at])) {\n          return true;\n        }\n      }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0,\n        height = 0;\n\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize();\n      height += ch.height;\n      ch.parent = this;\n    }\n\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.size;\n    },\n    removeInner: function removeInner(at, n) {\n      this.size -= n;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var rm = Math.min(n, sz - at),\n              oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n\n          if (sz == rm) {\n            this.children.splice(i--, 1);\n            child.parent = null;\n          }\n\n          if ((n -= rm) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      } // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n\n\n      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function collapse(lines) {\n      for (var i = 0; i < this.children.length; ++i) {\n        this.children[i].collapse(lines);\n      }\n    },\n    insertInner: function insertInner(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n\n          break;\n        }\n\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function maybeSpill() {\n      if (this.children.length <= 10) {\n        return;\n      }\n\n      var me = this;\n\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n\n        if (!me.parent) {\n          // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n\n      me.parent.maybeSpill();\n    },\n    iterN: function iterN(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n\n          if (child.iterN(at, used, op)) {\n            return true;\n          }\n\n          if ((n -= used) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      }\n    }\n  }; // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function LineWidget(doc, node, options) {\n    if (options) {\n      for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm,\n        ws = this.line.widgets,\n        line = this.line,\n        no = lineNo(line);\n\n    if (no == null || !ws) {\n      return;\n    }\n\n    for (var i = 0; i < ws.length; ++i) {\n      if (ws[i] == this) {\n        ws.splice(i--, 1);\n      }\n    }\n\n    if (!ws.length) {\n      line.widgets = null;\n    }\n\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n    var this$1 = this;\n    var oldH = this.height,\n        cm = this.doc.cm,\n        line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n\n    if (!diff) {\n      return;\n    }\n\n    if (!lineIsHidden(this.doc, line)) {\n      updateLineHeight(line, line.height + diff);\n    }\n\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n      addToScrollTop(cm, diff);\n    }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n\n    if (cm && widget.noHScroll) {\n      cm.display.alignWidgets = true;\n    }\n\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n\n      if (widget.insertAt == null) {\n        widgets.push(widget);\n      } else {\n        widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n      }\n\n      widget.line = line;\n\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = _heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n\n        if (aboveVisible) {\n          addToScrollTop(cm, widget.height);\n        }\n\n        cm.curOp.forceUpdate = true;\n      }\n\n      return true;\n    });\n\n    if (cm) {\n      signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n    }\n\n    return widget;\n  } // TEXTMARKERS\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n\n\n  var nextMarkerId = 0;\n\n  var TextMarker = function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  }; // Clear the marker.\n\n\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    var cm = this.doc.cm,\n        withOp = cm && !cm.curOp;\n\n    if (withOp) {\n      _startOperation(cm);\n    }\n\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n\n      if (found) {\n        signalLater(this, \"clear\", found.from, found.to);\n      }\n    }\n\n    var min = null,\n        max = null;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n\n      if (cm && !this.collapsed) {\n        regLineChange(cm, lineNo(line), \"text\");\n      } else if (cm) {\n        if (span.to != null) {\n          max = lineNo(line);\n        }\n\n        if (span.from != null) {\n          min = lineNo(line);\n        }\n      }\n\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n        updateLineHeight(line, textHeight(cm.display));\n      }\n    }\n\n    if (cm && this.collapsed && !cm.options.lineWrapping) {\n      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n        var visual = visualLine(this.lines[i$1]),\n            len = lineLength(visual);\n\n        if (len > cm.display.maxLineLength) {\n          cm.display.maxLine = visual;\n          cm.display.maxLineLength = len;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n\n    if (min != null && cm && this.collapsed) {\n      regChange(cm, min, max + 1);\n    }\n\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n\n      if (cm) {\n        reCheckSelection(cm.doc);\n      }\n    }\n\n    if (cm) {\n      signalLater(cm, \"markerCleared\", cm, this, min, max);\n    }\n\n    if (withOp) {\n      _endOperation(cm);\n    }\n\n    if (this.parent) {\n      this.parent.clear();\n    }\n  }; // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n\n\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") {\n      side = 1;\n    }\n\n    var from, to;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n\n        if (side == -1) {\n          return from;\n        }\n      }\n\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n\n        if (side == 1) {\n          return to;\n        }\n      }\n    }\n\n    return from && {\n      from: from,\n      to: to\n    };\n  }; // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n\n\n  TextMarker.prototype.changed = function () {\n    var this$1 = this;\n    var pos = this.find(-1, true),\n        widget = this,\n        cm = this.doc.cm;\n\n    if (!pos || !cm) {\n      return;\n    }\n\n    runInOp(cm, function () {\n      var line = pos.line,\n          lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n\n      cm.curOp.updateMaxLine = true;\n\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n\n        if (dHeight) {\n          updateLineHeight(line, line.height + dHeight);\n        }\n      }\n\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n      }\n    }\n\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and\n\n  function _markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) {\n      return markTextShared(doc, from, to, options, type);\n    } // Ensure we are in an operation.\n\n\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, _markText)(doc, from, to, options, type);\n    }\n\n    var marker = new TextMarker(doc, type),\n        diff = cmp(from, to);\n\n    if (options) {\n      copyObj(options, marker, false);\n    } // Don't connect empty markers unless clearWhenEmpty is false\n\n\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n      return marker;\n    }\n\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\n      if (!options.handleMouseEvents) {\n        marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      if (options.insertLeft) {\n        marker.widgetNode.insertLeft = true;\n      }\n    }\n\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      }\n\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory) {\n      addChangeToHistory(doc, {\n        from: from,\n        to: to,\n        origin: \"markText\"\n      }, doc.sel, NaN);\n    }\n\n    var curLine = from.line,\n        cm = doc.cm,\n        updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n        updateMaxLine = true;\n      }\n\n      if (marker.collapsed && curLine != from.line) {\n        updateLineHeight(line, 0);\n      }\n\n      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n      ++curLine;\n    }); // lineIsHidden depends on the presence of the spans, so needs a second pass\n\n    if (marker.collapsed) {\n      doc.iter(from.line, to.line + 1, function (line) {\n        if (lineIsHidden(doc, line)) {\n          updateLineHeight(line, 0);\n        }\n      });\n    }\n\n    if (marker.clearOnEnter) {\n      on(marker, \"beforeCursorEnter\", function () {\n        return marker.clear();\n      });\n    }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n\n      if (doc.history.done.length || doc.history.undone.length) {\n        doc.clearHistory();\n      }\n    }\n\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) {\n        cm.curOp.updateMaxLine = true;\n      }\n\n      if (marker.collapsed) {\n        regChange(cm, from.line, to.line + 1);\n      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n        for (var i = from.line; i <= to.line; i++) {\n          regLineChange(cm, i, \"text\");\n        }\n      }\n\n      if (marker.atomic) {\n        reCheckSelection(cm.doc);\n      }\n\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n\n    return marker;\n  } // SHARED TEXTMARKERS\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n\n\n  var SharedTextMarker = function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n\n    for (var i = 0; i < markers.length; ++i) {\n      markers[i].parent = this;\n    }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    this.explicitlyCleared = true;\n\n    for (var i = 0; i < this.markers.length; ++i) {\n      this.markers[i].clear();\n    }\n\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [_markText(doc, from, to, options, type)],\n        primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) {\n        options.widgetNode = widget.cloneNode(true);\n      }\n\n      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));\n\n      for (var i = 0; i < doc.linked.length; ++i) {\n        if (doc.linked[i].isParent) {\n          return;\n        }\n      }\n\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {\n      return m.parent;\n    });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i],\n          pos = marker.find();\n      var mFrom = doc.clipPos(pos.from),\n          mTo = doc.clipPos(pos.to);\n\n      if (cmp(mFrom, mTo)) {\n        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function loop(i) {\n      var marker = markers[i],\n          linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) {\n        return linked.push(d);\n      });\n\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) {\n      loop(i);\n    }\n  }\n\n  var nextDocId = 0;\n\n  var Doc = function Doc(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) {\n      return new Doc(text, mode, firstLine, lineSep, direction);\n    }\n\n    if (firstLine == null) {\n      firstLine = 0;\n    }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = direction == \"rtl\" ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") {\n      text = this.splitLines(text);\n    }\n\n    updateDoc(this, {\n      from: start,\n      to: start,\n      text: text\n    });\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function iter(from, to, op) {\n      if (op) {\n        this.iterN(from - this.first, to - from, op);\n      } else {\n        this.iterN(this.first, this.first + this.size, from);\n      }\n    },\n    // Non-public interface for adding and removing lines.\n    insert: function insert(at, lines) {\n      var height = 0;\n\n      for (var i = 0; i < lines.length; ++i) {\n        height += lines[i].height;\n      }\n\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function remove(at, n) {\n      this.removeInner(at - this.first, n);\n    },\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n    getValue: function getValue(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function (code) {\n      var top = Pos(this.first, 0),\n          last = this.first + this.size - 1;\n      makeChange(this, {\n        from: top,\n        to: Pos(last, getLine(this, last).text.length),\n        text: this.splitLines(code),\n        origin: \"setValue\",\n        full: true\n      }, true);\n\n      if (this.cm) {\n        scrollToCoords(this.cm, 0, 0);\n      }\n\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function replaceRange(code, from, to, origin) {\n      from = _clipPos(this, from);\n      to = to ? _clipPos(this, to) : from;\n\n      _replaceRange(this, code, from, to, origin);\n    },\n    getRange: function getRange(from, to, lineSep) {\n      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      if (lineSep === '') {\n        return lines.join('');\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    getLine: function getLine(line) {\n      var l = this.getLineHandle(line);\n      return l && l.text;\n    },\n    getLineHandle: function getLineHandle(line) {\n      if (isLine(this, line)) {\n        return getLine(this, line);\n      }\n    },\n    getLineNumber: function getLineNumber(line) {\n      return lineNo(line);\n    },\n    getLineHandleVisualStart: function getLineHandleVisualStart(line) {\n      if (typeof line == \"number\") {\n        line = getLine(this, line);\n      }\n\n      return visualLine(line);\n    },\n    lineCount: function lineCount() {\n      return this.size;\n    },\n    firstLine: function firstLine() {\n      return this.first;\n    },\n    lastLine: function lastLine() {\n      return this.first + this.size - 1;\n    },\n    clipPos: function clipPos(pos) {\n      return _clipPos(this, pos);\n    },\n    getCursor: function getCursor(start) {\n      var range = this.sel.primary(),\n          pos;\n\n      if (start == null || start == \"head\") {\n        pos = range.head;\n      } else if (start == \"anchor\") {\n        pos = range.anchor;\n      } else if (start == \"end\" || start == \"to\" || start === false) {\n        pos = range.to();\n      } else {\n        pos = range.from();\n      }\n\n      return pos;\n    },\n    listSelections: function listSelections() {\n      return this.sel.ranges;\n    },\n    somethingSelected: function somethingSelected() {\n      return this.sel.somethingSelected();\n    },\n    setCursor: docMethodOp(function (line, ch, options) {\n      setSimpleSelection(this, _clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function (anchor, head, options) {\n      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function (head, other, options) {\n      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function (heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function (f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function (ranges, primary, options) {\n      if (!ranges.length) {\n        return;\n      }\n\n      var out = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        out[i] = new Range(_clipPos(this, ranges[i].anchor), _clipPos(this, ranges[i].head || ranges[i].anchor));\n      }\n\n      if (primary == null) {\n        primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      }\n\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function (anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n    getSelection: function getSelection(lineSep) {\n      var ranges = this.sel.ranges,\n          lines;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n\n      if (lineSep === false) {\n        return lines;\n      } else {\n        return lines.join(lineSep || this.lineSeparator());\n      }\n    },\n    getSelections: function getSelections(lineSep) {\n      var parts = [],\n          ranges = this.sel.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\n        if (lineSep !== false) {\n          sel = sel.join(lineSep || this.lineSeparator());\n        }\n\n        parts[i] = sel;\n      }\n\n      return parts;\n    },\n    replaceSelection: function replaceSelection(code, collapse, origin) {\n      var dup = [];\n\n      for (var i = 0; i < this.sel.ranges.length; i++) {\n        dup[i] = code;\n      }\n\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function (code, collapse, origin) {\n      var changes = [],\n          sel = this.sel;\n\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {\n          from: range.from(),\n          to: range.to(),\n          text: this.splitLines(code[i]),\n          origin: origin\n        };\n      }\n\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {\n        makeChange(this, changes[i$1]);\n      }\n\n      if (newSel) {\n        setSelectionReplaceHistory(this, newSel);\n      } else if (this.cm) {\n        ensureCursorVisible(this.cm);\n      }\n    }),\n    undo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\");\n    }),\n    redo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\");\n    }),\n    undoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\", true);\n    }),\n    redoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\", true);\n    }),\n    setExtending: function setExtending(val) {\n      this.extend = val;\n    },\n    getExtending: function getExtending() {\n      return this.extend;\n    },\n    historySize: function historySize() {\n      var hist = this.history,\n          done = 0,\n          undone = 0;\n\n      for (var i = 0; i < hist.done.length; i++) {\n        if (!hist.done[i].ranges) {\n          ++done;\n        }\n      }\n\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {\n        if (!hist.undone[i$1].ranges) {\n          ++undone;\n        }\n      }\n\n      return {\n        undo: done,\n        redo: undone\n      };\n    },\n    clearHistory: function clearHistory() {\n      var this$1 = this;\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) {\n        return doc.history = this$1.history;\n      }, true);\n    },\n    markClean: function markClean() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function changeGeneration(forceSplit) {\n      if (forceSplit) {\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      }\n\n      return this.history.generation;\n    },\n    isClean: function isClean(gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n    getHistory: function getHistory() {\n      return {\n        done: copyHistoryArray(this.history.done),\n        undone: copyHistoryArray(this.history.undone)\n      };\n    },\n    setHistory: function setHistory(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n    setGutterMarker: docMethodOp(function (line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n\n        if (!value && isEmpty(markers)) {\n          line.gutterMarkers = null;\n        }\n\n        return true;\n      });\n    }),\n    clearGutter: docMethodOp(function (gutterID) {\n      var this$1 = this;\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n\n            if (isEmpty(line.gutterMarkers)) {\n              line.gutterMarkers = null;\n            }\n\n            return true;\n          });\n        }\n      });\n    }),\n    lineInfo: function lineInfo(line) {\n      var n;\n\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) {\n          return null;\n        }\n\n        n = line;\n        line = getLine(this, line);\n\n        if (!line) {\n          return null;\n        }\n      } else {\n        n = lineNo(line);\n\n        if (n == null) {\n          return null;\n        }\n      }\n\n      return {\n        line: n,\n        handle: line,\n        text: line.text,\n        gutterMarkers: line.gutterMarkers,\n        textClass: line.textClass,\n        bgClass: line.bgClass,\n        wrapClass: line.wrapClass,\n        widgets: line.widgets\n      };\n    },\n    addLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\n        if (!line[prop]) {\n          line[prop] = cls;\n        } else if (classTest(cls).test(line[prop])) {\n          return false;\n        } else {\n          line[prop] += \" \" + cls;\n        }\n\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n\n        if (!cur) {\n          return false;\n        } else if (cls == null) {\n          line[prop] = null;\n        } else {\n          var found = cur.match(classTest(cls));\n\n          if (!found) {\n            return false;\n          }\n\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n\n        return true;\n      });\n    }),\n    addLineWidget: docMethodOp(function (handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function removeLineWidget(widget) {\n      widget.clear();\n    },\n    markText: function markText(from, to, options) {\n      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function setBookmark(pos, options) {\n      var realOpts = {\n        replacedWith: options && (options.nodeType == null ? options.widget : options),\n        insertLeft: options && options.insertLeft,\n        clearWhenEmpty: false,\n        shared: options && options.shared,\n        handleMouseEvents: options && options.handleMouseEvents\n      };\n      pos = _clipPos(this, pos);\n      return _markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function findMarksAt(pos) {\n      pos = _clipPos(this, pos);\n      var markers = [],\n          spans = getLine(this, pos.line).markedSpans;\n\n      if (spans) {\n        for (var i = 0; i < spans.length; ++i) {\n          var span = spans[i];\n\n          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n            markers.push(span.marker.parent || span.marker);\n          }\n        }\n      }\n\n      return markers;\n    },\n    findMarks: function findMarks(from, to, filter) {\n      from = _clipPos(this, from);\n      to = _clipPos(this, to);\n      var found = [],\n          lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n\n        if (spans) {\n          for (var i = 0; i < spans.length; i++) {\n            var span = spans[i];\n\n            if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n              found.push(span.marker.parent || span.marker);\n            }\n          }\n        }\n\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function getAllMarks() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n\n        if (sps) {\n          for (var i = 0; i < sps.length; ++i) {\n            if (sps[i].from != null) {\n              markers.push(sps[i].marker);\n            }\n          }\n        }\n      });\n      return markers;\n    },\n    posFromIndex: function posFromIndex(off) {\n      var ch,\n          lineNo = this.first,\n          sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n\n        if (sz > off) {\n          ch = off;\n          return true;\n        }\n\n        off -= sz;\n        ++lineNo;\n      });\n      return _clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function indexFromPos(coords) {\n      coords = _clipPos(this, coords);\n      var index = coords.ch;\n\n      if (coords.line < this.first || coords.ch < 0) {\n        return 0;\n      }\n\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) {\n        // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index;\n    },\n    copy: function copy(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop;\n      doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n\n      return doc;\n    },\n    linkedDoc: function linkedDoc(options) {\n      if (!options) {\n        options = {};\n      }\n\n      var from = this.first,\n          to = this.first + this.size;\n\n      if (options.from != null && options.from > from) {\n        from = options.from;\n      }\n\n      if (options.to != null && options.to < to) {\n        to = options.to;\n      }\n\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n\n      if (options.sharedHist) {\n        copy.history = this.history;\n      }\n\n      (this.linked || (this.linked = [])).push({\n        doc: copy,\n        sharedHist: options.sharedHist\n      });\n      copy.linked = [{\n        doc: this,\n        isParent: true,\n        sharedHist: options.sharedHist\n      }];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function unlinkDoc(other) {\n      if (other instanceof CodeMirror) {\n        other = other.doc;\n      }\n\n      if (this.linked) {\n        for (var i = 0; i < this.linked.length; ++i) {\n          var link = this.linked[i];\n\n          if (link.doc != other) {\n            continue;\n          }\n\n          this.linked.splice(i, 1);\n          other.unlinkDoc(this);\n          detachSharedMarkers(findSharedMarkers(this));\n          break;\n        }\n      } // If the histories were shared, split them again\n\n\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) {\n          return splitIds.push(doc.id);\n        }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function iterLinkedDocs(f) {\n      linkedDocs(this, f);\n    },\n    getMode: function getMode() {\n      return this.mode;\n    },\n    getEditor: function getEditor() {\n      return this.cm;\n    },\n    splitLines: function splitLines(str) {\n      if (this.lineSep) {\n        return str.split(this.lineSep);\n      }\n\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function lineSeparator() {\n      return this.lineSep || \"\\n\";\n    },\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") {\n        dir = \"ltr\";\n      }\n\n      if (dir == this.direction) {\n        return;\n      }\n\n      this.direction = dir;\n      this.iter(function (line) {\n        return line.order = null;\n      });\n\n      if (this.cm) {\n        directionChanged(this.cm);\n      }\n    })\n  }); // Public alias.\n\n  Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e_preventDefault(e);\n\n    if (ie) {\n      lastDrop = +new Date();\n    }\n\n    var pos = posFromMouse(cm, e, true),\n        files = e.dataTransfer.files;\n\n    if (!pos || cm.isReadOnly()) {\n      return;\n    } // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n\n\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length,\n          text = Array(n),\n          read = 0;\n\n      var markAsReadAndPasteIfAllFilesAreRead = function markAsReadAndPasteIfAllFilesAreRead() {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = _clipPos(cm.doc, pos);\n            var change = {\n              from: pos,\n              to: pos,\n              text: cm.doc.splitLines(text.filter(function (t) {\n                return t != null;\n              }).join(cm.doc.lineSeparator())),\n              origin: \"paste\"\n            };\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(_clipPos(cm.doc, pos), _clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n\n      var readTextFromFile = function readTextFromFile(file, i) {\n        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return;\n        }\n\n        var reader = new FileReader();\n\n        reader.onerror = function () {\n          return markAsReadAndPasteIfAllFilesAreRead();\n        };\n\n        reader.onload = function () {\n          var content = reader.result;\n\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return;\n          }\n\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n\n        reader.readAsText(file);\n      };\n\n      for (var i = 0; i < files.length; i++) {\n        readTextFromFile(files[i], i);\n      }\n    } else {\n      // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e); // Ensure the editor is re-focused\n\n        setTimeout(function () {\n          return cm.display.input.focus();\n        }, 20);\n        return;\n      }\n\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n\n        if (text$1) {\n          var selected;\n\n          if (cm.state.draggingText && !cm.state.draggingText.copy) {\n            selected = cm.listSelections();\n          }\n\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\n          if (selected) {\n            for (var i$1 = 0; i$1 < selected.length; ++i$1) {\n              _replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\");\n            }\n          }\n\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      } catch (e$1) {}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n      e_stop(e);\n      return;\n    }\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\"; // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason\n\n        img._top = img.offsetTop;\n      }\n\n      e.dataTransfer.setDragImage(img, 0, 0);\n\n      if (presto) {\n        img.parentNode.removeChild(img);\n      }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n\n    if (!pos) {\n      return;\n    }\n\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  } // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) {\n      return;\n    }\n\n    var byClass = document.getElementsByClassName(\"CodeMirror\"),\n        editors = [];\n\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n\n      if (cm) {\n        editors.push(cm);\n      }\n    }\n\n    if (editors.length) {\n      editors[0].operation(function () {\n        for (var i = 0; i < editors.length; i++) {\n          f(editors[i]);\n        }\n      });\n    }\n  }\n\n  var globalsRegistered = false;\n\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) {\n      return;\n    }\n\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) {\n        resizeTimer = setTimeout(function () {\n          resizeTimer = null;\n          forEachCodeMirror(onResize);\n        }, 100);\n      }\n    }); // When the window loses focus, we want to show the editor as blurred\n\n    on(window, \"blur\", function () {\n      return forEachCodeMirror(onBlur);\n    });\n  } // Called when the window resizes\n\n\n  function onResize(cm) {\n    var d = cm.display; // Might be a text scaling operation, clear size caches.\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\",\n    8: \"Backspace\",\n    9: \"Tab\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Ctrl\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Esc\",\n    32: \"Space\",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"Left\",\n    38: \"Up\",\n    39: \"Right\",\n    40: \"Down\",\n    44: \"PrintScrn\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    61: \"=\",\n    91: \"Mod\",\n    92: \"Mod\",\n    93: \"Mod\",\n    106: \"*\",\n    107: \"=\",\n    109: \"-\",\n    110: \".\",\n    111: \"/\",\n    145: \"ScrollLock\",\n    173: \"-\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\",\n    224: \"Mod\",\n    63232: \"Up\",\n    63233: \"Down\",\n    63234: \"Left\",\n    63235: \"Right\",\n    63272: \"Delete\",\n    63273: \"Home\",\n    63275: \"End\",\n    63276: \"PageUp\",\n    63277: \"PageDown\",\n    63302: \"Insert\"\n  }; // Number keys\n\n  for (var i = 0; i < 10; i++) {\n    keyNames[i + 48] = keyNames[i + 96] = String(i);\n  } // Alphabetic keys\n\n\n  for (var i$1 = 65; i$1 <= 90; i$1++) {\n    keyNames[i$1] = String.fromCharCode(i$1);\n  } // Function keys\n\n\n  for (var i$2 = 1; i$2 <= 12; i$2++) {\n    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2;\n  }\n\n  var keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\",\n    \"Right\": \"goCharRight\",\n    \"Up\": \"goLineUp\",\n    \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStartSmart\",\n    \"PageUp\": \"goPageUp\",\n    \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\",\n    \"Backspace\": \"delCharBefore\",\n    \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\",\n    \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  }; // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\",\n    \"Ctrl-D\": \"deleteLine\",\n    \"Ctrl-Z\": \"undo\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\",\n    \"Ctrl-End\": \"goDocEnd\",\n    \"Ctrl-Up\": \"goLineUp\",\n    \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\",\n    \"Ctrl-Right\": \"goGroupRight\",\n    \"Alt-Left\": \"goLineStart\",\n    \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Delete\": \"delGroupAfter\",\n    \"Ctrl-S\": \"save\",\n    \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\",\n    \"Shift-Ctrl-G\": \"findPrev\",\n    \"Shift-Ctrl-F\": \"replace\",\n    \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\",\n    \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\",\n    \"Shift-Ctrl-U\": \"redoSelection\",\n    \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  }; // Very basic readline/emacs-style bindings, which are standard on Mac.\n\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\",\n    \"Ctrl-B\": \"goCharLeft\",\n    \"Ctrl-P\": \"goLineUp\",\n    \"Ctrl-N\": \"goLineDown\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\",\n    \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\",\n    \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\",\n    \"Cmd-D\": \"deleteLine\",\n    \"Cmd-Z\": \"undo\",\n    \"Shift-Cmd-Z\": \"redo\",\n    \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\",\n    \"Cmd-Up\": \"goDocStart\",\n    \"Cmd-End\": \"goDocEnd\",\n    \"Cmd-Down\": \"goDocEnd\",\n    \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\",\n    \"Cmd-Left\": \"goLineLeft\",\n    \"Cmd-Right\": \"goLineRight\",\n    \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n    \"Alt-Delete\": \"delGroupAfter\",\n    \"Cmd-S\": \"save\",\n    \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\",\n    \"Shift-Cmd-G\": \"findPrev\",\n    \"Cmd-Alt-F\": \"replace\",\n    \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\",\n    \"Cmd-]\": \"indentMore\",\n    \"Cmd-Backspace\": \"delWrappedLineLeft\",\n    \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\",\n    \"Shift-Cmd-U\": \"redoSelection\",\n    \"Ctrl-Up\": \"goDocStart\",\n    \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n\n      if (/^(cmd|meta|m)$/i.test(mod)) {\n        cmd = true;\n      } else if (/^a(lt)?$/i.test(mod)) {\n        alt = true;\n      } else if (/^(c|ctrl|control)$/i.test(mod)) {\n        ctrl = true;\n      } else if (/^s(hift)?$/i.test(mod)) {\n        shift = true;\n      } else {\n        throw new Error(\"Unrecognized modifier name: \" + mod);\n      }\n    }\n\n    if (alt) {\n      name = \"Alt-\" + name;\n    }\n\n    if (ctrl) {\n      name = \"Ctrl-\" + name;\n    }\n\n    if (cmd) {\n      name = \"Cmd-\" + name;\n    }\n\n    if (shift) {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n\n\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n\n    for (var keyname in keymap) {\n      if (keymap.hasOwnProperty(keyname)) {\n        var value = keymap[keyname];\n\n        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n          continue;\n        }\n\n        if (value == \"...\") {\n          delete keymap[keyname];\n          continue;\n        }\n\n        var keys = map(keyname.split(\" \"), normalizeKeyName);\n\n        for (var i = 0; i < keys.length; i++) {\n          var val = void 0,\n              name = void 0;\n\n          if (i == keys.length - 1) {\n            name = keys.join(\" \");\n            val = value;\n          } else {\n            name = keys.slice(0, i + 1).join(\" \");\n            val = \"...\";\n          }\n\n          var prev = copy[name];\n\n          if (!prev) {\n            copy[name] = val;\n          } else if (prev != val) {\n            throw new Error(\"Inconsistent bindings for \" + name);\n          }\n        }\n\n        delete keymap[keyname];\n      }\n    }\n\n    for (var prop in copy) {\n      keymap[prop] = copy[prop];\n    }\n\n    return keymap;\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n\n    if (found === false) {\n      return \"nothing\";\n    }\n\n    if (found === \"...\") {\n      return \"multi\";\n    }\n\n    if (found != null && handle(found)) {\n      return \"handled\";\n    }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\") {\n        return lookupKey(key, map.fallthrough, handle, context);\n      }\n\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n  } // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n\n\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n\n    if (event.altKey && base != \"Alt\") {\n      name = \"Alt-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") {\n      name = \"Ctrl-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") {\n      name = \"Cmd-\" + name;\n    }\n\n    if (!noShift && event.shiftKey && base != \"Shift\") {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // Look up the name of a key as indicated by an event object.\n\n\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) {\n      return false;\n    }\n\n    var name = keyNames[event.keyCode];\n\n    if (name == null || event.altGraphKey) {\n      return false;\n    } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n\n\n    if (event.keyCode == 3 && event.code) {\n      name = event.code;\n    }\n\n    return addModifierNames(name, event, noShift);\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  } // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n\n\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges,\n        kill = []; // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n\n      kill.push(toKill);\n    } // Next, remove those actual ranges.\n\n\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      }\n\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\");\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") {\n        dir = -dir;\n      }\n\n      var order = getOrder(lineObj, cm.doc.direction);\n\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = dir < 0 == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) {\n            return measureCharPrepared(cm, prep, ch).top == targetTop;\n          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n\n          if (sticky == \"before\") {\n            ch = moveCharLogically(lineObj, ch, 1);\n          }\n        } else {\n          ch = dir < 0 ? part.to : part.from;\n        }\n\n        return new Pos(lineNo, ch, sticky);\n      }\n    }\n\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\");\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n\n    if (!bidi) {\n      return moveLogically(line, start, dir);\n    }\n\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),\n        part = bidi[partPos];\n\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir);\n    }\n\n    var mv = function mv(pos, dir) {\n      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);\n    };\n\n    var prep;\n\n    var getWrappedLineExtent = function getWrappedLineExtent(ch) {\n      if (!cm.options.lineWrapping) {\n        return {\n          begin: 0,\n          end: line.text.length\n        };\n      }\n\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch);\n    };\n\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = part.level == 1 == dir < 0;\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky);\n      }\n    } // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n\n    var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {\n      var getRes = function getRes(ch, moveInStorageOrder) {\n        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), \"before\") : new Pos(start.line, ch, \"after\");\n      };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = dir > 0 == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n\n        if (part.from <= ch && ch < part.to) {\n          return getRes(ch, moveInStorageOrder);\n        }\n\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {\n          return getRes(ch, moveInStorageOrder);\n        }\n      }\n    }; // Case 3a: Look for other bidi parts on the same visual line\n\n\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n\n    if (res) {\n      return res;\n    } // Case 3b: Look for other bidi parts on the next visual line\n\n\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n\n      if (res) {\n        return res;\n      }\n    } // Case 4: Nowhere to move\n\n\n    return null;\n  } // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n\n\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function singleSelection(cm) {\n      return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function killLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n\n          if (range.head.ch == len && range.head.line < cm.lastLine()) {\n            return {\n              from: range.head,\n              to: Pos(range.head.line + 1, 0)\n            };\n          } else {\n            return {\n              from: range.head,\n              to: Pos(range.head.line, len)\n            };\n          }\n        } else {\n          return {\n            from: range.from(),\n            to: range.to()\n          };\n        }\n      });\n    },\n    deleteLine: function deleteLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))\n        };\n      });\n    },\n    delLineLeft: function delLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineLeft: function delWrappedLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n        return {\n          from: leftPos,\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineRight: function delWrappedLineRight(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n        return {\n          from: range.from(),\n          to: rightPos\n        };\n      });\n    },\n    undo: function undo(cm) {\n      return cm.undo();\n    },\n    redo: function redo(cm) {\n      return cm.redo();\n    },\n    undoSelection: function undoSelection(cm) {\n      return cm.undoSelection();\n    },\n    redoSelection: function redoSelection(cm) {\n      return cm.redoSelection();\n    },\n    goDocStart: function goDocStart(cm) {\n      return cm.extendSelection(Pos(cm.firstLine(), 0));\n    },\n    goDocEnd: function goDocEnd(cm) {\n      return cm.extendSelection(Pos(cm.lastLine()));\n    },\n    goLineStart: function goLineStart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStart(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineStartSmart: function goLineStartSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStartSmart(cm, range.head);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineEnd: function goLineEnd(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineEnd(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: -1\n      });\n    },\n    goLineRight: function goLineRight(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function goLineLeft(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function goLineLeftSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n          return lineStartSmart(cm, range.head);\n        }\n\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function goLineUp(cm) {\n      return cm.moveV(-1, \"line\");\n    },\n    goLineDown: function goLineDown(cm) {\n      return cm.moveV(1, \"line\");\n    },\n    goPageUp: function goPageUp(cm) {\n      return cm.moveV(-1, \"page\");\n    },\n    goPageDown: function goPageDown(cm) {\n      return cm.moveV(1, \"page\");\n    },\n    goCharLeft: function goCharLeft(cm) {\n      return cm.moveH(-1, \"char\");\n    },\n    goCharRight: function goCharRight(cm) {\n      return cm.moveH(1, \"char\");\n    },\n    goColumnLeft: function goColumnLeft(cm) {\n      return cm.moveH(-1, \"column\");\n    },\n    goColumnRight: function goColumnRight(cm) {\n      return cm.moveH(1, \"column\");\n    },\n    goWordLeft: function goWordLeft(cm) {\n      return cm.moveH(-1, \"word\");\n    },\n    goGroupRight: function goGroupRight(cm) {\n      return cm.moveH(1, \"group\");\n    },\n    goGroupLeft: function goGroupLeft(cm) {\n      return cm.moveH(-1, \"group\");\n    },\n    goWordRight: function goWordRight(cm) {\n      return cm.moveH(1, \"word\");\n    },\n    delCharBefore: function delCharBefore(cm) {\n      return cm.deleteH(-1, \"codepoint\");\n    },\n    delCharAfter: function delCharAfter(cm) {\n      return cm.deleteH(1, \"char\");\n    },\n    delWordBefore: function delWordBefore(cm) {\n      return cm.deleteH(-1, \"word\");\n    },\n    delWordAfter: function delWordAfter(cm) {\n      return cm.deleteH(1, \"word\");\n    },\n    delGroupBefore: function delGroupBefore(cm) {\n      return cm.deleteH(-1, \"group\");\n    },\n    delGroupAfter: function delGroupAfter(cm) {\n      return cm.deleteH(1, \"group\");\n    },\n    indentAuto: function indentAuto(cm) {\n      return cm.indentSelection(\"smart\");\n    },\n    indentMore: function indentMore(cm) {\n      return cm.indentSelection(\"add\");\n    },\n    indentLess: function indentLess(cm) {\n      return cm.indentSelection(\"subtract\");\n    },\n    insertTab: function insertTab(cm) {\n      return cm.replaceSelection(\"\\t\");\n    },\n    insertSoftTab: function insertSoftTab(cm) {\n      var spaces = [],\n          ranges = cm.listSelections(),\n          tabSize = cm.options.tabSize;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function defaultTab(cm) {\n      if (cm.somethingSelected()) {\n        cm.indentSelection(\"add\");\n      } else {\n        cm.execCommand(\"insertTab\");\n      }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function transposeChars(cm) {\n      return runInOp(cm, function () {\n        var ranges = cm.listSelections(),\n            newSel = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          if (!ranges[i].empty()) {\n            continue;\n          }\n\n          var cur = ranges[i].head,\n              line = getLine(cm.doc, cur.line).text;\n\n          if (line) {\n            if (cur.ch == line.length) {\n              cur = new Pos(cur.line, cur.ch - 1);\n            }\n\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n\n              if (prev) {\n                cur = new Pos(cur.line, 1);\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n              }\n            }\n          }\n\n          newSel.push(new Range(cur, cur));\n        }\n\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function newlineAndIndent(cm) {\n      return runInOp(cm, function () {\n        var sels = cm.listSelections();\n\n        for (var i = sels.length - 1; i >= 0; i--) {\n          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\");\n        }\n\n        sels = cm.listSelections();\n\n        for (var i$1 = 0; i$1 < sels.length; i$1++) {\n          cm.indentLine(sels[i$1].from().line, null, true);\n        }\n\n        ensureCursorVisible(cm);\n      });\n    },\n    openLine: function openLine(cm) {\n      return cm.replaceSelection(\"\\n\", \"start\");\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      return cm.toggleOverwrite();\n    }\n  };\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, visual, lineN, 1);\n  }\n\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, line, lineN, -1);\n  }\n\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n    }\n\n    return start;\n  } // Run a handler that was bound to a key.\n\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n\n      if (!bound) {\n        return false;\n      }\n    } // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n\n\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift,\n        done = false;\n\n    try {\n      if (cm.isReadOnly()) {\n        cm.state.suppressEdits = true;\n      }\n\n      if (dropShift) {\n        cm.display.shift = false;\n      }\n\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n  } // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n\n  var stopSeq = new Delayed();\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n\n    if (seq) {\n      if (isModifierKey(name)) {\n        return \"handled\";\n      }\n\n      if (/\\'$/.test(name)) {\n        cm.state.keySeq = null;\n      } else {\n        stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        });\n      }\n\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) {\n        return true;\n      }\n    }\n\n    return dispatchKeyInner(cm, name, e, handle);\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\") {\n      cm.state.keySeq = name;\n    }\n\n    if (result == \"handled\") {\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result;\n  } // Handle a key from the keydown event.\n\n\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n\n    if (!name) {\n      return false;\n    }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) {\n        return doHandleBinding(cm, b, true);\n      }) || dispatchKey(cm, name, e, function (b) {\n        if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) {\n          return doHandleBinding(cm, b);\n        }\n      });\n    } else {\n      return dispatchKey(cm, name, e, function (b) {\n        return doHandleBinding(cm, b);\n      });\n    }\n  } // Handle a key from the keypress event\n\n\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) {\n      return doHandleBinding(cm, b, true);\n    });\n  }\n\n  var lastStoppedKey = null;\n\n  function onKeyDown(e) {\n    var cm = this;\n\n    if (e.target && e.target != cm.display.input.getField()) {\n      return;\n    }\n\n    cm.curOp.focus = activeElt();\n\n    if (signalDOMEvent(cm, e)) {\n      return;\n    } // IE does strange things with escape.\n\n\n    if (ie && ie_version < 11 && e.keyCode == 27) {\n      e.returnValue = false;\n    }\n\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n\n    if (presto) {\n      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo\n\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n        cm.replaceSelection(\"\", null, \"cut\");\n      }\n    }\n\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n      document.execCommand(\"cut\");\n    } // Turn mouse into crosshair when Alt is held on Mac.\n\n\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n      showCrossHair(cm);\n    }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) {\n      this.doc.sel.shift = false;\n    }\n\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n\n    if (e.target && e.target != cm.display.input.getField()) {\n      return;\n    }\n\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n      return;\n    }\n\n    var keyCode = e.keyCode,\n        charCode = e.charCode;\n\n    if (presto && keyCode == lastStoppedKey) {\n      lastStoppedKey = null;\n      e_preventDefault(e);\n      return;\n    }\n\n    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n      return;\n    }\n\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace\n\n    if (ch == \"\\x08\") {\n      return;\n    }\n\n    if (handleCharBinding(cm, e, ch)) {\n      return;\n    }\n\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function PastClick(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n  };\n\n  var lastClick, lastDoubleClick;\n\n  function clickRepeat(pos, button) {\n    var now = +new Date();\n\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\";\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\";\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\";\n    }\n  } // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n\n\n  function onMouseDown(e) {\n    var cm = this,\n        display = cm.display;\n\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n      return;\n    }\n\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () {\n          return display.scroller.draggable = true;\n        }, 100);\n      }\n\n      return;\n    }\n\n    if (clickInGutter(cm, e)) {\n      return;\n    }\n\n    var pos = posFromMouse(cm, e),\n        button = e_button(e),\n        repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus(); // #3261: make sure, that we're not starting a second selection\n\n    if (button == 1 && cm.state.selectingText) {\n      cm.state.selectingText(e);\n    }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n      return;\n    }\n\n    if (button == 1) {\n      if (pos) {\n        leftButtonDown(cm, pos, repeat, e);\n      } else if (e_target(e) == display.scroller) {\n        e_preventDefault(e);\n      }\n    } else if (button == 2) {\n      if (pos) {\n        extendSelection(cm.doc, pos);\n      }\n\n      setTimeout(function () {\n        return display.input.focus();\n      }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) {\n        cm.display.input.onContextMenu(e);\n      } else {\n        delayBlurEvent(cm);\n      }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n\n    if (repeat == \"double\") {\n      name = \"Double\" + name;\n    } else if (repeat == \"triple\") {\n      name = \"Triple\" + name;\n    }\n\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n      }\n\n      if (!bound) {\n        return false;\n      }\n\n      var done = false;\n\n      try {\n        if (cm.isReadOnly()) {\n          cm.state.suppressEdits = true;\n        }\n\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n\n      return done;\n    });\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n\n    if (value.extend == null || cm.doc.extend) {\n      value.extend = cm.doc.extend || event.shiftKey;\n    }\n\n    if (value.addNew == null) {\n      value.addNew = mac ? event.metaKey : event.ctrlKey;\n    }\n\n    if (value.moveOnDrag == null) {\n      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n    }\n\n    return value;\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) {\n      setTimeout(bind(ensureFocus, cm), 0);\n    } else {\n      cm.curOp.focus = activeElt();\n    }\n\n    var behavior = configureMouse(cm, repeat, event);\n    var sel = cm.doc.sel,\n        contained;\n\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == \"single\" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n      leftButtonStartDrag(cm, event, pos, behavior);\n    } else {\n      leftButtonSelect(cm, event, pos, behavior);\n    }\n  } // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n\n\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display,\n        moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) {\n        display.scroller.draggable = false;\n      }\n\n      cm.state.draggingText = false;\n\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) {\n          cm.state.delayingBlurEvent = false;\n        } else {\n          delayBlurEvent(cm);\n        }\n      }\n\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n\n      if (!moved) {\n        e_preventDefault(e);\n\n        if (!behavior.addNew) {\n          extendSelection(cm.doc, pos, null, null, behavior.extend);\n        } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\n\n        if (webkit && !safari || ie && ie_version == 9) {\n          setTimeout(function () {\n            display.wrapper.ownerDocument.body.focus({\n              preventScroll: true\n            });\n            display.input.focus();\n          }, 20);\n        } else {\n          display.input.focus();\n        }\n      }\n    });\n\n    var mouseMove = function mouseMove(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n\n    var dragStart = function dragStart() {\n      return moved = true;\n    }; // Let the drag handler handle this.\n\n\n    if (webkit) {\n      display.scroller.draggable = true;\n    }\n\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () {\n      return display.input.focus();\n    }, 20); // IE's approach to draggable\n\n    if (display.scroller.dragDrop) {\n      display.scroller.dragDrop();\n    }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") {\n      return new Range(pos, pos);\n    }\n\n    if (unit == \"word\") {\n      return cm.findWordAt(pos);\n    }\n\n    if (unit == \"line\") {\n      return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n    }\n\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to);\n  } // Normal selection, as opposed to text dragging.\n\n\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) {\n      delayBlurEvent(cm);\n    }\n\n    var display = cm.display,\n        doc = cm.doc;\n    e_preventDefault(event);\n    var ourRange,\n        ourIndex,\n        startSel = doc.sel,\n        ranges = startSel.ranges;\n\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n\n      if (ourIndex > -1) {\n        ourRange = ranges[ourIndex];\n      } else {\n        ourRange = new Range(start, start);\n      }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) {\n        ourRange = new Range(start, start);\n      }\n\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n\n      if (behavior.extend) {\n        ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);\n      } else {\n        ourRange = range;\n      }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) {\n        return;\n      }\n\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [],\n            tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol),\n            right = Math.max(startCol, posCol);\n\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n          var text = getLine(doc, line).text,\n              leftPos = findColumn(text, left, tabSize);\n\n          if (left == right) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          } else if (text.length > leftPos) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n          }\n        }\n\n        if (!ranges.length) {\n          ranges.push(new Range(start, start));\n        }\n\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {\n          origin: \"*mouse\",\n          scroll: false\n        });\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor,\n            head;\n\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n\n      if (!cur) {\n        return;\n      }\n\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n\n        if (cur.line >= visible.to || cur.line < visible.from) {\n          setTimeout(operation(cm, function () {\n            if (counter == curCount) {\n              extend(e);\n            }\n          }), 150);\n        }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\n        if (outside) {\n          setTimeout(operation(cm, function () {\n            if (counter != curCount) {\n              return;\n            }\n\n            display.scroller.scrollTop += outside;\n            extend(e);\n          }), 50);\n        }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity; // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) {\n        done(e);\n      } else {\n        extend(e);\n      }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  } // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n\n\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n      return range;\n    }\n\n    var order = getOrder(anchorLine);\n\n    if (!order) {\n      return range;\n    }\n\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),\n        part = order[index];\n\n    if (part.from != anchor.ch && part.to != anchor.ch) {\n      return range;\n    }\n\n    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n\n    if (boundary == 0 || boundary == order.length) {\n      return range;\n    } // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n\n\n    var leftSide;\n\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n\n      if (headIndex == boundary - 1 || headIndex == boundary) {\n        leftSide = dir < 0;\n      } else {\n        leftSide = dir > 0;\n      }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to,\n        sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);\n  } // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n\n\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try {\n        mX = e.clientX;\n        mY = e.clientY;\n      } catch (e$1) {\n        return false;\n      }\n    }\n\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n      return false;\n    }\n\n    if (prevent) {\n      e_preventDefault(e);\n    }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n      return e_defaultPrevented(e);\n    }\n\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = _lineAtHeight(cm.doc, mY);\n\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  } // CONTEXT MENU HANDLING\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n\n\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n      return;\n    }\n\n    if (signalDOMEvent(cm, e, \"contextmenu\")) {\n      return;\n    }\n\n    if (!captureRightClick) {\n      cm.display.input.onContextMenu(e);\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) {\n      return false;\n    }\n\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {\n    toString: function toString() {\n      return \"CodeMirror.Init\";\n    }\n  };\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n\n      if (handle) {\n        optionHandlers[name] = notOnInit ? function (cm, val, old) {\n          if (old != Init) {\n            handle(cm, val, old);\n          }\n        } : handle;\n      }\n    }\n\n    CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.\n\n    CodeMirror.Init = Init; // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n\n    option(\"value\", \"\", function (cm, val) {\n      return cm.setValue(val);\n    }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n\n      if (!val) {\n        return;\n      }\n\n      var newBreaks = [],\n          lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n\n          if (found == -1) {\n            break;\n          }\n\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n\n        lineNo++;\n      });\n\n      for (var i = newBreaks.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));\n      }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\n      if (old != Init) {\n        cm.refresh();\n      }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) {\n      return cm.getInputField().spellcheck = val;\n    }, true);\n    option(\"autocorrect\", false, function (cm, val) {\n      return cm.getInputField().autocorrect = val;\n    }, true);\n    option(\"autocapitalize\", false, function (cm, val) {\n      return cm.getInputField().autocapitalize = val;\n    }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n\n      if (prev && prev.detach) {\n        prev.detach(cm, next);\n      }\n\n      if (next.attach) {\n        next.attach(cm, prev || null);\n      }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) {\n      return updateScrollbars(cm);\n    }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) {\n      return integer;\n    }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = val === '' ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {\n      if (!val) {\n        cm.display.input.reset();\n      }\n    }, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) {\n      return cm.doc.history.undoDepth = val;\n    });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) {\n        cm.display.input.resetPosition();\n      }\n    });\n    option(\"tabindex\", null, function (cm, val) {\n      return cm.display.input.getField().tabIndex = val || \"\";\n    });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) {\n      return cm.doc.setDirection(val);\n    }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () {\n      return updateScrollbars(cm);\n    }, 100);\n  } // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) {\n      return new CodeMirror(place, options);\n    }\n\n    this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.\n\n    copyObj(defaults, options, false);\n    var doc = options.value;\n\n    if (typeof doc == \"string\") {\n      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n    } else if (options.mode) {\n      doc.modeOption = options.mode;\n    }\n\n    this.doc = doc;\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n\n    if (options.lineWrapping) {\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    }\n\n    initScrollbars(this);\n    this.state = {\n      keyMaps: [],\n      // stores maps added by addKeyMap\n      overlays: [],\n      // highlighting overlays, as added by addOverlay\n      modeGen: 0,\n      // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false,\n      // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1,\n      cutIncoming: -1,\n      // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(),\n      // stores highlight worker timeout\n      keySeq: null,\n      // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) {\n      display.input.focus();\n    } // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n\n\n    if (ie && ie_version < 11) {\n      setTimeout(function () {\n        return this$1.display.input.reset(true);\n      }, 20);\n    }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    _startOperation(this);\n\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if (options.autofocus && !mobile || this.hasFocus()) {\n      setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) {\n          onFocus(this$1);\n        }\n      }, 20);\n    } else {\n      onBlur(this);\n    }\n\n    for (var opt in optionHandlers) {\n      if (optionHandlers.hasOwnProperty(opt)) {\n        optionHandlers[opt](this, options[opt], Init);\n      }\n    }\n\n    maybeUpdateLineNumberWidth(this);\n\n    if (options.finishInit) {\n      options.finishInit(this);\n    }\n\n    for (var i = 0; i < initHooks.length; ++i) {\n      initHooks[i](this);\n    }\n\n    _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n\n\n    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\") {\n      display.lineDiv.style.textRendering = \"auto\";\n    }\n  } // The default configuration options.\n\n\n  CodeMirror.defaults = defaults; // Functions to run when options are changed.\n\n  CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click\n\n    if (ie && ie_version < 11) {\n      on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) {\n          return;\n        }\n\n        var pos = posFromMouse(cm, e);\n\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n          return;\n        }\n\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    } else {\n      on(d.scroller, \"dblclick\", function (e) {\n        return signalDOMEvent(cm, e) || e_preventDefault(e);\n      });\n    } // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n\n\n    on(d.scroller, \"contextmenu\", function (e) {\n      return onContextMenu(cm, e);\n    });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) {\n        onContextMenu(cm, e);\n      }\n    }); // Used to suppress mouse event handling when a touch happens\n\n    var touchFinished,\n        prevTouch = {\n      end: 0\n    };\n\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () {\n          return d.activeTouch = null;\n        }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date();\n      }\n    }\n\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) {\n        return false;\n      }\n\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n\n    function farAway(touch, other) {\n      if (other.left == null) {\n        return true;\n      }\n\n      var dx = other.left - touch.left,\n          dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date();\n        d.activeTouch = {\n          start: now,\n          moved: false,\n          prev: now - prevTouch.end <= 300 ? prevTouch : null\n        };\n\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) {\n        d.activeTouch.moved = true;\n      }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n\n      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"),\n            range;\n\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          {\n            range = new Range(pos, pos);\n          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          {\n            range = cm.findWordAt(pos);\n          } else // Triple tap\n          {\n            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch); // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    }); // Listen to wheel events in order to try and update the viewport on time.\n\n    on(d.scroller, \"mousewheel\", function (e) {\n      return onScrollWheel(cm, e);\n    });\n    on(d.scroller, \"DOMMouseScroll\", function (e) {\n      return onScrollWheel(cm, e);\n    }); // Prevent wrapper from ever scrolling\n\n    on(d.wrapper, \"scroll\", function () {\n      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n    });\n    d.dragFunctions = {\n      enter: function enter(e) {\n        if (!signalDOMEvent(cm, e)) {\n          e_stop(e);\n        }\n      },\n      over: function over(e) {\n        if (!signalDOMEvent(cm, e)) {\n          onDragOver(cm, e);\n          e_stop(e);\n        }\n      },\n      start: function start(e) {\n        return onDragStart(cm, e);\n      },\n      drop: operation(cm, onDrop),\n      leave: function leave(e) {\n        if (!signalDOMEvent(cm, e)) {\n          clearDragCursor(cm);\n        }\n      }\n    };\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) {\n      return onKeyUp.call(cm, e);\n    });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) {\n      return onFocus(cm, e);\n    });\n    on(inp, \"blur\", function (e) {\n      return onBlur(cm, e);\n    });\n  }\n\n  var initHooks = [];\n\n  CodeMirror.defineInitHook = function (f) {\n    return initHooks.push(f);\n  }; // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc,\n        state;\n\n    if (how == null) {\n      how = \"add\";\n    }\n\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) {\n        how = \"prev\";\n      } else {\n        state = getContextBefore(cm, n).state;\n      }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n),\n        curSpace = countColumn(line.text, null, tabSize);\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    var curSpaceString = line.text.match(/^\\s*/)[0],\n        indentation;\n\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) {\n          return;\n        }\n\n        how = \"prev\";\n      }\n    }\n\n    if (how == \"prev\") {\n      if (n > doc.first) {\n        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n      } else {\n        indentation = 0;\n      }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n\n    indentation = Math.max(0, indentation);\n    var indentString = \"\",\n        pos = 0;\n\n    if (cm.options.indentWithTabs) {\n      for (var i = Math.floor(indentation / tabSize); i; --i) {\n        pos += tabSize;\n        indentString += \"\\t\";\n      }\n    }\n\n    if (pos < indentation) {\n      indentString += spaceStr(indentation - pos);\n    }\n\n    if (indentString != curSpaceString) {\n      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break;\n        }\n      }\n    }\n  } // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n\n\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n\n    if (!sel) {\n      sel = doc.sel;\n    }\n\n    var recent = +new Date() - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted),\n        multiPaste = null; // When pasting N lines into N selections, insert one line per selection\n\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n\n          for (var i = 0; i < lastCopied.text.length; i++) {\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n          }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) {\n          return [l];\n        });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection\n\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(),\n          to = range.to();\n\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          {\n            from = Pos(from.line, from.ch - deleted);\n          } else if (cm.state.overwrite && !paste) // Handle overwrite\n          {\n            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\")) {\n          from = to = Pos(from.line, 0);\n        }\n      }\n\n      var changeEvent = {\n        from: from,\n        to: to,\n        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n        origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")\n      };\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n\n    if (inserted && !paste) {\n      triggerElectric(cm, inserted);\n    }\n\n    ensureCursorVisible(cm);\n\n    if (cm.curOp.updateInput < 2) {\n      cm.curOp.updateInput = updateInput;\n    }\n\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n\n    if (pasted) {\n      e.preventDefault();\n\n      if (!cm.isReadOnly() && !cm.options.disableInput) {\n        runInOp(cm, function () {\n          return applyTextInput(cm, pasted, 0, null, \"paste\");\n        });\n      }\n\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) {\n      return;\n    }\n\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n\n      if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {\n        continue;\n      }\n\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++) {\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n        }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {\n          indented = indentLine(cm, range.head.line, \"smart\");\n        }\n      }\n\n      if (indented) {\n        signalLater(cm, \"electricInput\", cm, range.head.line);\n      }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [],\n        ranges = [];\n\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {\n        anchor: Pos(line, 0),\n        head: Pos(line + 1, 0)\n      };\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n\n    return {\n      text: text,\n      ranges: ranges\n    };\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\"); // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n\n    if (webkit) {\n      te.style.width = \"1000px\";\n    } else {\n      te.setAttribute(\"wrap\", \"off\");\n    } // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\n\n    if (ios) {\n      te.style.border = \"1px solid black\";\n    }\n\n    disableBrowserMagic(te);\n    return div;\n  } // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n    var helpers = CodeMirror.helpers = {};\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function focus() {\n        window.focus();\n        this.display.input.focus();\n      },\n      setOption: function setOption(option, value) {\n        var options = this.options,\n            old = options[option];\n\n        if (options[option] == value && option != \"mode\") {\n          return;\n        }\n\n        options[option] = value;\n\n        if (optionHandlers.hasOwnProperty(option)) {\n          operation(this, optionHandlers[option])(this, value, old);\n        }\n\n        signal(this, \"optionChange\", this, option);\n      },\n      getOption: function getOption(option) {\n        return this.options[option];\n      },\n      getDoc: function getDoc() {\n        return this.doc;\n      },\n      addKeyMap: function addKeyMap(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function removeKeyMap(map) {\n        var maps = this.state.keyMaps;\n\n        for (var i = 0; i < maps.length; ++i) {\n          if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true;\n          }\n        }\n      },\n      addOverlay: methodOp(function (spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\n        if (mode.startState) {\n          throw new Error(\"Overlays may not be stateful.\");\n        }\n\n        insertSorted(this.state.overlays, {\n          mode: mode,\n          modeSpec: spec,\n          opaque: options && options.opaque,\n          priority: options && options.priority || 0\n        }, function (overlay) {\n          return overlay.priority;\n        });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function (spec) {\n        var overlays = this.state.overlays;\n\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return;\n          }\n        }\n      }),\n      indentLine: methodOp(function (n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) {\n            dir = this.options.smartIndent ? \"smart\" : \"prev\";\n          } else {\n            dir = dir ? \"add\" : \"subtract\";\n          }\n        }\n\n        if (isLine(this.doc, n)) {\n          indentLine(this, n, dir, aggressive);\n        }\n      }),\n      indentSelection: methodOp(function (how) {\n        var ranges = this.doc.sel.ranges,\n            end = -1;\n\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n\n          if (!range.empty()) {\n            var from = range.from(),\n                to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\n            for (var j = start; j < end; ++j) {\n              indentLine(this, j, how);\n            }\n\n            var newRanges = this.doc.sel.ranges;\n\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {\n              replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n            }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n\n            if (i == this.doc.sel.primIndex) {\n              ensureCursorVisible(this);\n            }\n          }\n        }\n      }),\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function getTokenAt(pos, precise) {\n        return takeToken(this, pos, precise);\n      },\n      getLineTokens: function getLineTokens(line, precise) {\n        return takeToken(this, Pos(line), precise, true);\n      },\n      getTokenTypeAt: function getTokenTypeAt(pos) {\n        pos = _clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0,\n            after = (styles.length - 1) / 2,\n            ch = pos.ch;\n        var type;\n\n        if (ch == 0) {\n          type = styles[2];\n        } else {\n          for (;;) {\n            var mid = before + after >> 1;\n\n            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n              after = mid;\n            } else if (styles[mid * 2 + 1] < ch) {\n              before = mid + 1;\n            } else {\n              type = styles[mid * 2 + 2];\n              break;\n            }\n          }\n        }\n\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n      },\n      getModeAt: function getModeAt(pos) {\n        var mode = this.doc.mode;\n\n        if (!mode.innerMode) {\n          return mode;\n        }\n\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n      },\n      getHelper: function getHelper(pos, type) {\n        return this.getHelpers(pos, type)[0];\n      },\n      getHelpers: function getHelpers(pos, type) {\n        var found = [];\n\n        if (!helpers.hasOwnProperty(type)) {\n          return found;\n        }\n\n        var help = helpers[type],\n            mode = this.getModeAt(pos);\n\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) {\n            found.push(help[mode[type]]);\n          }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n\n            if (val) {\n              found.push(val);\n            }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {\n            found.push(cur.val);\n          }\n        }\n\n        return found;\n      },\n      getStateAfter: function getStateAfter(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n        return getContextBefore(this, line + 1, precise).state;\n      },\n      cursorCoords: function cursorCoords(start, mode) {\n        var pos,\n            range = this.doc.sel.primary();\n\n        if (start == null) {\n          pos = range.head;\n        } else if (_typeof(start) == \"object\") {\n          pos = _clipPos(this.doc, start);\n        } else {\n          pos = start ? range.from() : range.to();\n        }\n\n        return _cursorCoords(this, pos, mode || \"page\");\n      },\n      charCoords: function charCoords(pos, mode) {\n        return _charCoords(this, _clipPos(this.doc, pos), mode || \"page\");\n      },\n      coordsChar: function coordsChar(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return _coordsChar(this, coords.left, coords.top);\n      },\n      lineAtHeight: function lineAtHeight(height, mode) {\n        height = fromCoordSystem(this, {\n          top: height,\n          left: 0\n        }, mode || \"page\").top;\n        return _lineAtHeight(this.doc, height + this.display.viewOffset);\n      },\n      heightAtLine: function heightAtLine(line, mode, includeWidgets) {\n        var end = false,\n            lineObj;\n\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n\n          if (line < this.doc.first) {\n            line = this.doc.first;\n          } else if (line > last) {\n            line = last;\n            end = true;\n          }\n\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n\n        return intoCoordSystem(this, lineObj, {\n          top: 0,\n          left: 0\n        }, mode || \"page\", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);\n      },\n      defaultTextHeight: function defaultTextHeight() {\n        return textHeight(this.display);\n      },\n      defaultCharWidth: function defaultCharWidth() {\n        return charWidth(this.display);\n      },\n      getViewport: function getViewport() {\n        return {\n          from: this.display.viewFrom,\n          to: this.display.viewTo\n        };\n      },\n      addWidget: function addWidget(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = _cursorCoords(this, _clipPos(this.doc, pos));\n        var top = pos.bottom,\n            left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below\n\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n            top = pos.top - node.offsetHeight;\n          } else if (pos.bottom + node.offsetHeight <= vspace) {\n            top = pos.bottom;\n          }\n\n          if (left + node.offsetWidth > hspace) {\n            left = hspace - node.offsetWidth;\n          }\n        }\n\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") {\n            left = 0;\n          } else if (horiz == \"middle\") {\n            left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n          }\n\n          node.style.left = left + \"px\";\n        }\n\n        if (scroll) {\n          scrollIntoView(this, {\n            left: left,\n            top: top,\n            right: left + node.offsetWidth,\n            bottom: top + node.offsetHeight\n          });\n        }\n      },\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n      execCommand: function execCommand(cmd) {\n        if (commands.hasOwnProperty(cmd)) {\n          return commands[cmd].call(null, this);\n        }\n      },\n      triggerElectric: methodOp(function (text) {\n        triggerElectric(this, text);\n      }),\n      findPosH: function findPosH(from, amount, unit, visually) {\n        var dir = 1;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          cur = _findPosH(this.doc, cur, dir, unit, visually);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveH: methodOp(function (dir, unit) {\n        var this$1 = this;\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty()) {\n            return _findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);\n          } else {\n            return dir < 0 ? range.from() : range.to();\n          }\n        }, sel_move);\n      }),\n      deleteH: methodOp(function (dir, unit) {\n        var sel = this.doc.sel,\n            doc = this.doc;\n\n        if (sel.somethingSelected()) {\n          doc.replaceSelection(\"\", null, \"+delete\");\n        } else {\n          deleteNearSelection(this, function (range) {\n            var other = _findPosH(doc, range.head, dir, unit, false);\n\n            return dir < 0 ? {\n              from: other,\n              to: range.head\n            } : {\n              from: range.head,\n              to: other\n            };\n          });\n        }\n      }),\n      findPosV: function findPosV(from, amount, unit, goalColumn) {\n        var dir = 1,\n            x = goalColumn;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          var coords = _cursorCoords(this, cur, \"div\");\n\n          if (x == null) {\n            x = coords.left;\n          } else {\n            coords.left = x;\n          }\n\n          cur = _findPosV(this, coords, dir, unit);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveV: methodOp(function (dir, unit) {\n        var this$1 = this;\n        var doc = this.doc,\n            goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse) {\n            return dir < 0 ? range.from() : range.to();\n          }\n\n          var headPos = _cursorCoords(this$1, range.head, \"div\");\n\n          if (range.goalColumn != null) {\n            headPos.left = range.goalColumn;\n          }\n\n          goals.push(headPos.left);\n\n          var pos = _findPosV(this$1, headPos, dir, unit);\n\n          if (unit == \"page\" && range == doc.sel.primary()) {\n            addToScrollTop(this$1, _charCoords(this$1, pos, \"div\").top - headPos.top);\n          }\n\n          return pos;\n        }, sel_move);\n\n        if (goals.length) {\n          for (var i = 0; i < doc.sel.ranges.length; i++) {\n            doc.sel.ranges[i].goalColumn = goals[i];\n          }\n        }\n      }),\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function findWordAt(pos) {\n        var doc = this.doc,\n            line = getLine(doc, pos.line).text;\n        var start = pos.ch,\n            end = pos.ch;\n\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n\n          if ((pos.sticky == \"before\" || end == line.length) && start) {\n            --start;\n          } else {\n            ++end;\n          }\n\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper) ? function (ch) {\n            return isWordChar(ch, helper);\n          } : /\\s/.test(startChar) ? function (ch) {\n            return /\\s/.test(ch);\n          } : function (ch) {\n            return !/\\s/.test(ch) && !isWordChar(ch);\n          };\n\n          while (start > 0 && check(line.charAt(start - 1))) {\n            --start;\n          }\n\n          while (end < line.length && check(line.charAt(end))) {\n            ++end;\n          }\n        }\n\n        return new Range(Pos(pos.line, start), Pos(pos.line, end));\n      },\n      toggleOverwrite: function toggleOverwrite(value) {\n        if (value != null && value == this.state.overwrite) {\n          return;\n        }\n\n        if (this.state.overwrite = !this.state.overwrite) {\n          addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        } else {\n          rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function hasFocus() {\n        return this.display.input.getField() == activeElt();\n      },\n      isReadOnly: function isReadOnly() {\n        return !!(this.options.readOnly || this.doc.cantEdit);\n      },\n      scrollTo: methodOp(function (x, y) {\n        scrollToCoords(this, x, y);\n      }),\n      getScrollInfo: function getScrollInfo() {\n        var scroller = this.display.scroller;\n        return {\n          left: scroller.scrollLeft,\n          top: scroller.scrollTop,\n          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n          clientHeight: displayHeight(this),\n          clientWidth: displayWidth(this)\n        };\n      },\n      scrollIntoView: methodOp(function (range, margin) {\n        if (range == null) {\n          range = {\n            from: this.doc.sel.primary().head,\n            to: null\n          };\n\n          if (margin == null) {\n            margin = this.options.cursorScrollMargin;\n          }\n        } else if (typeof range == \"number\") {\n          range = {\n            from: Pos(range, 0),\n            to: null\n          };\n        } else if (range.from == null) {\n          range = {\n            from: range,\n            to: null\n          };\n        }\n\n        if (!range.to) {\n          range.to = range.from;\n        }\n\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n      setSize: methodOp(function (width, height) {\n        var this$1 = this;\n\n        var interpret = function interpret(val) {\n          return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n        };\n\n        if (width != null) {\n          this.display.wrapper.style.width = interpret(width);\n        }\n\n        if (height != null) {\n          this.display.wrapper.style.height = interpret(height);\n        }\n\n        if (this.options.lineWrapping) {\n          clearLineMeasurementCache(this);\n        }\n\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) {\n            for (var i = 0; i < line.widgets.length; i++) {\n              if (line.widgets[i].noHScroll) {\n                regLineChange(this$1, lineNo, \"widget\");\n                break;\n              }\n            }\n          }\n\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n      operation: function operation(f) {\n        return runInOp(this, f);\n      },\n      startOperation: function startOperation() {\n        return _startOperation(this);\n      },\n      endOperation: function endOperation() {\n        return _endOperation(this);\n      },\n      refresh: methodOp(function () {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) {\n          estimateLineHeights(this);\n        }\n\n        signal(this, \"refresh\", this);\n      }),\n      swapDoc: methodOp(function (doc) {\n        var old = this.doc;\n        old.cm = null; // Cancel the current text selection if any (#5821)\n\n        if (this.state.selectingText) {\n          this.state.selectingText();\n        }\n\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old;\n      }),\n      phrase: function phrase(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n      },\n      getInputField: function getInputField() {\n        return this.display.input.getField();\n      },\n      getWrapperElement: function getWrapperElement() {\n        return this.display.wrapper;\n      },\n      getScrollerElement: function getScrollerElement() {\n        return this.display.scroller;\n      },\n      getGutterElement: function getGutterElement() {\n        return this.display.gutters;\n      }\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function (type, name, value) {\n      if (!helpers.hasOwnProperty(type)) {\n        helpers[type] = CodeMirror[type] = {\n          _global: []\n        };\n      }\n\n      helpers[type][name] = value;\n    };\n\n    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n\n      helpers[type]._global.push({\n        pred: predicate,\n        val: value\n      });\n    };\n  } // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n\n\n  function _findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n\n    function findNextLine() {\n      var l = pos.line + lineDir;\n\n      if (l < doc.first || l >= doc.first + doc.size) {\n        return false;\n      }\n\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l);\n    }\n\n    function moveOnce(boundToLine) {\n      var next;\n\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n        } else {\n          return false;\n        }\n      } else {\n        pos = next;\n      }\n\n      return true;\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null,\n          group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) {\n          break;\n        }\n\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\" : group && cur == \"\\n\" ? \"n\" : !group || /\\s/.test(cur) ? null : \"p\";\n\n        if (group && !first && !type) {\n          type = \"s\";\n        }\n\n        if (sawType && sawType != type) {\n          if (dir < 0) {\n            dir = 1;\n            moveOnce();\n            pos.sticky = \"after\";\n          }\n\n          break;\n        }\n\n        if (type) {\n          sawType = type;\n        }\n\n        if (dir > 0 && !moveOnce(!first)) {\n          break;\n        }\n      }\n    }\n\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n\n    if (equalCursorPos(oldPos, result)) {\n      result.hitSide = true;\n    }\n\n    return result;\n  } // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n\n\n  function _findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc,\n        x = pos.left,\n        y;\n\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n\n    var target;\n\n    for (;;) {\n      target = _coordsChar(cm, x, y);\n\n      if (!target.outside) {\n        break;\n      }\n\n      if (dir < 0 ? y <= 0 : y >= doc.height) {\n        target.hitSide = true;\n        break;\n      }\n\n      y += dir * 5;\n    }\n\n    return target;\n  } // CONTENTEDITABLE INPUT STYLE\n\n\n  var ContentEditableInput = function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) {\n          return true;\n        }\n\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n          break;\n        }\n      }\n\n      return false;\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      } // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n\n\n      if (ie_version <= 11) {\n        setTimeout(operation(cm, function () {\n          return this$1.updateFromDOM();\n        }), 20);\n      }\n    });\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {\n        data: e.data,\n        done: false\n      };\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) {\n        this$1.composing = {\n          data: e.data,\n          done: false\n        };\n      }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) {\n          this$1.readFromDOMSoon();\n        }\n\n        this$1.composing.done = true;\n      }\n    });\n    on(div, \"touchstart\", function () {\n      return input.forceCompositionEnd();\n    });\n    on(div, \"input\", function () {\n      if (!this$1.composing) {\n        this$1.readFromDOMSoon();\n      }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n\n        if (e.type == \"cut\") {\n          cm.replaceSelection(\"\", null, \"cut\");\n        }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\"); // iOS exposes the clipboard API, but seems to discard content inserted into it\n\n        e.clipboardData.setData(\"Text\", content);\n\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return;\n        }\n      } // Old-fashioned briefly-focus-a-textarea hack\n\n\n      var kludge = hiddenTextarea(),\n          te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = activeElt();\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n\n        if (hadFocus == div) {\n          input.showPrimarySelection();\n        }\n      }, 50);\n    }\n\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if (label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt() == this.div;\n    return result;\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) {\n      return;\n    }\n\n    if (info.focus || takeFocus) {\n      this.showPrimarySelection();\n    }\n\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection();\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(),\n        cm = this.cm,\n        prim = cm.doc.sel.primary();\n    var from = prim.from(),\n        to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n      return;\n    }\n\n    var view = cm.display.view;\n    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n      node: view[0].measure.map[2],\n      offset: 0\n    };\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {\n        node: map[map.length - 1],\n        offset: map[map.length - 2] - map[map.length - 3]\n      };\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0),\n        rng;\n\n    try {\n      rng = range(start.node, start.offset, end.offset, end.node);\n    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\n\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n\n      if (old && sel.anchorNode == null) {\n        sel.addRange(old);\n      } else if (gecko) {\n        this.startGracePeriod();\n      }\n    }\n\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n\n      if (this$1.selectionChanged()) {\n        this$1.cm.operation(function () {\n          return this$1.cm.curOp.selectionChanged = true;\n        });\n      }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode;\n    this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode;\n    this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n\n    if (!sel.rangeCount) {\n      return false;\n    }\n\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node);\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || activeElt() != this.div) {\n        this.showSelection(this.prepareSelection(), true);\n      }\n\n      this.div.focus();\n    }\n  };\n\n  ContentEditableInput.prototype.blur = function () {\n    this.div.blur();\n  };\n\n  ContentEditableInput.prototype.getField = function () {\n    return this.div;\n  };\n\n  ContentEditableInput.prototype.supportsTouch = function () {\n    return true;\n  };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var this$1 = this;\n    var input = this;\n\n    if (this.selectionInEditor()) {\n      setTimeout(function () {\n        return this$1.pollSelection();\n      }, 20);\n    } else {\n      runInOp(this.cm, function () {\n        return input.cm.curOp.selectionChanged = true;\n      });\n    }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n      return;\n    }\n\n    var sel = this.getSelection(),\n        cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({\n        type: \"keydown\",\n        keyCode: 8,\n        preventDefault: Math.abs\n      });\n      this.blur();\n      this.focus();\n      return;\n    }\n\n    if (this.composing) {\n      return;\n    }\n\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (anchor && head) {\n      runInOp(cm, function () {\n        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\n        if (anchor.bad || head.bad) {\n          cm.curOp.selectionChanged = true;\n        }\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm,\n        display = cm.display,\n        sel = cm.doc.sel.primary();\n    var from = sel.from(),\n        to = sel.to();\n\n    if (from.ch == 0 && from.line > cm.firstLine()) {\n      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n    }\n\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n      to = Pos(to.line + 1, 0);\n    }\n\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n      return false;\n    }\n\n    var fromIndex, fromLine, fromNode;\n\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) {\n      return false;\n    }\n\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) {\n        newText.pop();\n        oldText.pop();\n        toLine--;\n      } else if (newText[0] == oldText[0]) {\n        newText.shift();\n        oldText.shift();\n        fromLine++;\n      } else {\n        break;\n      }\n    }\n\n    var cutFront = 0,\n        cutEnd = 0;\n    var newTop = newText[0],\n        oldTop = oldText[0],\n        maxCutFront = Math.min(newTop.length, oldTop.length);\n\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n      ++cutFront;\n    }\n\n    var newBot = lst(newText),\n        oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\n    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      ++cutEnd;\n    } // Try to move start of change to start of selection if ambiguous\n\n\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      _replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\n      return true;\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) {\n      return;\n    }\n\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n    if (this.readDOMTimeout != null) {\n      return;\n    }\n\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n\n      if (this$1.composing) {\n        if (this$1.composing.done) {\n          this$1.composing = null;\n        } else {\n          return;\n        }\n      }\n\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent()) {\n      runInOp(this.cm, function () {\n        return regChange(this$1.cm);\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) {\n      return;\n    }\n\n    e.preventDefault();\n\n    if (!this.cm.isReadOnly()) {\n      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n\n    if (!view || view.hidden) {\n      return null;\n    }\n\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n    var order = getOrder(line, cm.doc.direction),\n        side = \"left\";\n\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode) {\n      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function badPos(pos, bad) {\n    if (bad) {\n      pos.bad = true;\n    }\n\n    return pos;\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\",\n        closing = false,\n        lineSep = cm.doc.lineSeparator(),\n        extraLinebreak = false;\n\n    function recognizeMarker(id) {\n      return function (marker) {\n        return marker.id == id;\n      };\n    }\n\n    function close() {\n      if (closing) {\n        text += lineSep;\n\n        if (extraLinebreak) {\n          text += lineSep;\n        }\n\n        closing = extraLinebreak = false;\n      }\n    }\n\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n\n        if (cmText) {\n          addText(cmText);\n          return;\n        }\n\n        var markerID = node.getAttribute(\"cm-marker\"),\n            range;\n\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\n          if (found.length && (range = found[0].find(0))) {\n            addText(getBetween(cm.doc, range.from, range.to).join(lineSep));\n          }\n\n          return;\n        }\n\n        if (node.getAttribute(\"contenteditable\") == \"false\") {\n          return;\n        }\n\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n          return;\n        }\n\n        if (isBlock) {\n          close();\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n          walk(node.childNodes[i]);\n        }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) {\n          extraLinebreak = true;\n        }\n\n        if (isBlock) {\n          closing = true;\n        }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n\n    for (;;) {\n      walk(from);\n\n      if (from == to) {\n        break;\n      }\n\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n\n    return text;\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n\n      if (!lineNode) {\n        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      }\n\n      node = null;\n      offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) {\n          return null;\n        }\n\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n\n      if (lineView.node == lineNode) {\n        return locateNodeInLineView(lineView, node, offset);\n      }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild,\n        bad = false;\n\n    if (!node || !contains(wrapper, node)) {\n      return badPos(Pos(lineNo(lineView.line), 0), true);\n    }\n\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null,\n        topNode = node;\n\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n\n      if (offset) {\n        offset = textNode.nodeValue.length;\n      }\n    }\n\n    while (topNode.parentNode != wrapper) {\n      topNode = topNode.parentNode;\n    }\n\n    var measure = lineView.measure,\n        maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n\n            if (offset < 0 || curNode != textNode) {\n              ch = map[j + (offset ? 1 : 0)];\n            }\n\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n\n    var found = find(textNode, topNode, offset);\n\n    if (found) {\n      return badPos(found, bad);\n    } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\n\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      } else {\n        dist += after.textContent.length;\n      }\n    }\n\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch + dist$1), bad);\n      } else {\n        dist$1 += before.textContent.length;\n      }\n    }\n  } // TEXTAREA INPUT STYLE\n\n\n  var TextareaInput = function TextareaInput(cm) {\n    this.cm = cm; // See input.poll and input.reset\n\n    this.prevInput = \"\"; // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n\n    this.pollingFast = false; // Self-resetting timeout for the poller\n\n    this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\n    if (ios) {\n      te.style.width = \"0px\";\n    }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) {\n        this$1.hasSelection = null;\n      }\n\n      input.poll();\n    });\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      }\n\n      cm.state.pasteIncoming = +new Date();\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n\n      if (e.type == \"cut\") {\n        cm.state.cutIncoming = +new Date();\n      }\n    }\n\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date();\n        input.focus();\n        return;\n      } // Pass the `paste` event to the textarea so it's handled by its event listener.\n\n\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    }); // Prevent normal selection in the editor (we handle our own)\n\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) {\n        e_preventDefault(e);\n      }\n    });\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n\n      if (input.composing) {\n        input.composing.range.clear();\n      }\n\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        })\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if (label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm,\n        display = cm.display,\n        doc = cm.doc;\n    var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\n    if (cm.options.moveInputWithCursor) {\n      var headPos = _cursorCoords(cm, doc.sel.primary().head, \"div\");\n\n      var wrapOff = display.wrapper.getBoundingClientRect(),\n          lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result;\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm,\n        display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  }; // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n\n\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) {\n      return;\n    }\n\n    var cm = this.cm;\n\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n\n      if (cm.state.focused) {\n        selectInput(this.textarea);\n      }\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = content;\n      }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = null;\n      }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () {\n    return this.textarea;\n  };\n\n  TextareaInput.prototype.supportsTouch = function () {\n    return false;\n  };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try {\n        this.textarea.focus();\n      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\n    }\n  };\n\n  TextareaInput.prototype.blur = function () {\n    this.textarea.blur();\n  };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () {\n    this.slowPoll();\n  }; // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n\n\n  TextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n    if (this.pollingFast) {\n      return;\n    }\n\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n\n      if (this$1.cm.state.focused) {\n        this$1.slowPoll();\n      }\n    });\n  }; // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n\n\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false,\n        input = this;\n    input.pollingFast = true;\n\n    function p() {\n      var changed = input.poll();\n\n      if (!changed && !missed) {\n        missed = true;\n        input.polling.set(60, p);\n      } else {\n        input.pollingFast = false;\n        input.slowPoll();\n      }\n    }\n\n    input.polling.set(20, p);\n  }; // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n\n\n  TextareaInput.prototype.poll = function () {\n    var this$1 = this;\n    var cm = this.cm,\n        input = this.textarea,\n        prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n\n    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n      return false;\n    }\n\n    var text = input.value; // If nothing changed, bail.\n\n    if (text == prevInput && !cm.somethingSelected()) {\n      return false;\n    } // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n\n\n    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false;\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n\n      if (first == 0x200b && !prevInput) {\n        prevInput = \"\\u200B\";\n      }\n\n      if (first == 0x21da) {\n        this.reset();\n        return this.cm.execCommand(\"undo\");\n      }\n    } // Find the part of the input that is actually new\n\n\n    var same = 0,\n        l = Math.min(prevInput.length, text.length);\n\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n      ++same;\n    }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? \"*compose\" : null); // Don't leave long text in the textarea, since it makes further polling slow\n\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) {\n        input.value = this$1.prevInput = \"\";\n      } else {\n        this$1.prevInput = text;\n      }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        });\n      }\n    });\n    return true;\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) {\n      this.pollingFast = false;\n    }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) {\n      this.hasSelection = null;\n    }\n\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this,\n        cm = input.cm,\n        display = cm.display,\n        te = input.textarea;\n\n    if (input.contextMenuPending) {\n      input.contextMenuPending();\n    }\n\n    var pos = posFromMouse(cm, e),\n        scrollPos = display.scroller.scrollTop;\n\n    if (!pos || presto) {\n      return;\n    } // Opera is difficult.\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n\n\n    var reset = cm.options.resetSelectionOnContextMenu;\n\n    if (reset && cm.doc.sel.contains(pos) == -1) {\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n    }\n\n    var oldCSS = te.style.cssText,\n        oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n\n    if (webkit) {\n      oldScrollY = window.scrollY;\n    } // Work around Chrome issue (#2712)\n\n\n    display.input.focus();\n\n    if (webkit) {\n      window.scrollTo(null, oldScrollY);\n    }\n\n    display.input.reset(); // Adds \"Select all\" to context menu in FF\n\n    if (!cm.somethingSelected()) {\n      te.value = input.prevInput = \" \";\n    }\n\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200B\" + (selected ? te.value : \"\");\n        te.value = \"\\u21DA\"; // Used to catch context-menu undo\n\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200B\";\n        te.selectionStart = 1;\n        te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n\n    function rehide() {\n      if (input.contextMenuPending != rehide) {\n        return;\n      }\n\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n\n      if (ie && ie_version < 9) {\n        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n      } // Try to detect the user choosing select-all\n\n\n      if (te.selectionStart != null) {\n        if (!ie || ie && ie_version < 9) {\n          prepareSelectAllHack();\n        }\n\n        var i = 0,\n            poll = function poll() {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == \"\\u200B\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) {\n      prepareSelectAllHack();\n    }\n\n    if (captureRightClick) {\n      e_stop(e);\n\n      var mouseup = function mouseup() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) {\n      this.reset();\n    }\n\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n\n    if (!options.tabindex && textarea.tabIndex) {\n      options.tabindex = textarea.tabIndex;\n    }\n\n    if (!options.placeholder && textarea.placeholder) {\n      options.placeholder = textarea.placeholder;\n    } // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n\n\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {\n      textarea.value = cm.getValue();\n    }\n\n    var realSubmit;\n\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save); // Deplorable hack to make the submit method do the right thing.\n\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch (e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n\n      cm.getTextArea = function () {\n        return textarea;\n      };\n\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\") {\n            textarea.form.submit = realSubmit;\n          }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) {\n      return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  } // EDITOR CONSTRUCTOR\n\n\n  defineOptions(CodeMirror);\n  addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\n  for (var prop in Doc.prototype) {\n    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n      CodeMirror.prototype[prop] = function (method) {\n        return function () {\n          return method.apply(this.doc, arguments);\n        };\n      }(Doc.prototype[prop]);\n    }\n  }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\n    \"textarea\": TextareaInput,\n    \"contenteditable\": ContentEditableInput\n  }; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  CodeMirror.defineMode = function (name\n  /*, mode, */\n  ) {\n    if (!CodeMirror.defaults.mode && name != \"null\") {\n      CodeMirror.defaults.mode = name;\n    }\n\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME; // Minimal default mode.\n\n  CodeMirror.defineMode(\"null\", function () {\n    return {\n      token: function token(stream) {\n        return stream.skipToEnd();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\"); // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n  addLegacyProps(CodeMirror);\n  CodeMirror.version = \"5.65.1\";\n  return CodeMirror;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvY29kZW1pcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUMsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7RUFDMUIsc0JBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsYUFBa0IsV0FBakQsR0FBK0RDLE1BQU0sQ0FBQ0QsT0FBUCxHQUFpQkQsT0FBTyxFQUF2RixHQUNBLFFBQTZDRyxvQ0FBT0gsT0FBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFuRCxJQUNDRCxDQURELENBREE7QUFHRCxDQUpBLEVBSUMsSUFKRCxFQUlRLFlBQVk7RUFBRSxhQUFGLENBRW5CO0VBQ0E7O0VBQ0EsSUFBSVEsU0FBUyxHQUFHQyxTQUFTLENBQUNELFNBQTFCO0VBQ0EsSUFBSUUsUUFBUSxHQUFHRCxTQUFTLENBQUNDLFFBQXpCO0VBRUEsSUFBSUMsS0FBSyxHQUFHLGFBQWFDLElBQWIsQ0FBa0JKLFNBQWxCLENBQVo7RUFDQSxJQUFJSyxTQUFTLEdBQUcsVUFBVUQsSUFBVixDQUFlSixTQUFmLENBQWhCO0VBQ0EsSUFBSU0sT0FBTyxHQUFHLHdDQUF3Q0MsSUFBeEMsQ0FBNkNQLFNBQTdDLENBQWQ7RUFDQSxJQUFJUSxJQUFJLEdBQUcsY0FBY0QsSUFBZCxDQUFtQlAsU0FBbkIsQ0FBWDtFQUNBLElBQUlTLEVBQUUsR0FBR0osU0FBUyxJQUFJQyxPQUFiLElBQXdCRSxJQUFqQztFQUNBLElBQUlFLFVBQVUsR0FBR0QsRUFBRSxLQUFLSixTQUFTLEdBQUdNLFFBQVEsQ0FBQ0MsWUFBVCxJQUF5QixDQUE1QixHQUFnQyxDQUFDLENBQUNKLElBQUksSUFBSUYsT0FBVCxFQUFrQixDQUFsQixDQUEvQyxDQUFuQjtFQUNBLElBQUlPLE1BQU0sR0FBRyxDQUFDTCxJQUFELElBQVMsV0FBV0osSUFBWCxDQUFnQkosU0FBaEIsQ0FBdEI7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Y2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvY29kZW1pcnJvci5qcz9lNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cHM6Ly9jb2RlbWlycm9yLm5ldCksIGEgY29kZSBlZGl0b3Jcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxuLy9cbi8vIFlvdSBjYW4gZmluZCBzb21lIHRlY2huaWNhbCBiYWNrZ3JvdW5kIGZvciBzb21lIG9mIHRoZSBjb2RlIGJlbG93XG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ29kZU1pcnJvciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBLbHVkZ2VzIGZvciBidWdzIGFuZCBiZWhhdmlvciBkaWZmZXJlbmNlcyB0aGF0IGNhbid0IGJlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0ZWQgYXJlIGVuYWJsZWQgYmFzZWQgb24gdXNlckFnZW50IGV0YyBzbmlmZmluZy5cbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHZhciBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybTtcblxuICB2YXIgZ2Vja28gPSAvZ2Vja29cXC9cXGQvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgdmFyIGVkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBlZGdlO1xuICB2YXIgaWVfdmVyc2lvbiA9IGllICYmIChpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgNiA6ICsoZWRnZSB8fCBpZV8xMXVwKVsxXSk7XG4gIHZhciB3ZWJraXQgPSAhZWRnZSAmJiAvV2ViS2l0XFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXC9cXGQrXFwuXFxkKy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgY2hyb21lID0gIWVkZ2UgJiYgL0Nocm9tZVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgcHJlc3RvID0gL09wZXJhXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG4gIHZhciBtYWNfZ2VNb3VudGFpbkxpb24gPSAvTWFjIE9TIFggMVxcZFxcRChbOC05XXxcXGRcXGQpXFxELy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBwaGFudG9tID0gL1BoYW50b21KUy8udGVzdCh1c2VyQWdlbnQpO1xuXG4gIHZhciBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KHVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMik7XG4gIHZhciBhbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcbiAgLy8gVGhpcyBpcyB3b2VmdWxseSBpbmNvbXBsZXRlLiBTdWdnZXN0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbWV0aG9kcyB3ZWxjb21lLlxuICB2YXIgbW9iaWxlID0gaW9zIHx8IGFuZHJvaWQgfHwgL3dlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pO1xuICB2YXIgY2hyb21lT1MgPSAvXFxiQ3JPU1xcYi8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKTtcblxuICB2YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xuICBpZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pOyB9XG4gIGlmIChwcmVzdG9fdmVyc2lvbiAmJiBwcmVzdG9fdmVyc2lvbiA+PSAxNSkgeyBwcmVzdG8gPSBmYWxzZTsgd2Via2l0ID0gdHJ1ZTsgfVxuICAvLyBTb21lIGJyb3dzZXJzIHVzZSB0aGUgd3JvbmcgZXZlbnQgcHJvcGVydGllcyB0byBzaWduYWwgY21kL2N0cmwgb24gT1MgWFxuICB2YXIgZmxpcEN0cmxDbWQgPSBtYWMgJiYgKHF0d2Via2l0IHx8IHByZXN0byAmJiAocHJlc3RvX3ZlcnNpb24gPT0gbnVsbCB8fCBwcmVzdG9fdmVyc2lvbiA8IDEyLjExKSk7XG4gIHZhciBjYXB0dXJlUmlnaHRDbGljayA9IGdlY2tvIHx8IChpZSAmJiBpZV92ZXJzaW9uID49IDkpO1xuXG4gIGZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNscyArIFwiKD86JHxcXFxccylcXFxccypcIikgfVxuXG4gIHZhciBybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFwiXCIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXG4gICAgICB7IGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTsgfVxuICAgIHJldHVybiBlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKVxuICB9XG5cbiAgZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChjbGFzc05hbWUpIHsgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7IH1cbiAgICBpZiAoc3R5bGUpIHsgZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIikgeyBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTsgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSB7IGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7IH0gfVxuICAgIHJldHVybiBlXG4gIH1cbiAgLy8gd3JhcHBlciBmb3IgZWx0LCB3aGljaCByZW1vdmVzIHRoZSBlbHQgZnJvbSB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlXG4gIGZ1bmN0aW9uIGVsdFAodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKTtcbiAgICBlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIHZhciByYW5nZTtcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xuICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZCk7XG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuICBlbHNlIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHRyeSB7IHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTsgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIHIgfVxuICAgIHIuY29sbGFwc2UodHJ1ZSk7XG4gICAgci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgci5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgc3RhcnQpO1xuICAgIHJldHVybiByXG4gIH07IH1cblxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcbiAgICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlOyB9XG4gICAgaWYgKHBhcmVudC5jb250YWlucylcbiAgICAgIHsgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCkgfVxuICAgIGRvIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxMSkgeyBjaGlsZCA9IGNoaWxkLmhvc3Q7IH1cbiAgICAgIGlmIChjaGlsZCA9PSBwYXJlbnQpIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHtcbiAgICAvLyBJRSBhbmQgRWRnZSBtYXkgdGhyb3cgYW4gXCJVbnNwZWNpZmllZCBFcnJvclwiIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuXG4gICAgLy8gSUUgPCAxMCB3aWxsIHRocm93IHdoZW4gYWNjZXNzZWQgd2hpbGUgdGhlIHBhZ2UgaXMgbG9hZGluZyBvciBpbiBhbiBpZnJhbWUuXG4gICAgLy8gSUUgPiA5IGFuZCBFZGdlIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCBpbiBhbiBpZnJhbWUgaWYgZG9jdW1lbnQuYm9keSBpcyB1bmF2YWlsYWJsZS5cbiAgICB2YXIgYWN0aXZlRWxlbWVudDtcbiAgICB0cnkge1xuICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSB8fCBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgICB7IGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDsgfVxuICAgIHJldHVybiBhY3RpdmVFbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkgeyBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFwiIFwiIDogXCJcIikgKyBjbHM7IH1cbiAgfVxuICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XG4gICAgdmFyIGFzID0gYS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIHsgYiArPSBcIiBcIiArIGFzW2ldOyB9IH1cbiAgICByZXR1cm4gYlxuICB9XG5cbiAgdmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xuICBpZiAoaW9zKSAvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cbiAgICB7IHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdGlvblN0YXJ0ID0gMDsgbm9kZS5zZWxlY3Rpb25FbmQgPSBub2RlLnZhbHVlLmxlbmd0aDsgfTsgfVxuICBlbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCk7IH0gY2F0Y2goX2UpIHt9IH07IH1cblxuICBmdW5jdGlvbiBiaW5kKGYpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgeyB0YXJnZXQgPSB7fTsgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgeyBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSB7IGVuZCA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pZCA9IG51bGw7XG4gICAgdGhpcy5mID0gbnVsbDtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuaGFuZGxlciA9IGJpbmQodGhpcy5vblRpbWVvdXQsIHRoaXMpO1xuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5vblRpbWVvdXQgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgIHNlbGYuaWQgPSAwO1xuICAgIGlmIChzZWxmLnRpbWUgPD0gK25ldyBEYXRlKSB7XG4gICAgICBzZWxmLmYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChzZWxmLmhhbmRsZXIsIHNlbGYudGltZSAtICtuZXcgRGF0ZSk7XG4gICAgfVxuICB9O1xuICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlICsgbXM7XG4gICAgaWYgKCF0aGlzLmlkIHx8IHRpbWUgPCB0aGlzLnRpbWUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlciwgbXMpO1xuICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG4gIHZhciBzY3JvbGxlckdhcCA9IDUwO1xuXG4gIC8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcbiAgLy8gaGFuZGxpbmcgdGhpcycuXG4gIHZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuUGFzc1wifX07XG5cbiAgLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXG4gIHZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfSwgc2VsX21vdXNlID0ge29yaWdpbjogXCIqbW91c2VcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXCIrbW92ZVwifTtcblxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuICBmdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIHsgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxuICAgICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XG4gICAgICBjb2wgKz0gbmV4dFRhYiAtIHBvcztcbiAgICAgIGNvbCArPSB0YWJTaXplIC0gKGNvbCAlIHRhYlNpemUpO1xuICAgICAgcG9zID0gbmV4dFRhYiArIDE7XG4gICAgICBpZiAoY29sID49IGdvYWwpIHsgcmV0dXJuIHBvcyB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNwYWNlU3RycyA9IFtcIlwiXTtcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xuICAgIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXG4gICAgICB7IHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpOyB9XG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXVxuICB9XG5cbiAgZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcbiAgICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSk7XG4gICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKzsgfVxuICAgIGFycmF5LnNwbGljZShwb3MsIDAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KTsgfVxuICAgIHJldHVybiBpbnN0XG4gIH1cblxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG4gIGZ1bmN0aW9uIGlzV29yZENoYXJCYXNpYyhjaCkge1xuICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJlxuICAgICAgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSlcbiAgfVxuICBmdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcbiAgICBpZiAoIWhlbHBlcikgeyByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKSB9XG4gICAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGhlbHBlci50ZXN0KGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEV4dGVuZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuIEEgc2VyaWVzIG9mIGEgbm9uLWV4dGVuZGluZyBjaGFyICtcbiAgLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxuICAvLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxuICAvLyBzaW5jZSBzb21lIHNjcmlwdHMvZm9udHMvYnJvd3NlcnMgYWxzbyB0cmVhdCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAvLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxuICB2YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRlLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwOTAwLVxcdTA5MDJcXHUwOTNjXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1NVxcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTBhMDFcXHUwYTAyXFx1MGEzY1xcdTBhNDFcXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MFxcdTBhNzFcXHUwYTc1XFx1MGE4MVxcdTBhODJcXHUwYWJjXFx1MGFjMS1cXHUwYWM1XFx1MGFjN1xcdTBhYzhcXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjY1xcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NFxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMThcXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjkwLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM2FcXHUxMDNkXFx1MTAzZVxcdTEwNThcXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTdcXHUxYTE4XFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFiMDAtXFx1MWIwM1xcdTFiMzRcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODBcXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOFxcdTFiYTlcXHUxYzJjLVxcdTFjMzNcXHUxYzM2XFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxZGMwLVxcdTFkZTZcXHUxZGZkLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwZDAtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTY2Zi1cXHVhNjcyXFx1YTY3Y1xcdWE2N2RcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjVcXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjXFx1YWEyOS1cXHVhYTJlXFx1YWEzMVxcdWFhMzJcXHVhYTM1XFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZGMwMC1cXHVkZmZmXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZmOWVcXHVmZjlmXS87XG4gIGZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxuICBmdW5jdGlvbiBza2lwRXh0ZW5kaW5nQ2hhcnMoc3RyLCBwb3MsIGRpcikge1xuICAgIHdoaWxlICgoZGlyIDwgMCA/IHBvcyA+IDAgOiBwb3MgPCBzdHIubGVuZ3RoKSAmJiBpc0V4dGVuZGluZ0NoYXIoc3RyLmNoYXJBdChwb3MpKSkgeyBwb3MgKz0gZGlyOyB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgcmFuZ2UgW2Bmcm9tYDsgYHRvYF0gdGhhdCBzYXRpc2ZpZXNcbiAgLy8gYHByZWRgIGFuZCBpcyBjbG9zZXN0IHRvIGBmcm9tYC4gQXNzdW1lcyB0aGF0IGF0IGxlYXN0IGB0b2BcbiAgLy8gc2F0aXNmaWVzIGBwcmVkYC4gU3VwcG9ydHMgYGZyb21gIGJlaW5nIGdyZWF0ZXIgdGhhbiBgdG9gLlxuICBmdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcbiAgICAvLyBBdCBhbnkgcG9pbnQgd2UgYXJlIGNlcnRhaW4gYHRvYCBzYXRpc2ZpZXMgYHByZWRgLCBkb24ndCBrbm93XG4gICAgLy8gd2hldGhlciBgZnJvbWAgZG9lcy5cbiAgICB2YXIgZGlyID0gZnJvbSA+IHRvID8gLTEgOiAxO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIHZhciBtaWRGID0gKGZyb20gKyB0bykgLyAyLCBtaWQgPSBkaXIgPCAwID8gTWF0aC5jZWlsKG1pZEYpIDogTWF0aC5mbG9vcihtaWRGKTtcbiAgICAgIGlmIChtaWQgPT0gZnJvbSkgeyByZXR1cm4gcHJlZChtaWQpID8gZnJvbSA6IHRvIH1cbiAgICAgIGlmIChwcmVkKG1pZCkpIHsgdG8gPSBtaWQ7IH1cbiAgICAgIGVsc2UgeyBmcm9tID0gbWlkICsgZGlyOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQklESSBIRUxQRVJTXG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBmKGZyb20sIHRvLCBcImx0clwiLCAwKSB9XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xuICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXCJydGxcIiA6IFwibHRyXCIsIGkpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXCJsdHJcIik7IH1cbiAgfVxuXG4gIHZhciBiaWRpT3RoZXIgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGJpZGlPdGhlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xuICAgICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHsgcmV0dXJuIGkgfVxuICAgICAgaWYgKGN1ci50byA9PSBjaCkge1xuICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGZvdW5kID0gaTsgfVxuICAgICAgICBlbHNlIHsgYmlkaU90aGVyID0gaTsgfVxuICAgICAgfVxuICAgICAgaWYgKGN1ci5mcm9tID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ICE9IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZCAhPSBudWxsID8gZm91bmQgOiBiaWRpT3RoZXJcbiAgfVxuXG4gIC8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG5cbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4gIC8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4gIC8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuICAvLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbiAgLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4gIC8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXG5cbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbiAgLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbiAgICB2YXIgYXJhYmljVHlwZXMgPSBcIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIjtcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA8PSAweGY3KSB7IHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSkgfVxuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcIlJcIiB9XG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZjkpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgeyByZXR1cm4gXCJyXCIgfVxuICAgICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHsgcmV0dXJuIFwid1wiIH1cbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSB7IHJldHVybiBcImJcIiB9XG4gICAgICBlbHNlIHsgcmV0dXJuIFwiTFwiIH1cbiAgICB9XG5cbiAgICB2YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbiAgICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vO1xuXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFwibHRyXCIgPyBcIkxcIiA6IFwiUlwiO1xuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcImx0clwiICYmICFiaWRpUkUudGVzdChzdHIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHsgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpOyB9XG5cbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2kkMV07XG4gICAgICAgIGlmICh0eXBlID09IFwibVwiKSB7IHR5cGVzW2kkMV0gPSBwcmV2OyB9XG4gICAgICAgIGVsc2UgeyBwcmV2ID0gdHlwZTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAvLyBudW1iZXIuXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyIDwgbGVuOyArK2kkMikge1xuICAgICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXTtcbiAgICAgICAgaWYgKHR5cGUkMSA9PSBcIjFcIiAmJiBjdXIgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiblwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQxKSkgeyBjdXIgPSB0eXBlJDE7IGlmICh0eXBlJDEgPT0gXCJyXCIpIHsgdHlwZXNbaSQyXSA9IFwiUlwiOyB9IH1cbiAgICAgIH1cblxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cbiAgICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICBmb3IgKHZhciBpJDMgPSAxLCBwcmV2JDEgPSB0eXBlc1swXTsgaSQzIDwgbGVuIC0gMTsgKytpJDMpIHtcbiAgICAgICAgdmFyIHR5cGUkMiA9IHR5cGVzW2kkM107XG4gICAgICAgIGlmICh0eXBlJDIgPT0gXCIrXCIgJiYgcHJldiQxID09IFwiMVwiICYmIHR5cGVzW2kkMysxXSA9PSBcIjFcIikgeyB0eXBlc1tpJDNdID0gXCIxXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQyID09IFwiLFwiICYmIHByZXYkMSA9PSB0eXBlc1tpJDMrMV0gJiZcbiAgICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcIjFcIiB8fCBwcmV2JDEgPT0gXCJuXCIpKSB7IHR5cGVzW2kkM10gPSBwcmV2JDE7IH1cbiAgICAgICAgcHJldiQxID0gdHlwZSQyO1xuICAgICAgfVxuXG4gICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgICAvLyBOZXV0cmFsLlxuICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbGVuOyArK2kkNCkge1xuICAgICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XTtcbiAgICAgICAgaWYgKHR5cGUkMyA9PSBcIixcIikgeyB0eXBlc1tpJDRdID0gXCJOXCI7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSQzID09IFwiJVwiKSB7XG4gICAgICAgICAgdmFyIGVuZCA9ICh2b2lkIDApO1xuICAgICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIlXCI7ICsrZW5kKSB7fVxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXCIhXCIpIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIjFcIikgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2U7IH1cbiAgICAgICAgICBpJDQgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcbiAgICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV07XG4gICAgICAgIGlmIChjdXIkMSA9PSBcIkxcIiAmJiB0eXBlJDQgPT0gXCIxXCIpIHsgdHlwZXNbaSQ1XSA9IFwiTFwiOyB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQ0KSkgeyBjdXIkMSA9IHR5cGUkNDsgfVxuICAgICAgfVxuXG4gICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGxlbjsgKytpJDYpIHtcbiAgICAgICAgaWYgKGlzTmV1dHJhbC50ZXN0KHR5cGVzW2kkNl0pKSB7XG4gICAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQkMSA9IGkkNiArIDE7IGVuZCQxIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZCQxXSk7ICsrZW5kJDEpIHt9XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IChpJDYgPyB0eXBlc1tpJDYtMV0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIHJlcGxhY2UkMSA9IGJlZm9yZSA9PSBhZnRlciA/IChiZWZvcmUgPyBcIkxcIiA6IFwiUlwiKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxOyB9XG4gICAgICAgICAgaSQ2ID0gZW5kJDEgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcbiAgICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcbiAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3O1xuICAgICAgICAgIGZvciAoKytpJDc7IGkkNyA8IGxlbiAmJiBjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKTsgKytpJDcpIHt9XG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkkNykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoLCBpc1JUTCA9IGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gMSA6IDA7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXCJMXCI7ICsraSQ3KSB7fVxuICAgICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xuICAgICAgICAgICAgaWYgKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpOyBhdCArPSBpc1JUTDsgfVxuICAgICAgICAgICAgICB2YXIgbnN0YXJ0ID0gaiQyO1xuICAgICAgICAgICAgICBmb3IgKCsraiQyOyBqJDIgPCBpJDcgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKTsgKytqJDIpIHt9XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSk7XG4gICAgICAgICAgICAgIGF0ICs9IGlzUlRMO1xuICAgICAgICAgICAgICBwb3MgPSBqJDI7XG4gICAgICAgICAgICB9IGVsc2UgeyArK2okMjsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zIDwgaSQ3KSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImx0clwiKSB7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICAgIG9yZGVyWzBdLmZyb20gPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xccyskLykpKSB7XG4gICAgICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gb3JkZXIucmV2ZXJzZSgpIDogb3JkZXJcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xuICAvLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQsIGRpcmVjdGlvbik7IH1cbiAgICByZXR1cm4gb3JkZXJcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG5cbiAgLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcbiAgLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cblxuICB2YXIgbm9IYW5kbGVycyA9IFtdO1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5hdHRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgIG1hcFt0eXBlXSA9IChtYXBbdHlwZV0gfHwgbm9IYW5kbGVycykuY29uY2F0KGYpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycywgYXJyID0gbWFwICYmIG1hcFt0eXBlXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIGYpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICB7IG1hcFt0eXBlXSA9IGFyci5zbGljZSgwLCBpbmRleCkuY29uY2F0KGFyci5zbGljZShpbmRleCArIDEpKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7IH1cbiAgfVxuXG4gIC8vIFRoZSBET00gZXZlbnRzIHRoYXQgQ29kZU1pcnJvciBoYW5kbGVzIGNhbiBiZSBvdmVycmlkZGVuIGJ5XG4gIC8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXG4gIC8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cbiAgZnVuY3Rpb24gc2lnbmFsRE9NRXZlbnQoY20sIGUsIG92ZXJyaWRlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fTsgfVxuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XG4gICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XG4gICAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XG4gICAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXG4gICAgICB7IHNldC5wdXNoKGFycltpXSk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XG4gICAgY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBmKSB7b24odGhpcywgdHlwZSwgZik7fTtcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XG4gIH1cblxuICAvLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXG4gIC8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cblxuICBmdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG4gICAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgfVxuICB9XG4gIGZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fVxuXG4gIGZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgMikgeyBiID0gMzsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyOyB9XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgeyBiID0gMzsgfVxuICAgIHJldHVybiBiXG4gIH1cblxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxuICB2YXIgZHJhZ0FuZERyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xuICAgIHJldHVybiBcImRyYWdnYWJsZVwiIGluIGRpdiB8fCBcImRyYWdEcm9wXCIgaW4gZGl2XG4gIH0oKTtcblxuICB2YXIgendzcFN1cHBvcnRlZDtcbiAgZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XG4gICAgaWYgKHp3c3BTdXBwb3J0ZWQgPT0gbnVsbCkge1xuICAgICAgdmFyIHRlc3QgPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTtcbiAgICAgIGlmIChtZWFzdXJlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICE9IDApXG4gICAgICAgIHsgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIShpZSAmJiBpZV92ZXJzaW9uIDwgOCk7IH1cbiAgICB9XG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxuICAgICAgZWx0KFwic3BhblwiLCBcIlxcdTAwYTBcIiwgbnVsbCwgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XG4gIHZhciBiYWRCaWRpUmVjdHM7XG4gIGZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7IHJldHVybiBiYWRCaWRpUmVjdHMgfVxuICAgIHZhciB0eHQgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7XG4gICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlbW92ZUNoaWxkcmVuKG1lYXN1cmUpO1xuICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxuICAgIHJldHVybiBiYWRCaWRpUmVjdHMgPSAocjEucmlnaHQgLSByMC5yaWdodCA8IDMpXG4gIH1cblxuICAvLyBTZWUgaWYgXCJcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXG4gIC8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cbiAgdmFyIHNwbGl0TGluZXNBdXRvID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XG4gICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXCJcXHJcIiA/IG5sIC0gMSA6IG5sKTtcbiAgICAgIHZhciBydCA9IGxpbmUuaW5kZXhPZihcIlxcclwiKTtcbiAgICAgIGlmIChydCAhPSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XG4gICAgICAgIHBvcyArPSBydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgcG9zID0gbmwgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcclxcbj98XFxuLyk7IH07XG5cbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAodGUpIHtcbiAgICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XG4gIH0gOiBmdW5jdGlvbiAodGUpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgdHJ5IHtyYW5nZSA9IHRlLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7fVxuICAgIGNhdGNoKGUpIHt9XG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5wYXJlbnRFbGVtZW50KCkgIT0gdGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgcmFuZ2UpICE9IDBcbiAgfTtcblxuICB2YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IGVsdChcImRpdlwiKTtcbiAgICBpZiAoXCJvbmNvcHlcIiBpbiBlKSB7IHJldHVybiB0cnVlIH1cbiAgICBlLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLCBcInJldHVybjtcIik7XG4gICAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcImZ1bmN0aW9uXCJcbiAgfSkoKTtcblxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICBmdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZFpvb21lZFJlY3RzIH1cbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcbiAgICB2YXIgbm9ybWFsID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXG4gIH1cblxuICAvLyBLbm93biBtb2RlcywgYnkgbmFtZSBhbmQgYnkgTUlNRVxuICB2YXIgbW9kZXMgPSB7fSwgbWltZU1vZGVzID0ge307XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIGZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSwgbW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOyB9XG4gICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgfVxuXG4gIC8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXG4gIGZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcbiAgICAgIHNwZWMgPSBtaW1lTW9kZXNbc3BlY107XG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XG4gICAgICBpZiAodHlwZW9mIGZvdW5kID09IFwic3RyaW5nXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9OyB9XG4gICAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKTtcbiAgICAgIHNwZWMubmFtZSA9IGZvdW5kLm5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24veG1sXCIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL2pzb25cIilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XG4gICAgZWxzZSB7IHJldHVybiBzcGVjIHx8IHtuYW1lOiBcIm51bGxcIn0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIHNwZWMgKGFueXRoaW5nIHRoYXQgcmVzb2x2ZU1vZGUgYWNjZXB0cyksIGZpbmQgYW5kXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuICBmdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcbiAgICBzcGVjID0gcmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcbiAgICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKSB9XG4gICAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xuICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7IG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07IH1cbiAgICAgICAgbW9kZU9ialtwcm9wXSA9IGV4dHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZTtcbiAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7IG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTsgfVxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgeyBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpXG4gICAgICB7IG1vZGVPYmpbcHJvcCQxXSA9IHNwZWMubW9kZVByb3BzW3Byb3AkMV07IH0gfVxuXG4gICAgcmV0dXJuIG1vZGVPYmpcbiAgfVxuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cbiAgLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbiAgdmFyIG1vZGVFeHRlbnNpb25zID0ge307XG4gIGZ1bmN0aW9uIGV4dGVuZE1vZGUobW9kZSwgcHJvcGVydGllcykge1xuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSB7IHJldHVybiBzdGF0ZSB9XG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxuICAgIHZhciBuc3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSk7IH1cbiAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG5zdGF0ZVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcbiAgLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cbiAgZnVuY3Rpb24gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKSB7XG4gICAgdmFyIGluZm87XG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSB7IGJyZWFrIH1cbiAgICAgIHN0YXRlID0gaW5mby5zdGF0ZTtcbiAgICAgIG1vZGUgPSBpbmZvLm1vZGU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvIHx8IHttb2RlOiBtb2RlLCBzdGF0ZTogc3RhdGV9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xuICAgIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWVcbiAgfVxuXG4gIC8vIFNUUklORyBTVFJFQU1cblxuICAvLyBGZWQgdG8gdGhlIG1vZGUgcGFyc2VycywgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byBtYWtlXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cblxuICB2YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplLCBsaW5lT3JhY2xlKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XG4gICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmxpbmVPcmFjbGUgPSBsaW5lT3JhY2xlO1xuICB9O1xuXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZW9sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGh9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICB2YXIgb2s7XG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKSB7IG9rID0gY2ggPT0gbWF0Y2g7IH1cbiAgICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTsgfVxuICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSB7ICsrdGhpcy5wb3M7IH1cbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUbyA9IGZ1bmN0aW9uIChjaCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhY2tVcCA9IGZ1bmN0aW9uIChuKSB7dGhpcy5wb3MgLT0gbjt9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cbiAgICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9O1xuICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDsgfVxuICAgICAgcmV0dXJuIG1hdGNoXG4gICAgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycyA9IGZ1bmN0aW9uIChuLCBpbm5lcikge1xuICAgIHRoaXMubGluZVN0YXJ0ICs9IG47XG4gICAgdHJ5IHsgcmV0dXJuIGlubmVyKCkgfVxuICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubG9va0FoZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmxvb2tBaGVhZChuKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmJhc2VUb2tlbih0aGlzLnBvcylcbiAgfTtcblxuICAvLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcbiAgICBuIC09IGRvYy5maXJzdDtcbiAgICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBsaW5lIFwiICsgKG4gKyBkb2MuZmlyc3QpICsgXCIgaW4gdGhlIGRvY3VtZW50LlwiKSB9XG4gICAgdmFyIGNodW5rID0gZG9jO1xuICAgIHdoaWxlICghY2h1bmsubGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrIH1cbiAgICAgICAgbiAtPSBzejtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLmxpbmVzW25dXG4gIH1cblxuICAvLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXG4gIC8vIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcbiAgICAgIGlmIChuID09IGVuZC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCk7IH1cbiAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2Uoc3RhcnQuY2gpOyB9XG4gICAgICBvdXQucHVzaCh0ZXh0KTtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbiAobGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIHRydXRoeSB2YWx1ZVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcbiAgLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XG4gICAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodDtcbiAgICBpZiAoZGlmZikgeyBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7IG4uaGVpZ2h0ICs9IGRpZmY7IH0gfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXG4gIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSB7IGJyZWFrIH1cbiAgICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBubyArIGN1ci5maXJzdFxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG4gIGZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgb3V0ZXI6IGRvIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXIgfVxuICAgICAgICBoIC09IGNoO1xuICAgICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaCA8IGxoKSB7IGJyZWFrIH1cbiAgICAgIGggLT0gbGg7XG4gICAgfVxuICAgIHJldHVybiBuICsgaVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemV9XG5cbiAgZnVuY3Rpb24gbGluZU51bWJlckZvcihvcHRpb25zLCBpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcbiAgfVxuXG4gIC8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXG4gIGZ1bmN0aW9uIFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB7XG4gICAgaWYgKCBzdGlja3kgPT09IHZvaWQgMCApIHN0aWNreSA9IG51bGw7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB9XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNoID0gY2g7XG4gICAgdGhpcy5zdGlja3kgPSBzdGlja3k7XG4gIH1cblxuICAvLyBDb21wYXJlIHR3byBwb3NpdGlvbnMsIHJldHVybiAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBhIG5lZ2F0aXZlXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XG5cbiAgZnVuY3Rpb24gZXF1YWxDdXJzb3JQb3MoYSwgYikgeyByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKX1cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XG4gIGZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGIgfVxuXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcbiAgLy8gYWN0dWFsbHkgZXhpc3Qgd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHsgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSB7IHJldHVybiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSB9XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXG4gIH1cbiAgZnVuY3Rpb24gY2xpcFRvTGVuKHBvcywgbGluZWxlbikge1xuICAgIHZhciBjaCA9IHBvcy5jaDtcbiAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgbGluZWxlbikgfVxuICAgIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XG4gICAgZWxzZSB7IHJldHVybiBwb3MgfVxuICB9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKTsgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHZhciBTYXZlZENvbnRleHQgPSBmdW5jdGlvbihzdGF0ZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICB9O1xuXG4gIHZhciBDb250ZXh0ID0gZnVuY3Rpb24oZG9jLCBzdGF0ZSwgbGluZSwgbG9va0FoZWFkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5tYXhMb29rQWhlYWQgPSBsb29rQWhlYWQgfHwgMDtcbiAgICB0aGlzLmJhc2VUb2tlbnMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRva2VuUG9zID0gMTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZSh0aGlzLmxpbmUgKyBuKTtcbiAgICBpZiAobGluZSAhPSBudWxsICYmIG4gPiB0aGlzLm1heExvb2tBaGVhZCkgeyB0aGlzLm1heExvb2tBaGVhZCA9IG47IH1cbiAgICByZXR1cm4gbGluZVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKCF0aGlzLmJhc2VUb2tlbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHdoaWxlICh0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIDw9IG4pXG4gICAgICB7IHRoaXMuYmFzZVRva2VuUG9zICs9IDI7IH1cbiAgICB2YXIgdHlwZSA9IHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcyArIDFdO1xuICAgIHJldHVybiB7dHlwZTogdHlwZSAmJiB0eXBlLnJlcGxhY2UoLyggfF4pb3ZlcmxheSAuKi8sIFwiXCIpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXSAtIG59XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saW5lKys7XG4gICAgaWYgKHRoaXMubWF4TG9va0FoZWFkID4gMCkgeyB0aGlzLm1heExvb2tBaGVhZC0tOyB9XG4gIH07XG5cbiAgQ29udGV4dC5mcm9tU2F2ZWQgPSBmdW5jdGlvbiAoZG9jLCBzYXZlZCwgbGluZSkge1xuICAgIGlmIChzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dClcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZC5zdGF0ZSksIGxpbmUsIHNhdmVkLmxvb2tBaGVhZCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgY29weVN0YXRlKGRvYy5tb2RlLCBzYXZlZCksIGxpbmUpIH1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGNvcHkpIHtcbiAgICB2YXIgc3RhdGUgPSBjb3B5ICE9PSBmYWxzZSA/IGNvcHlTdGF0ZSh0aGlzLmRvYy5tb2RlLCB0aGlzLnN0YXRlKSA6IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMubWF4TG9va0FoZWFkID4gMCA/IG5ldyBTYXZlZENvbnRleHQoc3RhdGUsIHRoaXMubWF4TG9va0FoZWFkKSA6IHN0YXRlXG4gIH07XG5cblxuICAvLyBDb21wdXRlIGEgc3R5bGUgYXJyYXkgKGFuIGFycmF5IHN0YXJ0aW5nIHdpdGggYSBtb2RlIGdlbmVyYXRpb25cbiAgLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxuICAvLyBzdHlsZSBzdHJpbmdzKSwgd2hpY2ggaXMgdXNlZCB0byBoaWdobGlnaHQgdGhlIHRva2VucyBvbiB0aGVcbiAgLy8gbGluZS5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgZm9yY2VUb0VuZCkge1xuICAgIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXG4gICAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHsgcmV0dXJuIHN0LnB1c2goZW5kLCBzdHlsZSk7IH0sXG4gICAgICAgICAgICBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XG4gICAgdmFyIHN0YXRlID0gY29udGV4dC5zdGF0ZTtcblxuICAgIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5zID0gc3Q7XG4gICAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwO1xuICAgICAgY29udGV4dC5zdGF0ZSA9IHRydWU7XG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIG92ZXJsYXkubW9kZSwgY29udGV4dCwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xuICAgICAgICAgIGlmIChpX2VuZCA+IGVuZClcbiAgICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpOyB9XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHlsZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcbiAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcIm92ZXJsYXkgXCIgKyBzdHlsZSk7XG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJvdmVybGF5IFwiICsgc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XG4gICAgICBjb250ZXh0LnN0YXRlID0gc3RhdGU7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgY29udGV4dC5iYXNlVG9rZW5Qb3MgPSAxO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSBsb29wKCBvICk7XG5cbiAgICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcbiAgICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIHZhciByZXNldFN0YXRlID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoICYmIGNvcHlTdGF0ZShjbS5kb2MubW9kZSwgY29udGV4dC5zdGF0ZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCk7XG4gICAgICBpZiAocmVzZXRTdGF0ZSkgeyBjb250ZXh0LnN0YXRlID0gcmVzZXRTdGF0ZTsgfVxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5zYXZlKCFyZXNldFN0YXRlKTtcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzOyB9XG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7IH1cbiAgICAgIGlmICh1cGRhdGVGcm9udGllciA9PT0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKVxuICAgICAgICB7IGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChjbS5kb2MubW9kZUZyb250aWVyLCArK2NtLmRvYy5oaWdobGlnaHRGcm9udGllcik7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUuc3R5bGVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0QmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiBuZXcgQ29udGV4dChkb2MsIHRydWUsIG4pIH1cbiAgICB2YXIgc3RhcnQgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKTtcbiAgICB2YXIgc2F2ZWQgPSBzdGFydCA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgc3RhcnQgLSAxKS5zdGF0ZUFmdGVyO1xuICAgIHZhciBjb250ZXh0ID0gc2F2ZWQgPyBDb250ZXh0LmZyb21TYXZlZChkb2MsIHNhdmVkLCBzdGFydCkgOiBuZXcgQ29udGV4dChkb2MsIHN0YXJ0U3RhdGUoZG9jLm1vZGUpLCBzdGFydCk7XG5cbiAgICBkb2MuaXRlcihzdGFydCwgbiwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpO1xuICAgICAgdmFyIHBvcyA9IGNvbnRleHQubGluZTtcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG8gPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIHsgZG9jLm1vZGVGcm9udGllciA9IGNvbnRleHQubGluZTsgfVxuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxuICAvLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RhcnRBdCkge1xuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KTtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBjb250ZXh0LnN0YXRlKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpIH1cbiAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiB9XG4gICAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcbiAgICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGlmIChpbm5lcikgeyBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTsgfVxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpXG4gIH1cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0cmVhbS5zdGFydDsgdGhpcy5lbmQgPSBzdHJlYW0ucG9zO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcbiAgZnVuY3Rpb24gdGFrZVRva2VuKGNtLCBwb3MsIHByZWNpc2UsIGFzQXJyYXkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlO1xuICAgIHBvcyA9IGNsaXBQb3MoZG9jLCBwb3MpO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgY29udGV4dCA9IGdldENvbnRleHRCZWZvcmUoY20sIHBvcy5saW5lLCBwcmVjaXNlKTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHRva2VucztcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXTsgfVxuICAgIHdoaWxlICgoYXNBcnJheSB8fCBzdHJlYW0ucG9zIDwgcG9zLmNoKSAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpKSk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBuZXcgVG9rZW4oc3RyZWFtLCBzdHlsZSwgY29udGV4dC5zdGF0ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZSkgeyBmb3IgKDs7KSB7XG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtcbiAgICAgIGlmICghbGluZUNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpO1xuICAgICAgdmFyIHByb3AgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XG4gICAgICBpZiAob3V0cHV0W3Byb3BdID09IG51bGwpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdOyB9XG4gICAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiICsgbGluZUNsYXNzWzJdICsgXCIoPzokfFxcXFxzKVwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxuICAgICAgICB7IG91dHB1dFtwcm9wXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTsgfVxuICAgIH0gfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgY29udGV4dCwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zOyB9XG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHN0eWxlO1xuICAgIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXTtcbiAgICBpZiAodGV4dCA9PSBcIlwiKSB7IGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7IH1cbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xuICAgICAgICBmbGF0dGVuU3BhbnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIGNvbnRleHQsIHN0cmVhbS5wb3MpOyB9XG4gICAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgc3R5bGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgY29udGV4dC5zdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZTtcbiAgICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXCJtLVwiICsgKHN0eWxlID8gbU5hbWUgKyBcIiBcIiArIHN0eWxlIDogbU5hbWUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcbiAgICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1MDAwKTtcbiAgICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgfVxuICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcbiAgICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXG4gICAgICAvLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cbiAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgZihwb3MsIGN1clN0eWxlKTtcbiAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgeyByZXR1cm4gZG9jLmZpcnN0IH1cbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpLCBhZnRlciA9IGxpbmUuc3RhdGVBZnRlcjtcbiAgICAgIGlmIChhZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoICsgKGFmdGVyIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0ID8gYWZ0ZXIubG9va0FoZWFkIDogMCkgPD0gZG9jLm1vZGVGcm9udGllcikpXG4gICAgICAgIHsgcmV0dXJuIHNlYXJjaCB9XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJlYXRGcm9udGllcihkb2MsIG4pIHtcbiAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5taW4oZG9jLm1vZGVGcm9udGllciwgbik7XG4gICAgaWYgKGRvYy5oaWdobGlnaHRGcm9udGllciA8IG4gLSAxMCkgeyByZXR1cm4gfVxuICAgIHZhciBzdGFydCA9IGRvYy5maXJzdDtcbiAgICBmb3IgKHZhciBsaW5lID0gbiAtIDE7IGxpbmUgPiBzdGFydDsgbGluZS0tKSB7XG4gICAgICB2YXIgc2F2ZWQgPSBnZXRMaW5lKGRvYywgbGluZSkuc3RhdGVBZnRlcjtcbiAgICAgIC8vIGNoYW5nZSBpcyBvbiAzXG4gICAgICAvLyBzdGF0ZSBvbiBsaW5lIDEgbG9va2VkIGFoZWFkIDIgLS0gc28gc2F3IDNcbiAgICAgIC8vIHRlc3QgMSArIDIgPCAzIHNob3VsZCBjb3ZlciB0aGlzXG4gICAgICBpZiAoc2F2ZWQgJiYgKCEoc2F2ZWQgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQpIHx8IGxpbmUgKyBzYXZlZC5sb29rQWhlYWQgPCBuKSkge1xuICAgICAgICBzdGFydCA9IGxpbmUgKyAxO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuaGlnaGxpZ2h0RnJvbnRpZXIsIHN0YXJ0KTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cbiAgdmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZSwgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZWVSZWFkT25seVNwYW5zKCkge1xuICAgIHNhd1JlYWRPbmx5U3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XG4gICAgc2F3Q29sbGFwc2VkU3BhbnMgPSB0cnVlO1xuICB9XG5cbiAgLy8gVEVYVE1BUktFUiBTUEFOU1xuXG4gIGZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xuICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgfVxuXG4gIC8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXG4gIGZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgeyByZXR1cm4gc3BhbiB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICB2YXIgcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7IH0gfVxuICAgIHJldHVybiByXG4gIH1cblxuICAvLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cbiAgZnVuY3Rpb24gYWRkTWFya2VkU3BhbihsaW5lLCBzcGFuLCBvcCkge1xuICAgIHZhciBpblRoaXNPcCA9IG9wICYmIHdpbmRvdy5XZWFrU2V0ICYmIChvcC5tYXJrZWRTcGFucyB8fCAob3AubWFya2VkU3BhbnMgPSBuZXcgV2Vha1NldCkpO1xuICAgIGlmIChpblRoaXNPcCAmJiBpblRoaXNPcC5oYXMobGluZS5tYXJrZWRTcGFucykpIHtcbiAgICAgIGxpbmUubWFya2VkU3BhbnMucHVzaChzcGFuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IGxpbmUubWFya2VkU3BhbnMgPyBsaW5lLm1hcmtlZFNwYW5zLmNvbmNhdChbc3Bhbl0pIDogW3NwYW5dO1xuICAgICAgaWYgKGluVGhpc09wKSB7IGluVGhpc09wLmFkZChsaW5lLm1hcmtlZFNwYW5zKTsgfVxuICAgIH1cbiAgICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdGhlIGFsZ29yaXRobSB0aGF0IGFkanVzdHMgbWFya2VycyBmb3IgYSBjaGFuZ2UgaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cbiAgLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcbiAgLy8gdW5kZWZpbmVkIGlmIG5vdGhpbmcgcmVtYWlucykuXG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcbiAgICB2YXIgbnc7XG4gICAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBzdGFydENoIDogc3Bhbi5mcm9tIDwgc3RhcnRDaCk7XG4gICAgICBpZiAoc3RhcnRzQmVmb3JlIHx8IHNwYW4uZnJvbSA9PSBzdGFydENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8ICFzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IHN0YXJ0Q2ggOiBzcGFuLnRvID4gc3RhcnRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKTtcbiAgICAgIGlmIChlbmRzQWZ0ZXIgfHwgc3Bhbi5mcm9tID09IGVuZENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gZW5kQ2ggOiBzcGFuLmZyb20gPCBlbmRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpO1xuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBud1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XG4gIC8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xuICAvLyBlbnRpcmVseSB3aXRoaW4gdGhlIGNoYW5nZSwgcmVjb25uZWN0cyBzcGFucyBiZWxvbmdpbmcgdG8gdGhlXG4gIC8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXG4gIC8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXG4gIC8vIGFycmF5cyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGxpbmUgaW4gKGFmdGVyKSB0aGUgY2hhbmdlLlxuICBmdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgb2xkRmlyc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkubWFya2VkU3BhbnM7XG4gICAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFucztcbiAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwO1xuICAgIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXG4gICAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KTtcbiAgICB2YXIgbGFzdCA9IG1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCwgZW5kQ2gsIGlzSW5zZXJ0KTtcblxuICAgIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXG4gICAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRml4IHVwIC50byBwcm9wZXJ0aWVzIG9mIGZpcnN0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gZmlyc3RbaV07XG4gICAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHNwYW4udG8gPSBzdGFydENoOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc2FtZUxpbmUpIHsgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQ7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCkge1xuICAgICAgLy8gRml4IHVwIC5mcm9tIGluIGxhc3QgKG9yIG1vdmUgdGhlbSBpbnRvIGZpcnN0IGluIGNhc2Ugb2Ygc2FtZUxpbmUpXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsYXN0Lmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXTtcbiAgICAgICAgaWYgKHNwYW4kMS50byAhPSBudWxsKSB7IHNwYW4kMS50byArPSBvZmZzZXQ7IH1cbiAgICAgICAgaWYgKHNwYW4kMS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQkMSA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4kMS5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQkMSkge1xuICAgICAgICAgICAgc3BhbiQxLmZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4kMS5mcm9tICs9IG9mZnNldDtcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KTsgfVxuICAgIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIHsgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KTsgfVxuXG4gICAgdmFyIG5ld01hcmtlcnMgPSBbZmlyc3RdO1xuICAgIGlmICghc2FtZUxpbmUpIHtcbiAgICAgIC8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xuICAgICAgdmFyIGdhcCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDIsIGdhcE1hcmtlcnM7XG4gICAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdClcbiAgICAgICAgeyBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBmaXJzdC5sZW5ndGg7ICsraSQyKVxuICAgICAgICAgIHsgaWYgKGZpcnN0W2kkMl0udG8gPT0gbnVsbClcbiAgICAgICAgICAgIHsgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaSQyXS5tYXJrZXIsIG51bGwsIG51bGwpKTsgfSB9IH1cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXG4gICAgICAgIHsgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpOyB9XG4gICAgICBuZXdNYXJrZXJzLnB1c2gobGFzdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXJrZXJzXG4gIH1cblxuICAvLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxuICAvLyBvcHRpb24gb2YgZmFsc2UuXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgICB7IHNwYW5zLnNwbGljZShpLS0sIDEpOyB9XG4gICAgfVxuICAgIGlmICghc3BhbnMubGVuZ3RoKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gc3BhbnNcbiAgfVxuXG4gIC8vIFVzZWQgdG8gJ2NsaXAnIG91dCByZWFkT25seSByYW5nZXMgd2hlbiBtYWtpbmcgYSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgbWFya2VycyA9IG51bGw7XG4gICAgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbWFyayA9IGxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyO1xuICAgICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXG4gICAgICAgICAgeyAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKTsgfVxuICAgICAgfSB9XG4gICAgfSk7XG4gICAgaWYgKCFtYXJrZXJzKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcGFydHMgPSBbe2Zyb206IGZyb20sIHRvOiB0b31dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG1rID0gbWFya2Vyc1tpXSwgbSA9IG1rLmZpbmQoMCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBwID0gcGFydHNbal07XG4gICAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKTtcbiAgICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXG4gICAgICAgICAgeyBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KTsgfVxuICAgICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IG0udG8sIHRvOiBwLnRvfSk7IH1cbiAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XG4gICAgICAgIGogKz0gbmV3UGFydHMubGVuZ3RoIC0gMztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzXG4gIH1cblxuICAvLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBzcGFuc1tpXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKTsgfVxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHNwYW5zO1xuICB9XG5cbiAgLy8gSGVscGVycyB1c2VkIHdoZW4gY29tcHV0aW5nIHdoaWNoIG92ZXJsYXBwaW5nIGNvbGxhcHNlZCBzcGFuXG4gIC8vIGNvdW50cyBhcyB0aGUgbGFyZ2VyIG9uZS5cbiAgZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxuICBmdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDAgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGljaCBvZiB0d28gb3ZlcmxhcHBpbmcgY29sbGFwc2VkXG4gIC8vIHNwYW5zIGlzIGxhcmdlciAoYW5kIHRodXMgaW5jbHVkZXMgdGhlIG90aGVyKS4gRmFsbHMgYmFjayB0b1xuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXG4gIGZ1bmN0aW9uIGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGEsIGIpIHtcbiAgICB2YXIgbGVuRGlmZiA9IGEubGluZXMubGVuZ3RoIC0gYi5saW5lcy5sZW5ndGg7XG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgeyByZXR1cm4gbGVuRGlmZiB9XG4gICAgdmFyIGFQb3MgPSBhLmZpbmQoKSwgYlBvcyA9IGIuZmluZCgpO1xuICAgIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYik7XG4gICAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cbiAgICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYik7XG4gICAgaWYgKHRvQ21wKSB7IHJldHVybiB0b0NtcCB9XG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkXG4gIH1cblxuICAvLyBGaW5kIG91dCB3aGV0aGVyIGEgbGluZSBlbmRzIG9yIHN0YXJ0cyBpbiBhIGNvbGxhcHNlZCBzcGFuLiBJZlxuICAvLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxuICAgICAgICAgICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSlcbiAgICAgICAgeyBmb3VuZCA9IHNwLm1hcmtlcjsgfVxuICAgIH0gfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgdHJ1ZSkgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSkgfVxuXG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5Bcm91bmQobGluZSwgY2gpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHNwLmZyb20gPT0gbnVsbCB8fCBzcC5mcm9tIDwgY2gpICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gY2gpICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKSB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcbiAgLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXG4gIC8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cbiAgZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVObyk7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xuICAgICAgdmFyIGZyb21DbXAgPSBjbXAoZm91bmQuZnJvbSwgZnJvbSkgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYUxlZnQobWFya2VyKTtcbiAgICAgIHZhciB0b0NtcCA9IGNtcChmb3VuZC50bywgdG8pIHx8IGV4dHJhUmlnaHQoc3AubWFya2VyKSAtIGV4dHJhUmlnaHQobWFya2VyKTtcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoZnJvbUNtcCA8PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQudG8sIGZyb20pID49IDAgOiBjbXAoZm91bmQudG8sIGZyb20pID4gMCkgfHxcbiAgICAgICAgICBmcm9tQ21wID49IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC5mcm9tLCB0bykgPD0gMCA6IGNtcChmb3VuZC5mcm9tLCB0bykgPCAwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3JcbiAgLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXG4gIC8vIHZpc3VhbCBsaW5lLiBUaGlzIGZpbmRzIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XG4gICAgdmFyIG1lcmdlZDtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBmdW5jdGlvbiB2aXN1YWxMaW5lRW5kKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxuICAvLyBzdGFydGVkIGJ5IHRoZSBhcmd1bWVudCwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBzdWNoIGxpbmVzLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkLCBsaW5lcztcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxuICAgICAgOyhsaW5lcyB8fCAobGluZXMgPSBbXSkpLnB1c2gobGluZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lc1xuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVObyhkb2MsIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCB2aXMgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmIChsaW5lID09IHZpcykgeyByZXR1cm4gbGluZU4gfVxuICAgIHJldHVybiBsaW5lTm8odmlzKVxuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcbiAgLy8gdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIG1lcmdlZDtcbiAgICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZU5vKGxpbmUpICsgMVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcbiAgLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxuICAvLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAoc3AubWFya2VyLndpZGdldE5vZGUpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gMCAmJiBzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCAmJiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XG4gICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgdmFyIGVuZCA9IHNwYW4ubWFya2VyLmZpbmQoMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKVxuICAgIH1cbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXG4gICAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxuICAgICAgICAgIChzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCB8fCBzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCkgJiZcbiAgICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xuICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuXG4gICAgdmFyIGggPSAwLCBjaHVuayA9IGxpbmVPYmoucGFyZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XG4gICAgICBpZiAobGluZSA9PSBsaW5lT2JqKSB7IGJyZWFrIH1cbiAgICAgIGVsc2UgeyBoICs9IGxpbmUuaGVpZ2h0OyB9XG4gICAgfVxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcC5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV07XG4gICAgICAgIGlmIChjdXIgPT0gY2h1bmspIHsgYnJlYWsgfVxuICAgICAgICBlbHNlIHsgaCArPSBjdXIuaGVpZ2h0OyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxuICAvLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cbiAgLy8gb3RoZXIgbGluZXMgb250byBpdC5cbiAgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XG4gICAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHsgcmV0dXJuIDAgfVxuICAgIHZhciBsZW4gPSBsaW5lLnRleHQubGVuZ3RoLCBtZXJnZWQsIGN1ciA9IGxpbmU7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgY3VyID0gZm91bmQuZnJvbS5saW5lO1xuICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcbiAgICB9XG4gICAgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCQxID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBsZW4gLT0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS5mcm9tLmNoO1xuICAgICAgY3VyID0gZm91bmQkMS50by5saW5lO1xuICAgICAgbGVuICs9IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEudG8uY2g7XG4gICAgfVxuICAgIHJldHVybiBsZW5cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRNYXhMaW5lKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgZC5tYXhMaW5lID0gZ2V0TGluZShkb2MsIGRvYy5maXJzdCk7XG4gICAgZC5tYXhMaW5lTGVuZ3RoID0gbGluZUxlbmd0aChkLm1heExpbmUpO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgZC5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTElORSBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXG4gIC8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cbiAgdmFyIExpbmUgPSBmdW5jdGlvbih0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcbiAgICB0aGlzLmhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQodGhpcykgOiAxO1xuICB9O1xuXG4gIExpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVObyh0aGlzKSB9O1xuICBldmVudE1peGluKExpbmUpO1xuXG4gIC8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XG4gIC8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXG4gIC8vIGxpbmUncyBoZWlnaHQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgbGluZS50ZXh0ID0gdGV4dDtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgeyBsaW5lLm9yZGVyID0gbnVsbDsgfVxuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcbiAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDE7XG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7IH1cbiAgfVxuXG4gIC8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXG4gIGZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcbiAgICBsaW5lLnBhcmVudCA9IG51bGw7XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGEgc3R5bGUgYXMgcmV0dXJuZWQgYnkgYSBtb2RlIChlaXRoZXIgbnVsbCwgb3IgYSBzdHJpbmdcbiAgLy8gY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdHlsZXMpIHRvIGEgQ1NTIHN0eWxlLiBUaGlzIGlzIGNhY2hlZCxcbiAgLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXG4gIHZhciBzdHlsZVRvQ2xhc3NDYWNoZSA9IHt9LCBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlID0ge307XG4gIGZ1bmN0aW9uIGludGVycHJldFRva2VuU3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN0eWxlIHx8IC9eXFxzKiQvLnRlc3Qoc3R5bGUpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZTtcbiAgICByZXR1cm4gY2FjaGVbc3R5bGVdIHx8XG4gICAgICAoY2FjaGVbc3R5bGVdID0gc3R5bGUucmVwbGFjZSgvXFxTKy9nLCBcImNtLSQmXCIpKVxuICB9XG5cbiAgLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xuICAvLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XG4gIC8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXG4gIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cbiAgZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxuICAgIC8vIGlzIG5lZWRlZCBvbiBXZWJraXQgdG8gYmUgYWJsZSB0byBnZXQgbGluZS1sZXZlbCBib3VuZGluZ1xuICAgIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXG4gICAgdmFyIGNvbnRlbnQgPSBlbHRQKFwic3BhblwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcInBhZGRpbmctcmlnaHQ6IC4xcHhcIiA6IG51bGwpO1xuICAgIHZhciBidWlsZGVyID0ge3ByZTogZWx0UChcInByZVwiLCBbY29udGVudF0sIFwiQ29kZU1pcnJvci1saW5lXCIpLCBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgIGNvbDogMCwgcG9zOiAwLCBjbTogY20sXG4gICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07XG4gICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyID0gKHZvaWQgMCk7XG4gICAgICBidWlsZGVyLnBvcyA9IDA7XG4gICAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcbiAgICAgIC8vIE9wdGlvbmFsbHkgd2lyZSBpbiBzb21lIGhhY2tzIGludG8gdGhlIHRva2VuLXJlbmRlcmluZ1xuICAgICAgLy8gYWxnb3JpdGhtLCB0byBkZWFsIHdpdGggYnJvd3NlciBxdWlya3MuXG4gICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbikpKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcik7IH1cbiAgICAgIGJ1aWxkZXIubWFwID0gW107XG4gICAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XG4gICAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSk7XG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXG4gICAgICAgICAgeyBidWlsZGVyLmJnQ2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzLCBidWlsZGVyLmJnQ2xhc3MgfHwgXCJcIik7IH1cbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxuICAgICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxuICAgICAgICB7IGJ1aWxkZXIubWFwLnB1c2goMCwgMCwgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHplcm9XaWR0aEVsZW1lbnQoY20uZGlzcGxheS5tZWFzdXJlKSkpOyB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcDtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKVxuICAgICAgICA7KGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXG4gICAgaWYgKHdlYmtpdCkge1xuICAgICAgdmFyIGxhc3QgPSBidWlsZGVyLmNvbnRlbnQubGFzdENoaWxkO1xuICAgICAgaWYgKC9cXGJjbS10YWJcXGIvLnRlc3QobGFzdC5jbGFzc05hbWUpIHx8IChsYXN0LnF1ZXJ5U2VsZWN0b3IgJiYgbGFzdC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSkpXG4gICAgICAgIHsgYnVpbGRlci5jb250ZW50LmNsYXNzTmFtZSA9IFwiY20tdGFiLXdyYXAtaGFja1wiOyB9XG4gICAgfVxuXG4gICAgc2lnbmFsKGNtLCBcInJlbmRlckxpbmVcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKTtcbiAgICBpZiAoYnVpbGRlci5wcmUuY2xhc3NOYW1lKVxuICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXCJcIik7IH1cblxuICAgIHJldHVybiBidWlsZGVyXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xuICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDIyXCIsIFwiY20taW52YWxpZGNoYXJcIik7XG4gICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICB0b2tlbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRva2VuLnRpdGxlKTtcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuXG4gIC8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXG4gIC8vIHRoZSBsaW5lIG1hcC4gVGFrZXMgY2FyZSB0byByZW5kZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIHNlcGFyYXRlbHkuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW4oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRleHQpIHsgcmV0dXJuIH1cbiAgICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gc3BsaXRTcGFjZXModGV4dCwgYnVpbGRlci50cmFpbGluZ1NwYWNlKSA6IHRleHQ7XG4gICAgdmFyIHNwZWNpYWwgPSBidWlsZGVyLmNtLnN0YXRlLnNwZWNpYWxDaGFycywgbXVzdFdyYXAgPSBmYWxzZTtcbiAgICB2YXIgY29udGVudDtcbiAgICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xuICAgICAgYnVpbGRlci5jb2wgKz0gdGV4dC5sZW5ndGg7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xuICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyB0ZXh0Lmxlbmd0aCwgY29udGVudCk7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgbXVzdFdyYXAgPSB0cnVlOyB9XG4gICAgICBidWlsZGVyLnBvcyArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3M7XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dF0pKTsgfVxuICAgICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7IH1cbiAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dCk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gc2tpcHBlZDtcbiAgICAgICAgICBidWlsZGVyLnBvcyArPSBza2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbSkgeyBicmVhayB9XG4gICAgICAgIHBvcyArPSBza2lwcGVkICsgMTtcbiAgICAgICAgdmFyIHR4dCQxID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChtWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICB2YXIgdGFiU2l6ZSA9IGJ1aWxkZXIuY20ub3B0aW9ucy50YWJTaXplLCB0YWJXaWR0aCA9IHRhYlNpemUgLSBidWlsZGVyLmNvbCAlIHRhYlNpemU7XG4gICAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcImNtLXRhYlwiKSk7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXFx0XCIpO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHRhYldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKG1bMF0gPT0gXCJcXHJcIiB8fCBtWzBdID09IFwiXFxuXCIpIHtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBtWzBdID09IFwiXFxyXCIgPyBcIlxcdTI0MGRcIiA6IFwiXFx1MjQyNFwiLCBcImNtLWludmFsaWRjaGFyXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dCQxXSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpOyB9XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKTtcbiAgICAgICAgYnVpbGRlci5wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyO1xuICAgIGlmIChzdHlsZSB8fCBzdGFydFN0eWxlIHx8IGVuZFN0eWxlIHx8IG11c3RXcmFwIHx8IGNzcyB8fCBhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXCJcIjtcbiAgICAgIGlmIChzdGFydFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlOyB9XG4gICAgICBpZiAoZW5kU3R5bGUpIHsgZnVsbFN0eWxlICs9IGVuZFN0eWxlOyB9XG4gICAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7IGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpICYmIGF0dHIgIT0gXCJzdHlsZVwiICYmIGF0dHIgIT0gXCJjbGFzc1wiKVxuICAgICAgICAgIHsgdG9rZW4uc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJpYnV0ZXNbYXR0cl0pOyB9IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pXG4gICAgfVxuICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuXG4gIC8vIENoYW5nZSBzb21lIHNwYWNlcyB0byBOQlNQIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBjb2xsYXBzaW5nXG4gIC8vIHRyYWlsaW5nIHNwYWNlcyBhdCB0aGUgZW5kIG9mIGEgbGluZSB3aGVuIHJlbmRlcmluZyB0ZXh0IChpc3N1ZSAjMTM2MikuXG4gIGZ1bmN0aW9uIHNwbGl0U3BhY2VzKHRleHQsIHRyYWlsaW5nQmVmb3JlKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cbiAgICB2YXIgc3BhY2VCZWZvcmUgPSB0cmFpbGluZ0JlZm9yZSwgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgaWYgKGNoID09IFwiIFwiICYmIHNwYWNlQmVmb3JlICYmIChpID09IHRleHQubGVuZ3RoIC0gMSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09IDMyKSlcbiAgICAgICAgeyBjaCA9IFwiXFx1MDBhMFwiOyB9XG4gICAgICByZXN1bHQgKz0gY2g7XG4gICAgICBzcGFjZUJlZm9yZSA9IGNoID09IFwiIFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcbiAgLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcIiBjbS1mb3JjZS1ib3JkZXJcIiA6IFwiY20tZm9yY2UtYm9yZGVyXCI7XG4gICAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxuICAgICAgICB2YXIgcGFydCA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgICAgIGlmIChwYXJ0LnRvID4gc3RhcnQgJiYgcGFydC5mcm9tIDw9IHN0YXJ0KSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50byA+PSBlbmQpIHsgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB9XG4gICAgICAgIGlubmVyKGJ1aWxkZXIsIHRleHQuc2xpY2UoMCwgcGFydC50byAtIHN0YXJ0KSwgc3R5bGUsIHN0YXJ0U3R5bGUsIG51bGwsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgIHN0YXJ0U3R5bGUgPSBudWxsO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHBhcnQudG87XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIHNpemUsIG1hcmtlciwgaWdub3JlV2lkZ2V0KSB7XG4gICAgdmFyIHdpZGdldCA9ICFpZ25vcmVXaWRnZXQgJiYgbWFya2VyLndpZGdldE5vZGU7XG4gICAgaWYgKHdpZGdldCkgeyBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNpemUsIHdpZGdldCk7IH1cbiAgICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XG4gICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgeyB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpOyB9XG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsIG1hcmtlci5pZCk7XG4gICAgfVxuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldCk7XG4gICAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcbiAgICB9XG4gICAgYnVpbGRlci5wb3MgKz0gc2l6ZTtcbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcbiAgLy8gYW5kIG1hcmtlZCB0ZXh0IGludG8gYWNjb3VudC5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xuICAgIGlmICghc3BhbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcbiAgICAgICAgeyBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2kkMV0pLCBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpJDErMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYWxsVGV4dC5sZW5ndGgsIHBvcyA9IDAsIGkgPSAxLCB0ZXh0ID0gXCJcIiwgc3R5bGUsIGNzcztcbiAgICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgY29sbGFwc2VkLCBhdHRyaWJ1dGVzO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG4gICAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gY3NzID0gXCJcIjtcbiAgICAgICAgYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIGNvbGxhcHNlZCA9IG51bGw7IG5leHRDaGFuZ2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGZvdW5kQm9va21hcmtzID0gW10sIGVuZFN0eWxlcyA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICBmb3VuZEJvb2ttYXJrcy5wdXNoKG0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xuICAgICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AudG87XG4gICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jbGFzc05hbWUpIHsgc3BhblN0eWxlICs9IFwiIFwiICsgbS5jbGFzc05hbWU7IH1cbiAgICAgICAgICAgIGlmIChtLmNzcykgeyBjc3MgPSAoY3NzID8gY3NzICsgXCI7XCIgOiBcIlwiKSArIG0uY3NzOyB9XG4gICAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7IHNwYW5TdGFydFN0eWxlICs9IFwiIFwiICsgbS5zdGFydFN0eWxlOyB9XG4gICAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSB7IChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50byk7IH1cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHRoZSBvbGQgdGl0bGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL0NvZGVNaXJyb3IvcHVsbC81NjczXG4gICAgICAgICAgICBpZiAobS50aXRsZSkgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSkudGl0bGUgPSBtLnRpdGxlOyB9XG4gICAgICAgICAgICBpZiAobS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgIHsgKGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSkpW2F0dHJdID0gbS5hdHRyaWJ1dGVzW2F0dHJdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcbiAgICAgICAgICAgICAgeyBjb2xsYXBzZWQgPSBzcDsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHlsZXMpIHsgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiQxICs9IDIpXG4gICAgICAgICAgeyBpZiAoZW5kU3R5bGVzW2okMSArIDFdID09IG5leHRDaGFuZ2UpIHsgc3BhbkVuZFN0eWxlICs9IFwiIFwiICsgZW5kU3R5bGVzW2okMV07IH0gfSB9XG5cbiAgICAgICAgaWYgKCFjb2xsYXBzZWQgfHwgY29sbGFwc2VkLmZyb20gPT0gcG9zKSB7IGZvciAodmFyIGokMiA9IDA7IGokMiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqJDIpXG4gICAgICAgICAgeyBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3NbaiQyXSk7IH0gfVxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZC5tYXJrZXIsIGNvbGxhcHNlZC5mcm9tID09IG51bGwpO1xuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gcG9zKSB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPj0gbGVuKSB7IGJyZWFrIH1cblxuICAgICAgdmFyIHVwdG8gPSBNYXRoLm1pbihsZW4sIG5leHRDaGFuZ2UpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHQ7XG4gICAgICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIHRva2VuVGV4dCwgc3R5bGUgPyBzdHlsZSArIHNwYW5TdHlsZSA6IHNwYW5TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUsIHBvcyArIHRva2VuVGV4dC5sZW5ndGggPT0gbmV4dENoYW5nZSA/IHNwYW5FbmRTdHlsZSA6IFwiXCIsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVha31cbiAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgc3BhblN0YXJ0U3R5bGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpKytdKTtcbiAgICAgICAgc3R5bGUgPSBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpKytdLCBidWlsZGVyLmNtLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxuICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxO1xuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cbiAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5XG4gIH1cblxuICB2YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3ApIHtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XG4gICAgICAgIG9wczogW29wXSxcbiAgICAgICAgZGVsYXllZENhbGxiYWNrczogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCkge1xuICAgIC8vIENhbGxzIGRlbGF5ZWQgY2FsbGJhY2tzIGFuZCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyB1bnRpbCBub1xuICAgIC8vIG5ldyBvbmVzIGFwcGVhclxuICAgIHZhciBjYWxsYmFja3MgPSBncm91cC5kZWxheWVkQ2FsbGJhY2tzLCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBjYWxsYmFja3NbaV0uY2FsbChudWxsKTsgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xuICAgICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgICAgICB7IHdoaWxlIChvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCA8IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMubGVuZ3RoKVxuICAgICAgICAgICAgeyBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pOyB9IH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChpIDwgY2FsbGJhY2tzLmxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE9wZXJhdGlvbihvcCwgZW5kQ2IpIHtcbiAgICB2YXIgZ3JvdXAgPSBvcC5vd25zR3JvdXA7XG4gICAgaWYgKCFncm91cCkgeyByZXR1cm4gfVxuXG4gICAgdHJ5IHsgZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCk7IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcbiAgICAgIGVuZENiKGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG5cbiAgLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcbiAgLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xuICAvLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxuICAvLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cbiAgLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXG4gIC8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXG4gIC8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxuICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBhcnIgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3Q7XG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICBsaXN0ID0gb3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrcztcbiAgICB9IGVsc2UgaWYgKG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MpIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdO1xuICAgICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XG4gICAgfVxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgbG9vcCggaSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKSB7XG4gICAgdmFyIGRlbGF5ZWQgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCk7IH1cbiAgfVxuXG4gIC8vIFdoZW4gYW4gYXNwZWN0IG9mIGEgbGluZSBjaGFuZ2VzLCBhIHN0cmluZyBpcyBhZGRlZCB0b1xuICAvLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xuICAvLyBET00gc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XG4gICAgICBpZiAodHlwZSA9PSBcInRleHRcIikgeyB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImNsYXNzXCIpIHsgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIndpZGdldFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7IH1cbiAgICB9XG4gICAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvLyBMaW5lcyB3aXRoIGd1dHRlciBlbGVtZW50cywgd2lkZ2V0cyBvciBhIGJhY2tncm91bmQgY2xhc3MgbmVlZCB0b1xuICAvLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KSB7XG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZVZpZXcudGV4dCkge1xuICAgICAgbGluZVZpZXcubm9kZSA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXG4gICAgICAgIHsgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTsgfVxuICAgICAgbGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBsaW5lVmlldy5ub2RlLnN0eWxlLnpJbmRleCA9IDI7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICBpZiAoY2xzKSB7IGNscyArPSBcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCI7IH1cbiAgICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xuICAgICAgaWYgKGNscykgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNsczsgfVxuICAgICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGw7IH1cbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kID0gd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuYmFja2dyb3VuZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcHBlciBhcm91bmQgYnVpbGRMaW5lQ29udGVudCB3aGljaCB3aWxsIHJldXNlIHRoZSBzdHJ1Y3R1cmVcbiAgLy8gaW4gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkIHdoZW4gcG9zc2libGUuXG4gIGZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBleHQubGluZSA9PSBsaW5lVmlldy5saW5lKSB7XG4gICAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlO1xuICAgICAgcmV0dXJuIGV4dC5idWlsdFxuICAgIH1cbiAgICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXG4gIH1cblxuICAvLyBSZWRyYXcgdGhlIGxpbmUncyB0ZXh0LiBJbnRlcmFjdHMgd2l0aCB0aGUgYmFja2dyb3VuZCBhbmQgdGV4dFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcbiAgLy8gY2xhc3Nlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgeyBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlOyB9XG4gICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MgIT0gbGluZVZpZXcuYmdDbGFzcyB8fCBidWlsdC50ZXh0Q2xhc3MgIT0gbGluZVZpZXcudGV4dENsYXNzKSB7XG4gICAgICBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcbiAgICAgIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcbiAgICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gY2xzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldykge1xuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxuICAgICAgeyBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7IH1cbiAgICBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpXG4gICAgICB7IGxpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lID0gXCJcIjsgfVxuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xuICAgICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgd3JhcC5pbnNlcnRCZWZvcmUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCwgbGluZVZpZXcudGV4dCk7XG4gICAgfVxuICAgIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzIHx8IG1hcmtlcnMpIHtcbiAgICAgIHZhciB3cmFwJDEgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgZ3V0dGVyV3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoZ3V0dGVyV3JhcCk7XG4gICAgICB3cmFwJDEuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpO1xuICAgICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpXG4gICAgICAgIHsgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXCIgXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzOyB9XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSlcbiAgICAgICAgeyBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBlbHQoXCJkaXZcIiwgbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTiksXG4gICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFxuICAgICAgICAgICAgICAoXCJsZWZ0OiBcIiArIChkaW1zLmd1dHRlckxlZnRbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSArIFwicHg7IHdpZHRoOiBcIiArIChjbS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoKSArIFwicHhcIikpKTsgfVxuICAgICAgaWYgKG1hcmtlcnMpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIHZhciBpZCA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3Nba10uY2xhc3NOYW1lLCBmb3VuZCA9IG1hcmtlcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hcmtlcnNbaWRdO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgeyBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZm91bmRdLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtpZF0pICsgXCJweDsgd2lkdGg6IFwiICsgKGRpbXMuZ3V0dGVyV2lkdGhbaWRdKSArIFwicHhcIikpKTsgfVxuICAgICAgfSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKGxpbmVWaWV3LmFsaWduYWJsZSkgeyBsaW5lVmlldy5hbGlnbmFibGUgPSBudWxsOyB9XG4gICAgdmFyIGlzV2lkZ2V0ID0gY2xhc3NUZXN0KFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIpO1xuICAgIGZvciAodmFyIG5vZGUgPSBsaW5lVmlldy5ub2RlLmZpcnN0Q2hpbGQsIG5leHQgPSAodm9pZCAwKTsgbm9kZTsgbm9kZSA9IG5leHQpIHtcbiAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKGlzV2lkZ2V0LnRlc3Qobm9kZS5jbGFzc05hbWUpKSB7IGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7IH1cbiAgICB9XG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgbGluZSdzIERPTSByZXByZXNlbnRhdGlvbiBmcm9tIHNjcmF0Y2hcbiAgZnVuY3Rpb24gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcbiAgICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcykgeyBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzczsgfVxuICAgIGlmIChidWlsdC50ZXh0Q2xhc3MpIHsgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzOyB9XG5cbiAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xuICAgIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcbiAgICByZXR1cm4gbGluZVZpZXcubm9kZVxuICB9XG5cbiAgLy8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxuICAvLyBjb2xsYXBzZWQgc3BhbnMpLiBUaGUgd2lkZ2V0cyBmb3IgYWxsIG9mIHRoZW0gbmVlZCB0byBiZSBkcmF3bi5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LmxpbmUsIGxpbmVWaWV3LCBkaW1zLCB0cnVlKTtcbiAgICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICB7IGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpOyB9IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lLCBsaW5lVmlldywgZGltcywgYWxsb3dBYm92ZSkge1xuICAgIGlmICghbGluZS53aWRnZXRzKSB7IHJldHVybiB9XG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpIDwgd3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3aWRnZXQgPSB3c1tpXSwgbm9kZSA9IGVsdChcImRpdlwiLCBbd2lkZ2V0Lm5vZGVdLCBcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiICsgKHdpZGdldC5jbGFzc05hbWUgPyBcIiBcIiArIHdpZGdldC5jbGFzc05hbWUgOiBcIlwiKSk7XG4gICAgICBpZiAoIXdpZGdldC5oYW5kbGVNb3VzZUV2ZW50cykgeyBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpOyB9XG4gICAgICBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcyk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpXG4gICAgICAgIHsgd3JhcC5pbnNlcnRCZWZvcmUobm9kZSwgbGluZVZpZXcuZ3V0dGVyIHx8IGxpbmVWaWV3LnRleHQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgd3JhcC5hcHBlbmRDaGlsZChub2RlKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIod2lkZ2V0LCBcInJlZHJhd1wiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcykge1xuICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XG4gIChsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKTtcbiAgICAgIHZhciB3aWR0aCA9IGRpbXMud3JhcHBlcldpZHRoO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFwicHhcIjtcbiAgICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nTGVmdCA9IGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9XG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA1O1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgeyBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xuICAgIGlmICh3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIHdpZGdldC5oZWlnaHQgfVxuICAgIHZhciBjbSA9IHdpZGdldC5kb2MuY207XG4gICAgaWYgKCFjbSkgeyByZXR1cm4gMCB9XG4gICAgaWYgKCFjb250YWlucyhkb2N1bWVudC5ib2R5LCB3aWRnZXQubm9kZSkpIHtcbiAgICAgIHZhciBwYXJlbnRTdHlsZSA9IFwicG9zaXRpb246IHJlbGF0aXZlO1wiO1xuICAgICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcbiAgICAgICAgeyBwYXJlbnRTdHlsZSArPSBcIm1hcmdpbi1sZWZ0OiAtXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiOyB9XG4gICAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbClcbiAgICAgICAgeyBwYXJlbnRTdHlsZSArPSBcIndpZHRoOiBcIiArIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIG51bGwsIHBhcmVudFN0eWxlKSk7XG4gICAgfVxuICAgIHJldHVybiB3aWRnZXQuaGVpZ2h0ID0gd2lkZ2V0Lm5vZGUucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHRcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIHdoZW4gdGhlIGdpdmVuIG1vdXNlIGV2ZW50IGhhcHBlbmVkIGluIGEgd2lkZ2V0XG4gIGZ1bmN0aW9uIGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkge1xuICAgIGZvciAodmFyIG4gPSBlX3RhcmdldChlKTsgbiAhPSBkaXNwbGF5LndyYXBwZXI7IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmICghbiB8fCAobi5ub2RlVHlwZSA9PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKSA9PSBcInRydWVcIikgfHxcbiAgICAgICAgICAobi5wYXJlbnROb2RlID09IGRpc3BsYXkuc2l6ZXIgJiYgbiAhPSBkaXNwbGF5Lm1vdmVyKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gUE9TSVRJT04gTUVBU1VSRU1FTlRcblxuICBmdW5jdGlvbiBwYWRkaW5nVG9wKGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wfVxuICBmdW5jdGlvbiBwYWRkaW5nVmVydChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0fVxuICBmdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkUGFkZGluZ0gpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggfVxuICAgIHZhciBlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJwcmVcIiwgXCJ4XCIsIFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIikpO1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcbiAgICB2YXIgZGF0YSA9IHtsZWZ0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCksIHJpZ2h0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpfTtcbiAgICBpZiAoIWlzTmFOKGRhdGEubGVmdCkgJiYgIWlzTmFOKGRhdGEucmlnaHQpKSB7IGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhOyB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbEdhcChjbSkgeyByZXR1cm4gc2Nyb2xsZXJHYXAgLSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoIH1cbiAgZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aFxuICB9XG4gIGZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQgLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJIZWlnaHRcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGUgbGluZVZpZXcud3JhcHBpbmcuaGVpZ2h0cyBhcnJheSBpcyBwb3B1bGF0ZWQuIFRoaXMgaXNcbiAgLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxuICAvLyBsaW5lLiBXaGVuIGxpbmVXcmFwcGluZyBpcyBvbiwgdGhlcmUgbWlnaHQgYmUgbW9yZSB0aGFuIG9uZVxuICAvLyBoZWlnaHQuXG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xuICAgIHZhciB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIHZhciBjdXJXaWR0aCA9IHdyYXBwaW5nICYmIGRpc3BsYXlXaWR0aChjbSk7XG4gICAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xuICAgICAgdmFyIGhlaWdodHMgPSBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBbXTtcbiAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGg7XG4gICAgICAgIHZhciByZWN0cyA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBjdXIgPSByZWN0c1tpXSwgbmV4dCA9IHJlY3RzW2kgKyAxXTtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VyLmJvdHRvbSAtIG5leHQuYm90dG9tKSA+IDIpXG4gICAgICAgICAgICB7IGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxuICAvLyBtZWFzdXJlbWVudCBjYWNoZSBmb3IgdGhlIGdpdmVuIGxpbmUgbnVtYmVyLiAoQSBsaW5lIHZpZXcgbWlnaHRcbiAgLy8gY29udGFpbiBtdWx0aXBsZSBsaW5lcyB3aGVuIGNvbGxhcHNlZCByYW5nZXMgYXJlIHByZXNlbnQuKVxuICBmdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsIGxpbmUsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUgPT0gbGluZSlcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZX0gfVxuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgaWYgKGxpbmVWaWV3LnJlc3RbaV0gPT0gbGluZSlcbiAgICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXX0gfSB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSQxKyspXG4gICAgICAgIHsgaWYgKGxpbmVObyhsaW5lVmlldy5yZXN0W2kkMV0pID4gbGluZU4pXG4gICAgICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2kkMV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpJDFdLCBiZWZvcmU6IHRydWV9IH0gfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciBhIGxpbmUgaW50byB0aGUgaGlkZGVuIG5vZGUgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkLiBVc2VkXG4gIC8vIHdoZW4gbWVhc3VyZW1lbnQgaXMgbmVlZGVkIGZvciBhIGxpbmUgdGhhdCdzIG5vdCBpbiB0aGUgdmlld3BvcnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpIHtcbiAgICBsaW5lID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBsaW5lLCBsaW5lTik7XG4gICAgdmlldy5saW5lTiA9IGxpbmVOO1xuICAgIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KTtcbiAgICB2aWV3LnRleHQgPSBidWlsdC5wcmU7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSwgYnVpbHQucHJlKTtcbiAgICByZXR1cm4gdmlld1xuICB9XG5cbiAgLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxuICAvLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xuICAgIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcylcbiAgfVxuXG4gIC8vIEZpbmQgYSBsaW5lIHZpZXcgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyByZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmVOKV0gfVxuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lTiA+PSBleHQubGluZU4gJiYgbGluZU4gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgIHsgcmV0dXJuIGV4dCB9XG4gIH1cblxuICAvLyBNZWFzdXJlbWVudCBjYW4gYmUgc3BsaXQgaW4gdHdvIHN0ZXBzLCB0aGUgc2V0LXVwIHdvcmsgdGhhdFxuICAvLyBhcHBsaWVzIHRvIHRoZSB3aG9sZSBsaW5lLCBhbmQgdGhlIG1lYXN1cmVtZW50IG9mIHRoZSBhY3R1YWxcbiAgLy8gY2hhcmFjdGVyLiBGdW5jdGlvbnMgbGlrZSBjb29yZHNDaGFyLCB0aGF0IG5lZWQgdG8gZG8gYSBsb3Qgb2ZcbiAgLy8gbWVhc3VyZW1lbnRzIGluIGEgcm93LCBjYW4gdGh1cyBlbnN1cmUgdGhhdCB0aGUgc2V0LXVwIHdvcmsgaXNcbiAgLy8gb25seSBkb25lIG9uY2UuXG4gIGZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgIGlmICh2aWV3ICYmICF2aWV3LnRleHQpIHtcbiAgICAgIHZpZXcgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpIHtcbiAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpO1xuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZpZXcpXG4gICAgICB7IHZpZXcgPSB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKTsgfVxuXG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBsaW5lLCB2aWV3OiB2aWV3LCByZWN0OiBudWxsLFxuICAgICAgbWFwOiBpbmZvLm1hcCwgY2FjaGU6IGluZm8uY2FjaGUsIGJlZm9yZTogaW5mby5iZWZvcmUsXG4gICAgICBoYXNIZWlnaHRzOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmVuIGEgcHJlcGFyZWQgbWVhc3VyZW1lbnQgb2JqZWN0LCBtZWFzdXJlcyB0aGUgcG9zaXRpb24gb2YgYW5cbiAgLy8gYWN0dWFsIGNoYXJhY3RlciAob3IgZmV0Y2hlcyBpdCBmcm9tIHRoZSBjYWNoZSkuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XG4gICAgaWYgKHByZXBhcmVkLmJlZm9yZSkgeyBjaCA9IC0xOyB9XG4gICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXCJcIiksIGZvdW5kO1xuICAgIGlmIChwcmVwYXJlZC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcHJlcGFyZWQucmVjdClcbiAgICAgICAgeyBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICBpZiAoIXByZXBhcmVkLmhhc0hlaWdodHMpIHtcbiAgICAgICAgZW5zdXJlTGluZUhlaWdodHMoY20sIHByZXBhcmVkLnZpZXcsIHByZXBhcmVkLnJlY3QpO1xuICAgICAgICBwcmVwYXJlZC5oYXNIZWlnaHRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvdW5kID0gbWVhc3VyZUNoYXJJbm5lcihjbSwgcHJlcGFyZWQsIGNoLCBiaWFzKTtcbiAgICAgIGlmICghZm91bmQuYm9ndXMpIHsgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kOyB9XG4gICAgfVxuICAgIHJldHVybiB7bGVmdDogZm91bmQubGVmdCwgcmlnaHQ6IGZvdW5kLnJpZ2h0LFxuICAgICAgICAgICAgdG9wOiB2YXJIZWlnaHQgPyBmb3VuZC5ydG9wIDogZm91bmQudG9wLFxuICAgICAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tfVxuICB9XG5cbiAgdmFyIG51bGxSZWN0ID0ge2xlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMH07XG5cbiAgZnVuY3Rpb24gbm9kZUFuZE9mZnNldEluTGluZU1hcChtYXAsIGNoLCBiaWFzKSB7XG4gICAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmQ7XG4gICAgLy8gRmlyc3QsIHNlYXJjaCB0aGUgbGluZSBtYXAgZm9yIHRoZSB0ZXh0IG5vZGUgY29ycmVzcG9uZGluZyB0byxcbiAgICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgbVN0YXJ0ID0gbWFwW2ldO1xuICAgICAgbUVuZCA9IG1hcFtpICsgMV07XG4gICAgICBpZiAoY2ggPCBtU3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSAwOyBlbmQgPSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgfSBlbHNlIGlmIChjaCA8IG1FbmQpIHtcbiAgICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcbiAgICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpID09IG1hcC5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwW2kgKyAzXSA+IGNoKSB7XG4gICAgICAgIGVuZCA9IG1FbmQgLSBtU3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcbiAgICAgICAgaWYgKGNoID49IG1FbmQpIHsgY29sbGFwc2UgPSBcInJpZ2h0XCI7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBtYXBbaSArIDJdO1xuICAgICAgICBpZiAobVN0YXJ0ID09IG1FbmQgJiYgYmlhcyA9PSAobm9kZS5pbnNlcnRMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpKVxuICAgICAgICAgIHsgY29sbGFwc2UgPSBiaWFzOyB9XG4gICAgICAgIGlmIChiaWFzID09IFwibGVmdFwiICYmIHN0YXJ0ID09IDApXG4gICAgICAgICAgeyB3aGlsZSAoaSAmJiBtYXBbaSAtIDJdID09IG1hcFtpIC0gM10gJiYgbWFwW2kgLSAxXS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICBub2RlID0gbWFwWyhpIC09IDMpICsgMl07XG4gICAgICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgICAgIH0gfVxuICAgICAgICBpZiAoYmlhcyA9PSBcInJpZ2h0XCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcbiAgICAgICAgICB7IHdoaWxlIChpIDwgbWFwLmxlbmd0aCAtIDMgJiYgbWFwW2kgKyAzXSA9PSBtYXBbaSArIDRdICYmICFtYXBbaSArIDVdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgKz0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgICAgIH0gfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZWZ1bFJlY3QocmVjdHMsIGJpYXMpIHtcbiAgICB2YXIgcmVjdCA9IG51bGxSZWN0O1xuICAgIGlmIChiaWFzID09IFwibGVmdFwiKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2ldKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxuICAgIH0gfSBlbHNlIHsgZm9yICh2YXIgaSQxID0gcmVjdHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICBpZiAoKHJlY3QgPSByZWN0c1tpJDFdKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxuICAgIH0gfVxuICAgIHJldHVybiByZWN0XG4gIH1cblxuICBmdW5jdGlvbiBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgcGxhY2UgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKHByZXBhcmVkLm1hcCwgY2gsIGJpYXMpO1xuICAgIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlO1xuXG4gICAgdmFyIHJlY3Q7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykgeyAvLyBJZiBpdCBpcyBhIHRleHQgbm9kZSwgdXNlIGEgcmFuZ2UgdG8gcmV0cmlldmUgdGhlIGNvb3JkaW5hdGVzLlxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgNDsgaSQxKyspIHsgLy8gUmV0cnkgYSBtYXhpbXVtIG9mIDQgdGltZXMgd2hlbiBub25zZW5zZSByZWN0YW5nbGVzIGFyZSByZXR1cm5lZFxuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIHN0YXJ0KSkpIHsgLS1zdGFydDsgfVxuICAgICAgICB3aGlsZSAocGxhY2UuY292ZXJTdGFydCArIGVuZCA8IHBsYWNlLmNvdmVyRW5kICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQpKSkgeyArK2VuZDsgfVxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KVxuICAgICAgICAgIHsgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZWN0ID0gZ2V0VXNlZnVsUmVjdChyYW5nZShub2RlLCBzdGFydCwgZW5kKS5nZXRDbGllbnRSZWN0cygpLCBiaWFzKTsgfVxuICAgICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkgeyBicmVhayB9XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IHN0YXJ0IC0gMTtcbiAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IHJlY3QgPSBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKGNtLmRpc3BsYXkubWVhc3VyZSwgcmVjdCk7IH1cbiAgICB9IGVsc2UgeyAvLyBJZiBpdCBpcyBhIHdpZGdldCwgc2ltcGx5IGdldCB0aGUgYm94IGZvciB0aGUgd2hvbGUgd2lkZ2V0LlxuICAgICAgaWYgKHN0YXJ0ID4gMCkgeyBjb2xsYXBzZSA9IGJpYXMgPSBcInJpZ2h0XCI7IH1cbiAgICAgIHZhciByZWN0cztcbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAocmVjdHMgPSBub2RlLmdldENsaWVudFJlY3RzKCkpLmxlbmd0aCA+IDEpXG4gICAgICAgIHsgcmVjdCA9IHJlY3RzW2JpYXMgPT0gXCJyaWdodFwiID8gcmVjdHMubGVuZ3RoIC0gMSA6IDBdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICB9XG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmICFzdGFydCAmJiAoIXJlY3QgfHwgIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkpIHtcbiAgICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xuICAgICAgaWYgKHJTcGFuKVxuICAgICAgICB7IHJlY3QgPSB7bGVmdDogclNwYW4ubGVmdCwgcmlnaHQ6IHJTcGFuLmxlZnQgKyBjaGFyV2lkdGgoY20uZGlzcGxheSksIHRvcDogclNwYW4udG9wLCBib3R0b206IHJTcGFuLmJvdHRvbX07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbnVsbFJlY3Q7IH1cbiAgICB9XG5cbiAgICB2YXIgcnRvcCA9IHJlY3QudG9wIC0gcHJlcGFyZWQucmVjdC50b3AsIHJib3QgPSByZWN0LmJvdHRvbSAtIHByZXBhcmVkLnJlY3QudG9wO1xuICAgIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMjtcbiAgICB2YXIgaGVpZ2h0cyA9IHByZXBhcmVkLnZpZXcubWVhc3VyZS5oZWlnaHRzO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgeyBpZiAobWlkIDwgaGVpZ2h0c1tpXSkgeyBicmVhayB9IH1cbiAgICB2YXIgdG9wID0gaSA/IGhlaWdodHNbaSAtIDFdIDogMCwgYm90ID0gaGVpZ2h0c1tpXTtcbiAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogdG9wLCBib3R0b206IGJvdH07XG4gICAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHsgcmVzdWx0LmJvZ3VzID0gdHJ1ZTsgfVxuICAgIGlmICghY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKSB7IHJlc3VsdC5ydG9wID0gcnRvcDsgcmVzdWx0LnJib3R0b20gPSByYm90OyB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBwcm9ibGVtIHdpdGggYm91bmRpbmcgY2xpZW50IHJlY3RzIG9uIHJhbmdlcyBiZWluZ1xuICAvLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XG4gICAgaWYgKCF3aW5kb3cuc2NyZWVuIHx8IHNjcmVlbi5sb2dpY2FsWERQSSA9PSBudWxsIHx8XG4gICAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXG4gICAgICB7IHJldHVybiByZWN0IH1cbiAgICB2YXIgc2NhbGVYID0gc2NyZWVuLmxvZ2ljYWxYRFBJIC8gc2NyZWVuLmRldmljZVhEUEk7XG4gICAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xuICAgIHJldHVybiB7bGVmdDogcmVjdC5sZWZ0ICogc2NhbGVYLCByaWdodDogcmVjdC5yaWdodCAqIHNjYWxlWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGxpbmVWaWV3KSB7XG4gICAgaWYgKGxpbmVWaWV3Lm1lYXN1cmUpIHtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IG51bGw7XG4gICAgICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0gPSB7fTsgfSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xuICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbDtcbiAgICByZW1vdmVDaGlsZHJlbihjbS5kaXNwbGF5LmxpbmVNZWFzdXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKylcbiAgICAgIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNhY2hlcyhjbSkge1xuICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pO1xuICAgIGNtLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gY20uZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gY20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTsgfVxuICAgIGNtLmRpc3BsYXkubGluZU51bUNoYXJzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxYKCkge1xuICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ4OTIwNlxuICAgIC8vIHdoaWNoIGNhdXNlcyBwYWdlX09mZnNldCBhbmQgYm91bmRpbmcgY2xpZW50IHJlY3RzIHRvIHVzZVxuICAgIC8vIGRpZmZlcmVudCByZWZlcmVuY2Ugdmlld3BvcnRzIGFuZCBpbnZhbGlkYXRlIG91ciBjYWxjdWxhdGlvbnMuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7IHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luTGVmdCkpIH1cbiAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdFxuICB9XG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCkge1xuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCkgeyByZXR1cm4gLShkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luVG9wKSkgfVxuICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3BcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpZGdldFRvcEhlaWdodChsaW5lT2JqKSB7XG4gICAgdmFyIHJlZiA9IHZpc3VhbExpbmUobGluZU9iaik7XG4gICAgdmFyIHdpZGdldHMgPSByZWYud2lkZ2V0cztcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBpZiAod2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyArK2kpIHsgaWYgKHdpZGdldHNbaV0uYWJvdmUpXG4gICAgICB7IGhlaWdodCArPSB3aWRnZXRIZWlnaHQod2lkZ2V0c1tpXSk7IH0gfSB9XG4gICAgcmV0dXJuIGhlaWdodFxuICB9XG5cbiAgLy8gQ29udmVydHMgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggZnJvbSBsaW5lLWxvY2FsXG4gIC8vIGNvb3JkaW5hdGVzIGludG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS4gQ29udGV4dCBtYXkgYmUgb25lIG9mXG4gIC8vIFwibGluZVwiLCBcImRpdlwiIChkaXNwbGF5LmxpbmVEaXYpLCBcImxvY2FsXCIuL251bGwgKGVkaXRvciksIFwid2luZG93XCIsXG4gIC8vIG9yIFwicGFnZVwiLlxuICBmdW5jdGlvbiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIHJlY3QsIGNvbnRleHQsIGluY2x1ZGVXaWRnZXRzKSB7XG4gICAgaWYgKCFpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgdmFyIGhlaWdodCA9IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICAgIHJlY3QudG9wICs9IGhlaWdodDsgcmVjdC5ib3R0b20gKz0gaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PSBcImxpbmVcIikgeyByZXR1cm4gcmVjdCB9XG4gICAgaWYgKCFjb250ZXh0KSB7IGNvbnRleHQgPSBcImxvY2FsXCI7IH1cbiAgICB2YXIgeU9mZiA9IGhlaWdodEF0TGluZShsaW5lT2JqKTtcbiAgICBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIpIHsgeU9mZiArPSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpOyB9XG4gICAgZWxzZSB7IHlPZmYgLT0gY20uZGlzcGxheS52aWV3T2Zmc2V0OyB9XG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIgfHwgY29udGV4dCA9PSBcIndpbmRvd1wiKSB7XG4gICAgICB2YXIgbE9mZiA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgeU9mZiArPSBsT2ZmLnRvcCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFkoKSk7XG4gICAgICB2YXIgeE9mZiA9IGxPZmYubGVmdCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFgoKSk7XG4gICAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmO1xuICAgIH1cbiAgICByZWN0LnRvcCArPSB5T2ZmOyByZWN0LmJvdHRvbSArPSB5T2ZmO1xuICAgIHJldHVybiByZWN0XG4gIH1cblxuICAvLyBDb3ZlcnRzIGEgYm94IGZyb20gXCJkaXZcIiBjb29yZHMgdG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS5cbiAgLy8gQ29udGV4dCBtYXkgYmUgXCJ3aW5kb3dcIiwgXCJwYWdlXCIsIFwiZGl2XCIsIG9yIFwibG9jYWxcIi4vbnVsbC5cbiAgZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PSBcImRpdlwiKSB7IHJldHVybiBjb29yZHMgfVxuICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XG4gICAgLy8gRmlyc3QgbW92ZSBpbnRvIFwicGFnZVwiIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKTtcbiAgICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIgfHwgIWNvbnRleHQpIHtcbiAgICAgIHZhciBsb2NhbEJveCA9IGNtLmRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZWZ0ICs9IGxvY2FsQm94LmxlZnQ7XG4gICAgICB0b3AgKz0gbG9jYWxCb3gudG9wO1xuICAgIH1cblxuICAgIHZhciBsaW5lU3BhY2VCb3ggPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQgLSBsaW5lU3BhY2VCb3gubGVmdCwgdG9wOiB0b3AgLSBsaW5lU3BhY2VCb3gudG9wfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBiaWFzKSB7XG4gICAgaWYgKCFsaW5lT2JqKSB7IGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpOyB9XG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXIoY20sIGxpbmVPYmosIHBvcy5jaCwgYmlhcyksIGNvbnRleHQpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cbiAgLy8gJ290aGVyJyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kYXJ5IGN1cnNvclxuICAvLyBvbiBhIGJpZGkgYm91bmRhcnkuXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImJlZm9yZVwiKSBpcyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZSBhcyBgY2hhciAtIDFgXG4gIC8vIGFuZCBhZnRlciBgY2hhciAtIDFgIGluIHdyaXRpbmcgb3JkZXIgb2YgYGNoYXIgLSAxYFxuICAvLyBBIGN1cnNvciBQb3MobGluZSwgY2hhciwgXCJhZnRlclwiKSBpcyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZSBhcyBgY2hhcmBcbiAgLy8gYW5kIGJlZm9yZSBgY2hhcmAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhcmBcbiAgLy8gRXhhbXBsZXMgKHVwcGVyLWNhc2UgbGV0dGVycyBhcmUgUlRMLCBsb3dlci1jYXNlIGFyZSBMVFIpOlxuICAvLyAgICAgUG9zKDAsIDEsIC4uLilcbiAgLy8gICAgIGJlZm9yZSAgIGFmdGVyXG4gIC8vIGFiICAgICBhfGIgICAgIGF8YlxuICAvLyBhQiAgICAgYXxCICAgICBhQnxcbiAgLy8gQWIgICAgIHxBYiAgICAgQXxiXG4gIC8vIEFCICAgICBCfEEgICAgIEJ8QVxuICAvLyBFdmVyeSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gYSBsaW5lIGlzIGNvbnNpZGVyZWQgdG8gc3RpY2tcbiAgLy8gdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9uIHRoZSBsaW5lLlxuICBmdW5jdGlvbiBjdXJzb3JDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB2YXJIZWlnaHQpIHtcbiAgICBsaW5lT2JqID0gbGluZU9iaiB8fCBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xuICAgIGlmICghcHJlcGFyZWRNZWFzdXJlKSB7IHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7IH1cbiAgICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XG4gICAgICB2YXIgbSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIHJpZ2h0ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIsIHZhckhlaWdodCk7XG4gICAgICBpZiAocmlnaHQpIHsgbS5sZWZ0ID0gbS5yaWdodDsgfSBlbHNlIHsgbS5yaWdodCA9IG0ubGVmdDsgfVxuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbSwgY29udGV4dClcbiAgICB9XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgY20uZG9jLmRpcmVjdGlvbiksIGNoID0gcG9zLmNoLCBzdGlja3kgPSBwb3Muc3RpY2t5O1xuICAgIGlmIChjaCA+PSBsaW5lT2JqLnRleHQubGVuZ3RoKSB7XG4gICAgICBjaCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICBzdGlja3kgPSBcImJlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPD0gMCkge1xuICAgICAgY2ggPSAwO1xuICAgICAgc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgIH1cbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBnZXQoc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBjaCAtIDEgOiBjaCwgc3RpY2t5ID09IFwiYmVmb3JlXCIpIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpZGkoY2gsIHBhcnRQb3MsIGludmVydCkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsID09IDE7XG4gICAgICByZXR1cm4gZ2V0KGludmVydCA/IGNoIC0gMSA6IGNoLCByaWdodCAhPSBpbnZlcnQpXG4gICAgfVxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgY2gsIHN0aWNreSk7XG4gICAgdmFyIG90aGVyID0gYmlkaU90aGVyO1xuICAgIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBzdGlja3kgPT0gXCJiZWZvcmVcIik7XG4gICAgaWYgKG90aGVyICE9IG51bGwpIHsgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgb3RoZXIsIHN0aWNreSAhPSBcImJlZm9yZVwiKTsgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIC8vIFVzZWQgdG8gY2hlYXBseSBlc3RpbWF0ZSB0aGUgY29vcmRpbmF0ZXMgZm9yIGEgcG9zaXRpb24uIFVzZWQgZm9yXG4gIC8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cbiAgZnVuY3Rpb24gZXN0aW1hdGVDb29yZHMoY20sIHBvcykge1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2g7IH1cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgdmFyIHRvcCA9IGhlaWdodEF0TGluZShsaW5lT2JqKSArIHBhZGRpbmdUb3AoY20uZGlzcGxheSk7XG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9XG4gIH1cblxuICAvLyBQb3NpdGlvbnMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhciBjb250YWluIHNvbWUgZXh0cmEgaW5mb3JtYXRpb24uXG4gIC8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXG4gIC8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xuICAvLyB0aGUgcmlnaHQgb2YgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiwgZm9yIGV4YW1wbGUpLiBXaGVuIG91dHNpZGVcbiAgLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xuICAvLyB2ZXJ0aWNhbCByYW5nZS5cbiAgZnVuY3Rpb24gUG9zV2l0aEluZm8obGluZSwgY2gsIHN0aWNreSwgb3V0c2lkZSwgeFJlbCkge1xuICAgIHZhciBwb3MgPSBQb3MobGluZSwgY2gsIHN0aWNreSk7XG4gICAgcG9zLnhSZWwgPSB4UmVsO1xuICAgIGlmIChvdXRzaWRlKSB7IHBvcy5vdXRzaWRlID0gb3V0c2lkZTsgfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgLy8gSW5wdXQgbXVzdCBiZSBsaW5lU3BhY2UtbG9jYWwgKFwiZGl2XCIgY29vcmRpbmF0ZSBzeXN0ZW0pLlxuICBmdW5jdGlvbiBjb29yZHNDaGFyKGNtLCB4LCB5KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICB5ICs9IGNtLmRpc3BsYXkudmlld09mZnNldDtcbiAgICBpZiAoeSA8IDApIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwgMCwgbnVsbCwgLTEsIC0xKSB9XG4gICAgdmFyIGxpbmVOID0gbGluZUF0SGVpZ2h0KGRvYywgeSksIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE7XG4gICAgaWYgKGxpbmVOID4gbGFzdClcbiAgICAgIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoLCBudWxsLCAxLCAxKSB9XG4gICAgaWYgKHggPCAwKSB7IHggPSAwOyB9XG5cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTik7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGZvdW5kID0gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTiwgeCwgeSk7XG4gICAgICB2YXIgY29sbGFwc2VkID0gY29sbGFwc2VkU3BhbkFyb3VuZChsaW5lT2JqLCBmb3VuZC5jaCArIChmb3VuZC54UmVsID4gMCB8fCBmb3VuZC5vdXRzaWRlID4gMCA/IDEgOiAwKSk7XG4gICAgICBpZiAoIWNvbGxhcHNlZCkgeyByZXR1cm4gZm91bmQgfVxuICAgICAgdmFyIHJhbmdlRW5kID0gY29sbGFwc2VkLmZpbmQoMSk7XG4gICAgICBpZiAocmFuZ2VFbmQubGluZSA9PSBsaW5lTikgeyByZXR1cm4gcmFuZ2VFbmQgfVxuICAgICAgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTiA9IHJhbmdlRW5kLmxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHkpIHtcbiAgICB5IC09IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICB2YXIgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICB2YXIgYmVnaW4gPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gMSkuYm90dG9tIDw9IHk7IH0sIGVuZCwgMCk7XG4gICAgZW5kID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCkudG9wID4geTsgfSwgYmVnaW4sIGVuZCk7XG4gICAgcmV0dXJuIHtiZWdpbjogYmVnaW4sIGVuZDogZW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnRDaGFyKGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCkge1xuICAgIGlmICghcHJlcGFyZWRNZWFzdXJlKSB7IHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7IH1cbiAgICB2YXIgdGFyZ2V0VG9wID0gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCksIFwibGluZVwiKS50b3A7XG4gICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldFRvcClcbiAgfVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2lkZSBvZiBhIGJveCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgLy8gY29vcmRpbmF0ZXMsIGluIHRvcC10by1ib3R0b20sIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gIGZ1bmN0aW9uIGJveElzQWZ0ZXIoYm94LCB4LCB5LCBsZWZ0KSB7XG4gICAgcmV0dXJuIGJveC5ib3R0b20gPD0geSA/IGZhbHNlIDogYm94LnRvcCA+IHkgPyB0cnVlIDogKGxlZnQgPyBib3gubGVmdCA6IGJveC5yaWdodCkgPiB4XG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVObywgeCwgeSkge1xuICAgIC8vIE1vdmUgeSBpbnRvIGxpbmUtbG9jYWwgY29vcmRpbmF0ZSBzcGFjZVxuICAgIHkgLT0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIHZhciBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgIC8vIFdoZW4gZGlyZWN0bHkgY2FsbGluZyBgbWVhc3VyZUNoYXJQcmVwYXJlZGAsIHdlIGhhdmUgdG8gYWRqdXN0XG4gICAgLy8gZm9yIHRoZSB3aWRnZXRzIGF0IHRoaXMgbGluZS5cbiAgICB2YXIgd2lkZ2V0SGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBiZWdpbiA9IDAsIGVuZCA9IGxpbmVPYmoudGV4dC5sZW5ndGgsIGx0ciA9IHRydWU7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAvLyBJZiB0aGUgbGluZSBpc24ndCBwbGFpbiBsZWZ0LXRvLXJpZ2h0IHRleHQsIGZpcnN0IGZpZ3VyZSBvdXRcbiAgICAvLyB3aGljaCBiaWRpIHNlY3Rpb24gdGhlIGNvb3JkaW5hdGVzIGZhbGwgaW50by5cbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIHZhciBwYXJ0ID0gKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nID8gY29vcmRzQmlkaVBhcnRXcmFwcGVkIDogY29vcmRzQmlkaVBhcnQpXG4gICAgICAgICAgICAgICAgICAgKGNtLCBsaW5lT2JqLCBsaW5lTm8sIHByZXBhcmVkTWVhc3VyZSwgb3JkZXIsIHgsIHkpO1xuICAgICAgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgLy8gVGhlIGF3a3dhcmQgLTEgb2Zmc2V0cyBhcmUgbmVlZGVkIGJlY2F1c2UgZmluZEZpcnN0IChjYWxsZWRcbiAgICAgIC8vIG9uIHRoZXNlIGJlbG93KSB3aWxsIHRyZWF0IGl0cyBmaXJzdCBib3VuZCBhcyBpbmNsdXNpdmUsXG4gICAgICAvLyBzZWNvbmQgYXMgZXhjbHVzaXZlLCBidXQgd2Ugd2FudCB0byBhY3R1YWxseSBhZGRyZXNzIHRoZVxuICAgICAgLy8gY2hhcmFjdGVycyBpbiB0aGUgcGFydCdzIHJhbmdlXG4gICAgICBiZWdpbiA9IGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8gLSAxO1xuICAgICAgZW5kID0gbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSAtIDE7XG4gICAgfVxuXG4gICAgLy8gQSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGZpcnN0IGNoYXJhY3RlciB3aG9zZSBib3VuZGluZyBib3hcbiAgICAvLyBzdGFydHMgYWZ0ZXIgdGhlIGNvb3JkaW5hdGVzLiBJZiB3ZSBydW4gYWNyb3NzIGFueSB3aG9zZSBib3ggd3JhcFxuICAgIC8vIHRoZSBjb29yZGluYXRlcywgc3RvcmUgdGhhdC5cbiAgICB2YXIgY2hBcm91bmQgPSBudWxsLCBib3hBcm91bmQgPSBudWxsO1xuICAgIHZhciBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHZhciBib3ggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKTtcbiAgICAgIGJveC50b3AgKz0gd2lkZ2V0SGVpZ2h0OyBib3guYm90dG9tICs9IHdpZGdldEhlaWdodDtcbiAgICAgIGlmICghYm94SXNBZnRlcihib3gsIHgsIHksIGZhbHNlKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKGJveC50b3AgPD0geSAmJiBib3gubGVmdCA8PSB4KSB7XG4gICAgICAgIGNoQXJvdW5kID0gY2g7XG4gICAgICAgIGJveEFyb3VuZCA9IGJveDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSwgYmVnaW4sIGVuZCk7XG5cbiAgICB2YXIgYmFzZVgsIHN0aWNreSwgb3V0c2lkZSA9IGZhbHNlO1xuICAgIC8vIElmIGEgYm94IGFyb3VuZCB0aGUgY29vcmRpbmF0ZXMgd2FzIGZvdW5kLCB1c2UgdGhhdFxuICAgIGlmIChib3hBcm91bmQpIHtcbiAgICAgIC8vIERpc3Rpbmd1aXNoIGNvb3JkaW5hdGVzIG5lYXJlciB0byB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBib3hcbiAgICAgIHZhciBhdExlZnQgPSB4IC0gYm94QXJvdW5kLmxlZnQgPCBib3hBcm91bmQucmlnaHQgLSB4LCBhdFN0YXJ0ID0gYXRMZWZ0ID09IGx0cjtcbiAgICAgIGNoID0gY2hBcm91bmQgKyAoYXRTdGFydCA/IDAgOiAxKTtcbiAgICAgIHN0aWNreSA9IGF0U3RhcnQgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgYmFzZVggPSBhdExlZnQgPyBib3hBcm91bmQubGVmdCA6IGJveEFyb3VuZC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKEFkanVzdCBmb3IgZXh0ZW5kZWQgYm91bmQsIGlmIG5lY2Vzc2FyeS4pXG4gICAgICBpZiAoIWx0ciAmJiAoY2ggPT0gZW5kIHx8IGNoID09IGJlZ2luKSkgeyBjaCsrOyB9XG4gICAgICAvLyBUbyBkZXRlcm1pbmUgd2hpY2ggc2lkZSB0byBhc3NvY2lhdGUgd2l0aCwgZ2V0IHRoZSBib3ggdG8gdGhlXG4gICAgICAvLyBsZWZ0IG9mIHRoZSBjaGFyYWN0ZXIgYW5kIGNvbXBhcmUgaXQncyB2ZXJ0aWNhbCBwb3NpdGlvbiB0byB0aGVcbiAgICAgIC8vIGNvb3JkaW5hdGVzXG4gICAgICBzdGlja3kgPSBjaCA9PSAwID8gXCJhZnRlclwiIDogY2ggPT0gbGluZU9iai50ZXh0Lmxlbmd0aCA/IFwiYmVmb3JlXCIgOlxuICAgICAgICAobWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCAtIChsdHIgPyAxIDogMCkpLmJvdHRvbSArIHdpZGdldEhlaWdodCA8PSB5KSA9PSBsdHIgP1xuICAgICAgICBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgLy8gTm93IGdldCBhY2N1cmF0ZSBjb29yZGluYXRlcyBmb3IgdGhpcyBwbGFjZSwgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICAgIC8vIGJhc2UgWCBwb3NpdGlvblxuICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgY2gsIHN0aWNreSksIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgYmFzZVggPSBjb29yZHMubGVmdDtcbiAgICAgIG91dHNpZGUgPSB5IDwgY29vcmRzLnRvcCA/IC0xIDogeSA+PSBjb29yZHMuYm90dG9tID8gMSA6IDA7XG4gICAgfVxuXG4gICAgY2ggPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZU9iai50ZXh0LCBjaCwgMSk7XG4gICAgcmV0dXJuIFBvc1dpdGhJbmZvKGxpbmVObywgY2gsIHN0aWNreSwgb3V0c2lkZSwgeCAtIGJhc2VYKVxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQmlkaVBhcnQoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEJpZGkgcGFydHMgYXJlIHNvcnRlZCBsZWZ0LXRvLXJpZ2h0LCBhbmQgaW4gYSBub24tbGluZS13cmFwcGluZ1xuICAgIC8vIHNpdHVhdGlvbiwgd2UgY2FuIHRha2UgdGhpcyBvcmRlcmluZyB0byBjb3JyZXNwb25kIHRvIHRoZSB2aXN1YWxcbiAgICAvLyBvcmRlcmluZy4gVGhpcyBmaW5kcyB0aGUgZmlyc3QgcGFydCB3aG9zZSBlbmQgaXMgYWZ0ZXIgdGhlIGdpdmVuXG4gICAgLy8gY29vcmRpbmF0ZXMuXG4gICAgdmFyIGluZGV4ID0gZmluZEZpcnN0KGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldLCBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICByZXR1cm4gYm94SXNBZnRlcihjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQudG8gOiBwYXJ0LmZyb20sIGx0ciA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpLCB4LCB5LCB0cnVlKVxuICAgIH0sIDAsIG9yZGVyLmxlbmd0aCAtIDEpO1xuICAgIHZhciBwYXJ0ID0gb3JkZXJbaW5kZXhdO1xuICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHBhcnQsIHRoZSBwYXJ0J3Mgc3RhcnQgaXMgYWxzbyBhZnRlclxuICAgIC8vIHRoZSBjb29yZGluYXRlcywgYW5kIHRoZSBjb29yZGluYXRlcyBhcmVuJ3Qgb24gdGhlIHNhbWUgbGluZSBhc1xuICAgIC8vIHRoYXQgc3RhcnQsIG1vdmUgb25lIHBhcnQgYmFjay5cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICB2YXIgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIHN0YXJ0ID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBsdHIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvLCBsdHIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgIGlmIChib3hJc0FmdGVyKHN0YXJ0LCB4LCB5LCB0cnVlKSAmJiBzdGFydC50b3AgPiB5KVxuICAgICAgICB7IHBhcnQgPSBvcmRlcltpbmRleCAtIDFdOyB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0XG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydFdyYXBwZWQoY20sIGxpbmVPYmosIF9saW5lTm8sIHByZXBhcmVkTWVhc3VyZSwgb3JkZXIsIHgsIHkpIHtcbiAgICAvLyBJbiBhIHdyYXBwZWQgbGluZSwgcnRsIHRleHQgb24gd3JhcHBpbmcgYm91bmRhcmllcyBjYW4gZG8gdGhpbmdzXG4gICAgLy8gdGhhdCBkb24ndCBjb3JyZXNwb25kIHRvIHRoZSBvcmRlcmluZyBpbiBvdXIgYG9yZGVyYCBhcnJheSBhdFxuICAgIC8vIGFsbCwgc28gYSBiaW5hcnkgc2VhcmNoIGRvZXNuJ3Qgd29yaywgYW5kIHdlIHdhbnQgdG8gcmV0dXJuIGFcbiAgICAvLyBwYXJ0IHRoYXQgb25seSBzcGFucyBvbmUgbGluZSBzbyB0aGF0IHRoZSBiaW5hcnkgc2VhcmNoIGluXG4gICAgLy8gY29vcmRzQ2hhcklubmVyIGlzIHNhZmUuIEFzIHN1Y2gsIHdlIGZpcnN0IGZpbmQgdGhlIGV4dGVudCBvZiB0aGVcbiAgICAvLyB3cmFwcGVkIGxpbmUsIGFuZCB0aGVuIGRvIGEgZmxhdCBzZWFyY2ggaW4gd2hpY2ggd2UgZGlzY2FyZCBhbnlcbiAgICAvLyBzcGFucyB0aGF0IGFyZW4ndCBvbiB0aGUgbGluZS5cbiAgICB2YXIgcmVmID0gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSk7XG4gICAgdmFyIGJlZ2luID0gcmVmLmJlZ2luO1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIGlmICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZW5kIC0gMSkpKSB7IGVuZC0tOyB9XG4gICAgdmFyIHBhcnQgPSBudWxsLCBjbG9zZXN0RGlzdCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwLmZyb20gPj0gZW5kIHx8IHAudG8gPD0gYmVnaW4pIHsgY29udGludWUgfVxuICAgICAgdmFyIGx0ciA9IHAubGV2ZWwgIT0gMTtcbiAgICAgIHZhciBlbmRYID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBsdHIgPyBNYXRoLm1pbihlbmQsIHAudG8pIC0gMSA6IE1hdGgubWF4KGJlZ2luLCBwLmZyb20pKS5yaWdodDtcbiAgICAgIC8vIFdlaWdoIGFnYWluc3Qgc3BhbnMgZW5kaW5nIGJlZm9yZSB0aGlzLCBzbyB0aGF0IHRoZXkgYXJlIG9ubHlcbiAgICAgIC8vIHBpY2tlZCBpZiBub3RoaW5nIGVuZHMgYWZ0ZXJcbiAgICAgIHZhciBkaXN0ID0gZW5kWCA8IHggPyB4IC0gZW5kWCArIDFlOSA6IGVuZFggLSB4O1xuICAgICAgaWYgKCFwYXJ0IHx8IGNsb3Nlc3REaXN0ID4gZGlzdCkge1xuICAgICAgICBwYXJ0ID0gcDtcbiAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnQpIHsgcGFydCA9IG9yZGVyW29yZGVyLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gQ2xpcCB0aGUgcGFydCB0byB0aGUgd3JhcHBlZCBsaW5lLlxuICAgIGlmIChwYXJ0LmZyb20gPCBiZWdpbikgeyBwYXJ0ID0ge2Zyb206IGJlZ2luLCB0bzogcGFydC50bywgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgaWYgKHBhcnQudG8gPiBlbmQpIHsgcGFydCA9IHtmcm9tOiBwYXJ0LmZyb20sIHRvOiBlbmQsIGxldmVsOiBwYXJ0LmxldmVsfTsgfVxuICAgIHJldHVybiBwYXJ0XG4gIH1cblxuICB2YXIgbWVhc3VyZVRleHQ7XG4gIC8vIENvbXB1dGUgdGhlIGRlZmF1bHQgdGV4dCBoZWlnaHQuXG4gIGZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0IH1cbiAgICBpZiAobWVhc3VyZVRleHQgPT0gbnVsbCkge1xuICAgICAgbWVhc3VyZVRleHQgPSBlbHQoXCJwcmVcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxuICAgICAgLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OTsgKytpKSB7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcImJyXCIpKTtcbiAgICAgIH1cbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgbWVhc3VyZVRleHQpO1xuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcbiAgICBpZiAoaGVpZ2h0ID4gMykgeyBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBoZWlnaHQ7IH1cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpO1xuICAgIHJldHVybiBoZWlnaHQgfHwgMVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXG4gIGZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoIH1cbiAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XG4gICAgdmFyIHByZSA9IGVsdChcInByZVwiLCBbYW5jaG9yXSwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIHByZSk7XG4gICAgdmFyIHJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMTA7XG4gICAgaWYgKHdpZHRoID4gMikgeyBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IHdpZHRoOyB9XG4gICAgcmV0dXJuIHdpZHRoIHx8IDEwXG4gIH1cblxuICAvLyBEbyBhIGJ1bGstcmVhZCBvZiB0aGUgRE9NIHBvc2l0aW9ucyBhbmQgc2l6ZXMgbmVlZGVkIHRvIGRyYXcgdGhlXG4gIC8vIHZpZXcsIHNvIHRoYXQgd2UgZG9uJ3QgaW50ZXJsZWF2ZSByZWFkaW5nIGFuZCB3cml0aW5nIHRvIHRoZSBET00uXG4gIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGxlZnQgPSB7fSwgd2lkdGggPSB7fTtcbiAgICB2YXIgZ3V0dGVyTGVmdCA9IGQuZ3V0dGVycy5jbGllbnRMZWZ0O1xuICAgIGZvciAodmFyIG4gPSBkLmd1dHRlcnMuZmlyc3RDaGlsZCwgaSA9IDA7IG47IG4gPSBuLm5leHRTaWJsaW5nLCArK2kpIHtcbiAgICAgIHZhciBpZCA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3NbaV0uY2xhc3NOYW1lO1xuICAgICAgbGVmdFtpZF0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0O1xuICAgICAgd2lkdGhbaWRdID0gbi5jbGllbnRXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHtmaXhlZFBvczogY29tcGVuc2F0ZUZvckhTY3JvbGwoZCksXG4gICAgICAgICAgICBndXR0ZXJUb3RhbFdpZHRoOiBkLmd1dHRlcnMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBndXR0ZXJMZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgZ3V0dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgd3JhcHBlcldpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGh9XG4gIH1cblxuICAvLyBDb21wdXRlcyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsXG4gIC8vIGJ1dCB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdG8gZ2V0IGEgc3ViLXBpeGVsLWFjY3VyYXRlXG4gIC8vIHJlc3VsdC5cbiAgZnVuY3Rpb24gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkge1xuICAgIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGltYXRlcyB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgdG8gdXNlIGFzXG4gIC8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xuICAvLyBwcm9wZXJseSBtZWFzdXJhYmxlKS5cbiAgZnVuY3Rpb24gZXN0aW1hdGVIZWlnaHQoY20pIHtcbiAgICB2YXIgdGggPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSB7IHJldHVybiAwIH1cblxuICAgICAgdmFyIHdpZGdldHNIZWlnaHQgPSAwO1xuICAgICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZS53aWRnZXRzW2ldLmhlaWdodCkgeyB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQ7IH1cbiAgICAgIH0gfVxuXG4gICAgICBpZiAod3JhcHBpbmcpXG4gICAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyAoTWF0aC5jZWlsKGxpbmUudGV4dC5sZW5ndGggLyBwZXJMaW5lKSB8fCAxKSAqIHRoIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZXN0ID0gZXN0aW1hdGVIZWlnaHQoY20pO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0KGxpbmUpO1xuICAgICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7IH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdpdmVuIGEgbW91c2UgZXZlbnQsIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24uIElmIGxpYmVyYWxcbiAgLy8gaXMgZmFsc2UsIGl0IGNoZWNrcyB3aGV0aGVyIGEgZ3V0dGVyIG9yIHNjcm9sbGJhciB3YXMgY2xpY2tlZCxcbiAgLy8gYW5kIHJldHVybnMgbnVsbCBpZiBpdCB3YXMuIGZvclJlY3QgaXMgdXNlZCBieSByZWN0YW5ndWxhclxuICAvLyBzZWxlY3Rpb25zLCBhbmQgdHJpZXMgdG8gZXN0aW1hdGUgYSBjaGFyYWN0ZXIgcG9zaXRpb24gZXZlbiBmb3JcbiAgLy8gY29vcmRpbmF0ZXMgYmV5b25kIHRoZSByaWdodCBvZiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmICghbGliZXJhbCAmJiBlX3RhcmdldChlKS5nZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiKSA9PSBcInRydWVcIikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgeCwgeSwgc3BhY2UgPSBkaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBGYWlscyB1bnByZWRpY3RhYmx5IG9uIElFWzY3XSB3aGVuIG1vdXNlIGlzIGRyYWdnZWQgYXJvdW5kIHF1aWNrbHkuXG4gICAgdHJ5IHsgeCA9IGUuY2xpZW50WCAtIHNwYWNlLmxlZnQ7IHkgPSBlLmNsaWVudFkgLSBzcGFjZS50b3A7IH1cbiAgICBjYXRjaCAoZSQxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmU7XG4gICAgaWYgKGZvclJlY3QgJiYgY29vcmRzLnhSZWwgPiAwICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XG4gICAgICB2YXIgY29sRGlmZiA9IGNvdW50Q29sdW1uKGxpbmUsIGxpbmUubGVuZ3RoLCBjbS5vcHRpb25zLnRhYlNpemUpIC0gbGluZS5sZW5ndGg7XG4gICAgICBjb29yZHMgPSBQb3MoY29vcmRzLmxpbmUsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoKHggLSBwYWRkaW5nSChjbS5kaXNwbGF5KS5sZWZ0KSAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSkgLSBjb2xEaWZmKSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZHNcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcbiAgLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxuICBmdW5jdGlvbiBmaW5kVmlld0luZGV4KGNtLCBuKSB7XG4gICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIG51bGwgfVxuICAgIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICBpZiAobiA8IDApIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgbiAtPSB2aWV3W2ldLnNpemU7XG4gICAgICBpZiAobiA8IDApIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXG4gIC8vIGRvY3VtZW50LiBGcm9tIGFuZCB0byBhcmUgaW4gcHJlLWNoYW5nZSBjb29yZGluYXRlcy4gTGVuZGlmZiBpc1xuICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGFkZGVkIG9yIHN1YnRyYWN0ZWQgYnkgdGhlIGNoYW5nZS4gVGhpcyBpc1xuICAvLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcbiAgLy8gbGluZXMgYXJlIGRpdmlkZWQgaW50byB2aXN1YWwgbGluZXMuIHJlZ0xpbmVDaGFuZ2UgKGJlbG93KVxuICAvLyByZWdpc3RlcnMgc2luZ2xlLWxpbmUgY2hhbmdlcy5cbiAgZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLCBmcm9tLCB0bywgbGVuZGlmZikge1xuICAgIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IGNtLmRvYy5maXJzdDsgfVxuICAgIGlmICh0byA9PSBudWxsKSB7IHRvID0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemU7IH1cbiAgICBpZiAoIWxlbmRpZmYpIHsgbGVuZGlmZiA9IDA7IH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGVuZGlmZiAmJiB0byA8IGRpc3BsYXkudmlld1RvICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKVxuICAgICAgeyBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gZnJvbTsgfVxuXG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuXG4gICAgaWYgKGZyb20gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQ2hhbmdlIGFmdGVyXG4gICAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSkgPCBkaXNwbGF5LnZpZXdUbylcbiAgICAgICAgeyByZXNldFZpZXcoY20pOyB9XG4gICAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBUb3Agb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxuICAgICAgdmFyIGN1dCQxID0gdmlld0N1dHRpbmdQb2ludChjbSwgZnJvbSwgZnJvbSwgLTEpO1xuICAgICAgaWYgKGN1dCQxKSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXQkMS5pbmRleCk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0JDEubGluZU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIEdhcCBpbiB0aGUgbWlkZGxlXG4gICAgICB2YXIgY3V0VG9wID0gdmlld0N1dHRpbmdQb2ludChjbSwgZnJvbSwgZnJvbSwgLTEpO1xuICAgICAgdmFyIGN1dEJvdCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dFRvcC5pbmRleClcbiAgICAgICAgICAuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBjdXRUb3AubGluZU4sIGN1dEJvdC5saW5lTikpXG4gICAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBleHQgPSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCkge1xuICAgICAgaWYgKHRvIDwgZXh0LmxpbmVOKVxuICAgICAgICB7IGV4dC5saW5lTiArPSBsZW5kaWZmOyB9XG4gICAgICBlbHNlIGlmIChmcm9tIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICAgIHsgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIHRvIGEgc2luZ2xlIGxpbmUuIFR5cGUgbXVzdCBiZSBvbmUgb2YgXCJ0ZXh0XCIsXG4gIC8vIFwiZ3V0dGVyXCIsIFwiY2xhc3NcIiwgXCJ3aWRnZXRcIlxuICBmdW5jdGlvbiByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lLCB0eXBlKSB7XG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgbGluZSA+PSBleHQubGluZU4gJiYgbGluZSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG5cbiAgICBpZiAobGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgbGluZSA+PSBkaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gfVxuICAgIHZhciBsaW5lVmlldyA9IGRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lKV07XG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pO1xuICAgIGlmIChpbmRleE9mKGFyciwgdHlwZSkgPT0gLTEpIHsgYXJyLnB1c2godHlwZSk7IH1cbiAgfVxuXG4gIC8vIENsZWFyIHRoZSB2aWV3LlxuICBmdW5jdGlvbiByZXNldFZpZXcoY20pIHtcbiAgICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgY20uZGlzcGxheS52aWV3ID0gW107XG4gICAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xuICAgIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcbiAgICAgIHsgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfSB9XG4gICAgdmFyIG4gPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgIHsgbiArPSB2aWV3W2ldLnNpemU7IH1cbiAgICBpZiAobiAhPSBvbGROKSB7XG4gICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdmlldy5sZW5ndGggLSAxKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgZGlmZiA9IChuICsgdmlld1tpbmRleF0uc2l6ZSkgLSBvbGROO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IG4gLSBvbGROO1xuICAgICAgfVxuICAgICAgb2xkTiArPSBkaWZmOyBuZXdOICs9IGRpZmY7XG4gICAgfVxuICAgIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XG4gICAgICBpZiAoaW5kZXggPT0gKGRpciA8IDAgPyAwIDogdmlldy5sZW5ndGggLSAxKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBuZXdOICs9IGRpciAqIHZpZXdbaW5kZXggLSAoZGlyIDwgMCA/IDEgOiAwKV0uc2l6ZTtcbiAgICAgIGluZGV4ICs9IGRpcjtcbiAgICB9XG4gICAgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfVxuICB9XG5cbiAgLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxuICAvLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICh2aWV3Lmxlbmd0aCA9PSAwIHx8IGZyb20gPj0gZGlzcGxheS52aWV3VG8gfHwgdG8gPD0gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIGRpc3BsYXkudmlld0Zyb20pLmNvbmNhdChkaXNwbGF5LnZpZXcpOyB9XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpOyB9XG4gICAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbTtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdUbyA8IHRvKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGRpc3BsYXkudmlld1RvLCB0bykpOyB9XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBmaW5kVmlld0luZGV4KGNtLCB0bykpOyB9XG4gICAgfVxuICAgIGRpc3BsYXkudmlld1RvID0gdG87XG4gIH1cblxuICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSB2aWV3IHdob3NlIERPTSByZXByZXNlbnRhdGlvbiBpc1xuICAvLyBvdXQgb2YgZGF0ZSAob3Igbm9uZXhpc3RlbnQpLlxuICBmdW5jdGlvbiBjb3VudERpcnR5VmlldyhjbSkge1xuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3LCBkaXJ0eSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKCFsaW5lVmlldy5oaWRkZW4gJiYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3LmNoYW5nZXMpKSB7ICsrZGlydHk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnR5XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oY20pIHtcbiAgICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdGlvbihjbSwgcHJpbWFyeSkge1xuICAgIGlmICggcHJpbWFyeSA9PT0gdm9pZCAwICkgcHJpbWFyeSA9IHRydWU7XG5cbiAgICB2YXIgZG9jID0gY20uZG9jLCByZXN1bHQgPSB7fTtcbiAgICB2YXIgY3VyRnJhZ21lbnQgPSByZXN1bHQuY3Vyc29ycyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgc2VsRnJhZ21lbnQgPSByZXN1bHQuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IGNtLm9wdGlvbnMuJGN1c3RvbUN1cnNvcjtcbiAgICBpZiAoY3VzdG9tQ3Vyc29yKSB7IHByaW1hcnkgPSB0cnVlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcmltYXJ5ICYmIGkgPT0gZG9jLnNlbC5wcmltSW5kZXgpIHsgY29udGludWUgfVxuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2UuZnJvbSgpLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgcmFuZ2UudG8oKS5saW5lIDwgY20uZGlzcGxheS52aWV3RnJvbSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgY29sbGFwc2VkID0gcmFuZ2UuZW1wdHkoKTtcbiAgICAgIGlmIChjdXN0b21DdXJzb3IpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBjdXN0b21DdXJzb3IoY20sIHJhbmdlKTtcbiAgICAgICAgaWYgKGhlYWQpIHsgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgY3VyRnJhZ21lbnQpOyB9XG4gICAgICB9IGVsc2UgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKSB7XG4gICAgICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLmhlYWQsIGN1ckZyYWdtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghY29sbGFwc2VkKVxuICAgICAgICB7IGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIHNlbEZyYWdtZW50KTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBEcmF3cyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIHJhbmdlXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIGhlYWQsIG91dHB1dCkge1xuICAgIHZhciBwb3MgPSBjdXJzb3JDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwsICFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO1xuXG4gICAgdmFyIGN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO1xuICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcInB4XCI7XG4gICAgY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgKyBcInB4XCI7XG4gICAgY3Vyc29yLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHBvcy5ib3R0b20gLSBwb3MudG9wKSAqIGNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgaWYgKC9cXGJjbS1mYXQtY3Vyc29yXFxiLy50ZXN0KGNtLmdldFdyYXBwZXJFbGVtZW50KCkuY2xhc3NOYW1lKSkge1xuICAgICAgdmFyIGNoYXJQb3MgPSBjaGFyQ29vcmRzKGNtLCBoZWFkLCBcImRpdlwiLCBudWxsLCBudWxsKTtcbiAgICAgIHZhciB3aWR0aCA9IGNoYXJQb3MucmlnaHQgLSBjaGFyUG9zLmxlZnQ7XG4gICAgICBjdXJzb3Iuc3R5bGUud2lkdGggPSAod2lkdGggPiAwID8gd2lkdGggOiBjbS5kZWZhdWx0Q2hhcldpZHRoKCkpICsgXCJweFwiO1xuICAgIH1cblxuICAgIGlmIChwb3Mub3RoZXIpIHtcbiAgICAgIC8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxuICAgICAgdmFyIG90aGVyQ3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclwiKSk7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmxlZnQgPSBwb3Mub3RoZXIubGVmdCArIFwicHhcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLnRvcCA9IHBvcy5vdGhlci50b3AgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5oZWlnaHQgPSAocG9zLm90aGVyLmJvdHRvbSAtIHBvcy5vdGhlci50b3ApICogLjg1ICsgXCJweFwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNtcENvb3JkcyhhLCBiKSB7IHJldHVybiBhLnRvcCAtIGIudG9wIHx8IGEubGVmdCAtIGIubGVmdCB9XG5cbiAgLy8gRHJhd3MgdGhlIGdpdmVuIHJhbmdlIGFzIGEgaGlnaGxpZ2h0ZWQgc2VsZWN0aW9uXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIG91dHB1dCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgcGFkZGluZyA9IHBhZGRpbmdIKGNtLmRpc3BsYXkpLCBsZWZ0U2lkZSA9IHBhZGRpbmcubGVmdDtcbiAgICB2YXIgcmlnaHRTaWRlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplcldpZHRoLCBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0KSAtIHBhZGRpbmcucmlnaHQ7XG4gICAgdmFyIGRvY0xUUiA9IGRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIjtcblxuICAgIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcbiAgICAgIGlmICh0b3AgPCAwKSB7IHRvcCA9IDA7IH1cbiAgICAgIHRvcCA9IE1hdGgucm91bmQodG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcIiwgKFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcIiArIGxlZnQgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIiArIHRvcCArIFwicHg7IHdpZHRoOiBcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcInB4XCIpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcbiAgICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVMZW4gPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG4gICAgICBmdW5jdGlvbiBjb29yZHMoY2gsIGJpYXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb29yZHMoY20sIFBvcyhsaW5lLCBjaCksIFwiZGl2XCIsIGxpbmVPYmosIGJpYXMpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBYKHBvcywgZGlyLCBzaWRlKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIG51bGwsIHBvcyk7XG4gICAgICAgIHZhciBwcm9wID0gKGRpciA9PSBcImx0clwiKSA9PSAoc2lkZSA9PSBcImFmdGVyXCIpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICAgIHZhciBjaCA9IHNpZGUgPT0gXCJhZnRlclwiID8gZXh0ZW50LmJlZ2luIDogZXh0ZW50LmVuZCAtICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZXh0ZW50LmVuZCAtIDEpKSA/IDIgOiAxKTtcbiAgICAgICAgcmV0dXJuIGNvb3JkcyhjaCwgcHJvcClbcHJvcF1cbiAgICAgIH1cblxuICAgICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgZG9jLmRpcmVjdGlvbik7XG4gICAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uIChmcm9tLCB0bywgZGlyLCBpKSB7XG4gICAgICAgIHZhciBsdHIgPSBkaXIgPT0gXCJsdHJcIjtcbiAgICAgICAgdmFyIGZyb21Qb3MgPSBjb29yZHMoZnJvbSwgbHRyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xuICAgICAgICB2YXIgdG9Qb3MgPSBjb29yZHModG8gLSAxLCBsdHIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG5cbiAgICAgICAgdmFyIG9wZW5TdGFydCA9IGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDAsIG9wZW5FbmQgPSB0b0FyZyA9PSBudWxsICYmIHRvID09IGxpbmVMZW47XG4gICAgICAgIHZhciBmaXJzdCA9IGkgPT0gMCwgbGFzdCA9ICFvcmRlciB8fCBpID09IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh0b1Bvcy50b3AgLSBmcm9tUG9zLnRvcCA8PSAzKSB7IC8vIFNpbmdsZSBsaW5lXG4gICAgICAgICAgdmFyIG9wZW5MZWZ0ID0gKGRvY0xUUiA/IG9wZW5TdGFydCA6IG9wZW5FbmQpICYmIGZpcnN0O1xuICAgICAgICAgIHZhciBvcGVuUmlnaHQgPSAoZG9jTFRSID8gb3BlbkVuZCA6IG9wZW5TdGFydCkgJiYgbGFzdDtcbiAgICAgICAgICB2YXIgbGVmdCA9IG9wZW5MZWZ0ID8gbGVmdFNpZGUgOiAobHRyID8gZnJvbVBvcyA6IHRvUG9zKS5sZWZ0O1xuICAgICAgICAgIHZhciByaWdodCA9IG9wZW5SaWdodCA/IHJpZ2h0U2lkZSA6IChsdHIgPyB0b1BvcyA6IGZyb21Qb3MpLnJpZ2h0O1xuICAgICAgICAgIGFkZChsZWZ0LCBmcm9tUG9zLnRvcCwgcmlnaHQgLSBsZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIE11bHRpcGxlIGxpbmVzXG4gICAgICAgICAgdmFyIHRvcExlZnQsIHRvcFJpZ2h0LCBib3RMZWZ0LCBib3RSaWdodDtcbiAgICAgICAgICBpZiAobHRyKSB7XG4gICAgICAgICAgICB0b3BMZWZ0ID0gZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IGxlZnRTaWRlIDogZnJvbVBvcy5sZWZ0O1xuICAgICAgICAgICAgdG9wUmlnaHQgPSBkb2NMVFIgPyByaWdodFNpZGUgOiB3cmFwWChmcm9tLCBkaXIsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgYm90TGVmdCA9IGRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICAgIGJvdFJpZ2h0ID0gZG9jTFRSICYmIG9wZW5FbmQgJiYgbGFzdCA/IHJpZ2h0U2lkZSA6IHRvUG9zLnJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BMZWZ0ID0gIWRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gIWRvY0xUUiAmJiBvcGVuU3RhcnQgJiYgZmlyc3QgPyByaWdodFNpZGUgOiBmcm9tUG9zLnJpZ2h0O1xuICAgICAgICAgICAgYm90TGVmdCA9ICFkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gbGVmdFNpZGUgOiB0b1Bvcy5sZWZ0O1xuICAgICAgICAgICAgYm90UmlnaHQgPSAhZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkKHRvcExlZnQsIGZyb21Qb3MudG9wLCB0b3BSaWdodCAtIHRvcExlZnQsIGZyb21Qb3MuYm90dG9tKTtcbiAgICAgICAgICBpZiAoZnJvbVBvcy5ib3R0b20gPCB0b1Bvcy50b3ApIHsgYWRkKGxlZnRTaWRlLCBmcm9tUG9zLmJvdHRvbSwgbnVsbCwgdG9Qb3MudG9wKTsgfVxuICAgICAgICAgIGFkZChib3RMZWZ0LCB0b1Bvcy50b3AsIGJvdFJpZ2h0IC0gYm90TGVmdCwgdG9Qb3MuYm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhcnQgfHwgY21wQ29vcmRzKGZyb21Qb3MsIHN0YXJ0KSA8IDApIHsgc3RhcnQgPSBmcm9tUG9zOyB9XG4gICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIHN0YXJ0KSA8IDApIHsgc3RhcnQgPSB0b1BvczsgfVxuICAgICAgICBpZiAoIWVuZCB8fCBjbXBDb29yZHMoZnJvbVBvcywgZW5kKSA8IDApIHsgZW5kID0gZnJvbVBvczsgfVxuICAgICAgICBpZiAoY21wQ29vcmRzKHRvUG9zLCBlbmQpIDwgMCkgeyBlbmQgPSB0b1BvczsgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9XG4gICAgfVxuXG4gICAgdmFyIHNGcm9tID0gcmFuZ2UuZnJvbSgpLCBzVG8gPSByYW5nZS50bygpO1xuICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XG4gICAgICBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc1RvLmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xuICAgICAgdmFyIHNpbmdsZVZMaW5lID0gdmlzdWFsTGluZShmcm9tTGluZSkgPT0gdmlzdWFsTGluZSh0b0xpbmUpO1xuICAgICAgdmFyIGxlZnRFbmQgPSBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc2luZ2xlVkxpbmUgPyBmcm9tTGluZS50ZXh0Lmxlbmd0aCArIDEgOiBudWxsKS5lbmQ7XG4gICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xuICAgICAgaWYgKHNpbmdsZVZMaW5lKSB7XG4gICAgICAgIGlmIChsZWZ0RW5kLnRvcCA8IHJpZ2h0U3RhcnQudG9wIC0gMikge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICAgIGFkZChsZWZ0U2lkZSwgcmlnaHRTdGFydC50b3AsIHJpZ2h0U3RhcnQubGVmdCwgcmlnaHRTdGFydC5ib3R0b20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcbiAgICAgICAgeyBhZGQobGVmdFNpZGUsIGxlZnRFbmQuYm90dG9tLCBudWxsLCByaWdodFN0YXJ0LnRvcCk7IH1cbiAgICB9XG5cbiAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG5cbiAgLy8gQ3Vyc29yLWJsaW5raW5nXG4gIGZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyByZXR1cm4gfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcik7XG4gICAgdmFyIG9uID0gdHJ1ZTtcbiAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwKVxuICAgICAgeyBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY20uaGFzRm9jdXMoKSkgeyBvbkJsdXIoY20pOyB9XG4gICAgICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSAob24gPSAhb24pID8gXCJcIiA6IFwiaGlkZGVuXCI7XG4gICAgICB9LCBjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk7IH1cbiAgICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXG4gICAgICB7IGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVGb2N1cyhjbSkge1xuICAgIGlmICghY20uaGFzRm9jdXMoKSkge1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXMoY20pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsYXlCbHVyRXZlbnQoY20pIHtcbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xuICAgICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IG9uQmx1cihjbSk7IH1cbiAgICB9IH0sIDEwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkZvY3VzKGNtLCBlKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ICYmICFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuXG4gICAgaWYgKGNtLm9wdGlvbnMucmVhZE9ubHkgPT0gXCJub2N1cnNvclwiKSB7IHJldHVybiB9XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICBzaWduYWwoY20sIFwiZm9jdXNcIiwgY20sIGUpO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgLy8gVGhpcyB0ZXN0IHByZXZlbnRzIHRoaXMgZnJvbSBmaXJpbmcgd2hlbiBhIGNvbnRleHRcbiAgICAgIC8vIG1lbnUgaXMgY2xvc2VkIChzaW5jZSB0aGUgaW5wdXQgcmVzZXQgd291bGQga2lsbCB0aGVcbiAgICAgIC8vIHNlbGVjdC1hbGwgZGV0ZWN0aW9uIGhhY2spXG4gICAgICBpZiAoIWNtLmN1ck9wICYmIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgIT0gY20uZG9jLnNlbCkge1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgIGlmICh3ZWJraXQpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IH0gLy8gSXNzdWUgIzE3MzBcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpO1xuICAgIH1cbiAgICByZXN0YXJ0QmxpbmsoY20pO1xuICB9XG4gIGZ1bmN0aW9uIG9uQmx1cihjbSwgZSkge1xuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgeyByZXR1cm4gfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJibHVyXCIsIGNtLCBlKTtcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICB9XG4gICAgY2xlYXJJbnRlcnZhbChjbS5kaXNwbGF5LmJsaW5rZXIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9IH0sIDE1MCk7XG4gIH1cblxuICAvLyBSZWFkIHRoZSBhY3R1YWwgaGVpZ2h0cyBvZiB0aGUgcmVuZGVyZWQgbGluZXMsIGFuZCB1cGRhdGUgdGhlaXJcbiAgLy8gc3RvcmVkIGhlaWdodHMgdG8gbWF0Y2guXG4gIGZ1bmN0aW9uIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBwcmV2Qm90dG9tID0gZGlzcGxheS5saW5lRGl2Lm9mZnNldFRvcDtcbiAgICB2YXIgdmlld1RvcCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB2YXIgb2xkSGVpZ2h0ID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB2YXIgbXVzdFNjcm9sbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBkaXNwbGF5LnZpZXdbaV0sIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgICB2YXIgaGVpZ2h0ID0gKHZvaWQgMCksIHdpZHRoID0gMDtcbiAgICAgIGlmIChjdXIuaGlkZGVuKSB7IGNvbnRpbnVlIH1cbiAgICAgIG9sZEhlaWdodCArPSBjdXIubGluZS5oZWlnaHQ7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcbiAgICAgICAgcHJldkJvdHRvbSA9IGJvdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgbGluZXMgZG9uJ3QgZXh0ZW5kIHBhc3QgdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGVkaXRvciB3aWR0aFxuICAgICAgICBpZiAoIXdyYXBwaW5nICYmIGN1ci50ZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgeyB3aWR0aCA9IGN1ci50ZXh0LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSBib3gubGVmdCAtIDE7IH1cbiAgICAgIH1cbiAgICAgIHZhciBkaWZmID0gY3VyLmxpbmUuaGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgaWYgKGRpZmYgPiAuMDA1IHx8IGRpZmYgPCAtLjAwNSkge1xuICAgICAgICBpZiAob2xkSGVpZ2h0IDwgdmlld1RvcCkgeyBtdXN0U2Nyb2xsIC09IGRpZmY7IH1cbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChjdXIubGluZSwgaGVpZ2h0KTtcbiAgICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5saW5lKTtcbiAgICAgICAgaWYgKGN1ci5yZXN0KSB7IGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXG4gICAgICAgICAgeyB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLnJlc3Rbal0pOyB9IH1cbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA+IGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCkge1xuICAgICAgICB2YXIgY2hXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSk7XG4gICAgICAgIGlmIChjaFdpZHRoID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gY2hXaWR0aDtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSBjdXIubGluZTtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMobXVzdFNjcm9sbCkgPiAyKSB7IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG11c3RTY3JvbGw7IH1cbiAgfVxuXG4gIC8vIFJlYWQgYW5kIHN0b3JlIHRoZSBoZWlnaHQgb2YgbGluZSB3aWRnZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgLy8gZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcbiAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdyA9IGxpbmUud2lkZ2V0c1tpXSwgcGFyZW50ID0gdy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50KSB7IHcuaGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodDsgfVxuICAgIH0gfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGluZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIGdpdmVuIHZpZXdwb3J0IChkZWZhdWx0c1xuICAvLyB0aGUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uKS4gdmlld3BvcnQgbWF5IGNvbnRhaW4gdG9wLFxuICAvLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cbiAgZnVuY3Rpb24gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYywgdmlld3BvcnQpIHtcbiAgICB2YXIgdG9wID0gdmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwgPyBNYXRoLm1heCgwLCB2aWV3cG9ydC50b3ApIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgdG9wID0gTWF0aC5mbG9vcih0b3AgLSBwYWRkaW5nVG9wKGRpc3BsYXkpKTtcbiAgICB2YXIgYm90dG9tID0gdmlld3BvcnQgJiYgdmlld3BvcnQuYm90dG9tICE9IG51bGwgPyB2aWV3cG9ydC5ib3R0b20gOiB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgdmFyIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCB0b3ApLCB0byA9IGxpbmVBdEhlaWdodChkb2MsIGJvdHRvbSk7XG4gICAgLy8gRW5zdXJlIGlzIGEge2Zyb206IHtsaW5lLCBjaH0sIHRvOiB7bGluZSwgY2h9fSBvYmplY3QsIGFuZFxuICAgIC8vIGZvcmNlcyB0aG9zZSBsaW5lcyBpbnRvIHRoZSB2aWV3cG9ydCAoaWYgcG9zc2libGUpLlxuICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC5lbnN1cmUpIHtcbiAgICAgIHZhciBlbnN1cmVGcm9tID0gdmlld3BvcnQuZW5zdXJlLmZyb20ubGluZSwgZW5zdXJlVG8gPSB2aWV3cG9ydC5lbnN1cmUudG8ubGluZTtcbiAgICAgIGlmIChlbnN1cmVGcm9tIDwgZnJvbSkge1xuICAgICAgICBmcm9tID0gZW5zdXJlRnJvbTtcbiAgICAgICAgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZUZyb20pKSArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLm1pbihlbnN1cmVUbywgZG9jLmxhc3RMaW5lKCkpID49IHRvKSB7XG4gICAgICAgIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZVRvKSkgLSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgdG8gPSBlbnN1cmVUbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBmcm9tLCB0bzogTWF0aC5tYXgodG8sIGZyb20gKyAxKX1cbiAgfVxuXG4gIC8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXG5cbiAgLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XG4gIC8vIHNjcm9sbGVkIG91dCBvZiB2aWV3LCB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUuXG4gIGZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KSB7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBcInNjcm9sbEN1cnNvckludG9WaWV3XCIpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcbiAgICBpZiAocmVjdC50b3AgKyBib3gudG9wIDwgMCkgeyBkb1Njcm9sbCA9IHRydWU7IH1cbiAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSArIGJveC50b3AgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKSB7IGRvU2Nyb2xsID0gZmFsc2U7IH1cbiAgICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xuICAgICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXCJkaXZcIiwgXCJcXHUyMDBiXCIsIG51bGwsIChcInBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIiArIChyZWN0LnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiICsgKHJlY3QubGVmdCkgKyBcInB4OyB3aWR0aDogXCIgKyAoTWF0aC5tYXgoMiwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCkpICsgXCJweDtcIikpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSk7XG4gICAgICBzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKHNjcm9sbE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxuICAvLyBpdCBhY3R1YWxseSBiZWNhbWUgdmlzaWJsZSAoYXMgbGluZSBoZWlnaHRzIGFyZSBhY2N1cmF0ZWx5XG4gIC8vIG1lYXN1cmVkLCB0aGUgcG9zaXRpb24gb2Ygc29tZXRoaW5nIG1heSAnZHJpZnQnIGR1cmluZyBkcmF3aW5nKS5cbiAgZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcbiAgICBpZiAobWFyZ2luID09IG51bGwpIHsgbWFyZ2luID0gMDsgfVxuICAgIHZhciByZWN0O1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgcG9zID09IGVuZCkge1xuICAgICAgLy8gU2V0IHBvcyBhbmQgZW5kIHRvIHRoZSBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCB0aGUgY2hhcmFjdGVyIHBvcyBzdGlja3MgdG9cbiAgICAgIC8vIElmIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiwgdGhhdCBpcyBhcm91bmQgcG9zLmNoIC0gMSwgb3RoZXJ3aXNlIGFyb3VuZCBwb3MuY2hcbiAgICAgIC8vIElmIHBvcyA9PSBQb3MoXywgMCwgXCJiZWZvcmVcIiksIHBvcyBhbmQgZW5kIGFyZSB1bmNoYW5nZWRcbiAgICAgIGVuZCA9IHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IFBvcyhwb3MubGluZSwgcG9zLmNoICsgMSwgXCJiZWZvcmVcIikgOiBwb3M7XG4gICAgICBwb3MgPSBwb3MuY2ggPyBQb3MocG9zLmxpbmUsIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IHBvcy5jaCAtIDEgOiBwb3MuY2gsIFwiYWZ0ZXJcIikgOiBwb3M7XG4gICAgfVxuICAgIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcbiAgICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XG4gICAgICByZWN0ID0ge2xlZnQ6IE1hdGgubWluKGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgIHRvcDogTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICBib3R0b206IE1hdGgubWF4KGNvb3Jkcy5ib3R0b20sIGVuZENvb3Jkcy5ib3R0b20pICsgbWFyZ2lufTtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGFuZ2VkKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cbiAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHJlY3QpIHtcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7IH1cbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7IH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIG5ldyBzY3JvbGwgcG9zaXRpb24gbmVlZGVkIHRvIHNjcm9sbCB0aGUgZ2l2ZW5cbiAgLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXG4gIC8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcbiAgLy8gdmVydGljYWwvaG9yaXpvbnRhbCBwb3NpdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkanVzdGVkLlxuICBmdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpO1xuICAgIGlmIChyZWN0LnRvcCA8IDApIHsgcmVjdC50b3AgPSAwOyB9XG4gICAgdmFyIHNjcmVlbnRvcCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsVG9wIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fTtcbiAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IHNjcmVlbikgeyByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgc2NyZWVuOyB9XG4gICAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcbiAgICB2YXIgYXRUb3AgPSByZWN0LnRvcCA8IHNuYXBNYXJnaW4sIGF0Qm90dG9tID0gcmVjdC5ib3R0b20gPiBkb2NCb3R0b20gLSBzbmFwTWFyZ2luO1xuICAgIGlmIChyZWN0LnRvcCA8IHNjcmVlbnRvcCkge1xuICAgICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHJlY3QudG9wO1xuICAgIH0gZWxzZSBpZiAocmVjdC5ib3R0b20gPiBzY3JlZW50b3AgKyBzY3JlZW4pIHtcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogcmVjdC5ib3R0b20pIC0gc2NyZWVuKTtcbiAgICAgIGlmIChuZXdUb3AgIT0gc2NyZWVudG9wKSB7IHJlc3VsdC5zY3JvbGxUb3AgPSBuZXdUb3A7IH1cbiAgICB9XG5cbiAgICB2YXIgZ3V0dGVyU3BhY2UgPSBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gMCA6IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgLSBndXR0ZXJTcGFjZTtcbiAgICB2YXIgc2NyZWVudyA9IGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHRvb1dpZGUgPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0ID4gc2NyZWVudztcbiAgICBpZiAodG9vV2lkZSkgeyByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgc2NyZWVudzsgfVxuICAgIGlmIChyZWN0LmxlZnQgPCAxMClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSAwOyB9XG4gICAgZWxzZSBpZiAocmVjdC5sZWZ0IDwgc2NyZWVubGVmdClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQgKyBndXR0ZXJTcGFjZSAtICh0b29XaWRlID8gMCA6IDEwKSk7IH1cbiAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gc2NyZWVudyArIHNjcmVlbmxlZnQgLSAzKVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IHJlY3QucmlnaHQgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53OyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAgLy8gb3BlcmF0aW9uICh0byBiZSBhcHBsaWVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcykuXG4gIGZ1bmN0aW9uIGFkZFRvU2Nyb2xsVG9wKGNtLCB0b3ApIHtcbiAgICBpZiAodG9wID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvcCA9IChjbS5jdXJPcC5zY3JvbGxUb3AgPT0gbnVsbCA/IGNtLmRvYy5zY3JvbGxUb3AgOiBjbS5jdXJPcC5zY3JvbGxUb3ApICsgdG9wO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uIHRoZSBjdXJyZW50IGN1cnNvciBpc1xuICAvLyBzaG93bi5cbiAgZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGN1ciwgdG86IGN1ciwgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbn07XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3JkcyhjbSwgeCwgeSkge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSB7IHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7IH1cbiAgICBpZiAoeCAhPSBudWxsKSB7IGNtLmN1ck9wLnNjcm9sbExlZnQgPSB4OyB9XG4gICAgaWYgKHkgIT0gbnVsbCkgeyBjbS5jdXJPcC5zY3JvbGxUb3AgPSB5OyB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb1JhbmdlKGNtLCByYW5nZSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSByYW5nZTtcbiAgfVxuXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xuICAvLyAnc2ltdWxhdGVzJyBzY3JvbGxpbmcgdGhhdCBwb3NpdGlvbiBpbnRvIHZpZXcgaW4gYSBjaGVhcCB3YXksIHNvXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5jdXJPcC5zY3JvbGxUb1BvcztcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50byk7XG4gICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgcmFuZ2UubWFyZ2luKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgbWFyZ2luKSB7XG4gICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHtcbiAgICAgIGxlZnQ6IE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gbWFyZ2luLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyBtYXJnaW5cbiAgICB9KTtcbiAgICBzY3JvbGxUb0Nvb3JkcyhjbSwgc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XG4gIH1cblxuICAvLyBTeW5jIHRoZSBzY3JvbGxhYmxlIGFyZWEgYW5kIHNjcm9sbGJhcnMsIGVuc3VyZSB0aGUgdmlld3BvcnRcbiAgLy8gY292ZXJzIHRoZSB2aXNpYmxlIGFyZWEuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChjbSwgdmFsKSB7XG4gICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSB2YWwpIDwgMikgeyByZXR1cm4gfVxuICAgIGlmICghZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdmFsfSk7IH1cbiAgICBzZXRTY3JvbGxUb3AoY20sIHZhbCwgdHJ1ZSk7XG4gICAgaWYgKGdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pOyB9XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCB2YWwpKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPT0gdmFsICYmICFmb3JjZVNjcm9sbCkgeyByZXR1cm4gfVxuICAgIGNtLmRvYy5zY3JvbGxUb3AgPSB2YWw7XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWw7IH1cbiAgfVxuXG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXG4gIC8vIGFsaWduZWQuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlciwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSk7XG4gICAgaWYgKChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgJiYgIWZvcmNlU2Nyb2xsKSB7IHJldHVybiB9XG4gICAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWw7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbDsgfVxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7XG4gIH1cblxuICAvLyBTQ1JPTExCQVJTXG5cbiAgLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcbiAgLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxuICBmdW5jdGlvbiBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZG9jSCA9IE1hdGgucm91bmQoY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50SGVpZ2h0OiBkLnNjcm9sbGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogZC5zY3JvbGxlci5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGg6IGQuc2Nyb2xsZXIuY2xpZW50V2lkdGgsXG4gICAgICB2aWV3V2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aCxcbiAgICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcbiAgICAgIGRvY0hlaWdodDogZG9jSCxcbiAgICAgIHNjcm9sbEhlaWdodDogZG9jSCArIHNjcm9sbEdhcChjbSkgKyBkLmJhckhlaWdodCxcbiAgICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxuICAgICAgZ3V0dGVyV2lkdGg6IGd1dHRlcldcbiAgICB9XG4gIH1cblxuICB2YXIgTmF0aXZlU2Nyb2xsYmFycyA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJtaW4td2lkdGg6IDFweFwiKV0sIFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpO1xuICAgIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgdmVydC50YWJJbmRleCA9IGhvcml6LnRhYkluZGV4ID0gLTE7XG4gICAgcGxhY2UodmVydCk7IHBsYWNlKGhvcml6KTtcblxuICAgIG9uKHZlcnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgeyBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFwidmVydGljYWxcIik7IH1cbiAgICB9KTtcbiAgICBvbihob3JpeiwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcImhvcml6b250YWxcIik7IH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IGZhbHNlO1xuICAgIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIjsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDE7XG4gICAgdmFyIHNXaWR0aCA9IG1lYXN1cmUubmF0aXZlQmFyV2lkdGg7XG5cbiAgICBpZiAobmVlZHNWKSB7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5ib3R0b20gPSBuZWVkc0ggPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHZhciB0b3RhbEhlaWdodCA9IG1lYXN1cmUudmlld0hlaWdodCAtIChuZWVkc0ggPyBzV2lkdGggOiAwKTtcbiAgICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXG4gICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0gpIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUubGVmdCA9IG1lYXN1cmUuYmFyTGVmdCArIFwicHhcIjtcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gbWVhc3VyZS52aWV3V2lkdGggLSBtZWFzdXJlLmJhckxlZnQgLSAobmVlZHNWID8gc1dpZHRoIDogMCk7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbFdpZHRoIC0gbWVhc3VyZS5jbGllbnRXaWR0aCArIHRvdGFsV2lkdGgpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICBpZiAoc1dpZHRoID09IDApIHsgdGhpcy56ZXJvV2lkdGhIYWNrKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyaWdodDogbmVlZHNWID8gc1dpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyBzV2lkdGggOiAwfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMuaG9yaXouc2Nyb2xsTGVmdCAhPSBwb3MpIHsgdGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZUhvcml6KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6LCBcImhvcml6XCIpOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgeyB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LCB0aGlzLmRpc2FibGVWZXJ0LCBcInZlcnRcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcIjEycHhcIiA6IFwiMThweFwiO1xuICAgIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gdztcbiAgICB0aGlzLmhvcml6LnN0eWxlLnBvaW50ZXJFdmVudHMgPSB0aGlzLnZlcnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIHRoaXMuZGlzYWJsZUhvcml6ID0gbmV3IERlbGF5ZWQ7XG4gICAgdGhpcy5kaXNhYmxlVmVydCA9IG5ldyBEZWxheWVkO1xuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uIChiYXIsIGRlbGF5LCB0eXBlKSB7XG4gICAgYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBmdW5jdGlvbiBtYXliZURpc2FibGUoKSB7XG4gICAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgdW5kZXIgdGhlIHBpeGVsIGluIHRoZSBib3R0b21cbiAgICAgIC8vIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2Nyb2xsYmFyIGJveCBpcyB0aGUgc2Nyb2xsYmFyIGJveFxuICAgICAgLy8gaXRzZWxmICh3aGVuIHRoZSBiYXIgaXMgc3RpbGwgdmlzaWJsZSkgb3IgaXRzIGZpbGxlciBjaGlsZFxuICAgICAgLy8gKHdoZW4gdGhlIGJhciBpcyBoaWRkZW4pLiBJZiBpdCBpcyBzdGlsbCB2aXNpYmxlLCB3ZSBrZWVwXG4gICAgICAvLyBpdCBlbmFibGVkLCBpZiBpdCdzIGhpZGRlbiwgd2UgZGlzYWJsZSBwb2ludGVyIGV2ZW50cy5cbiAgICAgIHZhciBib3ggPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgZWx0ID0gdHlwZSA9PSBcInZlcnRcIiA/IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoYm94LnJpZ2h0IC0gMSwgKGJveC50b3AgKyBib3guYm90dG9tKSAvIDIpXG4gICAgICAgICAgOiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KChib3gucmlnaHQgKyBib3gubGVmdCkgLyAyLCBib3guYm90dG9tIC0gMSk7XG4gICAgICBpZiAoZWx0ICE9IGJhcikgeyBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiOyB9XG4gICAgICBlbHNlIHsgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7IH1cbiAgICB9XG4gICAgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuaG9yaXoucGFyZW50Tm9kZTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7XG4gIH07XG5cbiAgdmFyIE51bGxTY3JvbGxiYXJzID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHtib3R0b206IDAsIHJpZ2h0OiAwfSB9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHt9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcbiAgICBpZiAoIW1lYXN1cmUpIHsgbWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTsgfVxuICAgIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcbiAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggfHwgc3RhcnRIZWlnaHQgIT0gY20uZGlzcGxheS5iYXJIZWlnaHQ7IGkrKykge1xuICAgICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtcbiAgICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlLXN5bmNocm9uaXplIHRoZSBmYWtlIHNjcm9sbGJhcnMgd2l0aCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlXG4gIC8vIGNvbnRlbnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xuXG4gICAgZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAoZC5iYXJXaWR0aCA9IHNpemVzLnJpZ2h0KSArIFwicHhcIjtcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXCJweFwiO1xuICAgIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFwicHggc29saWQgdHJhbnNwYXJlbnRcIjtcblxuICAgIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXCJweFwiO1xuICAgIH0gZWxzZSB7IGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gICAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgfVxuXG4gIHZhciBzY3JvbGxiYXJNb2RlbCA9IHtcIm5hdGl2ZVwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcIm51bGxcIjogTnVsbFNjcm9sbGJhcnN9O1xuXG4gIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycykge1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKCk7XG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpOyB9XG4gICAgfVxuXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IHNjcm9sbGJhck1vZGVsW2NtLm9wdGlvbnMuc2Nyb2xsYmFyU3R5bGVdKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBjbS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGNtLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKTtcbiAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xuICAgICAgb24obm9kZSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMCk7IH1cbiAgICAgIH0pO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgfSwgZnVuY3Rpb24gKHBvcywgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT0gXCJob3Jpem9udGFsXCIpIHsgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTsgfVxuICAgICAgZWxzZSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgcG9zKTsgfVxuICAgIH0sIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgeyBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgfVxuXG4gIC8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuICAvLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcbiAgLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXG5cbiAgdmFyIG5leHRPcElkID0gMDtcbiAgLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxuICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xuICAgIGNtLmN1ck9wID0ge1xuICAgICAgY206IGNtLFxuICAgICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cbiAgICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LCAvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcbiAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XG4gICAgICB1cGRhdGVJbnB1dDogMCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcbiAgICAgIHR5cGluZzogZmFsc2UsICAgICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxuICAgICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cbiAgICAgIGN1cnNvckFjdGl2aXR5Q2FsbGVkOiAwLCAvLyBUcmFja3Mgd2hpY2ggY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgaGF2ZSBiZWVuIGNhbGxlZCBhbHJlYWR5XG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cbiAgICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLCAgICAvLyBTZXQgd2hlbiB0aGUgd2lkZXN0IGxpbmUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBhbmV3XG4gICAgICBzY3JvbGxMZWZ0OiBudWxsLCBzY3JvbGxUb3A6IG51bGwsIC8vIEludGVybWVkaWF0ZSBzY3JvbGwgcG9zaXRpb24sIG5vdCBwdXNoZWQgdG8gRE9NIHlldFxuICAgICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cbiAgICAgIGZvY3VzOiBmYWxzZSxcbiAgICAgIGlkOiArK25leHRPcElkLCAgICAgICAgICAvLyBVbmlxdWUgSURcbiAgICAgIG1hcmtBcnJheXM6IG51bGwgICAgICAgICAvLyBVc2VkIGJ5IGFkZE1hcmtlZFNwYW5cbiAgICB9O1xuICAgIHB1c2hPcGVyYXRpb24oY20uY3VyT3ApO1xuICB9XG5cbiAgLy8gRmluaXNoIGFuIG9wZXJhdGlvbiwgdXBkYXRpbmcgdGhlIGRpc3BsYXkgYW5kIHNpZ25hbGxpbmcgZGVsYXllZCBldmVudHNcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uKGNtKSB7XG4gICAgdmFyIG9wID0gY20uY3VyT3A7XG4gICAgaWYgKG9wKSB7IGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBncm91cC5vcHNbaV0uY20uY3VyT3AgPSBudWxsOyB9XG4gICAgICBlbmRPcGVyYXRpb25zKGdyb3VwKTtcbiAgICB9KTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSB1cGRhdGVzIGRvbmUgd2hlbiBhbiBvcGVyYXRpb24gZmluaXNoZXMgYXJlIGJhdGNoZWQgc29cbiAgLy8gdGhhdCB0aGUgbWluaW11bSBudW1iZXIgb2YgcmVsYXlvdXRzIGFyZSByZXF1aXJlZC5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xuICAgIHZhciBvcHMgPSBncm91cC5vcHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9SMShvcHNbaV0pOyB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb3BzLmxlbmd0aDsgaSQxKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxXSk7IH1cbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBvcHMubGVuZ3RoOyBpJDIrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IyKG9wc1tpJDJdKTsgfVxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxuICAgICAgeyBlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pOyB9XG4gICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9maW5pc2gob3BzW2kkNF0pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7XG4gICAgaWYgKG9wLnVwZGF0ZU1heExpbmUpIHsgZmluZE1heExpbmUoY20pOyB9XG5cbiAgICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2Nyb2xsVG9Qb3MudG8ubGluZSA+PSBkaXNwbGF5LnZpZXdUbykgfHxcbiAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxuICAgICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKSB7XG4gICAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pOyB9XG5cbiAgICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuXG4gICAgLy8gSWYgdGhlIG1heCBsaW5lIGNoYW5nZWQgc2luY2UgaXQgd2FzIGxhc3QgbWVhc3VyZWQsIG1lYXN1cmUgaXQsXG4gICAgLy8gYW5kIGVuc3VyZSB0aGUgZG9jdW1lbnQncyB3aWR0aCBtYXRjaGVzIGl0LlxuICAgIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXG4gICAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBvcC5hZGp1c3RXaWR0aFRvID0gbWVhc3VyZUNoYXIoY20sIGRpc3BsYXkubWF4TGluZSwgZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0ICsgMztcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG9wLmFkanVzdFdpZHRoVG87XG4gICAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cbiAgICAgICAgTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKTtcbiAgICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnNlbGVjdGlvbkNoYW5nZWQpXG4gICAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtO1xuXG4gICAgaWYgKG9wLmFkanVzdFdpZHRoVG8gIT0gbnVsbCkge1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcInB4XCI7XG4gICAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxuICAgICAgICB7IHNldFNjcm9sbExlZnQoY20sIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgb3AubWF4U2Nyb2xsTGVmdCksIHRydWUpOyB9XG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpO1xuICAgIGlmIChvcC5wcmVwYXJlZFNlbGVjdGlvbilcbiAgICAgIHsgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKG9wLnByZXBhcmVkU2VsZWN0aW9uLCB0YWtlRm9jdXMpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXG4gICAgICB7IHVwZGF0ZVNjcm9sbGJhcnMoY20sIG9wLmJhck1lYXN1cmUpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KVxuICAgICAgeyBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSk7IH1cblxuICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSB7IHJlc3RhcnRCbGluayhjbSk7IH1cblxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkICYmIG9wLnVwZGF0ZUlucHV0KVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7IH1cbiAgICBpZiAodGFrZUZvY3VzKSB7IGVuc3VyZUZvY3VzKG9wLmNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX2ZpbmlzaChvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHBvc3RVcGRhdGVEaXNwbGF5KGNtLCBvcC51cGRhdGUpOyB9XG5cbiAgICAvLyBBYm9ydCBtb3VzZSB3aGVlbCBkZWx0YSBtZWFzdXJlbWVudCwgd2hlbiBzY3JvbGxpbmcgZXhwbGljaXRseVxuICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXG4gICAgICB7IGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDsgfVxuXG4gICAgLy8gUHJvcGFnYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIGFjdHVhbCBET00gc2Nyb2xsZXJcbiAgICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwpIHsgc2V0U2Nyb2xsVG9wKGNtLCBvcC5zY3JvbGxUb3AsIG9wLmZvcmNlU2Nyb2xsKTsgfVxuXG4gICAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBvcC5zY3JvbGxMZWZ0LCB0cnVlLCB0cnVlKTsgfVxuICAgIC8vIElmIHdlIG5lZWQgdG8gc2Nyb2xsIGEgc3BlY2lmaWMgcG9zaXRpb24gaW50byB2aWV3LCBkbyBzby5cbiAgICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcbiAgICAgIHZhciByZWN0ID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLnRvKSwgb3Auc2Nyb2xsVG9Qb3MubWFyZ2luKTtcbiAgICAgIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KTtcbiAgICB9XG5cbiAgICAvLyBGaXJlIGV2ZW50cyBmb3IgbWFya2VycyB0aGF0IGFyZSBoaWRkZW4vdW5pZGRlbiBieSBlZGl0aW5nIG9yXG4gICAgLy8gdW5kb2luZ1xuICAgIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XG4gICAgaWYgKGhpZGRlbikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbChoaWRkZW5baV0sIFwiaGlkZVwiKTsgfSB9IH1cbiAgICBpZiAodW5oaWRkZW4pIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdW5oaWRkZW4ubGVuZ3RoOyArK2kkMSlcbiAgICAgIHsgaWYgKHVuaGlkZGVuW2kkMV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbCh1bmhpZGRlbltpJDFdLCBcInVuaGlkZVwiKTsgfSB9IH1cblxuICAgIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KVxuICAgICAgeyBkb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7IH1cblxuICAgIC8vIEZpcmUgY2hhbmdlIGV2ZW50cywgYW5kIGRlbGF5ZWQgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAob3AuY2hhbmdlT2JqcylcbiAgICAgIHsgc2lnbmFsKGNtLCBcImNoYW5nZXNcIiwgY20sIG9wLmNoYW5nZU9ianMpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZSlcbiAgICAgIHsgb3AudXBkYXRlLmZpbmlzaCgpOyB9XG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvblxuICBmdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XG4gICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmKCkgfVxuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICB0cnkgeyByZXR1cm4gZigpIH1cbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICB9XG4gIC8vIFdyYXBzIGEgZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uLiBSZXR1cm5zIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkoY20sIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkoY20sIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgICB9XG4gIH1cbiAgLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cbiAgLy8gb3BlcmF0aW9ucy5cbiAgZnVuY3Rpb24gbWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcyk7IH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZG9jTWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjbSA9IHRoaXMuY207XG4gICAgICBpZiAoIWNtIHx8IGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhJR0hMSUdIVCBXT1JLRVJcblxuICBmdW5jdGlvbiBzdGFydFdvcmtlcihjbSwgdGltZSkge1xuICAgIGlmIChjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIHsgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0V29ya2VyKGNtKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIGNtLm9wdGlvbnMud29ya1RpbWU7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIpO1xuICAgIHZhciBjaGFuZ2VkTGluZXMgPSBbXTtcblxuICAgIGRvYy5pdGVyKGNvbnRleHQubGluZSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChjb250ZXh0LmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXG4gICAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcztcbiAgICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggPyBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpIDogbnVsbDtcbiAgICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXNldFN0YXRlKSB7IGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlOyB9XG4gICAgICAgIGxpbmUuc3R5bGVzID0gaGlnaGxpZ2h0ZWQuc3R5bGVzO1xuICAgICAgICB2YXIgb2xkQ2xzID0gbGluZS5zdHlsZUNsYXNzZXMsIG5ld0NscyA9IGhpZ2hsaWdodGVkLmNsYXNzZXM7XG4gICAgICAgIGlmIChuZXdDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBuZXdDbHM7IH1cbiAgICAgICAgZWxzZSBpZiAob2xkQ2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxuICAgICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8XG4gICAgICAgICAgb2xkQ2xzICE9IG5ld0NscyAmJiAoIW9sZENscyB8fCAhbmV3Q2xzIHx8IG9sZENscy5iZ0NsYXNzICE9IG5ld0Nscy5iZ0NsYXNzIHx8IG9sZENscy50ZXh0Q2xhc3MgIT0gbmV3Q2xzLnRleHRDbGFzcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgeyBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTsgfVxuICAgICAgICBpZiAoaXNjaGFuZ2UpIHsgY2hhbmdlZExpbmVzLnB1c2goY29udGV4dC5saW5lKTsgfVxuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpXG4gICAgICAgICAgeyBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBjb250ZXh0KTsgfVxuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LmxpbmUgJSA1ID09IDAgPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgrbmV3IERhdGUgPiBlbmQpIHtcbiAgICAgICAgc3RhcnRXb3JrZXIoY20sIGNtLm9wdGlvbnMud29ya0RlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBjb250ZXh0LmxpbmU7XG4gICAgZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGRvYy5tb2RlRnJvbnRpZXIsIGNvbnRleHQubGluZSk7XG4gICAgaWYgKGNoYW5nZWRMaW5lcy5sZW5ndGgpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkTGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2ldLCBcInRleHRcIik7IH1cbiAgICB9KTsgfVxuICB9XG5cbiAgLy8gRElTUExBWSBEUkFXSU5HXG5cbiAgdmFyIERpc3BsYXlVcGRhdGUgPSBmdW5jdGlvbihjbSwgdmlld3BvcnQsIGZvcmNlKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgIHRoaXMuZWRpdG9ySXNIaWRkZW4gPSAhZGlzcGxheS53cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgIHRoaXMud3JhcHBlckhlaWdodCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5vbGREaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGgoY20pO1xuICAgIHRoaXMuZm9yY2UgPSBmb3JjZTtcbiAgICB0aGlzLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICB9O1xuXG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkpXG4gICAgICB7IHRoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKTsgfVxuICB9O1xuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHsgc2lnbmFsLmFwcGx5KG51bGwsIHRoaXMuZXZlbnRzW2ldKTsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkICYmIGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcbiAgICAgIGRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLmhlaWdodCA9IHNjcm9sbEdhcChjbSkgKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zaXplci5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvblNuYXBzaG90KGNtKSB7XG4gICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBhY3RpdmUgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAoIWFjdGl2ZSB8fCAhY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBhY3RpdmUpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcmVzdWx0ID0ge2FjdGl2ZUVsdDogYWN0aXZlfTtcbiAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWwuYW5jaG9yTm9kZSAmJiBzZWwuZXh0ZW5kICYmIGNvbnRhaW5zKGNtLmRpc3BsYXkubGluZURpdiwgc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIHJlc3VsdC5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHJlc3VsdC5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICByZXN1bHQuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgcmVzdWx0LmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHNuYXBzaG90KSB7XG4gICAgaWYgKCFzbmFwc2hvdCB8fCAhc25hcHNob3QuYWN0aXZlRWx0IHx8IHNuYXBzaG90LmFjdGl2ZUVsdCA9PSBhY3RpdmVFbHQoKSkgeyByZXR1cm4gfVxuICAgIHNuYXBzaG90LmFjdGl2ZUVsdC5mb2N1cygpO1xuICAgIGlmICghL14oSU5QVVR8VEVYVEFSRUEpJC8udGVzdChzbmFwc2hvdC5hY3RpdmVFbHQubm9kZU5hbWUpICYmXG4gICAgICAgIHNuYXBzaG90LmFuY2hvck5vZGUgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuYW5jaG9yTm9kZSkgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuZm9jdXNOb2RlKSkge1xuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHNuYXBzaG90LmFuY2hvck5vZGUsIHNuYXBzaG90LmFuY2hvck9mZnNldCk7XG4gICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsLmV4dGVuZChzbmFwc2hvdC5mb2N1c05vZGUsIHNuYXBzaG90LmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XG4gIC8vIChyZXR1cm5pbmcgZmFsc2UpIHdoZW4gdGhlcmUgaXMgbm90aGluZyB0byBiZSBkb25lIGFuZCBmb3JjZWQgaXNcbiAgLy8gZmFsc2UuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAodXBkYXRlLmVkaXRvcklzSGlkZGVuKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXG4gICAgaWYgKCF1cGRhdGUuZm9yY2UgJiZcbiAgICAgICAgdXBkYXRlLnZpc2libGUuZnJvbSA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGRpc3BsYXkudmlld1RvICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcbiAgICAgICAgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmIGNvdW50RGlydHlWaWV3KGNtKSA9PSAwKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSkge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHVwZGF0ZS5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHN1aXRhYmxlIG5ldyB2aWV3cG9ydCAoZnJvbSAmIHRvKVxuICAgIHZhciBlbmQgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZTtcbiAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHVwZGF0ZS52aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xuICAgIHZhciB0byA9IE1hdGgubWluKGVuZCwgdXBkYXRlLnZpc2libGUudG8gKyBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKTtcbiAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA8IGZyb20gJiYgZnJvbSAtIGRpc3BsYXkudmlld0Zyb20gPCAyMCkgeyBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTsgfVxuICAgIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvICYmIGRpc3BsYXkudmlld1RvIC0gdG8gPCAyMCkgeyB0byA9IE1hdGgubWluKGVuZCwgZGlzcGxheS52aWV3VG8pOyB9XG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XG4gICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XG4gICAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW50ID0gZnJvbSAhPSBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvICE9IGRpc3BsYXkudmlld1RvIHx8XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKTtcblxuICAgIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpO1xuICAgIC8vIFBvc2l0aW9uIHRoZSBtb3ZlciBkaXYgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFwicHhcIjtcblxuICAgIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKTtcbiAgICBpZiAoIWRpZmZlcmVudCAmJiB0b1VwZGF0ZSA9PSAwICYmICF1cGRhdGUuZm9yY2UgJiYgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAvLyBGb3IgYmlnIGNoYW5nZXMsIHdlIGhpZGUgdGhlIGVuY2xvc2luZyBlbGVtZW50IGR1cmluZyB0aGVcbiAgICAvLyB1cGRhdGUsIHNpbmNlIHRoYXQgc3BlZWRzIHVwIHRoZSBvcGVyYXRpb25zIG9uIG1vc3QgYnJvd3NlcnMuXG4gICAgdmFyIHNlbFNuYXBzaG90ID0gc2VsZWN0aW9uU25hcHNob3QoY20pO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgfVxuICAgIHBhdGNoRGlzcGxheShjbSwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycywgdXBkYXRlLmRpbXMpO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gICAgZGlzcGxheS5yZW5kZXJlZFZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgLy8gVGhlcmUgbWlnaHQgaGF2ZSBiZWVuIGEgd2lkZ2V0IHdpdGggYSBmb2N1c2VkIGVsZW1lbnQgdGhhdCBnb3RcbiAgICAvLyBoaWRkZW4gb3IgdXBkYXRlZCwgaWYgc28gcmUtZm9jdXMgaXQuXG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxTbmFwc2hvdCk7XG5cbiAgICAvLyBQcmV2ZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycyBmcm9tIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtcbiAgICBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSAwO1xuXG4gICAgaWYgKGRpZmZlcmVudCkge1xuICAgICAgZGlzcGxheS5sYXN0V3JhcEhlaWdodCA9IHVwZGF0ZS53cmFwcGVySGVpZ2h0O1xuICAgICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuICAgIH1cblxuICAgIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcbiAgICB2YXIgdmlld3BvcnQgPSB1cGRhdGUudmlld3BvcnQ7XG5cbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcbiAgICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsKVxuICAgICAgICAgIHsgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX07IH1cbiAgICAgICAgLy8gVXBkYXRlZCBsaW5lIGhlaWdodHMgbWlnaHQgcmVzdWx0IGluIHRoZSBkcmF3biBhcmVhIG5vdFxuICAgICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgICAgICB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkgeyBicmVhayB9XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHVwZGF0ZS5mb3JjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidXBkYXRlXCIsIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xuICAgICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ2aWV3cG9ydENoYW5nZVwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pO1xuICAgICAgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3RnJvbTsgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbyA9IGNtLmRpc3BsYXkudmlld1RvO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHZpZXdwb3J0KSB7XG4gICAgdmFyIHVwZGF0ZSA9IG5ldyBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydCk7XG4gICAgaWYgKHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkge1xuICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSk7XG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHVwZGF0ZS5maW5pc2goKTtcbiAgICB9XG4gIH1cblxuICAvLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xuICAvLyBub2RlcyBmb3IgbGluZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHZpZXcsIGFuZCBjcmVhdGluZyB0aGUgb25lc1xuICAvLyB0aGF0IGFyZSBub3QgdGhlcmUgeWV0LCBhbmQgdXBkYXRpbmcgdGhlIG9uZXMgdGhhdCBhcmUgb3V0IG9mXG4gIC8vIGRhdGUuXG4gIGZ1bmN0aW9uIHBhdGNoRGlzcGxheShjbSwgdXBkYXRlTnVtYmVyc0Zyb20sIGRpbXMpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGxpbmVOdW1iZXJzID0gY20ub3B0aW9ucy5saW5lTnVtYmVycztcbiAgICB2YXIgY29udGFpbmVyID0gZGlzcGxheS5saW5lRGl2LCBjdXIgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgIGZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIC8vIFdvcmtzIGFyb3VuZCBhIHRocm93LXNjcm9sbCBidWcgaW4gT1MgWCBXZWJraXRcbiAgICAgIGlmICh3ZWJraXQgJiYgbWFjICYmIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID09IG5vZGUpXG4gICAgICAgIHsgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7IH1cbiAgICAgIHJldHVybiBuZXh0XG4gICAgfVxuXG4gICAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbTtcbiAgICAvLyBMb29wIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoZSB2aWV3LCBzeW5jaW5nIGN1ciAodGhlIERPTSBub2Rlc1xuICAgIC8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAobGluZVZpZXcuaGlkZGVuKSA7IGVsc2UgaWYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3Lm5vZGUucGFyZW50Tm9kZSAhPSBjb250YWluZXIpIHsgLy8gTm90IGRyYXduIHlldFxuICAgICAgICB2YXIgbm9kZSA9IGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobm9kZSwgY3VyKTtcbiAgICAgIH0gZWxzZSB7IC8vIEFscmVhZHkgZHJhd25cbiAgICAgICAgd2hpbGUgKGN1ciAhPSBsaW5lVmlldy5ub2RlKSB7IGN1ciA9IHJtKGN1cik7IH1cbiAgICAgICAgdmFyIHVwZGF0ZU51bWJlciA9IGxpbmVOdW1iZXJzICYmIHVwZGF0ZU51bWJlcnNGcm9tICE9IG51bGwgJiZcbiAgICAgICAgICB1cGRhdGVOdW1iZXJzRnJvbSA8PSBsaW5lTiAmJiBsaW5lVmlldy5saW5lTnVtYmVyO1xuICAgICAgICBpZiAobGluZVZpZXcuY2hhbmdlcykge1xuICAgICAgICAgIGlmIChpbmRleE9mKGxpbmVWaWV3LmNoYW5nZXMsIFwiZ3V0dGVyXCIpID4gLTEpIHsgdXBkYXRlTnVtYmVyID0gZmFsc2U7IH1cbiAgICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4obGluZVZpZXcubGluZU51bWJlcik7XG4gICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplO1xuICAgIH1cbiAgICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cik7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpIHtcbiAgICB2YXIgd2lkdGggPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0ID0gd2lkdGggKyBcInB4XCI7XG4gICAgLy8gU2VuZCBhbiBldmVudCB0byBjb25zdW1lcnMgcmVzcG9uZGluZyB0byBjaGFuZ2VzIGluIGd1dHRlciB3aWR0aC5cbiAgICBzaWduYWxMYXRlcihkaXNwbGF5LCBcImd1dHRlckNoYW5nZWRcIiwgZGlzcGxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREb2N1bWVudEhlaWdodChjbSwgbWVhc3VyZSkge1xuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgY20uZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IChtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0ICsgc2Nyb2xsR2FwKGNtKSkgKyBcInB4XCI7XG4gIH1cblxuICAvLyBSZS1hbGlnbiBsaW5lIG51bWJlcnMgYW5kIGd1dHRlciBtYXJrcyB0byBjb21wZW5zYXRlIGZvclxuICAvLyBob3Jpem9udGFsIHNjcm9sbGluZy5cbiAgZnVuY3Rpb24gYWxpZ25Ib3Jpem9udGFsbHkoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFkaXNwbGF5LmFsaWduV2lkZ2V0cyAmJiAoIWRpc3BsYXkuZ3V0dGVycy5maXJzdENoaWxkIHx8ICFjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSkgeyByZXR1cm4gfVxuICAgIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdDtcbiAgICB2YXIgZ3V0dGVyVyA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCwgbGVmdCA9IGNvbXAgKyBcInB4XCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7IGlmICghdmlld1tpXS5oaWRkZW4pIHtcbiAgICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICAgIGlmICh2aWV3W2ldLmd1dHRlcilcbiAgICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQgPSBsZWZ0OyB9XG4gICAgICAgIGlmICh2aWV3W2ldLmd1dHRlckJhY2tncm91bmQpXG4gICAgICAgICAgeyB2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQ7IH1cbiAgICAgIH1cbiAgICAgIHZhciBhbGlnbiA9IHZpZXdbaV0uYWxpZ25hYmxlO1xuICAgICAgaWYgKGFsaWduKSB7IGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXG4gICAgICAgIHsgYWxpZ25bal0uc3R5bGUubGVmdCA9IGxlZnQ7IH0gfVxuICAgIH0gfVxuICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKVxuICAgICAgeyBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IChjb21wICsgZ3V0dGVyVykgKyBcInB4XCI7IH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcbiAgLy8gc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2l6ZS4gUmV0dXJucyB0cnVlIHdoZW4gYW4gdXBkYXRlXG4gIC8vIGlzIG5lZWRlZC5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZU51bWJlcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGFzdC5sZW5ndGggIT0gZGlzcGxheS5saW5lTnVtQ2hhcnMpIHtcbiAgICAgIHZhciB0ZXN0ID0gZGlzcGxheS5tZWFzdXJlLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIGxhc3QpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO1xuICAgICAgdmFyIGlubmVyVyA9IHRlc3QuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgcGFkZGluZyA9IHRlc3Qub2Zmc2V0V2lkdGggLSBpbm5lclc7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZykgKyAxO1xuICAgICAgZGlzcGxheS5saW5lTnVtV2lkdGggPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgcGFkZGluZztcbiAgICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTE7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBkaXNwbGF5LmxpbmVOdW1XaWR0aCArIFwicHhcIjtcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtLmRpc3BsYXkpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBnZXRHdXR0ZXJzKGd1dHRlcnMsIGxpbmVOdW1iZXJzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBzYXdMaW5lTnVtYmVycyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3V0dGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBndXR0ZXJzW2ldLCBzdHlsZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIikgeyBzdHlsZSA9IG5hbWUuc3R5bGU7IG5hbWUgPSBuYW1lLmNsYXNzTmFtZTsgfVxuICAgICAgaWYgKG5hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgaWYgKCFsaW5lTnVtYmVycykgeyBjb250aW51ZSB9XG4gICAgICAgIGVsc2UgeyBzYXdMaW5lTnVtYmVycyA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHtjbGFzc05hbWU6IG5hbWUsIHN0eWxlOiBzdHlsZX0pO1xuICAgIH1cbiAgICBpZiAobGluZU51bWJlcnMgJiYgIXNhd0xpbmVOdW1iZXJzKSB7IHJlc3VsdC5wdXNoKHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiLCBzdHlsZTogbnVsbH0pOyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gUmVidWlsZCB0aGUgZ3V0dGVyIGVsZW1lbnRzLCBlbnN1cmUgdGhlIG1hcmdpbiB0byB0aGUgbGVmdCBvZiB0aGVcbiAgLy8gY29kZSBtYXRjaGVzIHRoZWlyIHdpZHRoLlxuICBmdW5jdGlvbiByZW5kZXJHdXR0ZXJzKGRpc3BsYXkpIHtcbiAgICB2YXIgZ3V0dGVycyA9IGRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBkaXNwbGF5Lmd1dHRlclNwZWNzO1xuICAgIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpO1xuICAgIGRpc3BsYXkubGluZUd1dHRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHJlZiA9IHNwZWNzW2ldO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgZ0VsdCA9IGd1dHRlcnMuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXIgXCIgKyBjbGFzc05hbWUpKTtcbiAgICAgIGlmIChzdHlsZSkgeyBnRWx0LnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIikge1xuICAgICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0O1xuICAgICAgICBnRWx0LnN0eWxlLndpZHRoID0gKGRpc3BsYXkubGluZU51bVdpZHRoIHx8IDEpICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBndXR0ZXJzLnN0eWxlLmRpc3BsYXkgPSBzcGVjcy5sZW5ndGggPyBcIlwiIDogXCJub25lXCI7XG4gICAgdXBkYXRlR3V0dGVyU3BhY2UoZGlzcGxheSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XG4gICAgcmVuZGVyR3V0dGVycyhjbS5kaXNwbGF5KTtcbiAgICByZWdDaGFuZ2UoY20pO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgfVxuXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xuICAvLyBhbmQgY29udGVudCBkcmF3aW5nLiBJdCBob2xkcyByZWZlcmVuY2VzIHRvIERPTSBub2RlcyBhbmRcbiAgLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxuXG4gIGZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZCA9IHRoaXM7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgLy8gQ292ZXJzIGJvdHRvbS1yaWdodCBzcXVhcmUgd2hlbiBib3RoIHNjcm9sbGJhcnMgYXJlIHByZXNlbnQuXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIik7XG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cbiAgICAvLyBhbmQgaCBzY3JvbGxiYXIgaXMgcHJlc2VudC5cbiAgICBkLmd1dHRlckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKTtcbiAgICBkLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXG4gICAgZC5saW5lRGl2ID0gZWx0UChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY29kZVwiKTtcbiAgICAvLyBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlc2UgdG8gcmVwcmVzZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycy5cbiAgICBkLnNlbGVjdGlvbkRpdiA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVwiKTtcbiAgICBkLmN1cnNvckRpdiA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTtcbiAgICAvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXG4gICAgZC5tZWFzdXJlID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1tZWFzdXJlXCIpO1xuICAgIC8vIFdoZW4gbGluZXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgYXJlIG1lYXN1cmVkLCB0aGV5IGFyZSBkcmF3biBpbiB0aGlzLlxuICAgIGQubGluZU1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV3JhcHMgZXZlcnl0aGluZyB0aGF0IG5lZWRzIHRvIGV4aXN0IGluc2lkZSB0aGUgdmVydGljYWxseS1wYWRkZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBkLmxpbmVTcGFjZSA9IGVsdFAoXCJkaXZcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXCIpO1xuICAgIHZhciBsaW5lcyA9IGVsdFAoXCJkaXZcIiwgW2QubGluZVNwYWNlXSwgXCJDb2RlTWlycm9yLWxpbmVzXCIpO1xuICAgIC8vIE1vdmVkIGFyb3VuZCBpdHMgcGFyZW50IHRvIGNvdmVyIHZpc2libGUgdmlldy5cbiAgICBkLm1vdmVyID0gZWx0KFwiZGl2XCIsIFtsaW5lc10sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgIC8vIFNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgYWxsb3dpbmcgc2Nyb2xsaW5nLlxuICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XG4gICAgZC5zaXplcldpZHRoID0gbnVsbDtcbiAgICAvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcbiAgICAvLyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoZVxuICAgIC8vIHNjcm9sbGFibGUgYXJlYSBpcyBiaWcgZW5vdWdoLlxuICAgIGQuaGVpZ2h0Rm9yY2VyID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IFwiICsgc2Nyb2xsZXJHYXAgKyBcInB4OyB3aWR0aDogMXB4O1wiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cbiAgICBkLmd1dHRlcnMgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlcnNcIik7XG4gICAgZC5saW5lR3V0dGVyID0gbnVsbDtcbiAgICAvLyBBY3R1YWwgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIGQuc2Nyb2xsZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO1xuICAgIGQuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKTtcbiAgICAvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxuICAgIGQud3JhcHBlciA9IGVsdChcImRpdlwiLCBbZC5zY3JvbGxiYXJGaWxsZXIsIGQuZ3V0dGVyRmlsbGVyLCBkLnNjcm9sbGVyXSwgXCJDb2RlTWlycm9yXCIpO1xuXG4gICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgcmVzcGVjdGVkIGJ5IGF1dG9tYXRpYyB0cmFuc2xhdGlvbiBzeXN0ZW1zIHN1Y2ggYXMgR29vZ2xlIFRyYW5zbGF0ZSxcbiAgICAvLyBhbmQgbWF5IGFsc28gYmUgcmVzcGVjdGVkIGJ5IHRvb2xzIHVzZWQgYnkgaHVtYW4gdHJhbnNsYXRvcnMuXG4gICAgZC53cmFwcGVyLnNldEF0dHJpYnV0ZSgndHJhbnNsYXRlJywgJ25vJyk7XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBJRTcgei1pbmRleCBidWcgKG5vdCBwZXJmZWN0LCBoZW5jZSBJRTcgbm90IHJlYWxseSBiZWluZyBzdXBwb3J0ZWQpXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwOyB9XG4gICAgaWYgKCF3ZWJraXQgJiYgIShnZWNrbyAmJiBtb2JpbGUpKSB7IGQuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHBsYWNlKSB7XG4gICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHsgcGxhY2UuYXBwZW5kQ2hpbGQoZC53cmFwcGVyKTsgfVxuICAgICAgZWxzZSB7IHBsYWNlKGQud3JhcHBlcik7IH1cbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IHJlbmRlcmVkIHJhbmdlIChtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIHZpZXcgd2luZG93KS5cbiAgICBkLnZpZXdGcm9tID0gZC52aWV3VG8gPSBkb2MuZmlyc3Q7XG4gICAgZC5yZXBvcnRlZFZpZXdGcm9tID0gZC5yZXBvcnRlZFZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZWQgbGluZXMuXG4gICAgZC52aWV3ID0gW107XG4gICAgZC5yZW5kZXJlZFZpZXcgPSBudWxsO1xuICAgIC8vIEhvbGRzIGluZm8gYWJvdXQgYSBzaW5nbGUgcmVuZGVyZWQgbGluZSB3aGVuIGl0IHdhcyByZW5kZXJlZFxuICAgIC8vIGZvciBtZWFzdXJlbWVudCwgd2hpbGUgbm90IGluIHZpZXcuXG4gICAgZC5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAvLyBFbXB0eSBzcGFjZSAoaW4gcGl4ZWxzKSBhYm92ZSB0aGUgdmlld1xuICAgIGQudmlld09mZnNldCA9IDA7XG4gICAgZC5sYXN0V3JhcEhlaWdodCA9IGQubGFzdFdyYXBXaWR0aCA9IDA7XG4gICAgZC51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG5cbiAgICBkLm5hdGl2ZUJhcldpZHRoID0gZC5iYXJIZWlnaHQgPSBkLmJhcldpZHRoID0gMDtcbiAgICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIHRvIG9ubHkgcmVzaXplIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgd2hlbiBuZWNlc3NhcnkgKHdoZW5cbiAgICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGNyb3NzZXMgYSBib3VuZGFyeSB0aGF0IG1ha2VzIGl0cyB3aWR0aCBjaGFuZ2UpXG4gICAgZC5saW5lTnVtV2lkdGggPSBkLmxpbmVOdW1Jbm5lcldpZHRoID0gZC5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICAgIC8vIFNldCB0byB0cnVlIHdoZW4gYSBub24taG9yaXpvbnRhbC1zY3JvbGxpbmcgbGluZSB3aWRnZXQgaXNcbiAgICAvLyBhZGRlZC4gQXMgYW4gb3B0aW1pemF0aW9uLCBsaW5lIHdpZGdldCBhbGlnbmluZyBpcyBza2lwcGVkIHdoZW5cbiAgICAvLyB0aGlzIGlzIGZhbHNlLlxuICAgIGQuYWxpZ25XaWRnZXRzID0gZmFsc2U7XG5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuXG4gICAgLy8gVHJhY2tzIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHNvIHRoYXQgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyXG4gICAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxuICAgIGQubWF4TGluZSA9IG51bGw7XG4gICAgZC5tYXhMaW5lTGVuZ3RoID0gMDtcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIGZvciBtZWFzdXJpbmcgd2hlZWwgc2Nyb2xsaW5nIGdyYW51bGFyaXR5XG4gICAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsO1xuXG4gICAgLy8gVHJ1ZSB3aGVuIHNoaWZ0IGlzIGhlbGQgZG93bi5cbiAgICBkLnNoaWZ0ID0gZmFsc2U7XG5cbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55dGhpbmcgaGFwcGVuZWQgc2luY2UgdGhlIGNvbnRleHQgbWVudVxuICAgIC8vIHdhcyBvcGVuZWQuXG4gICAgZC5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG5cbiAgICBkLmFjdGl2ZVRvdWNoID0gbnVsbDtcblxuICAgIGQuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKG9wdGlvbnMuZ3V0dGVycywgb3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgcmVuZGVyR3V0dGVycyhkKTtcblxuICAgIGlucHV0LmluaXQoZCk7XG4gIH1cblxuICAvLyBTaW5jZSB0aGUgZGVsdGEgdmFsdWVzIHJlcG9ydGVkIG9uIG1vdXNlIHdoZWVsIGV2ZW50cyBhcmVcbiAgLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcbiAgLy8gZ2VuZXJhbGx5IGhvcnJpYmx5IHVucHJlZGljdGFibGUsIHRoaXMgY29kZSBzdGFydHMgYnkgbWVhc3VyaW5nXG4gIC8vIHRoZSBzY3JvbGwgZWZmZWN0IHRoYXQgdGhlIGZpcnN0IGZldyBtb3VzZSB3aGVlbCBldmVudHMgaGF2ZSxcbiAgLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcbiAgLy8gb2Zmc2V0cyBhZnRlcndhcmRzLlxuICAvL1xuICAvLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcbiAgLy8gaXMgdGhhdCBpdCBnaXZlcyB1cyBhIGNoYW5jZSB0byB1cGRhdGUgdGhlIGRpc3BsYXkgYmVmb3JlIHRoZVxuICAvLyBhY3R1YWwgc2Nyb2xsaW5nIGhhcHBlbnMsIHJlZHVjaW5nIGZsaWNrZXJpbmcuXG5cbiAgdmFyIHdoZWVsU2FtcGxlcyA9IDAsIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IG51bGw7XG4gIC8vIEZpbGwgaW4gYSBicm93c2VyLWRldGVjdGVkIHN0YXJ0aW5nIHZhbHVlIG9uIGJyb3dzZXJzIHdoZXJlIHdlXG4gIC8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxuICAvLyBiZWluZyB3cm9uZyB3b3VsZCBqdXN0IGJlIGEgc2xpZ2h0IGZsaWNrZXIgb24gdGhlIGZpcnN0IHdoZWVsXG4gIC8vIHNjcm9sbCAoaWYgaXQgaXMgbGFyZ2UgZW5vdWdoKS5cbiAgaWYgKGllKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNTM7IH1cbiAgZWxzZSBpZiAoZ2Vja28pIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTU7IH1cbiAgZWxzZSBpZiAoY2hyb21lKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNzsgfVxuICBlbHNlIGlmIChzYWZhcmkpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLTEvMzsgfVxuXG4gIGZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKSB7XG4gICAgdmFyIGR4ID0gZS53aGVlbERlbHRhWCwgZHkgPSBlLndoZWVsRGVsdGFZO1xuICAgIGlmIChkeCA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLkhPUklaT05UQUxfQVhJUykgeyBkeCA9IGUuZGV0YWlsOyB9XG4gICAgaWYgKGR5ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuVkVSVElDQUxfQVhJUykgeyBkeSA9IGUuZGV0YWlsOyB9XG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgeyBkeSA9IGUud2hlZWxEZWx0YTsgfVxuICAgIHJldHVybiB7eDogZHgsIHk6IGR5fVxuICB9XG4gIGZ1bmN0aW9uIHdoZWVsRXZlbnRQaXhlbHMoZSkge1xuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKTtcbiAgICBkZWx0YS54ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICBkZWx0YS55ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcbiAgICByZXR1cm4gZGVsdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcbiAgICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSksIGR4ID0gZGVsdGEueCwgZHkgPSBkZWx0YS55O1xuICAgIHZhciBwaXhlbHNQZXJVbml0ID0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMCkge1xuICAgICAgZHggPSBlLmRlbHRhWDtcbiAgICAgIGR5ID0gZS5kZWx0YVk7XG4gICAgICBwaXhlbHNQZXJVbml0ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNjcm9sbCA9IGRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcbiAgICB2YXIgY2FuU2Nyb2xsWCA9IHNjcm9sbC5zY3JvbGxXaWR0aCA+IHNjcm9sbC5jbGllbnRXaWR0aDtcbiAgICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0O1xuICAgIGlmICghKGR4ICYmIGNhblNjcm9sbFggfHwgZHkgJiYgY2FuU2Nyb2xsWSkpIHsgcmV0dXJuIH1cblxuICAgIC8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XG4gICAgLy8gb2YgdGhlIHNjcm9sbCBldmVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICAvLyBUaGlzIGhhY2sgKHNlZSByZWxhdGVkIGNvZGUgaW4gcGF0Y2hEaXNwbGF5KSBtYWtlcyBzdXJlIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXG4gICAgaWYgKGR5ICYmIG1hYyAmJiB3ZWJraXQpIHtcbiAgICAgIG91dGVyOiBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHZpZXdbaV0ubm9kZSA9PSBjdXIpIHtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gY3VyO1xuICAgICAgICAgICAgYnJlYWsgb3V0ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIGJyb3dzZXJzLCBob3Jpem9udGFsIHNjcm9sbGluZyB3aWxsIGNhdXNlIHJlZHJhd3MgdG9cbiAgICAvLyBoYXBwZW4gYmVmb3JlIHRoZSBndXR0ZXIgaGFzIGJlZW4gcmVhbGlnbmVkLCBjYXVzaW5nIGl0IHRvXG4gICAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gZXN0aW1hdGVkIHBpeGVscy9kZWx0YSB2YWx1ZSwgd2UganVzdCBoYW5kbGUgaG9yaXpvbnRhbFxuICAgIC8vIHNjcm9sbGluZyBlbnRpcmVseSBoZXJlLiBJdCdsbCBiZSBzbGlnaHRseSBvZmYgZnJvbSBuYXRpdmUsIGJ1dFxuICAgIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXG4gICAgaWYgKGR4ICYmICFnZWNrbyAmJiAhcHJlc3RvICYmIHBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpXG4gICAgICAgIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBNYXRoLm1heCgwLCBzY3JvbGwuc2Nyb2xsVG9wICsgZHkgKiBwaXhlbHNQZXJVbml0KSk7IH1cbiAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxMZWZ0ICsgZHggKiBwaXhlbHNQZXJVbml0KSk7XG4gICAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgaWYgdmVydGljYWwgc2Nyb2xsaW5nIGlzXG4gICAgICAvLyBhY3R1YWxseSBwb3NzaWJsZS4gT3RoZXJ3aXNlLCBpdCBjYXVzZXMgdmVydGljYWwgc2Nyb2xsXG4gICAgICAvLyBqaXR0ZXIgb24gT1NYIHRyYWNrcGFkcyB3aGVuIGRlbHRhWCBpcyBzbWFsbCBhbmQgZGVsdGFZXG4gICAgICAvLyBpcyBsYXJnZSAoaXNzdWUgIzM1NzkpXG4gICAgICBpZiAoIWR5IHx8IChkeSAmJiBjYW5TY3JvbGxZKSlcbiAgICAgICAgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbDsgLy8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAnUHJvamVjdCcgdGhlIHZpc2libGUgdmlld3BvcnQgdG8gY292ZXIgdGhlIGFyZWEgdGhhdCBpcyBiZWluZ1xuICAgIC8vIHNjcm9sbGVkIGludG8gdmlldyAoaWYgd2Uga25vdyBlbm91Z2ggdG8gZXN0aW1hdGUgaXQpLlxuICAgIGlmIChkeSAmJiBwaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHBpeGVsc1BlclVuaXQ7XG4gICAgICB2YXIgdG9wID0gY20uZG9jLnNjcm9sbFRvcCwgYm90ID0gdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChwaXhlbHMgPCAwKSB7IHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKTsgfVxuICAgICAgZWxzZSB7IGJvdCA9IE1hdGgubWluKGNtLmRvYy5oZWlnaHQsIGJvdCArIHBpeGVscyArIDUwKTsgfVxuICAgICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdG9wLCBib3R0b206IGJvdH0pO1xuICAgIH1cblxuICAgIGlmICh3aGVlbFNhbXBsZXMgPCAyMCAmJiBlLmRlbHRhTW9kZSAhPT0gMCkge1xuICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7IGRpc3BsYXkud2hlZWxTdGFydFkgPSBzY3JvbGwuc2Nyb2xsVG9wO1xuICAgICAgICBkaXNwbGF5LndoZWVsRFggPSBkeDsgZGlzcGxheS53aGVlbERZID0gZHk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICAgICAgICB2YXIgbW92ZWRYID0gc2Nyb2xsLnNjcm9sbExlZnQgLSBkaXNwbGF5LndoZWVsU3RhcnRYO1xuICAgICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WTtcbiAgICAgICAgICB2YXIgc2FtcGxlID0gKG1vdmVkWSAmJiBkaXNwbGF5LndoZWVsRFkgJiYgbW92ZWRZIC8gZGlzcGxheS53aGVlbERZKSB8fFxuICAgICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKTtcbiAgICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7XG4gICAgICAgICAgaWYgKCFzYW1wbGUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKTtcbiAgICAgICAgICArK3doZWVsU2FtcGxlcztcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCArPSBkeDsgZGlzcGxheS53aGVlbERZICs9IGR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlbGVjdGlvbiBvYmplY3RzIGFyZSBpbW11dGFibGUuIEEgbmV3IG9uZSBpcyBjcmVhdGVkIGV2ZXJ5IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBBIHNlbGVjdGlvbiBpcyBvbmUgb3IgbW9yZSBub24tb3ZlcmxhcHBpbmdcbiAgLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xuICAvLyB3aGljaCBvbmUgaXMgdGhlIHByaW1hcnkgc2VsZWN0aW9uICh0aGUgb25lIHRoYXQncyBzY3JvbGxlZCBpbnRvXG4gIC8vIHZpZXcsIHRoYXQgZ2V0Q3Vyc29yIHJldHVybnMsIGV0YykuXG4gIHZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgIHRoaXMucHJpbUluZGV4ID0gcHJpbUluZGV4O1xuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XSB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09IHRoaXMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVyZSA9IHRoaXMucmFuZ2VzW2ldLCB0aGVyZSA9IG90aGVyLnJhbmdlc1tpXTtcbiAgICAgIGlmICghZXF1YWxDdXJzb3JQb3MoaGVyZS5hbmNob3IsIHRoZXJlLmFuY2hvcikgfHwgIWVxdWFsQ3Vyc29yUG9zKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzLnJhbmdlc1tpXS5hbmNob3IpLCBjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmhlYWQpKTsgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgdGhpcy5wcmltSW5kZXgpXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5zb21ldGhpbmdTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoIXRoaXMucmFuZ2VzW2ldLmVtcHR5KCkpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb3MsIGVuZCkge1xuICAgIGlmICghZW5kKSB7IGVuZCA9IHBvczsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2VzW2ldO1xuICAgICAgaWYgKGNtcChlbmQsIHJhbmdlLmZyb20oKSkgPj0gMCAmJiBjbXAocG9zLCByYW5nZS50bygpKSA8PSAwKVxuICAgICAgICB7IHJldHVybiBpIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH07XG5cbiAgdmFyIFJhbmdlID0gZnVuY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5Qb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfTtcbiAgUmFuZ2UucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH07XG4gIFJhbmdlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoIH07XG5cbiAgLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXG4gIC8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xuICAvLyBpdCkuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICB2YXIgbWF5VG91Y2ggPSBjbSAmJiBjbS5vcHRpb25zLnNlbGVjdGlvbnNNYXlUb3VjaDtcbiAgICB2YXIgcHJpbSA9IHJhbmdlc1twcmltSW5kZXhdO1xuICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYS5mcm9tKCksIGIuZnJvbSgpKTsgfSk7XG4gICAgcHJpbUluZGV4ID0gaW5kZXhPZihyYW5nZXMsIHByaW0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgIHZhciBkaWZmID0gY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSk7XG4gICAgICBpZiAobWF5VG91Y2ggJiYgIWN1ci5lbXB0eSgpID8gZGlmZiA+IDAgOiBkaWZmID49IDApIHtcbiAgICAgICAgdmFyIGZyb20gPSBtaW5Qb3MocHJldi5mcm9tKCksIGN1ci5mcm9tKCkpLCB0byA9IG1heFBvcyhwcmV2LnRvKCksIGN1ci50bygpKTtcbiAgICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWQ7XG4gICAgICAgIGlmIChpIDw9IHByaW1JbmRleCkgeyAtLXByaW1JbmRleDsgfVxuICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KVxuICB9XG5cbiAgZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcbiAgLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXG4gIGZ1bmN0aW9uIGNoYW5nZUVuZChjaGFuZ2UpIHtcbiAgICBpZiAoIWNoYW5nZS50ZXh0KSB7IHJldHVybiBjaGFuZ2UudG8gfVxuICAgIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSA/IGNoYW5nZS5mcm9tLmNoIDogMCkpXG4gIH1cblxuICAvLyBBZGp1c3QgYSBwb3NpdGlvbiB0byByZWZlciB0byB0aGUgcG9zdC1jaGFuZ2UgcG9zaXRpb24gb2YgdGhlXG4gIC8vIHNhbWUgdGV4dCwgb3IgdGhlIGVuZCBvZiB0aGUgY2hhbmdlIGlmIHRoZSBjaGFuZ2UgY292ZXJzIGl0LlxuICBmdW5jdGlvbiBhZGp1c3RGb3JDaGFuZ2UocG9zLCBjaGFuZ2UpIHtcbiAgICBpZiAoY21wKHBvcywgY2hhbmdlLmZyb20pIDwgMCkgeyByZXR1cm4gcG9zIH1cbiAgICBpZiAoY21wKHBvcywgY2hhbmdlLnRvKSA8PSAwKSB7IHJldHVybiBjaGFuZ2VFbmQoY2hhbmdlKSB9XG5cbiAgICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaDtcbiAgICBpZiAocG9zLmxpbmUgPT0gY2hhbmdlLnRvLmxpbmUpIHsgY2ggKz0gY2hhbmdlRW5kKGNoYW5nZSkuY2ggLSBjaGFuZ2UudG8uY2g7IH1cbiAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZS5hbmNob3IsIGNoYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmhlYWQsIGNoYW5nZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XG4gICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKVxuICAgICAgeyByZXR1cm4gUG9zKG53LmxpbmUsIHBvcy5jaCAtIG9sZC5jaCArIG53LmNoKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gUG9zKG53LmxpbmUgKyAocG9zLmxpbmUgLSBvbGQubGluZSksIHBvcy5jaCkgfVxuICB9XG5cbiAgLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcInN0YXJ0XCIgb3IgXCJhcm91bmRcIi5cbiAgZnVuY3Rpb24gY29tcHV0ZVJlcGxhY2VkU2VsKGRvYywgY2hhbmdlcywgaGludCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXRQb3MoY2hhbmdlLmZyb20sIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIG9sZFByZXYgPSBjaGFuZ2UudG87XG4gICAgICBuZXdQcmV2ID0gdG87XG4gICAgICBpZiAoaGludCA9PSBcImFyb3VuZFwiKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDA7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCB0aGUgZWRpdG9yIGludG8gYSBjb25zaXN0ZW50IHN0YXRlIGFnYWluIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG5cbiAgZnVuY3Rpb24gbG9hZE1vZGUoY20pIHtcbiAgICBjbS5kb2MubW9kZSA9IGdldE1vZGUoY20ub3B0aW9ucywgY20uZG9jLm1vZGVPcHRpb24pO1xuICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKSB7XG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgICAgaWYgKGxpbmUuc3R5bGVzKSB7IGxpbmUuc3R5bGVzID0gbnVsbDsgfVxuICAgIH0pO1xuICAgIGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gICAgY20uc3RhdGUubW9kZUdlbisrO1xuICAgIGlmIChjbS5jdXJPcCkgeyByZWdDaGFuZ2UoY20pOyB9XG4gIH1cblxuICAvLyBET0NVTUVOVCBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIEJ5IGRlZmF1bHQsIHVwZGF0ZXMgdGhhdCBzdGFydCBhbmQgZW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gIC8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxuICAvLyB3aWRnZXRzIGFuZCBtYXJrZXIgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBiZWhhdmUgbW9yZSBpbnR1aXRpdmUuXG4gIGZ1bmN0aW9uIGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSB7XG4gICAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcIlwiICYmXG4gICAgICAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpXG4gIH1cblxuICAvLyBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBkb2N1bWVudCBkYXRhIHN0cnVjdHVyZS5cbiAgZnVuY3Rpb24gdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7cmV0dXJuIG1hcmtlZFNwYW5zID8gbWFya2VkU3BhbnNbbl0gOiBudWxsfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0LCBzcGFucykge1xuICAgICAgdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBzcGFucywgZXN0aW1hdGVIZWlnaHQpO1xuICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJjaGFuZ2VcIiwgbGluZSwgY2hhbmdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpXG4gICAgICAgIHsgcmVzdWx0LnB1c2gobmV3IExpbmUodGV4dFtpXSwgc3BhbnNGb3IoaSksIGVzdGltYXRlSGVpZ2h0KSk7IH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xuICAgIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSk7XG4gICAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxuICAgIGlmIChjaGFuZ2UuZnVsbCkge1xuICAgICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgZG9jLnJlbW92ZSh0ZXh0Lmxlbmd0aCwgZG9jLnNpemUgLSB0ZXh0Lmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcbiAgICAgIC8vIHN1cmUgbGluZSBvYmplY3RzIG1vdmUgdGhlIHdheSB0aGV5IGFyZSBzdXBwb3NlZCB0by5cbiAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XG4gICAgICBpZiAobmxpbmVzKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lLCBubGluZXMpOyB9XG4gICAgICBpZiAoYWRkZWQubGVuZ3RoKSB7IGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7IH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0TGluZSA9PSBsYXN0TGluZSkge1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyBsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZGRlZCQxID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgYWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSk7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKTtcbiAgICAgIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RUZXh0ICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB2YXIgYWRkZWQkMiA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAobmxpbmVzID4gMSkgeyBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyAtIDEpOyB9XG4gICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDIpO1xuICAgIH1cblxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjaGFuZ2VcIiwgZG9jLCBjaGFuZ2UpO1xuICB9XG5cbiAgLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbGlua2VkRG9jcyhkb2MsIGYsIHNoYXJlZEhpc3RPbmx5KSB7XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xuICAgICAgaWYgKGRvYy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZWwgPSBkb2MubGlua2VkW2ldO1xuICAgICAgICBpZiAocmVsLmRvYyA9PSBza2lwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIHNoYXJlZCA9IHNoYXJlZEhpc3QgJiYgcmVsLnNoYXJlZEhpc3Q7XG4gICAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZihyZWwuZG9jLCBzaGFyZWQpO1xuICAgICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpO1xuICAgICAgfSB9XG4gICAgfVxuICAgIHByb3BhZ2F0ZShkb2MsIG51bGwsIHRydWUpO1xuICB9XG5cbiAgLy8gQXR0YWNoIGEgZG9jdW1lbnQgdG8gYW4gZWRpdG9yLlxuICBmdW5jdGlvbiBhdHRhY2hEb2MoY20sIGRvYykge1xuICAgIGlmIChkb2MuY20pIHsgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIikgfVxuICAgIGNtLmRvYyA9IGRvYztcbiAgICBkb2MuY20gPSBjbTtcbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcbiAgICBsb2FkTW9kZShjbSk7XG4gICAgc2V0RGlyZWN0aW9uQ2xhc3MoY20pO1xuICAgIGNtLm9wdGlvbnMuZGlyZWN0aW9uID0gZG9jLmRpcmVjdGlvbjtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZpbmRNYXhMaW5lKGNtKTsgfVxuICAgIGNtLm9wdGlvbnMubW9kZSA9IGRvYy5tb2RlT3B0aW9uO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREaXJlY3Rpb25DbGFzcyhjbSkge1xuICAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gYWRkQ2xhc3MgOiBybUNsYXNzKShjbS5kaXNwbGF5LmxpbmVEaXYsIFwiQ29kZU1pcnJvci1ydGxcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkaXJlY3Rpb25DaGFuZ2VkKGNtKSB7XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0RGlyZWN0aW9uQ2xhc3MoY20pO1xuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhpc3RvcnkocHJldikge1xuICAgIC8vIEFycmF5cyBvZiBjaGFuZ2UgZXZlbnRzIGFuZCBzZWxlY3Rpb25zLiBEb2luZyBzb21ldGhpbmcgYWRkcyBhblxuICAgIC8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcbiAgICAvLyB0byB1bmRvbmUsIHJlZG9pbmcgbW92ZXMgdGhlbSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgIHRoaXMuZG9uZSA9IFtdOyB0aGlzLnVuZG9uZSA9IFtdO1xuICAgIHRoaXMudW5kb0RlcHRoID0gcHJldiA/IHByZXYudW5kb0RlcHRoIDogSW5maW5pdHk7XG4gICAgLy8gVXNlZCB0byB0cmFjayB3aGVuIGNoYW5nZXMgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIHVuZG9cbiAgICAvLyBldmVudFxuICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLmxhc3RTZWxUaW1lID0gMDtcbiAgICB0aGlzLmxhc3RPcCA9IHRoaXMubGFzdFNlbE9wID0gbnVsbDtcbiAgICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIC8vIFVzZWQgYnkgdGhlIGlzQ2xlYW4oKSBtZXRob2RcbiAgICB0aGlzLmdlbmVyYXRpb24gPSB0aGlzLm1heEdlbmVyYXRpb24gPSBwcmV2ID8gcHJldi5tYXhHZW5lcmF0aW9uIDogMTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxuICAvLyBvYmplY3QuXG4gIGZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfTtcbiAgICBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7IH0sIHRydWUpO1xuICAgIHJldHVybiBoaXN0Q2hhbmdlXG4gIH1cblxuICAvLyBQb3AgYWxsIHNlbGVjdGlvbiBldmVudHMgb2ZmIHRoZSBlbmQgb2YgYSBoaXN0b3J5IGFycmF5LiBTdG9wIGF0XG4gIC8vIGEgY2hhbmdlIGV2ZW50LlxuICBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbkV2ZW50cyhhcnJheSkge1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHZhciBsYXN0ID0gbHN0KGFycmF5KTtcbiAgICAgIGlmIChsYXN0LnJhbmdlcykgeyBhcnJheS5wb3AoKTsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0b3AgY2hhbmdlIGV2ZW50IGluIHRoZSBoaXN0b3J5LiBQb3Agb2ZmIHNlbGVjdGlvblxuICAvLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cbiAgZnVuY3Rpb24gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpO1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoICYmICFsc3QoaGlzdC5kb25lKS5yYW5nZXMpIHtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCA+IDEgJiYgIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMl0ucmFuZ2VzKSB7XG4gICAgICBoaXN0LmRvbmUucG9wKCk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBhIGNoYW5nZSBpbiB0aGUgaGlzdG9yeS4gTWVyZ2VzIGNoYW5nZXMgdGhhdCBhcmUgd2l0aGluXG4gIC8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3IgYXJlIGNsb3NlIHRvZ2V0aGVyIHdpdGggYW4gb3JpZ2luIHRoYXRcbiAgLy8gYWxsb3dzIG1lcmdpbmcgKHN0YXJ0aW5nIHdpdGggXCIrXCIpIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gIGZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5O1xuICAgIGhpc3QudW5kb25lLmxlbmd0aCA9IDA7XG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1cjtcbiAgICB2YXIgbGFzdDtcblxuICAgIGlmICgoaGlzdC5sYXN0T3AgPT0gb3BJZCB8fFxuICAgICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxuICAgICAgICAgKChjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcIitcIiAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMCkpIHx8XG4gICAgICAgICAgY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIqXCIpKSAmJlxuICAgICAgICAoY3VyID0gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGhpc3QubGFzdE9wID09IG9wSWQpKSkge1xuICAgICAgLy8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxuICAgICAgbGFzdCA9IGxzdChjdXIuY2hhbmdlcyk7XG4gICAgICBpZiAoY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDAgJiYgY21wKGNoYW5nZS5mcm9tLCBsYXN0LnRvKSA9PSAwKSB7XG4gICAgICAgIC8vIE9wdGltaXplZCBjYXNlIGZvciBzaW1wbGUgaW5zZXJ0aW9uIC0tIGRvbid0IHdhbnQgdG8gYWRkXG4gICAgICAgIC8vIG5ldyBjaGFuZ2VzZXRzIGZvciBldmVyeSBjaGFyYWN0ZXIgdHlwZWRcbiAgICAgICAgbGFzdC50byA9IGNoYW5nZUVuZChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIG5ldyBzdWItZXZlbnRcbiAgICAgICAgY3VyLmNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYW4gbm90IGJlIG1lcmdlZCwgc3RhcnQgYSBuZXcgZXZlbnQuXG4gICAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSk7XG4gICAgICBpZiAoIWJlZm9yZSB8fCAhYmVmb3JlLnJhbmdlcylcbiAgICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSk7IH1cbiAgICAgIGN1ciA9IHtjaGFuZ2VzOiBbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpXSxcbiAgICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xuICAgICAgaGlzdC5kb25lLnB1c2goY3VyKTtcbiAgICAgIHdoaWxlIChoaXN0LmRvbmUubGVuZ3RoID4gaGlzdC51bmRvRGVwdGgpIHtcbiAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaGlzdC5kb25lWzBdLnJhbmdlcykgeyBoaXN0LmRvbmUuc2hpZnQoKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcik7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gKytoaXN0Lm1heEdlbmVyYXRpb247XG4gICAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lO1xuICAgIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IGNoYW5nZS5vcmlnaW47XG5cbiAgICBpZiAoIWxhc3QpIHsgc2lnbmFsKGRvYywgXCJoaXN0b3J5QWRkZWRcIik7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xuICAgIHZhciBjaCA9IG9yaWdpbi5jaGFyQXQoMCk7XG4gICAgcmV0dXJuIGNoID09IFwiKlwiIHx8XG4gICAgICBjaCA9PSBcIitcIiAmJlxuICAgICAgcHJldi5yYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmXG4gICAgICBwcmV2LnNvbWV0aGluZ1NlbGVjdGVkKCkgPT0gc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkgJiZcbiAgICAgIG5ldyBEYXRlIC0gZG9jLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xuICAvLyB0aGUgcGVuZGluZyBzZWxlY3Rpb24gaW4gdGhlIGhpc3RvcnksIGFuZCBwdXNoZXMgdGhlIG9sZCBwZW5kaW5nXG4gIC8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxuICAvLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXG4gIGZ1bmN0aW9uIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIHNlbCwgb3BJZCwgb3B0aW9ucykge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW47XG5cbiAgICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxuICAgIC8vIHRoZSBjdXJyZW50LCBvciB0aGUgb3JpZ2lucyBkb24ndCBhbGxvdyBtYXRjaGluZy4gT3JpZ2luc1xuICAgIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxuICAgIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXG4gICAgaWYgKG9wSWQgPT0gaGlzdC5sYXN0U2VsT3AgfHxcbiAgICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXG4gICAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcbiAgICAgICAgICBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBsc3QoaGlzdC5kb25lKSwgc2VsKSkpKVxuICAgICAgeyBoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDFdID0gc2VsOyB9XG4gICAgZWxzZVxuICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgaGlzdC5kb25lKTsgfVxuXG4gICAgaGlzdC5sYXN0U2VsVGltZSA9ICtuZXcgRGF0ZTtcbiAgICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW47XG4gICAgaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2xlYXJSZWRvICE9PSBmYWxzZSlcbiAgICAgIHsgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC51bmRvbmUpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xuICAgIHZhciB0b3AgPSBsc3QoZGVzdCk7XG4gICAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcbiAgICAgIHsgZGVzdC5wdXNoKHNlbCk7IH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gc3RvcmUgbWFya2VkIHNwYW4gaW5mb3JtYXRpb24gaW4gdGhlIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBjaGFuZ2UsIGZyb20sIHRvKSB7XG4gICAgdmFyIGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdLCBuID0gMDtcbiAgICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpXG4gICAgICAgIHsgKGV4aXN0aW5nIHx8IChleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSA9IHt9KSlbbl0gPSBsaW5lLm1hcmtlZFNwYW5zOyB9XG4gICAgICArK247XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIHVuL3JlLWRvaW5nIHJlc3RvcmVzIHRleHQgY29udGFpbmluZyBtYXJrZWQgc3BhbnMsIHRob3NlXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxuICBmdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgb3V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzcGFuc1tpXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQpIHsgaWYgKCFvdXQpIHsgb3V0ID0gc3BhbnMuc2xpY2UoMCwgaSk7IH0gfVxuICAgICAgZWxzZSBpZiAob3V0KSB7IG91dC5wdXNoKHNwYW5zW2ldKTsgfVxuICAgIH1cbiAgICByZXR1cm4gIW91dCA/IHNwYW5zIDogb3V0Lmxlbmd0aCA/IG91dCA6IG51bGxcbiAgfVxuXG4gIC8vIFJldHJpZXZlIGFuZCBmaWx0ZXIgdGhlIG9sZCBtYXJrZWQgc3BhbnMgc3RvcmVkIGluIGEgY2hhbmdlIGV2ZW50LlxuICBmdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBmb3VuZCA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXTtcbiAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbncgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpKVxuICAgICAgeyBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpOyB9XG4gICAgcmV0dXJuIG53XG4gIH1cblxuICAvLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxuICAvLyByZXN1bHQgb2YgY29tcHV0aW5nIHRoZSBleGlzdGluZyBzcGFucyB3aXRoIHRoZSBzZXQgb2Ygc3BhbnMgdGhhdFxuICAvLyBleGlzdGVkIGluIHRoZSBoaXN0b3J5IChzbyB0aGF0IGRlbGV0aW5nIGFyb3VuZCBhIHNwYW4gYW5kIHRoZW5cbiAgLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXG4gIGZ1bmN0aW9uIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb2xkID0gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpO1xuICAgIHZhciBzdHJldGNoZWQgPSBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBpZiAoIW9sZCkgeyByZXR1cm4gc3RyZXRjaGVkIH1cbiAgICBpZiAoIXN0cmV0Y2hlZCkgeyByZXR1cm4gb2xkIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgb2xkQ3VyID0gb2xkW2ldLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2ldO1xuICAgICAgaWYgKG9sZEN1ciAmJiBzdHJldGNoQ3VyKSB7XG4gICAgICAgIHNwYW5zOiBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal07XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDdXIubGVuZ3RoOyArK2spXG4gICAgICAgICAgICB7IGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSB7IGNvbnRpbnVlIHNwYW5zIH0gfVxuICAgICAgICAgIG9sZEN1ci5wdXNoKHNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgb2xkW2ldID0gc3RyZXRjaEN1cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9sZFxuICB9XG5cbiAgLy8gVXNlZCBib3RoIHRvIHByb3ZpZGUgYSBKU09OLXNhZmUgb2JqZWN0IGluIC5nZXRIaXN0b3J5LCBhbmQsIHdoZW5cbiAgLy8gZGV0YWNoaW5nIGEgZG9jdW1lbnQsIHRvIHNwbGl0IHRoZSBoaXN0b3J5IGluIHR3b1xuICBmdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cywgbmV3R3JvdXAsIGluc3RhbnRpYXRlU2VsKSB7XG4gICAgdmFyIGNvcHkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgaWYgKGV2ZW50LnJhbmdlcykge1xuICAgICAgICBjb3B5LnB1c2goaW5zdGFudGlhdGVTZWwgPyBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5LmNhbGwoZXZlbnQpIDogZXZlbnQpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZXMgPSBldmVudC5jaGFuZ2VzLCBuZXdDaGFuZ2VzID0gW107XG4gICAgICBjb3B5LnB1c2goe2NoYW5nZXM6IG5ld0NoYW5nZXN9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tqXSwgbSA9ICh2b2lkIDApO1xuICAgICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xuICAgICAgICBpZiAobmV3R3JvdXApIHsgZm9yICh2YXIgcHJvcCBpbiBjaGFuZ2UpIHsgaWYgKG0gPSBwcm9wLm1hdGNoKC9ec3BhbnNfKFxcZCspJC8pKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobmV3R3JvdXAsIE51bWJlcihtWzFdKSkgPiAtMSkge1xuICAgICAgICAgICAgbHN0KG5ld0NoYW5nZXMpW3Byb3BdID0gY2hhbmdlW3Byb3BdO1xuICAgICAgICAgICAgZGVsZXRlIGNoYW5nZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5XG4gIH1cblxuICAvLyBUaGUgJ3Njcm9sbCcgcGFyYW1ldGVyIGdpdmVuIHRvIG1hbnkgb2YgdGhlc2UgaW5kaWNhdGVkIHdoZXRoZXJcbiAgLy8gdGhlIG5ldyBjdXJzb3IgcG9zaXRpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlclxuICAvLyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbi5cblxuICAvLyBJZiBzaGlmdCBpcyBoZWxkIG9yIHRoZSBleHRlbmQgZmxhZyBpcyBzZXQsIGV4dGVuZHMgYSByYW5nZSB0b1xuICAvLyBpbmNsdWRlIGEgZ2l2ZW4gcG9zaXRpb24gKGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIHBvc2l0aW9uKS5cbiAgLy8gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJucyB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAvLyBVc2VkIGZvciBjdXJzb3IgbW90aW9uIGFuZCBzdWNoLlxuICBmdW5jdGlvbiBleHRlbmRSYW5nZShyYW5nZSwgaGVhZCwgb3RoZXIsIGV4dGVuZCkge1xuICAgIGlmIChleHRlbmQpIHtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMDtcbiAgICAgICAgaWYgKHBvc0JlZm9yZSAhPSAoY21wKG90aGVyLCBhbmNob3IpIDwgMCkpIHtcbiAgICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NCZWZvcmUgIT0gKGNtcChoZWFkLCBvdGhlcikgPCAwKSkge1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uob3RoZXIgfHwgaGVhZCwgaGVhZClcbiAgICB9XG4gIH1cblxuICAvLyBFeHRlbmQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLCBkaXNjYXJkIHRoZSByZXN0LlxuICBmdW5jdGlvbiBleHRlbmRTZWxlY3Rpb24oZG9jLCBoZWFkLCBvdGhlciwgb3B0aW9ucywgZXh0ZW5kKSB7XG4gICAgaWYgKGV4dGVuZCA9PSBudWxsKSB7IGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7IH1cbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtleHRlbmRSYW5nZShkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIsIGV4dGVuZCldLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBFeHRlbmQgYWxsIHNlbGVjdGlvbnMgKHBvcyBpcyBhbiBhcnJheSBvZiBzZWxlY3Rpb25zIHdpdGggbGVuZ3RoXG4gIC8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygc2VsZWN0aW9ucylcbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9ucyhkb2MsIGhlYWRzLCBvcHRpb25zKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBleHRlbmQgPSBkb2MuY20gJiYgKGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IG91dFtpXSA9IGV4dGVuZFJhbmdlKGRvYy5zZWwucmFuZ2VzW2ldLCBoZWFkc1tpXSwgbnVsbCwgZXh0ZW5kKTsgfVxuICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXdTZWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmFuZ2VzID0gZG9jLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgcmFuZ2VzW2ldID0gcmFuZ2U7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgcmFuZ2VzLCBkb2Muc2VsLnByaW1JbmRleCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHNlbGVjdGlvbiB0byBhIHNpbmdsZSByYW5nZS5cbiAgZnVuY3Rpb24gc2V0U2ltcGxlU2VsZWN0aW9uKGRvYywgYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gR2l2ZSBiZWZvcmVTZWxlY3Rpb25DaGFuZ2UgaGFuZGxlcnMgYSBjaGFuZ2UgdG8gaW5mbHVlbmNlIGFcbiAgLy8gc2VsZWN0aW9uIHVwZGF0ZS5cbiAgZnVuY3Rpb24gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHJhbmdlczogc2VsLnJhbmdlcyxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgdGhpcy5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgICB9LFxuICAgICAgb3JpZ2luOiBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luXG4gICAgfTtcbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cbiAgICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSB7IHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvYmoucmFuZ2VzLCBvYmoucmFuZ2VzLmxlbmd0aCAtIDEpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHNlbCB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHZhciBkb25lID0gZG9jLmhpc3RvcnkuZG9uZSwgbGFzdCA9IGxzdChkb25lKTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnJhbmdlcykge1xuICAgICAgZG9uZVtkb25lLmxlbmd0aCAtIDFdID0gc2VsO1xuICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgYSBuZXcgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikpXG4gICAgICB7IHNlbCA9IGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucyk7IH1cblxuICAgIHZhciBiaWFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmJpYXMgfHxcbiAgICAgIChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpO1xuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XG5cbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtICYmIGRvYy5jbS5nZXRPcHRpb24oXCJyZWFkT25seVwiKSAhPSBcIm5vY3Vyc29yXCIpXG4gICAgICB7IGVuc3VyZUN1cnNvclZpc2libGUoZG9jLmNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcbiAgICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkgeyByZXR1cm4gfVxuXG4gICAgZG9jLnNlbCA9IHNlbDtcblxuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDE7XG4gICAgICBkb2MuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICBzaWduYWxDdXJzb3JBY3Rpdml0eShkb2MuY20pO1xuICAgIH1cbiAgICBzaWduYWxMYXRlcihkb2MsIFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9jKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIG1hcmtlZCByYW5nZXMuXG4gIGZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XG4gICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBkb2Muc2VsLCBudWxsLCBmYWxzZSkpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIHJhbmdlcy5cbiAgZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG9sZCA9IHNlbC5yYW5nZXMubGVuZ3RoID09IGRvYy5zZWwucmFuZ2VzLmxlbmd0aCAmJiBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIHZhciBuZXdBbmNob3IgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuYW5jaG9yLCBvbGQgJiYgb2xkLmFuY2hvciwgYmlhcywgbWF5Q2xlYXIpO1xuICAgICAgdmFyIG5ld0hlYWQgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgb2xkICYmIG9sZC5oZWFkLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICBpZiAob3V0IHx8IG5ld0FuY2hvciAhPSByYW5nZS5hbmNob3IgfHwgbmV3SGVhZCAhPSByYW5nZS5oZWFkKSB7XG4gICAgICAgIGlmICghb3V0KSB7IG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7IH1cbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIHNlbC5wcmltSW5kZXgpIDogc2VsXG4gIH1cblxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgcHJldmVudCB0aGUgY3Vyc29yIGJlaW5nIHBsYWNlZCB0byB0aGUgbGVmdC9yaWdodCBvZiBhbiBhdG9taWMgbWFya2VyXG4gICAgICAvLyBIaXN0b3JpY2FsbHkgdGhpcyB3YXMgZGV0ZXJtaW5lZCB1c2luZyB0aGUgaW5jbHVzaXZlTGVmdC9SaWdodCBvcHRpb24sIGJ1dCB0aGUgbmV3IHdheSB0byBjb250cm9sIGl0XG4gICAgICAvLyBpcyB3aXRoIHNlbGVjdExlZnQvUmlnaHRcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yTGVmdCA9IChcInNlbGVjdExlZnRcIiBpbiBtKSA/ICFtLnNlbGVjdExlZnQgOiBtLmluY2x1c2l2ZUxlZnQ7XG4gICAgICB2YXIgcHJldmVudEN1cnNvclJpZ2h0ID0gKFwic2VsZWN0UmlnaHRcIiBpbiBtKSA/ICFtLnNlbGVjdFJpZ2h0IDogbS5pbmNsdXNpdmVSaWdodDtcblxuICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKHByZXZlbnRDdXJzb3JMZWZ0ID8gc3AuZnJvbSA8PSBwb3MuY2ggOiBzcC5mcm9tIDwgcG9zLmNoKSkgJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvclJpZ2h0ID8gc3AudG8gPj0gcG9zLmNoIDogc3AudG8gPiBwb3MuY2gpKSkge1xuICAgICAgICBpZiAobWF5Q2xlYXIpIHtcbiAgICAgICAgICBzaWduYWwobSwgXCJiZWZvcmVDdXJzb3JFbnRlclwiKTtcbiAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSB7IGJyZWFrIH1cbiAgICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWV9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbS5hdG9taWMpIHsgY29udGludWUgfVxuXG4gICAgICAgIGlmIChvbGRQb3MpIHtcbiAgICAgICAgICB2YXIgbmVhciA9IG0uZmluZChkaXIgPCAwID8gMSA6IC0xKSwgZGlmZiA9ICh2b2lkIDApO1xuICAgICAgICAgIGlmIChkaXIgPCAwID8gcHJldmVudEN1cnNvclJpZ2h0IDogcHJldmVudEN1cnNvckxlZnQpXG4gICAgICAgICAgICB7IG5lYXIgPSBtb3ZlUG9zKGRvYywgbmVhciwgLWRpciwgbmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsIG5lYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhciA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yTGVmdCA6IHByZXZlbnRDdXJzb3JSaWdodClcbiAgICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgcmV0dXJuIGZhciA/IHNraXBBdG9taWNJbm5lcihkb2MsIGZhciwgcG9zLCBkaXIsIG1heUNsZWFyKSA6IG51bGxcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBkaXIgPSBiaWFzIHx8IDE7XG4gICAgdmFyIGZvdW5kID0gc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgbWF5Q2xlYXIpIHx8XG4gICAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgdHJ1ZSkpIHx8XG4gICAgICAgIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgdHJ1ZSkpO1xuICAgIGlmICghZm91bmQpIHtcbiAgICAgIGRvYy5jYW50RWRpdCA9IHRydWU7XG4gICAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMClcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcbiAgICBpZiAoZGlyIDwgMCAmJiBwb3MuY2ggPT0gMCkge1xuICAgICAgaWYgKHBvcy5saW5lID4gZG9jLmZpcnN0KSB7IHJldHVybiBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lIC0gMSkpIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIGlmIChkaXIgPiAwICYmIHBvcy5jaCA9PSAobGluZSB8fCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpKS50ZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSB7IHJldHVybiBQb3MocG9zLmxpbmUgKyAxLCAwKSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvcyhwb3MubGluZSwgcG9zLmNoICsgZGlyKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbChjbSkge1xuICAgIGNtLnNldFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApLCBQb3MoY20ubGFzdExpbmUoKSksIHNlbF9kb250U2Nyb2xsKTtcbiAgfVxuXG4gIC8vIFVQREFUSU5HXG5cbiAgLy8gQWxsb3cgXCJiZWZvcmVDaGFuZ2VcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcbiAgZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICB0bzogY2hhbmdlLnRvLFxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iai5jYW5jZWxlZCA9IHRydWU7IH1cbiAgICB9O1xuICAgIGlmICh1cGRhdGUpIHsgb2JqLnVwZGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgdGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKTsgfVxuICAgICAgaWYgKHRvKSB7IG9iai50byA9IGNsaXBQb3MoZG9jLCB0byk7IH1cbiAgICAgIGlmICh0ZXh0KSB7IG9iai50ZXh0ID0gdGV4dDsgfVxuICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW47IH1cbiAgICB9OyB9XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLmNtLCBvYmopOyB9XG5cbiAgICBpZiAob2JqLmNhbmNlbGVkKSB7XG4gICAgICBpZiAoZG9jLmNtKSB7IGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDI7IH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogb2JqLmZyb20sIHRvOiBvYmoudG8sIHRleHQ6IG9iai50ZXh0LCBvcmlnaW46IG9iai5vcmlnaW59XG4gIH1cblxuICAvLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXG4gIC8vIGhpc3RvcnksIGFuZCBwcm9wYWdhdGluZyBpdCB0byBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIHtcbiAgICBpZiAoZG9jLmNtKSB7XG4gICAgICBpZiAoIWRvYy5jbS5jdXJPcCkgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB9XG4gICAgICBpZiAoZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHsgcmV0dXJuIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIikpIHtcbiAgICAgIGNoYW5nZSA9IGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoYW5nZSkgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIC8vIFBvc3NpYmx5IHNwbGl0IG9yIHN1cHByZXNzIHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cbiAgICB2YXIgc3BsaXQgPSBzYXdSZWFkT25seVNwYW5zICYmICFpZ25vcmVSZWFkT25seSAmJiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgIGlmIChzcGxpdCkge1xuICAgICAgZm9yICh2YXIgaSA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICB7IG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXCJcIl0gOiBjaGFuZ2UudGV4dCwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgY2hhbmdlLnRleHRbMF0gPT0gXCJcIiAmJiBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKTtcblxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgdmFyIHJlYmFzZWQgPSBbXTtcblxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgIH1cbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xuICAgIHZhciBzdXBwcmVzcyA9IGRvYy5jbSAmJiBkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cztcbiAgICBpZiAoc3VwcHJlc3MgJiYgIWFsbG93U2VsZWN0aW9uT25seSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgZXZlbnQsIHNlbEFmdGVyID0gZG9jLnNlbDtcbiAgICB2YXIgc291cmNlID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QuZG9uZSA6IGhpc3QudW5kb25lLCBkZXN0ID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lO1xuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxuICAgIC8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gc291cmNlW2ldO1xuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcbiAgICAgICAgeyBicmVhayB9XG4gICAgfVxuICAgIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgZXZlbnQgPSBzb3VyY2UucG9wKCk7XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xuICAgICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwge2NsZWFyUmVkbzogZmFsc2V9KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZWxBZnRlciA9IGV2ZW50O1xuICAgICAgfSBlbHNlIGlmIChzdXBwcmVzcykge1xuICAgICAgICBzb3VyY2UucHVzaChldmVudCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHVwIGEgcmV2ZXJzZSBjaGFuZ2Ugb2JqZWN0IHRvIGFkZCB0byB0aGUgb3Bwb3NpdGUgaGlzdG9yeVxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxuICAgIHZhciBhbnRpQ2hhbmdlcyA9IFtdO1xuICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpO1xuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb247XG5cbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIik7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBldmVudC5jaGFuZ2VzW2ldO1xuICAgICAgY2hhbmdlLm9yaWdpbiA9IHR5cGU7XG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xuICAgICAgICBzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgICB9XG5cbiAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcblxuICAgICAgdmFyIGFmdGVyID0gaSA/IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkgOiBsc3Qoc291cmNlKTtcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pOyB9XG4gICAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcbiAgICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkkMSApO1xuXG4gICAgICBpZiAoIHJldHVybmVkICkgcmV0dXJuIHJldHVybmVkLnY7XG4gICAgfVxuICB9XG5cbiAgLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXG4gIC8vIGFib3ZlIG9yIGJlbG93IHRoZW0gaW4gdGhlIHBhcmVudCBkb2N1bWVudC5cbiAgZnVuY3Rpb24gc2hpZnREb2MoZG9jLCBkaXN0YW5jZSkge1xuICAgIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XG4gICAgZG9jLmZpcnN0ICs9IGRpc3RhbmNlO1xuICAgIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgIFBvcyhyYW5nZS5oZWFkLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuaGVhZC5jaClcbiAgICApOyB9KSwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgICAgIGZvciAodmFyIGQgPSBkb2MuY20uZGlzcGxheSwgbCA9IGQudmlld0Zyb207IGwgPCBkLnZpZXdUbzsgbCsrKVxuICAgICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcImd1dHRlclwiKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XG4gIC8vIChub3QgbGlua2VkIG9uZXMpLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApXG4gICAgICB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB9XG5cbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA+IGRvYy5sYXN0TGluZSgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBDbGlwIHRoZSBjaGFuZ2UgdG8gdGhlIHNpemUgb2YgdGhpcyBkb2NcbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgdmFyIHNoaWZ0ID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChkb2MuZmlyc3QgLSBjaGFuZ2UuZnJvbS5saW5lKTtcbiAgICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpO1xuICAgICAgY2hhbmdlID0ge2Zyb206IFBvcyhkb2MuZmlyc3QsIDApLCB0bzogUG9zKGNoYW5nZS50by5saW5lICsgc2hpZnQsIGNoYW5nZS50by5jaCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59O1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpO1xuICAgIGlmIChjaGFuZ2UudG8ubGluZSA+IGxhc3QpIHtcbiAgICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtjaGFuZ2UudGV4dFswXV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuXG4gICAgY2hhbmdlLnJlbW92ZWQgPSBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG5cbiAgICBpZiAoIXNlbEFmdGVyKSB7IHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTsgfVxuICAgIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBlbHNlIHsgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWxBZnRlciwgc2VsX2RvbnRTY3JvbGwpO1xuXG4gICAgaWYgKGRvYy5jYW50RWRpdCAmJiBza2lwQXRvbWljKGRvYywgUG9zKGRvYy5maXJzdExpbmUoKSwgMCkpKVxuICAgICAgeyBkb2MuY2FudEVkaXQgPSBmYWxzZTsgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxuICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGNtLCBjaGFuZ2UsIHNwYW5zKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG87XG5cbiAgICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBjaGVja1dpZHRoU3RhcnQgPSBsaW5lTm8odmlzdWFsTGluZShnZXRMaW5lKGRvYywgZnJvbS5saW5lKSkpO1xuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XG4gICAgICAgICAgcmVjb21wdXRlTWF4TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnNlbC5jb250YWlucyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA+IC0xKVxuICAgICAgeyBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSk7IH1cblxuICAgIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KGNtKSk7XG5cbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgfVxuXG4gICAgcmV0cmVhdEZyb250aWVyKGRvYywgZnJvbS5saW5lKTtcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcblxuICAgIHZhciBsZW5kaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvLmxpbmUgLSBmcm9tLmxpbmUpIC0gMTtcbiAgICAvLyBSZW1lbWJlciB0aGF0IHRoZXNlIGxpbmVzIGNoYW5nZWQsIGZvciB1cGRhdGluZyB0aGUgZGlzcGxheVxuICAgIGlmIChjaGFuZ2UuZnVsbClcbiAgICAgIHsgcmVnQ2hhbmdlKGNtKTsgfVxuICAgIGVsc2UgaWYgKGZyb20ubGluZSA9PSB0by5saW5lICYmIGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmICFpc1dob2xlTGluZVVwZGF0ZShjbS5kb2MsIGNoYW5nZSkpXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXCJ0ZXh0XCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEsIGxlbmRpZmYpOyB9XG5cbiAgICB2YXIgY2hhbmdlc0hhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZXNcIiksIGNoYW5nZUhhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZVwiKTtcbiAgICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgZnJvbTogZnJvbSwgdG86IHRvLFxuICAgICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXG4gICAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpblxuICAgICAgfTtcbiAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSB7IHNpZ25hbExhdGVyKGNtLCBcImNoYW5nZVwiLCBjbSwgb2JqKTsgfVxuICAgICAgaWYgKGNoYW5nZXNIYW5kbGVyKSB7IChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaik7IH1cbiAgICB9XG4gICAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIGlmICghdG8pIHsgdG8gPSBmcm9tOyB9XG4gICAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IChhc3NpZ24gPSBbdG8sIGZyb21dLCBmcm9tID0gYXNzaWduWzBdLCB0byA9IGFzc2lnblsxXSk7IH1cbiAgICBpZiAodHlwZW9mIGNvZGUgPT0gXCJzdHJpbmdcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7IH1cbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcbiAgfVxuXG4gIC8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xuICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSArPSBkaWZmO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICBwb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xuICAvLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxuICAvLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXG4gIC8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcbiAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uYW5jaG9yLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xuICAgICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbaiQxXTtcbiAgICAgICAgaWYgKHRvIDwgY3VyLmZyb20ubGluZSkge1xuICAgICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaCk7XG4gICAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tIDw9IGN1ci50by5saW5lKSB7XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIGFwcGx5aW5nIGEgY2hhbmdlIHRvIGEgbGluZSBieSBoYW5kbGUgb3IgbnVtYmVyLFxuICAvLyByZXR1cm5pbmcgdGhlIG51bWJlciBhbmQgb3B0aW9uYWxseSByZWdpc3RlcmluZyB0aGUgbGluZSBhc1xuICAvLyBjaGFuZ2VkLlxuICBmdW5jdGlvbiBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBjaGFuZ2VUeXBlLCBvcCkge1xuICAgIHZhciBubyA9IGhhbmRsZSwgbGluZSA9IGhhbmRsZTtcbiAgICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiKSB7IGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKTsgfVxuICAgIGVsc2UgeyBubyA9IGxpbmVObyhoYW5kbGUpOyB9XG4gICAgaWYgKG5vID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChvcChsaW5lLCBubykgJiYgZG9jLmNtKSB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBubywgY2hhbmdlVHlwZSk7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gVGhlIGRvY3VtZW50IGlzIHJlcHJlc2VudGVkIGFzIGEgQlRyZWUgY29uc2lzdGluZyBvZiBsZWF2ZXMsIHdpdGhcbiAgLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3JcbiAgLy8gb3RoZXIgYnJhbmNoIG5vZGVzIGJlbG93IHRoZW0uIFRoZSB0b3Agbm9kZSBpcyBhbHdheXMgYSBicmFuY2hcbiAgLy8gbm9kZSwgYW5kIGlzIHRoZSBkb2N1bWVudCBvYmplY3QgaXRzZWxmIChtZWFuaW5nIGl0IGhhc1xuICAvLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxuICAvL1xuICAvLyBBbGwgbm9kZXMgaGF2ZSBwYXJlbnQgbGlua3MuIFRoZSB0cmVlIGlzIHVzZWQgYm90aCB0byBnbyBmcm9tXG4gIC8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cbiAgLy8gSXQgYWxzbyBpbmRleGVzIGJ5IGhlaWdodCwgYW5kIGlzIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIGhlaWdodFxuICAvLyBhbmQgbGluZSBvYmplY3QsIGFuZCB0byBmaW5kIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxuICAvL1xuICAvLyBTZWUgYWxzbyBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvY29kZW1pcnJvci1saW5lLXRyZWUuaHRtbFxuXG4gIGZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcykge1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgbGluZXNbaV0ucGFyZW50ID0gdGhpcztcbiAgICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgTGVhZkNodW5rLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggfSxcblxuICAgIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBhdCwgZSA9IGF0ICsgbjsgaSA8IGU7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xuICAgICAgICBjbGVhblVwTGluZShsaW5lKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJkZWxldGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHRoaXMubGluZXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gICAgfSxcblxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cbiAgICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XG4gICAgICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpXG4gICAgICAgIHsgaWYgKG9wKHRoaXMubGluZXNbYXRdKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQnJhbmNoQ2h1bmsoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdmFyIHNpemUgPSAwLCBoZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTsgaGVpZ2h0ICs9IGNoLmhlaWdodDtcbiAgICAgIGNoLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9XG5cbiAgQnJhbmNoQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNpemUgfSxcblxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgdGhpcy5zaXplIC09IG47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICB2YXIgcm0gPSBNYXRoLm1pbihuLCBzeiAtIGF0KSwgb2xkSGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzLmNoaWxkcmVuLnNwbGljZShpLS0sIDEpOyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cbiAgICAgIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcbiAgICAgICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGVhZkNodW5rKGxpbmVzKV07XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHsgdGhpcy5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7IH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNpemUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8PSBzeikge1xuICAgICAgICAgIGNoaWxkLmluc2VydElubmVyKGF0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1lbW9yeSB0aHJhc2hpbmcgd2hlbiBjaGlsZC5saW5lcyBpcyBodWdlIChlLmcuIGZpcnN0IHZpZXcgb2YgYSBsYXJnZSBmaWxlKSwgaXQncyBuZXZlciBzcGxpY2VkLlxuICAgICAgICAgICAgLy8gSW5zdGVhZCwgc21hbGwgc2xpY2VzIGFyZSB0YWtlbi4gVGhleSdyZSB0YWtlbiBpbiBvcmRlciBiZWNhdXNlIHNlcXVlbnRpYWwgbWVtb3J5IGFjY2Vzc2VzIGFyZSBmYXN0ZXN0LlxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNoaWxkLmxpbmVzLmxlbmd0aCAlIDI1ICsgMjU7XG4gICAgICAgICAgICBmb3IgKHZhciBwb3MgPSByZW1haW5pbmc7IHBvcyA8IGNoaWxkLmxpbmVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgdmFyIGxlYWYgPSBuZXcgTGVhZkNodW5rKGNoaWxkLmxpbmVzLnNsaWNlKHBvcywgcG9zICs9IDI1KSk7XG4gICAgICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBsZWFmLmhlaWdodDtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoKytpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQubGluZXMgPSBjaGlsZC5saW5lcy5zbGljZSgwLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFdoZW4gYSBub2RlIGhhcyBncm93biwgY2hlY2sgd2hldGhlciBpdCBzaG91bGQgYmUgc3BsaXQuXG4gICAgbWF5YmVTcGlsbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTApIHsgcmV0dXJuIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBzcGlsbGVkID0gbWUuY2hpbGRyZW4uc3BsaWNlKG1lLmNoaWxkcmVuLmxlbmd0aCAtIDUsIDUpO1xuICAgICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKTtcbiAgICAgICAgaWYgKCFtZS5wYXJlbnQpIHsgLy8gQmVjb21lIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEJyYW5jaENodW5rKG1lLmNoaWxkcmVuKTtcbiAgICAgICAgICBjb3B5LnBhcmVudCA9IG1lO1xuICAgICAgICAgIG1lLmNoaWxkcmVuID0gW2NvcHksIHNpYmxpbmddO1xuICAgICAgICAgIG1lID0gY29weTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplO1xuICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcbiAgICAgICAgICB2YXIgbXlJbmRleCA9IGluZGV4T2YobWUucGFyZW50LmNoaWxkcmVuLCBtZSk7XG4gICAgICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChtZS5jaGlsZHJlbi5sZW5ndGggPiAxMClcbiAgICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKCk7XG4gICAgfSxcblxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdCk7XG4gICAgICAgICAgaWYgKGNoaWxkLml0ZXJOKGF0LCB1c2VkLCBvcCkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIExpbmUgd2lkZ2V0cyBhcmUgYmxvY2sgZWxlbWVudHMgZGlzcGxheWVkIGFib3ZlIG9yIGJlbG93IGEgbGluZS5cblxuICB2YXIgTGluZVdpZGdldCA9IGZ1bmN0aW9uKGRvYywgbm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7IGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7IGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICB7IHRoaXNbb3B0XSA9IG9wdGlvbnNbb3B0XTsgfSB9IH1cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcbiAgICBpZiAobm8gPT0gbnVsbCB8fCAhd3MpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSB7IGlmICh3c1tpXSA9PSB0aGlzKSB7IHdzLnNwbGljZShpLS0sIDEpOyB9IH1cbiAgICBpZiAoIXdzLmxlbmd0aCkgeyBsaW5lLndpZGdldHMgPSBudWxsOyB9XG4gICAgdmFyIGhlaWdodCA9IHdpZGdldEhlaWdodCh0aGlzKTtcbiAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSk7XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpO1xuICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXCJ3aWRnZXRcIik7XG4gICAgICB9KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDbGVhcmVkXCIsIGNtLCB0aGlzLCBubyk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvbGRIID0gdGhpcy5oZWlnaHQsIGNtID0gdGhpcy5kb2MuY20sIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHZhciBkaWZmID0gd2lkZ2V0SGVpZ2h0KHRoaXMpIC0gb2xkSDtcbiAgICBpZiAoIWRpZmYpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpOyB9XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZik7XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDaGFuZ2VkXCIsIGNtLCB0aGlzJDEsIGxpbmVObyhsaW5lKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV2ZW50TWl4aW4oTGluZVdpZGdldCk7XG5cbiAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xuICAgIGlmIChoZWlnaHRBdExpbmUobGluZSkgPCAoKGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCkgfHwgY20uZG9jLnNjcm9sbFRvcCkpXG4gICAgICB7IGFkZFRvU2Nyb2xsVG9wKGNtLCBkaWZmKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xuICAgIHZhciBjbSA9IGRvYy5jbTtcbiAgICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgeyBjbS5kaXNwbGF5LmFsaWduV2lkZ2V0cyA9IHRydWU7IH1cbiAgICBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBcIndpZGdldFwiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKTtcbiAgICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgeyB3aWRnZXRzLnB1c2god2lkZ2V0KTsgfVxuICAgICAgZWxzZSB7IHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoLCBNYXRoLm1heCgwLCB3aWRnZXQuaW5zZXJ0QXQpKSwgMCwgd2lkZ2V0KTsgfVxuICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xuICAgICAgaWYgKGNtICYmICFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xuICAgICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcbiAgICAgICAgaWYgKGFib3ZlVmlzaWJsZSkgeyBhZGRUb1Njcm9sbFRvcChjbSwgd2lkZ2V0LmhlaWdodCk7IH1cbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KTtcbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldEFkZGVkXCIsIGNtLCB3aWRnZXQsIHR5cGVvZiBoYW5kbGUgPT0gXCJudW1iZXJcIiA/IGhhbmRsZSA6IGxpbmVObyhoYW5kbGUpKTsgfVxuICAgIHJldHVybiB3aWRnZXRcbiAgfVxuXG4gIC8vIFRFWFRNQVJLRVJTXG5cbiAgLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxuICAvLyBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhciBvciBmaW5kIGEgbWFya2VkIHBvc2l0aW9uIGluIHRoZVxuICAvLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xuICAvLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxuICAvLyBpbmRpY2F0aW5nIHRoYXQgc3VjaCBhIG1hcmtlciBpcyBwcmVzZW50IG9uIHRoYXQgbGluZS4gTXVsdGlwbGVcbiAgLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cbiAgLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcbiAgLy8gbWFya2VyIGNvbnRpbnVlcyBiZXlvbmQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgbGluZS4gTWFya2VycyBoYXZlXG4gIC8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxuXG4gIC8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxuICAvLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxuICAvLyB3aGVuIHRoZXkgb3ZlcmxhcCAodGhleSBtYXkgbmVzdCwgYnV0IG5vdCBwYXJ0aWFsbHkgb3ZlcmxhcCkuXG4gIHZhciBuZXh0TWFya2VySWQgPSAwO1xuXG4gIHZhciBUZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICB9O1xuXG4gIC8vIENsZWFyIHRoZSBtYXJrZXIuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdpdGhPcCA9IGNtICYmICFjbS5jdXJPcDtcbiAgICBpZiAod2l0aE9wKSB7IHN0YXJ0T3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmIChoYXNIYW5kbGVyKHRoaXMsIFwiY2xlYXJcIikpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpO1xuICAgICAgaWYgKGZvdW5kKSB7IHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pOyB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBudWxsLCBtYXggPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKGNtICYmICF0aGlzLmNvbGxhcHNlZCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFwidGV4dFwiKTsgfVxuICAgICAgZWxzZSBpZiAoY20pIHtcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgeyBtYXggPSBsaW5lTm8obGluZSk7IH1cbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7IG1pbiA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgfVxuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3Bhbik7XG4gICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pXG4gICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpKTsgfVxuICAgIH1cbiAgICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kkMSkge1xuICAgICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcy5saW5lc1tpJDFdKSwgbGVuID0gbGluZUxlbmd0aCh2aXN1YWwpO1xuICAgICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSB2aXN1YWw7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSB9XG5cbiAgICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHsgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpOyB9XG4gICAgdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xuICAgICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgIGlmIChjbSkgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICB9XG4gICAgaWYgKGNtKSB7IHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNsZWFyZWRcIiwgY20sIHRoaXMsIG1pbiwgbWF4KTsgfVxuICAgIGlmICh3aXRoT3ApIHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmICh0aGlzLnBhcmVudCkgeyB0aGlzLnBhcmVudC5jbGVhcigpOyB9XG4gIH07XG5cbiAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcbiAgLy8gdG99IG9iamVjdCBieSBkZWZhdWx0LiBTaWRlIGNhbiBiZSBwYXNzZWQgdG8gZ2V0IGEgc3BlY2lmaWMgc2lkZVxuICAvLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcbiAgLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcbiAgLy8gbnVtYmVyICh1c2VkIHRvIHByZXZlbnQgbG9va2luZyB1cCB0aGUgc2FtZSBsaW5lIHR3aWNlKS5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XG4gICAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXCJib29rbWFya1wiKSB7IHNpZGUgPSAxOyB9XG4gICAgdmFyIGZyb20sIHRvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4uZnJvbSk7XG4gICAgICAgIGlmIChzaWRlID09IC0xKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pO1xuICAgICAgICBpZiAoc2lkZSA9PSAxKSB7IHJldHVybiB0byB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99XG4gIH07XG5cbiAgLy8gU2lnbmFscyB0aGF0IHRoZSBtYXJrZXIncyB3aWRnZXQgY2hhbmdlZCwgYW5kIHN1cnJvdW5kaW5nIGxheW91dFxuICAvLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XG4gICAgaWYgKCFwb3MgfHwgIWNtKSB7IHJldHVybiB9XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxpbmUgPSBwb3MubGluZSwgbGluZU4gPSBsaW5lTm8ocG9zLmxpbmUpO1xuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3Iodmlldyk7XG4gICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgIGlmICghbGluZUlzSGlkZGVuKHdpZGdldC5kb2MsIGxpbmUpICYmIHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodDtcbiAgICAgICAgd2lkZ2V0LmhlaWdodCA9IG51bGw7XG4gICAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHQ7XG4gICAgICAgIGlmIChkSGVpZ2h0KVxuICAgICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpOyB9XG4gICAgICB9XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJtYXJrZXJDaGFuZ2VkXCIsIGNtLCB0aGlzJDEpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xuICAgICAgaWYgKCFvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgaW5kZXhPZihvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpID09IC0xKVxuICAgICAgICB7IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7IH1cbiAgICB9XG4gICAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpO1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXG4gICAgICA7KG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihUZXh0TWFya2VyKTtcblxuICAvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcbiAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgIC8vIFNoYXJlZCBtYXJrZXJzIChhY3Jvc3MgbGlua2VkIGRvY3VtZW50cykgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXG4gICAgLy8gZG9jdW1lbnQpLlxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkKSB7IHJldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG4gICAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYXJrVGV4dCkoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxuXG4gICAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChvcHRpb25zKSB7IGNvcHlPYmoob3B0aW9ucywgbWFya2VyLCBmYWxzZSk7IH1cbiAgICAvLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXG4gICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gbWFya2VyIH1cbiAgICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xuICAgICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXG4gICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0UChcInNwYW5cIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcIkNvZGVNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgaWYgKCFvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzKSB7IG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpOyB9XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSB7IG1hcmtlci53aWRnZXROb2RlLmluc2VydExlZnQgPSB0cnVlOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBpZiAoY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGZyb20ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikgfHxcbiAgICAgICAgICBmcm9tLmxpbmUgIT0gdG8ubGluZSAmJiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgdG8ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKSB9XG4gICAgICBzZWVDb2xsYXBzZWRTcGFucygpO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KVxuICAgICAgeyBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCBvcmlnaW46IFwibWFya1RleHRcIn0sIGRvYy5zZWwsIE5hTik7IH1cblxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcbiAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcbiAgICAgICAgeyB1cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCksIGRvYy5jbSAmJiBkb2MuY20uY3VyT3ApO1xuICAgICAgKytjdXJMaW5lO1xuICAgIH0pO1xuICAgIC8vIGxpbmVJc0hpZGRlbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUgc3BhbnMsIHNvIG5lZWRzIGEgc2Vjb25kIHBhc3NcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7IH1cbiAgICB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIHsgb24obWFya2VyLCBcImJlZm9yZUN1cnNvckVudGVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtlci5jbGVhcigpOyB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgc2VlUmVhZE9ubHlTcGFucygpO1xuICAgICAgaWYgKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RoIHx8IGRvYy5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpXG4gICAgICAgIHsgZG9jLmNsZWFySGlzdG9yeSgpOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZDtcbiAgICAgIG1hcmtlci5hdG9taWMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY20pIHtcbiAgICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXG4gICAgICBpZiAodXBkYXRlTWF4TGluZSkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXG4gICAgICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxKTsgfVxuICAgICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcyB8fFxuICAgICAgICAgICAgICAgbWFya2VyLmF0dHJpYnV0ZXMgfHwgbWFya2VyLnRpdGxlKVxuICAgICAgICB7IGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGksIFwidGV4dFwiKTsgfSB9XG4gICAgICBpZiAobWFya2VyLmF0b21pYykgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckFkZGVkXCIsIGNtLCBtYXJrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyXG4gIH1cblxuICAvLyBTSEFSRUQgVEVYVE1BUktFUlNcblxuICAvLyBBIHNoYXJlZCBtYXJrZXIgc3BhbnMgbXVsdGlwbGUgbGlua2VkIGRvY3VtZW50cy4gSXQgaXNcbiAgLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXG4gIC8vIG1hcmtlcnMuXG4gIHZhciBTaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24obWFya2VycywgcHJpbWFyeSkge1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpczsgfVxuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHRoaXMubWFya2Vyc1tpXS5jbGVhcigpOyB9XG4gICAgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiKTtcbiAgfTtcblxuICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iailcbiAgfTtcbiAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcblxuICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZTtcbiAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xuICAgIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmICh3aWRnZXQpIHsgb3B0aW9ucy53aWRnZXROb2RlID0gd2lkZ2V0LmNsb25lTm9kZSh0cnVlKTsgfVxuICAgICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpXG4gICAgICAgIHsgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHsgcmV0dXJuIH0gfVxuICAgICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xuICAgIHJldHVybiBkb2MuZmluZE1hcmtzKFBvcyhkb2MuZmlyc3QsIDApLCBkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29weVNoYXJlZE1hcmtlcnMoZG9jLCBtYXJrZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcbiAgICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKTtcbiAgICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcbiAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcbiAgICAgICAgbWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKTtcbiAgICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgbGlua2VkID0gW21hcmtlci5wcmltYXJ5LmRvY107XG4gICAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdO1xuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XG4gICAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgbWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cblxuICB2YXIgbmV4dERvY0lkID0gMDtcbiAgdmFyIERvYyA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHsgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIH1cbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMDsgfVxuXG4gICAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXCJcIiwgbnVsbCldKV0pO1xuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuY2FudEVkaXQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XG4gICAgdGhpcy5tb2RlRnJvbnRpZXIgPSB0aGlzLmhpZ2hsaWdodEZyb250aWVyID0gZmlyc3RMaW5lO1xuICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xuICAgIHRoaXMuc2VsID0gc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KTtcbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XG4gICAgdGhpcy5tb2RlT3B0aW9uID0gbW9kZTtcbiAgICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gKGRpcmVjdGlvbiA9PSBcInJ0bFwiKSA/IFwicnRsXCIgOiBcImx0clwiO1xuICAgIHRoaXMuZXh0ZW5kID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikgeyB0ZXh0ID0gdGhpcy5zcGxpdExpbmVzKHRleHQpOyB9XG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKTtcbiAgfTtcblxuICBEb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBEb2MsXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxuICAgIC8vIHRocmVlLCBpdCBpdGVyYXRlcyBvdmVyIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgZmlyc3QgdHdvICh3aXRoXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cbiAgICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcbiAgICAgIGlmIChvcCkgeyB0aGlzLml0ZXJOKGZyb20gLSB0aGlzLmZpcnN0LCB0byAtIGZyb20sIG9wKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7IH1cbiAgICB9LFxuXG4gICAgLy8gTm9uLXB1YmxpYyBpbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbGluZXMuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0OyB9XG4gICAgICB0aGlzLmluc2VydElubmVyKGF0IC0gdGhpcy5maXJzdCwgbGluZXMsIGhlaWdodCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcblxuICAgIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICB9LFxuICAgIHNldFZhbHVlOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlKSB7XG4gICAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7XG4gICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXCJzZXRWYWx1ZVwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBzY3JvbGxUb0Nvb3Jkcyh0aGlzLmNtLCAwLCAwKTsgfVxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbih0b3ApLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgfSksXG4gICAgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbihjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcbiAgICAgIHRvID0gdG8gPyBjbGlwUG9zKHRoaXMsIHRvKSA6IGZyb207XG4gICAgICByZXBsYWNlUmFuZ2UodGhpcywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbik7XG4gICAgfSxcbiAgICBnZXRSYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8sIGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldEJldHdlZW4odGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0bykpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICBpZiAobGluZVNlcCA9PT0gJycpIHsgcmV0dXJuIGxpbmVzLmpvaW4oJycpIH1cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXG4gICAgfSxcblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0fSxcblxuICAgIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpIH19LFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcblxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7IH1cbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXG4gICAgfSxcblxuICAgIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXG4gICAgZmlyc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdH0sXG4gICAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXG5cbiAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcblxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJhbmNob3JcIikgeyBwb3MgPSByYW5nZS5hbmNob3I7IH1cbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiZW5kXCIgfHwgc3RhcnQgPT0gXCJ0b1wiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZS50bygpOyB9XG4gICAgICBlbHNlIHsgcG9zID0gcmFuZ2UuZnJvbSgpOyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSxcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXMgfSxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxuXG4gICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgdHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGhlYWQpLCBvdGhlciAmJiBjbGlwUG9zKHRoaXMsIG90aGVyKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGVhZHMgPSBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKTtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uaGVhZCB8fCByYW5nZXNbaV0uYW5jaG9yKSk7IH1cbiAgICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHsgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHRoaXMuY20sIG91dCwgcHJpbWFyeSksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGFkZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgcmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpO1xuICAgIH0pLFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgbGluZXMgPSBsaW5lcyA/IGxpbmVzLmNvbmNhdChzZWwpIDogc2VsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSkgfVxuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSB7IHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpOyB9XG4gICAgICAgIHBhcnRzW2ldID0gc2VsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzXG4gICAgfSxcbiAgICByZXBsYWNlU2VsZWN0aW9uOiBmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgZHVwID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBkdXBbaV0gPSBjb2RlOyB9XG4gICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGR1cCwgY29sbGFwc2UsIG9yaWdpbiB8fCBcIitpbnB1dFwiKTtcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCksIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlW2ldKSwgb3JpZ2luOiBvcmlnaW59O1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFwiZW5kXCIgJiYgY29tcHV0ZVJlcGxhY2VkU2VsKHRoaXMsIGNoYW5nZXMsIGNvbGxhcHNlKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKVxuICAgICAgICB7IG1ha2VDaGFuZ2UodGhpcywgY2hhbmdlc1tpJDFdKTsgfVxuICAgICAgaWYgKG5ld1NlbCkgeyBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLmNtKSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcy5jbSk7IH1cbiAgICB9KSxcbiAgICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIpO30pLFxuICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIik7fSksXG4gICAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiLCB0cnVlKTt9KSxcbiAgICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIsIHRydWUpO30pLFxuXG4gICAgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbih2YWwpIHt0aGlzLmV4dGVuZCA9IHZhbDt9LFxuICAgIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcblxuICAgIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5LCBkb25lID0gMCwgdW5kb25lID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSB7IGlmICghaGlzdC5kb25lW2ldLnJhbmdlcykgeyArK2RvbmU7IH0gfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDErKykgeyBpZiAoIWhpc3QudW5kb25lW2kkMV0ucmFuZ2VzKSB7ICsrdW5kb25lOyB9IH1cbiAgICAgIHJldHVybiB7dW5kbzogZG9uZSwgcmVkbzogdW5kb25lfVxuICAgIH0sXG4gICAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkpO1xuICAgICAgbGlua2VkRG9jcyh0aGlzLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBkb2MuaGlzdG9yeSA9IHRoaXMkMS5oaXN0b3J5OyB9LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xuICAgIH0sXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgaWYgKGZvcmNlU3BsaXQpXG4gICAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGw7IH1cbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbjogZnVuY3Rpb24gKGdlbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXG4gICAgfSxcblxuICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtkb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lKSxcbiAgICAgICAgICAgICAgdW5kb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUpfVxuICAgIH0sXG4gICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oaGlzdERhdGEpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5KTtcbiAgICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBoaXN0LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEudW5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xuICAgICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpbmUuZ3V0dGVyTWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIG4gPSBsaW5lO1xuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cbiAgICB9LFxuXG4gICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIHsgbGluZVtwcm9wXSA9IGNsczsgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgeyBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiYmFja2dyb3VuZFwiID8gXCJiZ0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XG4gICAgICAgIGlmICghY3VyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgaWYgKGNscyA9PSBudWxsKSB7IGxpbmVbcHJvcF0gPSBudWxsOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcIlwiIDogXCIgXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVXaWRnZXQ6IGZ1bmN0aW9uKHdpZGdldCkgeyB3aWRnZXQuY2xlYXIoKTsgfSxcblxuICAgIG1hcmtUZXh0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcInJhbmdlXCIpXG4gICAgfSxcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVhbE9wdHMgPSB7cmVwbGFjZWRXaXRoOiBvcHRpb25zICYmIChvcHRpb25zLm5vZGVUeXBlID09IG51bGwgPyBvcHRpb25zLndpZGdldCA6IG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHN9O1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKVxuICAgIH0sXG4gICAgZmluZE1hcmtzQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcbiAgICAgICAgICAgIChzcGFuLnRvID09IG51bGwgfHwgc3Bhbi50byA+PSBwb3MuY2gpKVxuICAgICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIG1hcmtlcnNcbiAgICB9LFxuICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xuICAgICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8gIT0gZnJvbS5saW5lIHx8XG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID49IHRvLmNoKSAmJlxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpOyB9XG4gICAgICAgIH0gfVxuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kXG4gICAgfSxcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIHsgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpOyB9IH0gfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG5cbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xuICAgICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzeiA9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlIH1cbiAgICAgICAgb2ZmIC09IHN6O1xuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKVxuICAgIH0sXG4gICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxuICAgICAgdmFyIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XG4gICAgICB2YXIgZG9jID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XG4gICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuXG4gICAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSB7IGZyb20gPSBvcHRpb25zLmZyb207IH1cbiAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7IHRvID0gb3B0aW9ucy50bzsgfVxuICAgICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxuICAgICAgOyB9KHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcbiAgICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XTtcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb3B5XG4gICAgfSxcbiAgICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jOyB9XG4gICAgICBpZiAodGhpcy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua2VkW2ldO1xuICAgICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG90aGVyLnVubGlua0RvYyh0aGlzKTtcbiAgICAgICAgZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IH1cbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbiAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBzcGxpdElkcy5wdXNoKGRvYy5pZCk7IH0sIHRydWUpO1xuICAgICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbX0sXG5cbiAgICBzcGxpdExpbmVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cbiAgICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXG4gICAgfSxcbiAgICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcIlxcblwiIH0sXG5cbiAgICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIGlmIChkaXIgIT0gXCJydGxcIikgeyBkaXIgPSBcImx0clwiOyB9XG4gICAgICBpZiAoZGlyID09IHRoaXMuZGlyZWN0aW9uKSB7IHJldHVybiB9XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gbGluZS5vcmRlciA9IG51bGw7IH0pO1xuICAgICAgaWYgKHRoaXMuY20pIHsgZGlyZWN0aW9uQ2hhbmdlZCh0aGlzLmNtKTsgfVxuICAgIH0pXG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBhbGlhcy5cbiAgRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcblxuICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgc3RyYW5nZSBJRSBiZWhhdmlvciB3aGVyZSBpdCdsbCBzb21ldGltZXNcbiAgLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcbiAgdmFyIGxhc3REcm9wID0gMDtcblxuICBmdW5jdGlvbiBvbkRyb3AoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgY2xlYXJEcmFnQ3Vyc29yKGNtKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXG4gICAgICB7IHJldHVybiB9XG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAoaWUpIHsgbGFzdERyb3AgPSArbmV3IERhdGU7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHsgcmV0dXJuIH1cbiAgICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDA7XG4gICAgICB2YXIgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xuICAgICAgICAgIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPSBudWxsOyB9KS5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInBhc3RlXCJ9O1xuICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihjbGlwUG9zKGNtLmRvYywgcG9zKSwgY2xpcFBvcyhjbS5kb2MsIGNoYW5nZUVuZChjaGFuZ2UpKSkpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVhZFRleHRGcm9tRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxuICAgICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSkge1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7IH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRbaV0gPSBjb250ZW50O1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHsgcmVhZFRleHRGcm9tRmlsZShmaWxlc1tpXSwgaSk7IH1cbiAgICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxuICAgICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID4gLTEpIHtcbiAgICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGVkaXRvciBpcyByZS1mb2N1c2VkXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCQxKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxuICAgICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7IH1cbiAgICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBwb3MpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kkMSlcbiAgICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwgc2VsZWN0ZWRbaSQxXS5hbmNob3IsIHNlbGVjdGVkW2kkMV0uaGVhZCwgXCJkcmFnXCIpOyB9IH1cbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHRleHQkMSwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoKGUkMSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG5cbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCBjbS5nZXRTZWxlY3Rpb24oKSk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcblxuICAgIC8vIFVzZSBkdW1teSBpbWFnZSBpbnN0ZWFkIG9mIGRlZmF1bHQgYnJvd3NlcnMgaW1hZ2UuXG4gICAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xuICAgICAgdmFyIGltZyA9IGVsdChcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG4gICAgICBpZiAocHJlc3RvKSB7XG4gICAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xuICAgICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgLy8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxuICAgICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgIGlmIChwcmVzdG8pIHsgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ092ZXIoY20sIGUpIHtcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICBpZiAoIXBvcykgeyByZXR1cm4gfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHBvcywgZnJhZyk7XG4gICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29ycyBDb2RlTWlycm9yLWRyYWdjdXJzb3JzXCIpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgY20uZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKTtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcbiAgLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxuICAvLyBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7IHJldHVybiB9XG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSwgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnlDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xuICAgICAgaWYgKGNtKSB7IGVkaXRvcnMucHVzaChjbSk7IH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoKSB7IGVkaXRvcnNbMF0ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykgeyBmKGVkaXRvcnNbaV0pOyB9XG4gICAgfSk7IH1cbiAgfVxuXG4gIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVHbG9iYWxIYW5kbGVycygpIHtcbiAgICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cbiAgICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCk7XG4gICAgZ2xvYmFsc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cbiAgICB2YXIgcmVzaXplVGltZXI7XG4gICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgIH0sIDEwMCk7IH1cbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcbiAgICBvbih3aW5kb3csIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KTtcbiAgfVxuICAvLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbiAgZnVuY3Rpb24gb25SZXNpemUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcbiAgICBjbS5zZXRTaXplKCk7XG4gIH1cblxuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgMzogXCJQYXVzZVwiLCA4OiBcIkJhY2tzcGFjZVwiLCA5OiBcIlRhYlwiLCAxMzogXCJFbnRlclwiLCAxNjogXCJTaGlmdFwiLCAxNzogXCJDdHJsXCIsIDE4OiBcIkFsdFwiLFxuICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXG4gICAgMzY6IFwiSG9tZVwiLCAzNzogXCJMZWZ0XCIsIDM4OiBcIlVwXCIsIDM5OiBcIlJpZ2h0XCIsIDQwOiBcIkRvd25cIiwgNDQ6IFwiUHJpbnRTY3JuXCIsIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLCA1OTogXCI7XCIsIDYxOiBcIj1cIiwgOTE6IFwiTW9kXCIsIDkyOiBcIk1vZFwiLCA5MzogXCJNb2RcIixcbiAgICAxMDY6IFwiKlwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMTA6IFwiLlwiLCAxMTE6IFwiL1wiLCAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXG4gICAgMjIxOiBcIl1cIiwgMjIyOiBcIidcIiwgMjI0OiBcIk1vZFwiLCA2MzIzMjogXCJVcFwiLCA2MzIzMzogXCJEb3duXCIsIDYzMjM0OiBcIkxlZnRcIiwgNjMyMzU6IFwiUmlnaHRcIiwgNjMyNzI6IFwiRGVsZXRlXCIsXG4gICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwiXG4gIH07XG5cbiAgLy8gTnVtYmVyIGtleXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpOyB9XG4gIC8vIEFscGhhYmV0aWMga2V5c1xuICBmb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpOyB9XG4gIC8vIEZ1bmN0aW9uIGtleXNcbiAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXCJGXCIgKyBpJDI7IH1cblxuICB2YXIga2V5TWFwID0ge307XG5cbiAga2V5TWFwLmJhc2ljID0ge1xuICAgIFwiTGVmdFwiOiBcImdvQ2hhckxlZnRcIiwgXCJSaWdodFwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiVXBcIjogXCJnb0xpbmVVcFwiLCBcIkRvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJFbmRcIjogXCJnb0xpbmVFbmRcIiwgXCJIb21lXCI6IFwiZ29MaW5lU3RhcnRTbWFydFwiLCBcIlBhZ2VVcFwiOiBcImdvUGFnZVVwXCIsIFwiUGFnZURvd25cIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgXCJEZWxldGVcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJCYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsIFwiU2hpZnQtQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLCBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcbiAgICBcIkVudGVyXCI6IFwibmV3bGluZUFuZEluZGVudFwiLCBcIkluc2VydFwiOiBcInRvZ2dsZU92ZXJ3cml0ZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uXCJcbiAgfTtcbiAgLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcbiAgLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcbiAgLy8gYXJlIHNpbXBseSBpZ25vcmVkLlxuICBrZXlNYXAucGNEZWZhdWx0ID0ge1xuICAgIFwiQ3RybC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ3RybC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkN0cmwtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DdHJsLVpcIjogXCJyZWRvXCIsIFwiQ3RybC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLCBcIkN0cmwtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJBbHQtTGVmdFwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQWx0LVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsIFwiQ3RybC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ3RybC1TXCI6IFwic2F2ZVwiLCBcIkN0cmwtRlwiOiBcImZpbmRcIixcbiAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIiwgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ3RybC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkN0cmwtXVwiOiBcImluZGVudE1vcmVcIixcbiAgICBcIkN0cmwtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DdHJsLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQWx0LVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBcImJhc2ljXCJcbiAgfTtcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbiAga2V5TWFwLmVtYWNzeSA9IHtcbiAgICBcIkN0cmwtRlwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiQ3RybC1CXCI6IFwiZ29DaGFyTGVmdFwiLCBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1OXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJDdHJsLUVcIjogXCJnb0xpbmVFbmRcIiwgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIixcbiAgICBcIkN0cmwtRFwiOiBcImRlbENoYXJBZnRlclwiLCBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLCBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsXG4gICAgXCJDdHJsLVRcIjogXCJ0cmFuc3Bvc2VDaGFyc1wiLCBcIkN0cmwtT1wiOiBcIm9wZW5MaW5lXCJcbiAgfTtcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XG4gICAgXCJDbWQtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkNtZC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUNtZC1aXCI6IFwicmVkb1wiLCBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ21kLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkNtZC1Eb3duXCI6IFwiZ29Eb2NFbmRcIiwgXCJBbHQtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsXG4gICAgXCJBbHQtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJDbWQtTGVmdFwiOiBcImdvTGluZUxlZnRcIiwgXCJDbWQtUmlnaHRcIjogXCJnb0xpbmVSaWdodFwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkFsdC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ21kLVNcIjogXCJzYXZlXCIsIFwiQ21kLUZcIjogXCJmaW5kXCIsXG4gICAgXCJDbWQtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ21kLUdcIjogXCJmaW5kUHJldlwiLCBcIkNtZC1BbHQtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DbWQtQWx0LUZcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDbWQtW1wiOiBcImluZGVudExlc3NcIiwgXCJDbWQtXVwiOiBcImluZGVudE1vcmVcIiwgXCJDbWQtQmFja3NwYWNlXCI6IFwiZGVsV3JhcHBlZExpbmVMZWZ0XCIsIFwiQ21kLURlbGV0ZVwiOiBcImRlbFdyYXBwZWRMaW5lUmlnaHRcIixcbiAgICBcIkNtZC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUNtZC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkN0cmwtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1Eb3duXCI6IFwiZ29Eb2NFbmRcIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gIH07XG4gIGtleU1hcFtcImRlZmF1bHRcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHQ7XG5cbiAgLy8gS0VZTUFQIERJU1BBVENIXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBhbHQsIGN0cmwsIHNoaWZ0LCBjbWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgY21kID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7IGFsdCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7IHNoaWZ0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCkgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoY3RybCkgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmIChjbWQpIHsgbmFtZSA9IFwiQ21kLVwiICsgbmFtZTsgfVxuICAgIGlmIChzaGlmdCkgeyBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7IH1cbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byBrZWVwIGtleW1hcHMgbW9zdGx5IHdvcmtpbmcgYXMgcmF3IG9iamVjdHNcbiAgLy8gKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIHN1cHBvcnQgZmVhdHVyZXNcbiAgLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXG4gIC8vIG5ldyBub3JtYWxpemVkIGtleW1hcCwgYW5kIHRoZW4gdXBkYXRlcyB0aGUgb2xkIG9iamVjdCB0byByZWZsZWN0XG4gIC8vIHRoaXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7IGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGtleW1hcFtrZXluYW1lXTtcbiAgICAgIGlmICgvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpIHsgY29udGludWUgfVxuICAgICAgaWYgKHZhbHVlID09IFwiLi4uXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWUgfVxuXG4gICAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFwiIFwiKSwgbm9ybWFsaXplS2V5TmFtZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbCA9ICh2b2lkIDApLCBuYW1lID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICB2YWwgPSBcIi4uLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXTtcbiAgICAgICAgaWYgKCFwcmV2KSB7IGNvcHlbbmFtZV0gPSB2YWw7IH1cbiAgICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIiArIG5hbWUpIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBrZXltYXBba2V5bmFtZV07XG4gICAgfSB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb3B5KSB7IGtleW1hcFtwcm9wXSA9IGNvcHlbcHJvcF07IH1cbiAgICByZXR1cm4ga2V5bWFwXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXkoa2V5LCBtYXAsIGhhbmRsZSwgY29udGV4dCkge1xuICAgIG1hcCA9IGdldEtleU1hcChtYXApO1xuICAgIHZhciBmb3VuZCA9IG1hcC5jYWxsID8gbWFwLmNhbGwoa2V5LCBjb250ZXh0KSA6IG1hcFtrZXldO1xuICAgIGlmIChmb3VuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIFwibm90aGluZ1wiIH1cbiAgICBpZiAoZm91bmQgPT09IFwiLi4uXCIpIHsgcmV0dXJuIFwibXVsdGlcIiB9XG4gICAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuXG4gICAgaWYgKG1hcC5mYWxsdGhyb3VnaCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFwiW29iamVjdCBBcnJheV1cIilcbiAgICAgICAgeyByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmZhbGx0aHJvdWdoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2hbaV0sIGhhbmRsZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9kaWZpZXIga2V5IHByZXNzZXMgZG9uJ3QgY291bnQgYXMgJ3JlYWwnIGtleSBwcmVzc2VzIGZvciB0aGVcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXG4gIGZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtcbiAgICByZXR1cm4gbmFtZSA9PSBcIkN0cmxcIiB8fCBuYW1lID09IFwiQWx0XCIgfHwgbmFtZSA9PSBcIlNoaWZ0XCIgfHwgbmFtZSA9PSBcIk1vZFwiXG4gIH1cblxuICBmdW5jdGlvbiBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgdmFyIGJhc2UgPSBuYW1lO1xuICAgIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcIkFsdFwiKSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXCJDdHJsXCIpIHsgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXCJNb2RcIikgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXCJTaGlmdFwiKSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBuYW1lIG9mIGEga2V5IGFzIGluZGljYXRlZCBieSBhbiBldmVudCBvYmplY3QuXG4gIGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcbiAgICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXCJjaGFyXCJdKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXTtcbiAgICBpZiAobmFtZSA9PSBudWxsIHx8IGV2ZW50LmFsdEdyYXBoS2V5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gQ3RybC1TY3JvbGxMb2NrIGhhcyBrZXlDb2RlIDMsIHNhbWUgYXMgQ3RybC1QYXVzZSxcbiAgICAvLyBzbyB3ZSdsbCB1c2UgZXZlbnQuY29kZSB3aGVuIGF2YWlsYWJsZSAoQ2hyb21lIDQ4KywgRkYgMzgrLCBTYWZhcmkgMTAuMSspXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMyAmJiBldmVudC5jb2RlKSB7IG5hbWUgPSBldmVudC5jb2RlOyB9XG4gICAgcmV0dXJuIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlNYXAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiA/IGtleU1hcFt2YWxdIDogdmFsXG4gIH1cblxuICAvLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cbiAgZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgY29tcHV0ZSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdO1xuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXG4gICAgLy8gcmFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xuICAgICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGtpbGwucG9wKCk7XG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xuICAgICAgICAgIHRvS2lsbC5mcm9tID0gcmVwbGFjZWQuZnJvbTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBraWxsLnB1c2godG9LaWxsKTtcbiAgICB9XG4gICAgLy8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcIitkZWxldGVcIik7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgY2gsIGRpcikge1xuICAgIHZhciB0YXJnZXQgPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZS50ZXh0LCBjaCArIGRpciwgZGlyKTtcbiAgICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldFxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgc3RhcnQuY2gsIGRpcik7XG4gICAgcmV0dXJuIGNoID09IG51bGwgPyBudWxsIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgZGlyIDwgMCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpXG4gIH1cblxuICBmdW5jdGlvbiBlbmRPZkxpbmUodmlzdWFsbHksIGNtLCBsaW5lT2JqLCBsaW5lTm8sIGRpcikge1xuICAgIGlmICh2aXN1YWxseSkge1xuICAgICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikgeyBkaXIgPSAtZGlyOyB9XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICB2YXIgcGFydCA9IGRpciA8IDAgPyBsc3Qob3JkZXIpIDogb3JkZXJbMF07XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSk7XG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgICB2YXIgY2g7XG4gICAgICAgIC8vIFdpdGggYSB3cmFwcGVkIHJ0bCBjaHVuayAocG9zc2libHkgc3Bhbm5pbmcgbXVsdGlwbGUgYmlkaSBwYXJ0cyksXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGxhc3QgYmlkaSBwYXJ0IGlzIG5vdCBvbiB0aGUgbGFzdCB2aXN1YWwgbGluZSxcbiAgICAgICAgLy8gc2luY2UgdmlzdWFsIGxpbmVzIGNvbnRhaW4gY29udGVudCBvcmRlci1jb25zZWN1dGl2ZSBjaHVua3MuXG4gICAgICAgIC8vIFRodXMsIGluIHJ0bCwgd2UgYXJlIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyXG4gICAgICAgIC8vIGluIHRoZSBydGwgY2h1bmsgdGhhdCBpcyBvbiB0aGUgbGFzdCBsaW5lICh0aGF0IGlzLCB0aGUgc2FtZSBsaW5lXG4gICAgICAgIC8vIGFzIHRoZSBsYXN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXIpLlxuICAgICAgICBpZiAocGFydC5sZXZlbCA+IDAgfHwgY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7XG4gICAgICAgICAgdmFyIHByZXAgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgICAgICAgIGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB2YXIgdGFyZ2V0VG9wID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcDtcbiAgICAgICAgICBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3AgPT0gdGFyZ2V0VG9wOyB9LCAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSkgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMSwgY2gpO1xuICAgICAgICAgIGlmIChzdGlja3kgPT0gXCJiZWZvcmVcIikgeyBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmVPYmosIGNoLCAxKTsgfVxuICAgICAgICB9IGVsc2UgeyBjaCA9IGRpciA8IDAgPyBwYXJ0LnRvIDogcGFydC5mcm9tOyB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmVObywgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDAsIGRpciA8IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiKVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGNtLCBsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikgfVxuICAgIGlmIChzdGFydC5jaCA+PSBsaW5lLnRleHQubGVuZ3RoKSB7XG4gICAgICBzdGFydC5jaCA9IGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImJlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQuY2ggPD0gMCkge1xuICAgICAgc3RhcnQuY2ggPSAwO1xuICAgICAgc3RhcnQuc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgIH1cbiAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQuY2gsIHN0YXJ0LnN0aWNreSksIHBhcnQgPSBiaWRpW3BhcnRQb3NdO1xuICAgIGlmIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgJiYgcGFydC5sZXZlbCAlIDIgPT0gMCAmJiAoZGlyID4gMCA/IHBhcnQudG8gPiBzdGFydC5jaCA6IHBhcnQuZnJvbSA8IHN0YXJ0LmNoKSkge1xuICAgICAgLy8gQ2FzZSAxOiBXZSBtb3ZlIHdpdGhpbiBhbiBsdHIgcGFydCBpbiBhbiBsdHIgZWRpdG9yLiBFdmVuIHdpdGggd3JhcHBlZCBsaW5lcyxcbiAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGFwcGVucy5cbiAgICAgIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpXG4gICAgfVxuXG4gICAgdmFyIG12ID0gZnVuY3Rpb24gKHBvcywgZGlyKSB7IHJldHVybiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBwb3MgaW5zdGFuY2VvZiBQb3MgPyBwb3MuY2ggOiBwb3MsIGRpcik7IH07XG4gICAgdmFyIHByZXA7XG4gICAgdmFyIGdldFdyYXBwZWRMaW5lRXh0ZW50ID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IHJldHVybiB7YmVnaW46IDAsIGVuZDogbGluZS50ZXh0Lmxlbmd0aH0gfVxuICAgICAgcHJlcCA9IHByZXAgfHwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKTtcbiAgICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmUsIHByZXAsIGNoKVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRMaW5lRXh0ZW50ID0gZ2V0V3JhcHBlZExpbmVFeHRlbnQoc3RhcnQuc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBtdihzdGFydCwgLTEpIDogc3RhcnQuY2gpO1xuXG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiB8fCBwYXJ0LmxldmVsID09IDEpIHtcbiAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAocGFydC5sZXZlbCA9PSAxKSA9PSAoZGlyIDwgMCk7XG4gICAgICB2YXIgY2ggPSBtdihzdGFydCwgbW92ZUluU3RvcmFnZU9yZGVyID8gMSA6IC0xKTtcbiAgICAgIGlmIChjaCAhPSBudWxsICYmICghbW92ZUluU3RvcmFnZU9yZGVyID8gY2ggPj0gcGFydC5mcm9tICYmIGNoID49IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudC5lbmQpKSB7XG4gICAgICAgIC8vIENhc2UgMjogV2UgbW92ZSB3aXRoaW4gYW4gcnRsIHBhcnQgb3IgaW4gYW4gcnRsIGVkaXRvciBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZVxuICAgICAgICB2YXIgc3RpY2t5ID0gbW92ZUluU3RvcmFnZU9yZGVyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDM6IENvdWxkIG5vdCBtb3ZlIHdpdGhpbiB0aGlzIGJpZGkgcGFydCBpbiB0aGlzIHZpc3VhbCBsaW5lLCBzbyBsZWF2ZVxuICAgIC8vIHRoZSBjdXJyZW50IGJpZGkgcGFydFxuXG4gICAgdmFyIHNlYXJjaEluVmlzdWFsTGluZSA9IGZ1bmN0aW9uIChwYXJ0UG9zLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KSB7XG4gICAgICB2YXIgZ2V0UmVzID0gZnVuY3Rpb24gKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIHsgcmV0dXJuIG1vdmVJblN0b3JhZ2VPcmRlclxuICAgICAgICA/IG5ldyBQb3Moc3RhcnQubGluZSwgbXYoY2gsIDEpLCBcImJlZm9yZVwiKVxuICAgICAgICA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIFwiYWZ0ZXJcIik7IH07XG5cbiAgICAgIGZvciAoOyBwYXJ0UG9zID49IDAgJiYgcGFydFBvcyA8IGJpZGkubGVuZ3RoOyBwYXJ0UG9zICs9IGRpcikge1xuICAgICAgICB2YXIgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyID4gMCkgPT0gKHBhcnQubGV2ZWwgIT0gMSk7XG4gICAgICAgIHZhciBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogbXYod3JhcHBlZExpbmVFeHRlbnQuZW5kLCAtMSk7XG4gICAgICAgIGlmIChwYXJ0LmZyb20gPD0gY2ggJiYgY2ggPCBwYXJ0LnRvKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgICBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHBhcnQuZnJvbSA6IG12KHBhcnQudG8sIC0xKTtcbiAgICAgICAgaWYgKHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDw9IGNoICYmIGNoIDwgd3JhcHBlZExpbmVFeHRlbnQuZW5kKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYXNlIDNhOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgdmFyIHJlcyA9IHNlYXJjaEluVmlzdWFsTGluZShwYXJ0UG9zICsgZGlyLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KTtcbiAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuXG4gICAgLy8gQ2FzZSAzYjogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgbmV4dCB2aXN1YWwgbGluZVxuICAgIHZhciBuZXh0Q2ggPSBkaXIgPiAwID8gd3JhcHBlZExpbmVFeHRlbnQuZW5kIDogbXYod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4sIC0xKTtcbiAgICBpZiAobmV4dENoICE9IG51bGwgJiYgIShkaXIgPiAwICYmIG5leHRDaCA9PSBsaW5lLnRleHQubGVuZ3RoKSkge1xuICAgICAgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKGRpciA+IDAgPyAwIDogYmlkaS5sZW5ndGggLSAxLCBkaXIsIGdldFdyYXBwZWRMaW5lRXh0ZW50KG5leHRDaCkpO1xuICAgICAgaWYgKHJlcykgeyByZXR1cm4gcmVzIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDQ6IE5vd2hlcmUgdG8gbW92ZVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDb21tYW5kcyBhcmUgcGFyYW1ldGVyLWxlc3MgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gYW5cbiAgLy8gZWRpdG9yLCBtb3N0bHkgdXNlZCBmb3Iga2V5YmluZGluZ3MuXG4gIHZhciBjb21tYW5kcyA9IHtcbiAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcbiAgICBzaW5nbGVTZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcImFuY2hvclwiKSwgY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgc2VsX2RvbnRTY3JvbGwpOyB9LFxuICAgIGtpbGxMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lLCBsZW4pfSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9XG4gICAgICB9XG4gICAgfSk7IH0sXG4gICAgZGVsZXRlTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XG4gICAgICBmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLFxuICAgICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXG4gICAgfSk7IH0pOyB9LFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsV3JhcHBlZExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogbGVmdFBvcywgdG86IHJhbmdlLmZyb20oKX1cbiAgICB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfVxuICAgIH0pOyB9LFxuICAgIHVuZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kbygpOyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkbygpOyB9LFxuICAgIHVuZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kb1NlbGVjdGlvbigpOyB9LFxuICAgIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkb1NlbGVjdGlvbigpOyB9LFxuICAgIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpOyB9LFxuICAgIGdvRG9jRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20ubGFzdExpbmUoKSkpOyB9LFxuICAgIGdvTGluZVN0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogMX1cbiAgICApOyB9LFxuICAgIGdvTGluZVN0YXJ0U21hcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0U21hcnQoY20sIHJhbmdlLmhlYWQpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IC0xfVxuICAgICk7IH0sXG4gICAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKVxuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcUy8pKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCkgfVxuICAgICAgcmV0dXJuIHBvc1xuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvTGluZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvUGFnZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcInBhZ2VcIik7IH0sXG4gICAgZ29QYWdlRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcInBhZ2VcIik7IH0sXG4gICAgZ29DaGFyTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBnb0NvbHVtbkxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiY29sdW1uXCIpOyB9LFxuICAgIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Xb3JkTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGdvR3JvdXBSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvV29yZFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxDaGFyQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwiY29kZXBvaW50XCIpOyB9LFxuICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBkZWxXb3JkQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcIndvcmRcIik7IH0sXG4gICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJncm91cFwiKTsgfSxcbiAgICBkZWxHcm91cEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJncm91cFwiKTsgfSxcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpOyB9LFxuICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9LFxuICAgIGluZGVudExlc3M6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic3VidHJhY3RcIik7IH0sXG4gICAgaW5zZXJ0VGFiOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7IH0sXG4gICAgaW5zZXJ0U29mdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICB2YXIgc3BhY2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmZyb20oKTtcbiAgICAgICAgdmFyIGNvbCA9IGNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpO1xuICAgICAgfVxuICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKTtcbiAgICB9LFxuICAgIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9XG4gICAgICBlbHNlIHsgY20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7IH1cbiAgICB9LFxuICAgIC8vIFN3YXAgdGhlIHR3byBjaGFycyBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgLy8gTW92ZSBjdXJzb3IgYmVoaW5kIHRoZSB0d28gc3dhcHBlZCBjaGFyYWN0ZXJzIGFmdGVyd2FyZHMuXG4gICAgLy9cbiAgICAvLyBEb2Vzbid0IGNvbnNpZGVyIGxpbmUgZmVlZHMgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBzY2FuIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSB0byBmaW5kIGEgY2hhcmFjdGVyLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cbiAgICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIHdpdGggbm9uLWVtcHR5IHNlbGVjdGlvbnMuXG4gICAgdHJhbnNwb3NlQ2hhcnM6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSB7IGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpOyB9XG4gICAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcbiAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSk7XG4gICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIGNtLmRvYy5saW5lU2VwYXJhdG9yKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTZWwucHVzaChuZXcgUmFuZ2UoY3VyLCBjdXIpKTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2VsKTtcbiAgICB9KTsgfSxcbiAgICBuZXdsaW5lQW5kSW5kZW50OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSBzZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2ldLmFuY2hvciwgc2Vsc1tpXS5oZWFkLCBcIitpbnB1dFwiKTsgfVxuICAgICAgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxzLmxlbmd0aDsgaSQxKyspXG4gICAgICAgIHsgY20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsIG51bGwsIHRydWUpOyB9XG4gICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICB9KTsgfSxcbiAgICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXFxuXCIsIFwic3RhcnRcIik7IH0sXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XG4gIH07XG5cblxuICBmdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgdmlzdWFsLCBsaW5lTiwgMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZUVuZChsaW5lKTtcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKTsgfVxuICAgIHJldHVybiBlbmRPZkxpbmUodHJ1ZSwgY20sIGxpbmUsIGxpbmVOLCAtMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluZVN0YXJ0KGNtLCBwb3MubGluZSk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgc3RhcnQubGluZSk7XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgaWYgKCFvcmRlciB8fCBvcmRlclswXS5sZXZlbCA9PSAwKSB7XG4gICAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KHN0YXJ0LmNoLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XG4gICAgICB2YXIgaW5XUyA9IHBvcy5saW5lID09IHN0YXJ0LmxpbmUgJiYgcG9zLmNoIDw9IGZpcnN0Tm9uV1MgJiYgcG9zLmNoO1xuICAgICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MsIHN0YXJ0LnN0aWNreSlcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICAvLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxuICBmdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcbiAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdO1xuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcbiAgICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XG4gICAgY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY20uaXNSZWFkT25seSgpKSB7IGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlOyB9XG4gICAgICBpZiAoZHJvcFNoaWZ0KSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTsgfVxuICAgICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gcHJldlNoaWZ0O1xuICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZG9uZVxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkobmFtZSwgY20uc3RhdGUua2V5TWFwc1tpXSwgaGFuZGxlLCBjbSk7XG4gICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgIH1cbiAgICByZXR1cm4gKGNtLm9wdGlvbnMuZXh0cmFLZXlzICYmIGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmV4dHJhS2V5cywgaGFuZGxlLCBjbSkpXG4gICAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pXG4gIH1cblxuICAvLyBOb3RlIHRoYXQsIGRlc3BpdGUgdGhlIG5hbWUsIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIHRvIGNoZWNrXG4gIC8vIGZvciBib3VuZCBtb3VzZSBjbGlja3MuXG5cbiAgdmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZDtcblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICBpZiAoaXNNb2RpZmllcktleShuYW1lKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuICAgICAgaWYgKC9cXCckLy50ZXN0KG5hbWUpKVxuICAgICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG51bGw7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5rZXlTZXEgPT0gc2VxKSB7XG4gICAgICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsO1xuICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IH1cbiAgICAgIGlmIChkaXNwYXRjaEtleUlubmVyKGNtLCBzZXEgKyBcIiBcIiArIG5hbWUsIGUsIGhhbmRsZSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKTtcblxuICAgIGlmIChyZXN1bHQgPT0gXCJtdWx0aVwiKVxuICAgICAgeyBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lOyB9XG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIilcbiAgICAgIHsgc2lnbmFsTGF0ZXIoY20sIFwia2V5SGFuZGxlZFwiLCBjbSwgbmFtZSwgZSk7IH1cblxuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIgfHwgcmVzdWx0ID09IFwibXVsdGlcIikge1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhcmVzdWx0XG4gIH1cblxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xuICAgIHZhciBuYW1lID0ga2V5TmFtZShlLCB0cnVlKTtcbiAgICBpZiAoIW5hbWUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChlLnNoaWZ0S2V5ICYmICFjbS5zdGF0ZS5rZXlTZXEpIHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xuICAgICAgLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXG4gICAgICAvLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIlNoaWZ0LVwiICsgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gICAgICAgICAgfHwgZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxuICAgICAgICAgICAgICAgICB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpIH1cbiAgICAgICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpOyB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxuICBmdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gIH1cblxuICB2YXIgbGFzdFN0b3BwZWRLZXkgPSBudWxsO1xuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0ICE9IGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSkgeyByZXR1cm4gfVxuICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIC8vIElFIGRvZXMgc3RyYW5nZSB0aGluZ3Mgd2l0aCBlc2NhcGUuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSAmJiBlLmtleUNvZGUgPT0gMjcpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gICAgdmFyIGNvZGUgPSBlLmtleUNvZGU7XG4gICAgY20uZGlzcGxheS5zaGlmdCA9IGNvZGUgPT0gMTYgfHwgZS5zaGlmdEtleTtcbiAgICB2YXIgaGFuZGxlZCA9IGhhbmRsZUtleUJpbmRpbmcoY20sIGUpO1xuICAgIGlmIChwcmVzdG8pIHtcbiAgICAgIGxhc3RTdG9wcGVkS2V5ID0gaGFuZGxlZCA/IGNvZGUgOiBudWxsO1xuICAgICAgLy8gT3BlcmEgaGFzIG5vIGN1dCBldmVudC4uLiB3ZSB0cnkgdG8gYXQgbGVhc3QgY2F0Y2ggdGhlIGtleSBjb21ib1xuICAgICAgaWYgKCFoYW5kbGVkICYmIGNvZGUgPT0gODggJiYgIWhhc0NvcHlFdmVudCAmJiAobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcbiAgICAgICAgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpOyB9XG4gICAgfVxuICAgIGlmIChnZWNrbyAmJiAhbWFjICYmICFoYW5kbGVkICYmIGNvZGUgPT0gNDYgJiYgZS5zaGlmdEtleSAmJiAhZS5jdHJsS2V5ICYmIGRvY3VtZW50LmV4ZWNDb21tYW5kKVxuICAgICAgeyBkb2N1bWVudC5leGVjQ29tbWFuZChcImN1dFwiKTsgfVxuXG4gICAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cbiAgICBpZiAoY29kZSA9PSAxOCAmJiAhL1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKVxuICAgICAgeyBzaG93Q3Jvc3NIYWlyKGNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvd0Nyb3NzSGFpcihjbSkge1xuICAgIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2O1xuICAgIGFkZENsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XG5cbiAgICBmdW5jdGlvbiB1cChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09IDE4IHx8ICFlLmFsdEtleSkge1xuICAgICAgICBybUNsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJrZXl1cFwiLCB1cCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICAgICAgfVxuICAgIH1cbiAgICBvbihkb2N1bWVudCwgXCJrZXl1cFwiLCB1cCk7XG4gICAgb24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5VXAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMTYpIHsgdGhpcy5kb2Muc2VsLnNoaWZ0ID0gZmFsc2U7IH1cbiAgICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0ICE9IGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSkgeyByZXR1cm4gfVxuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IG1hYyAmJiBlLm1ldGFLZXkpIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSwgY2hhckNvZGUgPSBlLmNoYXJDb2RlO1xuICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJufVxuICAgIGlmICgocHJlc3RvICYmICghZS53aGljaCB8fCBlLndoaWNoIDwgMTApKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSk7XG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGtleXByZXNzIGV2ZW50cyBmb3IgYmFja3NwYWNlXG4gICAgaWYgKGNoID09IFwiXFx4MDhcIikgeyByZXR1cm4gfVxuICAgIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSB7IHJldHVybiB9XG4gICAgY20uZGlzcGxheS5pbnB1dC5vbktleVByZXNzKGUpO1xuICB9XG5cbiAgdmFyIERPVUJMRUNMSUNLX0RFTEFZID0gNDAwO1xuXG4gIHZhciBQYXN0Q2xpY2sgPSBmdW5jdGlvbih0aW1lLCBwb3MsIGJ1dHRvbikge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gIH07XG5cbiAgUGFzdENsaWNrLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZSArIERPVUJMRUNMSUNLX0RFTEFZID4gdGltZSAmJlxuICAgICAgY21wKHBvcywgdGhpcy5wb3MpID09IDAgJiYgYnV0dG9uID09IHRoaXMuYnV0dG9uXG4gIH07XG5cbiAgdmFyIGxhc3RDbGljaywgbGFzdERvdWJsZUNsaWNrO1xuICBmdW5jdGlvbiBjbGlja1JlcGVhdChwb3MsIGJ1dHRvbikge1xuICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdENsaWNrID0gbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInRyaXBsZVwiXG4gICAgfSBlbHNlIGlmIChsYXN0Q2xpY2sgJiYgbGFzdENsaWNrLmNvbXBhcmUobm93LCBwb3MsIGJ1dHRvbikpIHtcbiAgICAgIGxhc3REb3VibGVDbGljayA9IG5ldyBQYXN0Q2xpY2sobm93LCBwb3MsIGJ1dHRvbik7XG4gICAgICBsYXN0Q2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwiZG91YmxlXCJcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3REb3VibGVDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzaW5nbGVcIlxuICAgIH1cbiAgfVxuXG4gIC8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxuICAvLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXG4gIC8vIChjdHJsLWNsaWNrKSwgcmVjdGFuZ2xlIGRyYWcgKGFsdC1kcmFnKSwgb3IgeHdpblxuICAvLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxuICAvLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxuICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBkaXNwbGF5LmFjdGl2ZVRvdWNoICYmIGRpc3BsYXkuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSB7IHJldHVybiB9XG4gICAgZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICBkaXNwbGF5LnNoaWZ0ID0gZS5zaGlmdEtleTtcblxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XG4gICAgICBpZiAoIXdlYmtpdCkge1xuICAgICAgICAvLyBCcmllZmx5IHR1cm4gb2ZmIGRyYWdnYWJpbGl0eSwgdG8gYWxsb3cgd2lkZ2V0cyB0byBkb1xuICAgICAgICAvLyBub3JtYWwgZHJhZ2dpbmcgdGhpbmdzLlxuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfSwgMTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgYnV0dG9uID0gZV9idXR0b24oZSksIHJlcGVhdCA9IHBvcyA/IGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSA6IFwic2luZ2xlXCI7XG4gICAgd2luZG93LmZvY3VzKCk7XG5cbiAgICAvLyAjMzI2MTogbWFrZSBzdXJlLCB0aGF0IHdlJ3JlIG5vdCBzdGFydGluZyBhIHNlY29uZCBzZWxlY3Rpb25cbiAgICBpZiAoYnV0dG9uID09IDEgJiYgY20uc3RhdGUuc2VsZWN0aW5nVGV4dClcbiAgICAgIHsgY20uc3RhdGUuc2VsZWN0aW5nVGV4dChlKTsgfVxuXG4gICAgaWYgKHBvcyAmJiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGUpKSB7IHJldHVybiB9XG5cbiAgICBpZiAoYnV0dG9uID09IDEpIHtcbiAgICAgIGlmIChwb3MpIHsgbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBlKTsgfVxuICAgICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcikgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMikge1xuICAgICAgaWYgKHBvcykgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MpOyB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uID09IDMpIHtcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgICAgIGVsc2UgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG5hbWUgPSBcIkNsaWNrXCI7XG4gICAgaWYgKHJlcGVhdCA9PSBcImRvdWJsZVwiKSB7IG5hbWUgPSBcIkRvdWJsZVwiICsgbmFtZTsgfVxuICAgIGVsc2UgaWYgKHJlcGVhdCA9PSBcInRyaXBsZVwiKSB7IG5hbWUgPSBcIlRyaXBsZVwiICsgbmFtZTsgfVxuICAgIG5hbWUgPSAoYnV0dG9uID09IDEgPyBcIkxlZnRcIiA6IGJ1dHRvbiA9PSAyID8gXCJNaWRkbGVcIiA6IFwiUmlnaHRcIikgKyBuYW1lO1xuXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCAgYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCksIGV2ZW50LCBmdW5jdGlvbiAoYm91bmQpIHtcbiAgICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikgeyBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTsgfVxuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgICAgZG9uZSA9IGJvdW5kKGNtLCBwb3MpICE9IFBhc3M7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCkge1xuICAgIHZhciBvcHRpb24gPSBjbS5nZXRPcHRpb24oXCJjb25maWd1cmVNb3VzZVwiKTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb24gPyBvcHRpb24oY20sIHJlcGVhdCwgZXZlbnQpIDoge307XG4gICAgaWYgKHZhbHVlLnVuaXQgPT0gbnVsbCkge1xuICAgICAgdmFyIHJlY3QgPSBjaHJvbWVPUyA/IGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50Lm1ldGFLZXkgOiBldmVudC5hbHRLZXk7XG4gICAgICB2YWx1ZS51bml0ID0gcmVjdCA/IFwicmVjdGFuZ2xlXCIgOiByZXBlYXQgPT0gXCJzaW5nbGVcIiA/IFwiY2hhclwiIDogcmVwZWF0ID09IFwiZG91YmxlXCIgPyBcIndvcmRcIiA6IFwibGluZVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUuZXh0ZW5kID09IG51bGwgfHwgY20uZG9jLmV4dGVuZCkgeyB2YWx1ZS5leHRlbmQgPSBjbS5kb2MuZXh0ZW5kIHx8IGV2ZW50LnNoaWZ0S2V5OyB9XG4gICAgaWYgKHZhbHVlLmFkZE5ldyA9PSBudWxsKSB7IHZhbHVlLmFkZE5ldyA9IG1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5OyB9XG4gICAgaWYgKHZhbHVlLm1vdmVPbkRyYWcgPT0gbnVsbCkgeyB2YWx1ZS5tb3ZlT25EcmFnID0gIShtYWMgPyBldmVudC5hbHRLZXkgOiBldmVudC5jdHJsS2V5KTsgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgIGlmIChpZSkgeyBzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsIGNtKSwgMCk7IH1cbiAgICBlbHNlIHsgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTsgfVxuXG4gICAgdmFyIGJlaGF2aW9yID0gY29uZmlndXJlTW91c2UoY20sIHJlcGVhdCwgZXZlbnQpO1xuXG4gICAgdmFyIHNlbCA9IGNtLmRvYy5zZWwsIGNvbnRhaW5lZDtcbiAgICBpZiAoY20ub3B0aW9ucy5kcmFnRHJvcCAmJiBkcmFnQW5kRHJvcCAmJiAhY20uaXNSZWFkT25seSgpICYmXG4gICAgICAgIHJlcGVhdCA9PSBcInNpbmdsZVwiICYmIChjb250YWluZWQgPSBzZWwuY29udGFpbnMocG9zKSkgPiAtMSAmJlxuICAgICAgICAoY21wKChjb250YWluZWQgPSBzZWwucmFuZ2VzW2NvbnRhaW5lZF0pLmZyb20oKSwgcG9zKSA8IDAgfHwgcG9zLnhSZWwgPiAwKSAmJlxuICAgICAgICAoY21wKGNvbnRhaW5lZC50bygpLCBwb3MpID4gMCB8fCBwb3MueFJlbCA8IDApKVxuICAgICAgeyBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcik7IH1cbiAgICBlbHNlXG4gICAgICB7IGxlZnRCdXR0b25TZWxlY3QoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICB9XG5cbiAgLy8gU3RhcnQgYSB0ZXh0IGRyYWcuIFdoZW4gaXQgZW5kcywgc2VlIGlmIGFueSBkcmFnZ2luZyBhY3R1YWxseVxuICAvLyBoYXBwZW4sIGFuZCB0cmVhdCBhcyBhIGNsaWNrIGlmIGl0IGRpZG4ndC5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIG1vdmVkID0gZmFsc2U7XG4gICAgdmFyIGRyYWdFbmQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAod2Via2l0KSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7IH1cbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlO1xuICAgICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICAgIGlmIChjbS5oYXNGb2N1cygpKSB7IGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgICAgfVxuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG4gICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGlmICghYmVoYXZpb3IuYWRkTmV3KVxuICAgICAgICAgIHsgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgcG9zLCBudWxsLCBudWxsLCBiZWhhdmlvci5leHRlbmQpOyB9XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIHVuZXhwbGFpbmFibGUgZm9jdXMgcHJvYmxlbSBpbiBJRTkgKCMyMTI3KSBhbmQgQ2hyb21lICgjMzA4MSlcbiAgICAgICAgaWYgKCh3ZWJraXQgJiYgIXNhZmFyaSkgfHwgaWUgJiYgaWVfdmVyc2lvbiA9PSA5KVxuICAgICAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7ZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pOyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7fSwgMjApOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtb3VzZU1vdmUgPSBmdW5jdGlvbihlMikge1xuICAgICAgbW92ZWQgPSBtb3ZlZCB8fCBNYXRoLmFicyhldmVudC5jbGllbnRYIC0gZTIuY2xpZW50WCkgKyBNYXRoLmFicyhldmVudC5jbGllbnRZIC0gZTIuY2xpZW50WSkgPj0gMTA7XG4gICAgfTtcbiAgICB2YXIgZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZWQgPSB0cnVlOyB9O1xuICAgIC8vIExldCB0aGUgZHJhZyBoYW5kbGVyIGhhbmRsZSB0aGlzLlxuICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZHJhZ0VuZDtcbiAgICBkcmFnRW5kLmNvcHkgPSAhYmVoYXZpb3IubW92ZU9uRHJhZztcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmUpO1xuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ3N0YXJ0XCIsIGRyYWdTdGFydCk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGRyYWdFbmQpO1xuXG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgLy8gSUUncyBhcHByb2FjaCB0byBkcmFnZ2FibGVcbiAgICBpZiAoZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlRm9yVW5pdChjbSwgcG9zLCB1bml0KSB7XG4gICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShwb3MsIHBvcykgfVxuICAgIGlmICh1bml0ID09IFwid29yZFwiKSB7IHJldHVybiBjbS5maW5kV29yZEF0KHBvcykgfVxuICAgIGlmICh1bml0ID09IFwibGluZVwiKSB7IHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSkgfVxuICAgIHZhciByZXN1bHQgPSB1bml0KGNtLCBwb3MpO1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmVzdWx0LmZyb20sIHJlc3VsdC50bylcbiAgfVxuXG4gIC8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHN0YXJ0LCBiZWhhdmlvcikge1xuICAgIGlmIChpZSkgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBlX3ByZXZlbnREZWZhdWx0KGV2ZW50KTtcblxuICAgIHZhciBvdXJSYW5nZSwgb3VySW5kZXgsIHN0YXJ0U2VsID0gZG9jLnNlbCwgcmFuZ2VzID0gc3RhcnRTZWwucmFuZ2VzO1xuICAgIGlmIChiZWhhdmlvci5hZGROZXcgJiYgIWJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcbiAgICAgIGlmIChvdXJJbmRleCA+IC0xKVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3VyUmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIG91ckluZGV4ID0gZG9jLnNlbC5wcmltSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgICAgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgIG91ckluZGV4ID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlRm9yVW5pdChjbSwgc3RhcnQsIGJlaGF2aW9yLnVuaXQpO1xuICAgICAgaWYgKGJlaGF2aW9yLmV4dGVuZClcbiAgICAgICAgeyBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKG91clJhbmdlLCByYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBvdXJSYW5nZSA9IHJhbmdlOyB9XG4gICAgfVxuXG4gICAgaWYgKCFiZWhhdmlvci5hZGROZXcpIHtcbiAgICAgIG91ckluZGV4ID0gMDtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW291clJhbmdlXSwgMCksIHNlbF9tb3VzZSk7XG4gICAgICBzdGFydFNlbCA9IGRvYy5zZWw7XG4gICAgfSBlbHNlIGlmIChvdXJJbmRleCA9PSAtMSkge1xuICAgICAgb3VySW5kZXggPSByYW5nZXMubGVuZ3RoO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VzLmxlbmd0aCA+IDEgJiYgcmFuZ2VzW291ckluZGV4XS5lbXB0eSgpICYmIGJlaGF2aW9yLnVuaXQgPT0gXCJjaGFyXCIgJiYgIWJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLFxuICAgICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFwiKm1vdXNlXCJ9KTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvcyA9IHN0YXJ0O1xuICAgIGZ1bmN0aW9uIGV4dGVuZFRvKHBvcykge1xuICAgICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHsgcmV0dXJuIH1cbiAgICAgIGxhc3RQb3MgPSBwb3M7XG5cbiAgICAgIGlmIChiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgc3RhcnQubGluZSkudGV4dCwgc3RhcnQuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xuICAgICAgICBmb3IgKHZhciBsaW5lID0gTWF0aC5taW4oc3RhcnQubGluZSwgcG9zLmxpbmUpLCBlbmQgPSBNYXRoLm1pbihjbS5sYXN0TGluZSgpLCBNYXRoLm1heChzdGFydC5saW5lLCBwb3MubGluZSkpO1xuICAgICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcbiAgICAgICAgICBpZiAobGVmdCA9PSByaWdodClcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGxlZnRQb3MpKSk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGxlZnRQb3MpXG4gICAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBmaW5kQ29sdW1uKHRleHQsIHJpZ2h0LCB0YWJTaXplKSkpKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSk7IH1cbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMpLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcIiptb3VzZVwiLCBzY3JvbGw6IGZhbHNlfSk7XG4gICAgICAgIGNtLnNjcm9sbEludG9WaWV3KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2xkUmFuZ2UgPSBvdXJSYW5nZTtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIGJlaGF2aW9yLnVuaXQpO1xuICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkO1xuICAgICAgICBpZiAoY21wKHJhbmdlLmFuY2hvciwgYW5jaG9yKSA+IDApIHtcbiAgICAgICAgICBoZWFkID0gcmFuZ2UuaGVhZDtcbiAgICAgICAgICBhbmNob3IgPSBtaW5Qb3Mob2xkUmFuZ2UuZnJvbSgpLCByYW5nZS5hbmNob3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5hbmNob3I7XG4gICAgICAgICAgYW5jaG9yID0gbWF4UG9zKG9sZFJhbmdlLnRvKCksIHJhbmdlLmhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZXMkMSA9IHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgcmFuZ2VzJDFbb3VySW5kZXhdID0gYmlkaVNpbXBsaWZ5KGNtLCBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIGFuY2hvciksIGhlYWQpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMkMSwgb3VySW5kZXgpLCBzZWxfbW91c2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0b3JTaXplID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIFVzZWQgdG8gZW5zdXJlIHRpbWVvdXQgcmUtdHJpZXMgZG9uJ3QgZmlyZSB3aGVuIGFub3RoZXIgZXh0ZW5kXG4gICAgLy8gaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lIChjbGVhclRpbWVvdXQgaXNuJ3QgcmVsaWFibGUgLS0gYXRcbiAgICAvLyBsZWFzdCBvbiBDaHJvbWUsIHRoZSB0aW1lb3V0cyBzdGlsbCBoYXBwZW4gZXZlbiB3aGVuIGNsZWFyZWQsXG4gICAgLy8gaWYgdGhlIGNsZWFyIGhhcHBlbnMgYWZ0ZXIgdGhlaXIgc2NoZWR1bGVkIGZpcmluZyB0aW1lKS5cbiAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoZSkge1xuICAgICAgdmFyIGN1ckNvdW50ID0gKytjb3VudGVyO1xuICAgICAgdmFyIGN1ciA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKTtcbiAgICAgIGlmICghY3VyKSB7IHJldHVybiB9XG4gICAgICBpZiAoY21wKGN1ciwgbGFzdFBvcykgIT0gMCkge1xuICAgICAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgICBleHRlbmRUbyhjdXIpO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MpO1xuICAgICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcbiAgICAgICAgICB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7aWYgKGNvdW50ZXIgPT0gY3VyQ291bnQpIHsgZXh0ZW5kKGUpOyB9fSksIDE1MCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMDtcbiAgICAgICAgaWYgKG91dHNpZGUpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY291bnRlciAhPSBjdXJDb3VudCkgeyByZXR1cm4gfVxuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGU7XG4gICAgICAgICAgZXh0ZW5kKGUpO1xuICAgICAgICB9KSwgNTApOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZShlKSB7XG4gICAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBjb3VudGVyID0gSW5maW5pdHk7XG4gICAgICAvLyBJZiBlIGlzIG51bGwgb3IgdW5kZWZpbmVkIHdlIGludGVycHJldCB0aGlzIGFzIHNvbWVvbmUgdHJ5aW5nXG4gICAgICAvLyB0byBleHBsaWNpdGx5IGNhbmNlbCB0aGUgc2VsZWN0aW9uIHJhdGhlciB0aGFuIHRoZSB1c2VyXG4gICAgICAvLyBsZXR0aW5nIGdvIG9mIHRoZSBtb3VzZSBidXR0b24uXG4gICAgICBpZiAoZSkge1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdXApO1xuICAgICAgZG9jLmhpc3RvcnkubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vdmUgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5idXR0b25zID09PSAwIHx8ICFlX2J1dHRvbihlKSkgeyBkb25lKGUpOyB9XG4gICAgICBlbHNlIHsgZXh0ZW5kKGUpOyB9XG4gICAgfSk7XG4gICAgdmFyIHVwID0gb3BlcmF0aW9uKGNtLCBkb25lKTtcbiAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdXA7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdXApO1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIG1vdXNlLXNlbGVjdGluZyB0byBhZGp1c3QgdGhlIGFuY2hvciB0byB0aGUgcHJvcGVyIHNpZGVcbiAgLy8gb2YgYSBiaWRpIGp1bXAgZGVwZW5kaW5nIG9uIHRoZSB2aXN1YWwgcG9zaXRpb24gb2YgdGhlIGhlYWQuXG4gIGZ1bmN0aW9uIGJpZGlTaW1wbGlmeShjbSwgcmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xuICAgIHZhciBoZWFkID0gcmFuZ2UuaGVhZDtcbiAgICB2YXIgYW5jaG9yTGluZSA9IGdldExpbmUoY20uZG9jLCBhbmNob3IubGluZSk7XG4gICAgaWYgKGNtcChhbmNob3IsIGhlYWQpID09IDAgJiYgYW5jaG9yLnN0aWNreSA9PSBoZWFkLnN0aWNreSkgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGFuY2hvckxpbmUpO1xuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgaW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBhbmNob3IuY2gsIGFuY2hvci5zdGlja3kpLCBwYXJ0ID0gb3JkZXJbaW5kZXhdO1xuICAgIGlmIChwYXJ0LmZyb20gIT0gYW5jaG9yLmNoICYmIHBhcnQudG8gIT0gYW5jaG9yLmNoKSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIGJvdW5kYXJ5ID0gaW5kZXggKyAoKHBhcnQuZnJvbSA9PSBhbmNob3IuY2gpID09IChwYXJ0LmxldmVsICE9IDEpID8gMCA6IDEpO1xuICAgIGlmIChib3VuZGFyeSA9PSAwIHx8IGJvdW5kYXJ5ID09IG9yZGVyLmxlbmd0aCkgeyByZXR1cm4gcmFuZ2UgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcmVsYXRpdmUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBoZWFkIGNvbXBhcmVkIHRvIHRoZVxuICAgIC8vIGFuY2hvciAoPDAgaXMgdG8gdGhlIGxlZnQsID4wIHRvIHRoZSByaWdodClcbiAgICB2YXIgbGVmdFNpZGU7XG4gICAgaWYgKGhlYWQubGluZSAhPSBhbmNob3IubGluZSkge1xuICAgICAgbGVmdFNpZGUgPSAoaGVhZC5saW5lIC0gYW5jaG9yLmxpbmUpICogKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIiA/IDEgOiAtMSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVhZEluZGV4ID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgaGVhZC5jaCwgaGVhZC5zdGlja3kpO1xuICAgICAgdmFyIGRpciA9IGhlYWRJbmRleCAtIGluZGV4IHx8IChoZWFkLmNoIC0gYW5jaG9yLmNoKSAqIChwYXJ0LmxldmVsID09IDEgPyAtMSA6IDEpO1xuICAgICAgaWYgKGhlYWRJbmRleCA9PSBib3VuZGFyeSAtIDEgfHwgaGVhZEluZGV4ID09IGJvdW5kYXJ5KVxuICAgICAgICB7IGxlZnRTaWRlID0gZGlyIDwgMDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGxlZnRTaWRlID0gZGlyID4gMDsgfVxuICAgIH1cblxuICAgIHZhciB1c2VQYXJ0ID0gb3JkZXJbYm91bmRhcnkgKyAobGVmdFNpZGUgPyAtMSA6IDApXTtcbiAgICB2YXIgZnJvbSA9IGxlZnRTaWRlID09ICh1c2VQYXJ0LmxldmVsID09IDEpO1xuICAgIHZhciBjaCA9IGZyb20gPyB1c2VQYXJ0LmZyb20gOiB1c2VQYXJ0LnRvLCBzdGlja3kgPSBmcm9tID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICByZXR1cm4gYW5jaG9yLmNoID09IGNoICYmIGFuY2hvci5zdGlja3kgPT0gc3RpY2t5ID8gcmFuZ2UgOiBuZXcgUmFuZ2UobmV3IFBvcyhhbmNob3IubGluZSwgY2gsIHN0aWNreSksIGhlYWQpXG4gIH1cblxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciBhbiBldmVudCBoYXBwZW5lZCBpbiB0aGUgZ3V0dGVyLCBhbmQgZmlyZXMgdGhlXG4gIC8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cbiAgZnVuY3Rpb24gZ3V0dGVyRXZlbnQoY20sIGUsIHR5cGUsIHByZXZlbnQpIHtcbiAgICB2YXIgbVgsIG1ZO1xuICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgIG1YID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICBtWSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkgeyBtWCA9IGUuY2xpZW50WDsgbVkgPSBlLmNsaWVudFk7IH1cbiAgICAgIGNhdGNoKGUkMSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICBpZiAobVggPj0gTWF0aC5mbG9vcihjbS5kaXNwbGF5Lmd1dHRlcnMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHByZXZlbnQpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBsaW5lQm94ID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgaWYgKG1ZID4gbGluZUJveC5ib3R0b20gfHwgIWhhc0hhbmRsZXIoY20sIHR5cGUpKSB7IHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfVxuICAgIG1ZIC09IGxpbmVCb3gudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZyA9IGRpc3BsYXkuZ3V0dGVycy5jaGlsZE5vZGVzW2ldO1xuICAgICAgaWYgKGcgJiYgZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCA+PSBtWCkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKTtcbiAgICAgICAgdmFyIGd1dHRlciA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3NbaV07XG4gICAgICAgIHNpZ25hbChjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlci5jbGFzc05hbWUsIGUpO1xuICAgICAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xpY2tJbkd1dHRlcihjbSwgZSkge1xuICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgLy8gQ09OVEVYVCBNRU5VIEhBTkRMSU5HXG5cbiAgLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXG4gIC8vIHRleHRhcmVhIChtYWtpbmcgaXQgYXMgdW5vYnRydXNpdmUgYXMgcG9zc2libGUpIHRvIGxldCB0aGVcbiAgLy8gcmlnaHQtY2xpY2sgdGFrZSBlZmZlY3Qgb24gaXQuXG4gIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcbiAgICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSwgXCJjb250ZXh0bWVudVwiKSkgeyByZXR1cm4gfVxuICAgIGlmICghY2FwdHVyZVJpZ2h0Q2xpY2spIHsgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSB7XG4gICAgaWYgKCFoYXNIYW5kbGVyKGNtLCBcImd1dHRlckNvbnRleHRNZW51XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNvbnRleHRNZW51XCIsIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XG4gICAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLCBcIlwiKSArXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csIFwiIGNtLXMtXCIpO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgfVxuXG4gIHZhciBJbml0ID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuSW5pdFwifX07XG5cbiAgdmFyIGRlZmF1bHRzID0ge307XG4gIHZhciBvcHRpb25IYW5kbGVycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcikge1xuICAgIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XG5cbiAgICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XG4gICAgICBDb2RlTWlycm9yLmRlZmF1bHRzW25hbWVdID0gZGVmbHQ7XG4gICAgICBpZiAoaGFuZGxlKSB7IG9wdGlvbkhhbmRsZXJzW25hbWVdID1cbiAgICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge2lmIChvbGQgIT0gSW5pdCkgeyBoYW5kbGUoY20sIHZhbCwgb2xkKTsgfX0gOiBoYW5kbGU7IH1cbiAgICB9XG5cbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbiA9IG9wdGlvbjtcblxuICAgIC8vIFBhc3NlZCB0byBvcHRpb24gaGFuZGxlcnMgd2hlbiB0aGVyZSBpcyBubyBvbGQgdmFsdWUuXG4gICAgQ29kZU1pcnJvci5Jbml0ID0gSW5pdDtcblxuICAgIC8vIFRoZXNlIHR3byBhcmUsIG9uIGluaXQsIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZXlcbiAgICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXG4gICAgb3B0aW9uKFwidmFsdWVcIiwgXCJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLnNldFZhbHVlKHZhbCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1vZGVcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRvYy5tb2RlT3B0aW9uID0gdmFsO1xuICAgICAgbG9hZE1vZGUoY20pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwiaW5kZW50VW5pdFwiLCAyLCBsb2FkTW9kZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIiwgZmFsc2UpO1xuICAgIG9wdGlvbihcInNtYXJ0SW5kZW50XCIsIHRydWUpO1xuICAgIG9wdGlvbihcInRhYlNpemVcIiwgNCwgZnVuY3Rpb24gKGNtKSB7XG4gICAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gICAgICBjbGVhckNhY2hlcyhjbSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwibGluZVNlcGFyYXRvclwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZG9jLmxpbmVTZXAgPSB2YWw7XG4gICAgICBpZiAoIXZhbCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG5ld0JyZWFrcyA9IFtdLCBsaW5lTm8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBmb3IgKHZhciBwb3MgPSAwOzspIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBsaW5lLnRleHQuaW5kZXhPZih2YWwsIHBvcyk7XG4gICAgICAgICAgaWYgKGZvdW5kID09IC0xKSB7IGJyZWFrIH1cbiAgICAgICAgICBwb3MgPSBmb3VuZCArIHZhbC5sZW5ndGg7XG4gICAgICAgICAgbmV3QnJlYWtzLnB1c2goUG9zKGxpbmVObywgZm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lTm8rKztcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IG5ld0JyZWFrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCB2YWwsIG5ld0JyZWFrc1tpXSwgUG9zKG5ld0JyZWFrc1tpXS5saW5lLCBuZXdCcmVha3NbaV0uY2ggKyB2YWwubGVuZ3RoKSk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJzcGVjaWFsQ2hhcnNcIiwgL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFwiXFx0XCIpID8gXCJcIiA6IFwifFxcdFwiKSwgXCJnXCIpO1xuICAgICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xuICAgIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKSAvLyBGSVhNRVxuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNwZWxsY2hlY2tcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NvcnJlY3RcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NvcnJlY3QgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImF1dG9jYXBpdGFsaXplXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLmF1dG9jYXBpdGFsaXplID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJydGxNb3ZlVmlzdWFsbHlcIiwgIXdpbmRvd3MpO1xuICAgIG9wdGlvbihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInRoZW1lXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHRoZW1lQ2hhbmdlZChjbSk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcbiAgICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XG4gICAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHsgcHJldi5kZXRhY2goY20sIG5leHQpOyB9XG4gICAgICBpZiAobmV4dC5hdHRhY2gpIHsgbmV4dC5hdHRhY2goY20sIHByZXYgfHwgbnVsbCk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJleHRyYUtleXNcIiwgbnVsbCk7XG4gICAgb3B0aW9uKFwiY29uZmlndXJlTW91c2VcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJsaW5lV3JhcHBpbmdcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKHZhbCwgY20ub3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJmaXhlZEd1dHRlclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB2YWwgPyBjb21wZW5zYXRlRm9ySFNjcm9sbChjbS5kaXNwbGF5KSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgY20ucmVmcmVzaCgpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJzY3JvbGxiYXJTdHlsZVwiLCBcIm5hdGl2ZVwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGluaXRTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGNtLmRvYy5zY3JvbGxMZWZ0KTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKGNtLm9wdGlvbnMuZ3V0dGVycywgdmFsKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpcnN0TGluZU51bWJlclwiLCAxLCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lV2lzZUNvcHlDdXRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGFzdGVMaW5lc1BlclNlbGVjdGlvblwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwgZmFsc2UpO1xuXG4gICAgb3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xuICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJzY3JlZW5SZWFkZXJMYWJlbFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gbnVsbCA6IHZhbDtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7aWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpOyB9fSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKTtcbiAgICBvcHRpb24oXCJhbGxvd0Ryb3BGaWxlVHlwZXNcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJjdXJzb3JCbGlua1JhdGVcIiwgNTMwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwgMCk7XG4gICAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgIG9wdGlvbihcIndvcmtUaW1lXCIsIDEwMCk7XG4gICAgb3B0aW9uKFwid29ya0RlbGF5XCIsIDEwMCk7XG4gICAgb3B0aW9uKFwiZmxhdHRlblNwYW5zXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJhZGRNb2RlQ2xhc3NcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwb2xsSW50ZXJ2YWxcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ1bmRvRGVwdGhcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KTtcbiAgICBvcHRpb24oXCJoaXN0b3J5RXZlbnREZWxheVwiLCAxMjUwKTtcbiAgICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpOyB9XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7IH0pO1xuICAgIG9wdGlvbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJkaXJlY3Rpb25cIiwgXCJsdHJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5zZXREaXJlY3Rpb24odmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGhyYXNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSwgdmFsdWUsIG9sZCkge1xuICAgIHZhciB3YXNPbiA9IG9sZCAmJiBvbGQgIT0gSW5pdDtcbiAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xuICAgICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2VudGVyXCIsIGZ1bmNzLmVudGVyKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdvdmVyXCIsIGZ1bmNzLm92ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIGZ1bmNzLmxlYXZlKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZnVuY3MuZHJvcCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBmaW5kTWF4TGluZShjbSk7XG4gICAgfVxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIDEwMCk7XG4gIH1cblxuICAvLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxuICAvLyB0aGF0IHVzZXIgY29kZSBpcyB1c3VhbGx5IGRlYWxpbmcgd2l0aC5cblxuICBmdW5jdGlvbiBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICB2YXIgZG9jID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvciwgb3B0aW9ucy5kaXJlY3Rpb24pOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tb2RlKSB7IGRvYy5tb2RlT3B0aW9uID0gb3B0aW9ucy5tb2RlOyB9XG4gICAgdGhpcy5kb2MgPSBkb2M7XG5cbiAgICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcbiAgICB0aGVtZUNoYW5nZWQodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7IH1cbiAgICBpbml0U2Nyb2xsYmFycyh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxuICAgICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcbiAgICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcbiAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG4gICAgICBwYXN0ZUluY29taW5nOiAtMSwgY3V0SW5jb21pbmc6IC0xLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxuICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9XG5cbiAgICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcyk7XG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcblxuICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLmhhc0ZvY3VzKCkgJiYgIXRoaXMkMS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXModGhpcyQxKTsgfVxuICAgICAgfSwgMjApOyB9XG4gICAgZWxzZVxuICAgICAgeyBvbkJsdXIodGhpcyk7IH1cblxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgeyBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzLCBvcHRpb25zW29wdF0sIEluaXQpOyB9IH1cbiAgICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5maW5pc2hJbml0KSB7IG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSB7IGluaXRIb29rc1tpXSh0aGlzKTsgfVxuICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcbiAgICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxuICAgIC8vIG1lYXN1cmluZyBvbiBsaW5lIHdyYXBwaW5nIGJvdW5kYXJpZXMuXG4gICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcIm9wdGltaXplbGVnaWJpbGl0eVwiKVxuICAgICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFwiYXV0b1wiOyB9XG4gIH1cblxuICAvLyBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIENvZGVNaXJyb3IuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXG4gIENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcblxuICAvLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNlZG93blwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSk7XG4gICAgLy8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxuICAgICAgeyBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICAgICAgaWYgKCFwb3MgfHwgY2xpY2tJbkd1dHRlcihjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgeyByZXR1cm4gfVxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XG4gICAgICB9KSk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTsgfVxuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KTtcbiAgICBvbihkLmlucHV0LmdldEZpZWxkKCksIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZC5zY3JvbGxlci5jb250YWlucyhlLnRhcmdldCkpIHsgb25Db250ZXh0TWVudShjbSwgZSk7IH1cbiAgICB9KTtcblxuICAgIC8vIFVzZWQgdG8gc3VwcHJlc3MgbW91c2UgZXZlbnQgaGFuZGxpbmcgd2hlbiBhIHRvdWNoIGhhcHBlbnNcbiAgICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH07XG4gICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMCk7XG4gICAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICAgIHByZXZUb3VjaC5lbmQgPSArbmV3IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMVxuICAgIH1cbiAgICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB2YXIgZHggPSBvdGhlci5sZWZ0IC0gdG91Y2gubGVmdCwgZHkgPSBvdGhlci50b3AgLSB0b3VjaC50b3A7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwXG4gICAgfVxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSAmJiAhY2xpY2tJbkd1dHRlcihjbSwgZSkpIHtcbiAgICAgICAgZC5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHsgZC5hY3RpdmVUb3VjaC5tb3ZlZCA9IHRydWU7IH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICAgICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSAtIHRvdWNoLnN0YXJ0IDwgMzAwKSB7XG4gICAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFwicGFnZVwiKSwgcmFuZ2U7XG4gICAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpOyB9XG4gICAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTsgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaFRvdWNoKCk7XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGNhbmNlbFwiLCBmaW5pc2hUb3VjaCk7XG5cbiAgICAvLyBTeW5jIHNjcm9sbGluZyBiZXR3ZWVuIGZha2Ugc2Nyb2xsYmFycyBhbmQgcmVhbCBzY3JvbGxhYmxlXG4gICAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXG4gICAgb24oZC5zY3JvbGxlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApO1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xuXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pO1xuXG4gICAgZC5kcmFnRnVuY3Rpb25zID0ge1xuICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIG92ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKTsgfX0sXG4gICAgICBzdGFydDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTsgfSxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcbiAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSk7IH19XG4gICAgfTtcblxuICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XG4gICAgb24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbktleVVwLmNhbGwoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwia2V5ZG93blwiLCBvcGVyYXRpb24oY20sIG9uS2V5RG93bikpO1xuICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICBvbihpbnAsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRm9jdXMoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwiYmx1clwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25CbHVyKGNtLCBlKTsgfSk7XG4gIH1cblxuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7IH07XG5cbiAgLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXCJzbWFydFwiLFxuICAvLyBcImFkZFwiL251bGwsIFwic3VidHJhY3RcIiwgb3IgXCJwcmV2XCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxuICAvLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XG4gIC8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXG4gIC8vIGFyZSBsZWZ0IGFsb25lLlxuICBmdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZTtcbiAgICBpZiAoaG93ID09IG51bGwpIHsgaG93ID0gXCJhZGRcIjsgfVxuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFwicHJldlwiOyB9XG4gICAgICBlbHNlIHsgc3RhdGUgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBuKS5zdGF0ZTsgfVxuICAgIH1cblxuICAgIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLCBpbmRlbnRhdGlvbjtcbiAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgaW5kZW50YXRpb24gPSAwO1xuICAgICAgaG93ID0gXCJub3RcIjtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gZG9jLm1vZGUuaW5kZW50KHN0YXRlLCBsaW5lLnRleHQuc2xpY2UoY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgbGluZS50ZXh0KTtcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XG4gICAgICAgIGlmICghYWdncmVzc2l2ZSkgeyByZXR1cm4gfVxuICAgICAgICBob3cgPSBcInByZXZcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvdyA9PSBcInByZXZcIikge1xuICAgICAgaWYgKG4gPiBkb2MuZmlyc3QpIHsgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKTsgfVxuICAgICAgZWxzZSB7IGluZGVudGF0aW9uID0gMDsgfVxuICAgIH0gZWxzZSBpZiAoaG93ID09IFwiYWRkXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzdWJ0cmFjdFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdyA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93O1xuICAgIH1cbiAgICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKTtcblxuICAgIHZhciBpbmRlbnRTdHJpbmcgPSBcIlwiLCBwb3MgPSAwO1xuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKVxuICAgICAgeyBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fSB9XG4gICAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7IH1cblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJzb3Igd2FzIGluIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGxpbmUsIGl0IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhhdCBzcGFjZS5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaSQxXTtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSQxLCBuZXcgUmFuZ2UocG9zJDEsIHBvcyQxKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXG4gIC8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXG4gIC8vIHRleHQgd2FzIG1hZGUgb3V0IG9mLlxuICB2YXIgbGFzdENvcGllZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XG4gICAgbGFzdENvcGllZCA9IG5ld0xhc3RDb3BpZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgaWYgKCFzZWwpIHsgc2VsID0gZG9jLnNlbDsgfVxuXG4gICAgdmFyIHJlY2VudCA9ICtuZXcgRGF0ZSAtIDIwMDtcbiAgICB2YXIgcGFzdGUgPSBvcmlnaW4gPT0gXCJwYXN0ZVwiIHx8IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPiByZWNlbnQ7XG4gICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XG4gICAgLy8gV2hlbiBwYXN0aW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXG4gICAgaWYgKHBhc3RlICYmIHNlbC5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIikgPT0gaW5zZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgbXVsdGlQYXN0ZSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7IH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmIGNtLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbikge1xuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIFtsXTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XG4gICAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cbiAgICBmb3IgKHZhciBpJDEgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7IH1cbiAgICAgICAgZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkgLy8gSGFuZGxlIG92ZXJ3cml0ZVxuICAgICAgICAgIHsgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpOyB9XG4gICAgICAgIGVsc2UgaWYgKHBhc3RlICYmIGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSB0ZXh0TGluZXMuam9pbihcIlxcblwiKSlcbiAgICAgICAgICB7IGZyb20gPSB0byA9IFBvcyhmcm9tLmxpbmUsIDApOyB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXCJwYXN0ZVwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPiByZWNlbnQgPyBcImN1dFwiIDogXCIraW5wdXRcIil9O1xuICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZUV2ZW50KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImlucHV0UmVhZFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQgJiYgIXBhc3RlKVxuICAgICAgeyB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKTsgfVxuXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgaWYgKGNtLmN1ck9wLnVwZGF0ZUlucHV0IDwgMikgeyBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0OyB9XG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XG4gICAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHBhc3RlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFjbS5pc1JlYWRPbmx5KCkgJiYgIWNtLm9wdGlvbnMuZGlzYWJsZUlucHV0KVxuICAgICAgICB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwcGx5VGV4dElucHV0KGNtLCBwYXN0ZWQsIDAsIG51bGwsIFwicGFzdGVcIik7IH0pOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpIHtcbiAgICAvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcbiAgICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSBjbS5kb2Muc2VsO1xuXG4gICAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2UuaGVhZC5jaCA+IDEwMCB8fCAoaSAmJiBzZWwucmFuZ2VzW2kgLSAxXS5oZWFkLmxpbmUgPT0gcmFuZ2UuaGVhZC5saW5lKSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTtcbiAgICAgIHZhciBpbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKG1vZGUuZWxlY3RyaWNDaGFycykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcbiAgICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XG4gICAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlLmhlYWQuY2gpKSlcbiAgICAgICAgICB7IGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZW50ZWQpIHsgc2lnbmFsTGF0ZXIoY20sIFwiZWxlY3RyaWNJbnB1dFwiLCBjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlhYmxlUmFuZ2VzKGNtKSB7XG4gICAgdmFyIHRleHQgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBjbS5kb2Muc2VsLnJhbmdlc1tpXS5oZWFkLmxpbmU7XG4gICAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfTtcbiAgICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSk7XG4gICAgICB0ZXh0LnB1c2goY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCByYW5nZXM6IHJhbmdlc31cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQsIHNwZWxsY2hlY2ssIGF1dG9jb3JyZWN0LCBhdXRvY2FwaXRhbGl6ZSkge1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIsIGF1dG9jb3JyZWN0ID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIGF1dG9jYXBpdGFsaXplID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgISFzcGVsbGNoZWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBtaW4taGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcIik7XG4gICAgdmFyIGRpdiA9IGVsdChcImRpdlwiLCBbdGVdLCBudWxsLCBcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XCIpO1xuICAgIC8vIFRoZSB0ZXh0YXJlYSBpcyBrZXB0IHBvc2l0aW9uZWQgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gZmFjdCB0aGF0IGl0J2xsIGJlIHNjcm9sbGVkIGludG8gdmlldyBvbiBpbnB1dCBmcm9tIHNjcm9sbGluZ1xuICAgIC8vIG91ciBmYWtlIGN1cnNvciBvdXQgb2Ygdmlldy4gT24gd2Via2l0LCB3aGVuIHdyYXA9b2ZmLCBwYXN0ZSBpc1xuICAgIC8vIHZlcnkgc2xvdy4gU28gbWFrZSB0aGUgYXJlYSB3aWRlIGluc3RlYWQuXG4gICAgaWYgKHdlYmtpdCkgeyB0ZS5zdHlsZS53aWR0aCA9IFwiMTAwMHB4XCI7IH1cbiAgICBlbHNlIHsgdGUuc2V0QXR0cmlidXRlKFwid3JhcFwiLCBcIm9mZlwiKTsgfVxuICAgIC8vIElmIGJvcmRlcjogMDsgLS0gaU9TIGZhaWxzIHRvIG9wZW4ga2V5Ym9hcmQgKGlzc3VlICMxMjg3KVxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgYmxhY2tcIjsgfVxuICAgIGRpc2FibGVCcm93c2VyTWFnaWModGUpO1xuICAgIHJldHVybiBkaXZcbiAgfVxuXG4gIC8vIFRoZSBwdWJsaWNseSB2aXNpYmxlIEFQSS4gTm90ZSB0aGF0IG1ldGhvZE9wKGYpIG1lYW5zXG4gIC8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxuXG4gIC8vIFRoaXMgaXMgbm90IHRoZSBjb21wbGV0ZSBzZXQgb2YgZWRpdG9yIG1ldGhvZHMuIE1vc3Qgb2YgdGhlXG4gIC8vIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRG9jIHR5cGUgYXJlIGFsc28gaW5qZWN0ZWQgaW50b1xuICAvLyBDb2RlTWlycm9yLnByb3RvdHlwZSwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZFxuICAvLyBjb252ZW5pZW5jZS5cblxuICBmdW5jdGlvbiBhZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpIHtcbiAgICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzO1xuXG4gICAgdmFyIGhlbHBlcnMgPSBDb2RlTWlycm9yLmhlbHBlcnMgPSB7fTtcblxuICAgIENvZGVNaXJyb3IucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IENvZGVNaXJyb3IsXG4gICAgICBmb2N1czogZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTsgdGhpcy5kaXNwbGF5LmlucHV0LmZvY3VzKCk7fSxcblxuICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLCBvbGQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0gPT0gdmFsdWUgJiYgb3B0aW9uICE9IFwibW9kZVwiKSB7IHJldHVybiB9XG4gICAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcbiAgICAgICAgICB7IG9wZXJhdGlvbih0aGlzLCBvcHRpb25IYW5kbGVyc1tvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKTsgfVxuICAgICAgICBzaWduYWwodGhpcywgXCJvcHRpb25DaGFuZ2VcIiwgdGhpcywgb3B0aW9uKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uKSB7cmV0dXJuIHRoaXMub3B0aW9uc1tvcHRpb25dfSxcbiAgICAgIGdldERvYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jfSxcblxuICAgICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAsIGJvdHRvbSkge1xuICAgICAgICB0aGlzLnN0YXRlLmtleU1hcHNbYm90dG9tID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oZ2V0S2V5TWFwKG1hcCkpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUtleU1hcDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBtYXBzID0gdGhpcy5zdGF0ZS5rZXlNYXBzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgeyBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xuICAgICAgICAgICAgbWFwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gfVxuICAgICAgfSxcblxuICAgICAgYWRkT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvci5nZXRNb2RlKHRoaXMub3B0aW9ucywgc3BlYyk7XG4gICAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHsgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcmxheXMgbWF5IG5vdCBiZSBzdGF0ZWZ1bC5cIikgfVxuICAgICAgICBpbnNlcnRTb3J0ZWQodGhpcy5zdGF0ZS5vdmVybGF5cyxcbiAgICAgICAgICAgICAgICAgICAgIHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlLFxuICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSB8fCAwfSxcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvdmVybGF5KSB7IHJldHVybiBvdmVybGF5LnByaW9yaXR5OyB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgIH0pLFxuICAgICAgcmVtb3ZlT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG92ZXJsYXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IG92ZXJsYXlzW2ldLm1vZGVTcGVjO1xuICAgICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcbiAgICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xuICAgICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgaW5kZW50TGluZTogbWV0aG9kT3AoZnVuY3Rpb24obiwgZGlyLCBhZ2dyZXNzaXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlyICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGRpciAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKGRpciA9PSBudWxsKSB7IGRpciA9IHRoaXMub3B0aW9ucy5zbWFydEluZGVudCA/IFwic21hcnRcIiA6IFwicHJldlwiOyB9XG4gICAgICAgICAgZWxzZSB7IGRpciA9IGRpciA/IFwiYWRkXCIgOiBcInN1YnRyYWN0XCI7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgeyBpbmRlbnRMaW5lKHRoaXMsIG4sIGRpciwgYWdncmVzc2l2ZSk7IH1cbiAgICAgIH0pLFxuICAgICAgaW5kZW50U2VsZWN0aW9uOiBtZXRob2RPcChmdW5jdGlvbihob3cpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXMsIGVuZCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSk7XG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxhc3RMaW5lKCksIHRvLmxpbmUgLSAodG8uY2ggPyAwIDogMSkpICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgKytqKVxuICAgICAgICAgICAgICB7IGluZGVudExpbmUodGhpcywgaiwgaG93KTsgfVxuICAgICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXM7XG4gICAgICAgICAgICBpZiAoZnJvbS5jaCA9PSAwICYmIHJhbmdlcy5sZW5ndGggPT0gbmV3UmFuZ2VzLmxlbmd0aCAmJiBuZXdSYW5nZXNbaV0uZnJvbSgpLmNoID4gMClcbiAgICAgICAgICAgICAgeyByZXBsYWNlT25lU2VsZWN0aW9uKHRoaXMuZG9jLCBpLCBuZXcgUmFuZ2UoZnJvbSwgbmV3UmFuZ2VzW2ldLnRvKCkpLCBzZWxfZG9udFNjcm9sbCk7IH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmhlYWQubGluZSA+IGVuZCkge1xuICAgICAgICAgICAgaW5kZW50TGluZSh0aGlzLCByYW5nZS5oZWFkLmxpbmUsIGhvdywgdHJ1ZSk7XG4gICAgICAgICAgICBlbmQgPSByYW5nZS5oZWFkLmxpbmU7XG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLmRvYy5zZWwucHJpbUluZGV4KSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcyk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICAvLyBGZXRjaCB0aGUgcGFyc2VyIHRva2VuIGZvciBhIGdpdmVuIGNoYXJhY3Rlci4gVXNlZnVsIGZvciBoYWNrc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxuICAgICAgZ2V0VG9rZW5BdDogZnVuY3Rpb24ocG9zLCBwcmVjaXNlKSB7XG4gICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKVxuICAgICAgfSxcblxuICAgICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIFBvcyhsaW5lKSwgcHJlY2lzZSwgdHJ1ZSlcbiAgICAgIH0sXG5cbiAgICAgIGdldFRva2VuVHlwZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKTtcbiAgICAgICAgdmFyIGJlZm9yZSA9IDAsIGFmdGVyID0gKHN0eWxlcy5sZW5ndGggLSAxKSAvIDIsIGNoID0gcG9zLmNoO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgaWYgKGNoID09IDApIHsgdHlwZSA9IHN0eWxlc1syXTsgfVxuICAgICAgICBlbHNlIHsgZm9yICg7Oykge1xuICAgICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDE7XG4gICAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIHsgYWZ0ZXIgPSBtaWQ7IH1cbiAgICAgICAgICBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIHsgYmVmb3JlID0gbWlkICsgMTsgfVxuICAgICAgICAgIGVsc2UgeyB0eXBlID0gc3R5bGVzW21pZCAqIDIgKyAyXTsgYnJlYWsgfVxuICAgICAgICB9IH1cbiAgICAgICAgdmFyIGN1dCA9IHR5cGUgPyB0eXBlLmluZGV4T2YoXCJvdmVybGF5IFwiKSA6IC0xO1xuICAgICAgICByZXR1cm4gY3V0IDwgMCA/IHR5cGUgOiBjdXQgPT0gMCA/IG51bGwgOiB0eXBlLnNsaWNlKDAsIGN1dCAtIDEpXG4gICAgICB9LFxuXG4gICAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGU7XG4gICAgICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIG1vZGUgfVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgdGhpcy5nZXRUb2tlbkF0KHBvcykuc3RhdGUpLm1vZGVcbiAgICAgIH0sXG5cbiAgICAgIGdldEhlbHBlcjogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXVxuICAgICAgfSxcblxuICAgICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IFtdO1xuICAgICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgcmV0dXJuIGZvdW5kIH1cbiAgICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlW3R5cGVdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkgeyBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pOyB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVt0eXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGhlbHBbbW9kZVt0eXBlXVtpXV07XG4gICAgICAgICAgICBpZiAodmFsKSB7IGZvdW5kLnB1c2godmFsKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlLmhlbHBlclR5cGUgJiYgaGVscFttb2RlLmhlbHBlclR5cGVdKSB7XG4gICAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUuaGVscGVyVHlwZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGhlbHBbbW9kZS5uYW1lXSkge1xuICAgICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjdXIgPSBoZWxwLl9nbG9iYWxbaSQxXTtcbiAgICAgICAgICBpZiAoY3VyLnByZWQobW9kZSwgdGhpcykgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXG4gICAgICAgICAgICB7IGZvdW5kLnB1c2goY3VyLnZhbCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRcbiAgICAgIH0sXG5cbiAgICAgIGdldFN0YXRlQWZ0ZXI6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dEJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSkuc3RhdGVcbiAgICAgIH0sXG5cbiAgICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcbiAgICAgICAgdmFyIHBvcywgcmFuZ2UgPSB0aGlzLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBwb3MgPSByYW5nZS5oZWFkOyB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydCA9PSBcIm9iamVjdFwiKSB7IHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHN0YXJ0KTsgfVxuICAgICAgICBlbHNlIHsgcG9zID0gc3RhcnQgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpOyB9XG4gICAgICAgIHJldHVybiBjdXJzb3JDb29yZHModGhpcywgcG9zLCBtb2RlIHx8IFwicGFnZVwiKVxuICAgICAgfSxcblxuICAgICAgY2hhckNvb3JkczogZnVuY3Rpb24ocG9zLCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXCJwYWdlXCIpXG4gICAgICB9LFxuXG4gICAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcbiAgICAgICAgY29vcmRzID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIGNvb3JkcywgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgICAgIHJldHVybiBjb29yZHNDaGFyKHRoaXMsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKVxuICAgICAgfSxcblxuICAgICAgbGluZUF0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIG1vZGUpIHtcbiAgICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHt0b3A6IGhlaWdodCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIpLnRvcDtcbiAgICAgICAgcmV0dXJuIGxpbmVBdEhlaWdodCh0aGlzLmRvYywgaGVpZ2h0ICsgdGhpcy5kaXNwbGF5LnZpZXdPZmZzZXQpXG4gICAgICB9LFxuICAgICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlLCBpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgICB2YXIgZW5kID0gZmFsc2UsIGxpbmVPYmo7XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxO1xuICAgICAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIHsgbGluZSA9IHRoaXMuZG9jLmZpcnN0OyB9XG4gICAgICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cbiAgICAgICAgICBsaW5lT2JqID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU9iaiA9IGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIiwgaW5jbHVkZVdpZGdldHMgfHwgZW5kKS50b3AgK1xuICAgICAgICAgIChlbmQgPyB0aGlzLmRvYy5oZWlnaHQgLSBoZWlnaHRBdExpbmUobGluZU9iaikgOiAwKVxuICAgICAgfSxcblxuICAgICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpIH0sXG4gICAgICBkZWZhdWx0Q2hhcldpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJXaWR0aCh0aGlzLmRpc3BsYXkpIH0sXG5cbiAgICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfX0sXG5cbiAgICAgIGFkZFdpZGdldDogZnVuY3Rpb24ocG9zLCBub2RlLCBzY3JvbGwsIHZlcnQsIGhvcml6KSB7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5O1xuICAgICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XG4gICAgICAgIHZhciB0b3AgPSBwb3MuYm90dG9tLCBsZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xuICAgICAgICBkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBpZiAodmVydCA9PSBcIm92ZXJcIikge1xuICAgICAgICAgIHRvcCA9IHBvcy50b3A7XG4gICAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcImFib3ZlXCIgfHwgdmVydCA9PSBcIm5lYXJcIikge1xuICAgICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLFxuICAgICAgICAgIGhzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGgsIGRpc3BsYXkubGluZVNwYWNlLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGFib3ZlIChpZiBzcGVjaWZpZWQgYW5kIHBvc3NpYmxlKTsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gcG9zaXRpb25pbmcgYmVsb3dcbiAgICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcbiAgICAgICAgICAgIHsgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0OyB9XG4gICAgICAgICAgZWxzZSBpZiAocG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0IDw9IHZzcGFjZSlcbiAgICAgICAgICAgIHsgdG9wID0gcG9zLmJvdHRvbTsgfVxuICAgICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcbiAgICAgICAgICAgIHsgbGVmdCA9IGhzcGFjZSAtIG5vZGUub2Zmc2V0V2lkdGg7IH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgIGlmIChob3JpeiA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBsZWZ0ID0gZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhvcml6ID09IFwibGVmdFwiKSB7IGxlZnQgPSAwOyB9XG4gICAgICAgICAgZWxzZSBpZiAoaG9yaXogPT0gXCJtaWRkbGVcIikgeyBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDI7IH1cbiAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGwpXG4gICAgICAgICAgeyBzY3JvbGxJbnRvVmlldyh0aGlzLCB7bGVmdDogbGVmdCwgdG9wOiB0b3AsIHJpZ2h0OiBsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCwgYm90dG9tOiB0b3AgKyBub2RlLm9mZnNldEhlaWdodH0pOyB9XG4gICAgICB9LFxuXG4gICAgICB0cmlnZ2VyT25LZXlEb3duOiBtZXRob2RPcChvbktleURvd24pLFxuICAgICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxuICAgICAgdHJpZ2dlck9uS2V5VXA6IG9uS2V5VXAsXG4gICAgICB0cmlnZ2VyT25Nb3VzZURvd246IG1ldGhvZE9wKG9uTW91c2VEb3duKSxcblxuICAgICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgICBpZiAoY29tbWFuZHMuaGFzT3duUHJvcGVydHkoY21kKSlcbiAgICAgICAgICB7IHJldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCwgdGhpcykgfVxuICAgICAgfSxcblxuICAgICAgdHJpZ2dlckVsZWN0cmljOiBtZXRob2RPcChmdW5jdGlvbih0ZXh0KSB7IHRyaWdnZXJFbGVjdHJpYyh0aGlzLCB0ZXh0KTsgfSksXG5cbiAgICAgIGZpbmRQb3NIOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIHZpc3VhbGx5KSB7XG4gICAgICAgIHZhciBkaXIgPSAxO1xuICAgICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxuICAgICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzLmRvYywgY3VyLCBkaXIsIHVuaXQsIHZpc3VhbGx5KTtcbiAgICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKHRoaXMkMS5kaXNwbGF5LnNoaWZ0IHx8IHRoaXMkMS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgICB7IHJldHVybiBmaW5kUG9zSCh0aGlzJDEuZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIHRoaXMkMS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSkgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cbiAgICAgICAgfSwgc2VsX21vdmUpO1xuICAgICAgfSksXG5cbiAgICAgIGRlbGV0ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxuICAgICAgICAgIHsgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCIrZGVsZXRlXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGRlbGV0ZU5lYXJTZWxlY3Rpb24odGhpcywgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBmaW5kUG9zSChkb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyB7ZnJvbTogb3RoZXIsIHRvOiByYW5nZS5oZWFkfSA6IHtmcm9tOiByYW5nZS5oZWFkLCB0bzogb3RoZXJ9XG4gICAgICAgICAgfSk7IH1cbiAgICAgIH0pLFxuXG4gICAgICBmaW5kUG9zVjogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHZhciBkaXIgPSAxLCB4ID0gZ29hbENvbHVtbjtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjdXIsIFwiZGl2XCIpO1xuICAgICAgICAgIGlmICh4ID09IG51bGwpIHsgeCA9IGNvb3Jkcy5sZWZ0OyB9XG4gICAgICAgICAgZWxzZSB7IGNvb3Jkcy5sZWZ0ID0geDsgfVxuICAgICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMsIGNvb3JkcywgZGlyLCB1bml0KTtcbiAgICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVWOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBnb2FscyA9IFtdO1xuICAgICAgICB2YXIgY29sbGFwc2UgPSAhdGhpcy5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgICAgZG9jLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoY29sbGFwc2UpXG4gICAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XG4gICAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHModGhpcyQxLCByYW5nZS5oZWFkLCBcImRpdlwiKTtcbiAgICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSB7IGhlYWRQb3MubGVmdCA9IHJhbmdlLmdvYWxDb2x1bW47IH1cbiAgICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdCk7XG4gICAgICAgICAgdmFyIHBvcyA9IGZpbmRQb3NWKHRoaXMkMSwgaGVhZFBvcywgZGlyLCB1bml0KTtcbiAgICAgICAgICBpZiAodW5pdCA9PSBcInBhZ2VcIiAmJiByYW5nZSA9PSBkb2Muc2VsLnByaW1hcnkoKSlcbiAgICAgICAgICAgIHsgYWRkVG9TY3JvbGxUb3AodGhpcyQxLCBjaGFyQ29vcmRzKHRoaXMkMSwgcG9zLCBcImRpdlwiKS50b3AgLSBoZWFkUG9zLnRvcCk7IH1cbiAgICAgICAgICByZXR1cm4gcG9zXG4gICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgICAgaWYgKGdvYWxzLmxlbmd0aCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgZG9jLnNlbC5yYW5nZXNbaV0uZ29hbENvbHVtbiA9IGdvYWxzW2ldOyB9IH1cbiAgICAgIH0pLFxuXG4gICAgICAvLyBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiAoYXMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhcikuXG4gICAgICBmaW5kV29yZEF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0O1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaDtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICB2YXIgaGVscGVyID0gdGhpcy5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcbiAgICAgICAgICBpZiAoKHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSB7IC0tc3RhcnQ7IH0gZWxzZSB7ICsrZW5kOyB9XG4gICAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGxpbmUuY2hhckF0KHN0YXJ0KTtcbiAgICAgICAgICB2YXIgY2hlY2sgPSBpc1dvcmRDaGFyKHN0YXJ0Q2hhciwgaGVscGVyKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGlzV29yZENoYXIoY2gsIGhlbHBlcik7IH1cbiAgICAgICAgICAgIDogL1xccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiAvXFxzLy50ZXN0KGNoKTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuICghL1xccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpKTsgfTtcbiAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSB7IC0tc3RhcnQ7IH1cbiAgICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpIHsgKytlbmQ7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgc3RhcnQpLCBQb3MocG9zLmxpbmUsIGVuZCkpXG4gICAgICB9LFxuXG4gICAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID09IHRoaXMuc3RhdGUub3ZlcndyaXRlKSB7IHJldHVybiB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcbiAgICAgICAgICB7IGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOyB9XG5cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwib3ZlcndyaXRlVG9nZ2xlXCIsIHRoaXMsIHRoaXMuc3RhdGUub3ZlcndyaXRlKTtcbiAgICAgIH0sXG4gICAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSA9PSBhY3RpdmVFbHQoKSB9LFxuICAgICAgaXNSZWFkT25seTogZnVuY3Rpb24oKSB7IHJldHVybiAhISh0aGlzLm9wdGlvbnMucmVhZE9ubHkgfHwgdGhpcy5kb2MuY2FudEVkaXQpIH0sXG5cbiAgICAgIHNjcm9sbFRvOiBtZXRob2RPcChmdW5jdGlvbiAoeCwgeSkgeyBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCB4LCB5KTsgfSksXG4gICAgICBnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5kaXNwbGF5LnNjcm9sbGVyO1xuICAgICAgICByZXR1cm4ge2xlZnQ6IHNjcm9sbGVyLnNjcm9sbExlZnQsIHRvcDogc2Nyb2xsZXIuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhckhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBkaXNwbGF5SGVpZ2h0KHRoaXMpLCBjbGllbnRXaWR0aDogZGlzcGxheVdpZHRoKHRoaXMpfVxuICAgICAgfSxcblxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IG1ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4pIHtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiB0aGlzLmRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIHRvOiBudWxsfTtcbiAgICAgICAgICBpZiAobWFyZ2luID09IG51bGwpIHsgbWFyZ2luID0gdGhpcy5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbjsgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogUG9zKHJhbmdlLCAwKSwgdG86IG51bGx9O1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IHJhbmdlLCB0bzogbnVsbH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZS50bykgeyByYW5nZS50byA9IHJhbmdlLmZyb207IH1cbiAgICAgICAgcmFuZ2UubWFyZ2luID0gbWFyZ2luIHx8IDA7XG5cbiAgICAgICAgaWYgKHJhbmdlLmZyb20ubGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgc2Nyb2xsVG9SYW5nZSh0aGlzLCByYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsVG9Db29yZHNSYW5nZSh0aGlzLCByYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UubWFyZ2luKTtcbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIHNldFNpemU6IG1ldGhvZE9wKGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIiB8fCAvXlxcZCskLy50ZXN0KFN0cmluZyh2YWwpKSA/IHZhbCArIFwicHhcIiA6IHZhbDsgfTtcbiAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGggPSBpbnRlcnByZXQod2lkdGgpOyB9XG4gICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS5oZWlnaHQgPSBpbnRlcnByZXQoaGVpZ2h0KTsgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKHRoaXMpOyB9XG4gICAgICAgIHZhciBsaW5lTm8gPSB0aGlzLmRpc3BsYXkudmlld0Zyb207XG4gICAgICAgIHRoaXMuZG9jLml0ZXIobGluZU5vLCB0aGlzLmRpc3BsYXkudmlld1RvLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7IGlmIChsaW5lLndpZGdldHNbaV0ubm9IU2Nyb2xsKSB7IHJlZ0xpbmVDaGFuZ2UodGhpcyQxLCBsaW5lTm8sIFwid2lkZ2V0XCIpOyBicmVhayB9IH0gfVxuICAgICAgICAgICsrbGluZU5vO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHNpZ25hbCh0aGlzLCBcInJlZnJlc2hcIiwgdGhpcyk7XG4gICAgICB9KSxcblxuICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbihmKXtyZXR1cm4gcnVuSW5PcCh0aGlzLCBmKX0sXG4gICAgICBzdGFydE9wZXJhdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gc3RhcnRPcGVyYXRpb24odGhpcyl9LFxuICAgICAgZW5kT3BlcmF0aW9uOiBmdW5jdGlvbigpe3JldHVybiBlbmRPcGVyYXRpb24odGhpcyl9LFxuXG4gICAgICByZWZyZXNoOiBtZXRob2RPcChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xuICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjbGVhckNhY2hlcyh0aGlzKTtcbiAgICAgICAgc2Nyb2xsVG9Db29yZHModGhpcywgdGhpcy5kb2Muc2Nyb2xsTGVmdCwgdGhpcy5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgICAgdXBkYXRlR3V0dGVyU3BhY2UodGhpcy5kaXNwbGF5KTtcbiAgICAgICAgaWYgKG9sZEhlaWdodCA9PSBudWxsIHx8IE1hdGguYWJzKG9sZEhlaWdodCAtIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSkgPiAuNSB8fCB0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgICAgIHsgZXN0aW1hdGVMaW5lSGVpZ2h0cyh0aGlzKTsgfVxuICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgfSksXG5cbiAgICAgIHN3YXBEb2M6IG1ldGhvZE9wKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5kb2M7XG4gICAgICAgIG9sZC5jbSA9IG51bGw7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBpZiBhbnkgKCM1ODIxKVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KSB7IHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCgpOyB9XG4gICAgICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuICAgICAgICBjbGVhckNhY2hlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIGRvYy5zY3JvbGxMZWZ0LCBkb2Muc2Nyb2xsVG9wKTtcbiAgICAgICAgdGhpcy5jdXJPcC5mb3JjZVNjcm9sbCA9IHRydWU7XG4gICAgICAgIHNpZ25hbExhdGVyKHRoaXMsIFwic3dhcERvY1wiLCB0aGlzLCBvbGQpO1xuICAgICAgICByZXR1cm4gb2xkXG4gICAgICB9KSxcblxuICAgICAgcGhyYXNlOiBmdW5jdGlvbihwaHJhc2VUZXh0KSB7XG4gICAgICAgIHZhciBwaHJhc2VzID0gdGhpcy5vcHRpb25zLnBocmFzZXM7XG4gICAgICAgIHJldHVybiBwaHJhc2VzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwaHJhc2VzLCBwaHJhc2VUZXh0KSA/IHBocmFzZXNbcGhyYXNlVGV4dF0gOiBwaHJhc2VUZXh0XG4gICAgICB9LFxuXG4gICAgICBnZXRJbnB1dEZpZWxkOiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKX0sXG4gICAgICBnZXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LndyYXBwZXJ9LFxuICAgICAgZ2V0U2Nyb2xsZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXJ9LFxuICAgICAgZ2V0R3V0dGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnN9XG4gICAgfTtcbiAgICBldmVudE1peGluKENvZGVNaXJyb3IpO1xuXG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgaGVscGVyc1t0eXBlXSA9IENvZGVNaXJyb3JbdHlwZV0gPSB7X2dsb2JhbDogW119OyB9XG4gICAgICBoZWxwZXJzW3R5cGVdW25hbWVdID0gdmFsdWU7XG4gICAgfTtcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgcHJlZGljYXRlLCB2YWx1ZSkge1xuICAgICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcih0eXBlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBoZWxwZXJzW3R5cGVdLl9nbG9iYWwucHVzaCh7cHJlZDogcHJlZGljYXRlLCB2YWw6IHZhbHVlfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW90aW9uLiBEaXIgaXMgLTEgb3IgMSAobGVmdCBvclxuICAvLyByaWdodCksIHVuaXQgY2FuIGJlIFwiY29kZXBvaW50XCIsIFwiY2hhclwiLCBcImNvbHVtblwiIChsaWtlIGNoYXIsIGJ1dFxuICAvLyBkb2Vzbid0IGNyb3NzIGxpbmUgYm91bmRhcmllcyksIFwid29yZFwiIChhY3Jvc3MgbmV4dCB3b3JkKSwgb3JcbiAgLy8gXCJncm91cFwiICh0byB0aGUgc3RhcnQgb2YgbmV4dCBncm91cCBvZiB3b3JkIG9yXG4gIC8vIG5vbi13b3JkLW5vbi13aGl0ZXNwYWNlIGNoYXJzKS4gVGhlIHZpc3VhbGx5IHBhcmFtIGNvbnRyb2xzXG4gIC8vIHdoZXRoZXIsIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCwgZGlyZWN0aW9uIDEgbWVhbnMgdG8gbW92ZSB0b3dhcmRzXG4gIC8vIHRoZSBuZXh0IGluZGV4IGluIHRoZSBzdHJpbmcsIG9yIHRvd2FyZHMgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHRcbiAgLy8gb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24uIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGFcbiAgLy8gaGl0U2lkZT10cnVlIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRQb3NIKGRvYywgcG9zLCBkaXIsIHVuaXQsIHZpc3VhbGx5KSB7XG4gICAgdmFyIG9sZFBvcyA9IHBvcztcbiAgICB2YXIgb3JpZ0RpciA9IGRpcjtcbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBwb3MubGluZSk7XG4gICAgdmFyIGxpbmVEaXIgPSB2aXN1YWxseSAmJiBkb2MuZGlyZWN0aW9uID09IFwicnRsXCIgPyAtZGlyIDogZGlyO1xuICAgIGZ1bmN0aW9uIGZpbmROZXh0TGluZSgpIHtcbiAgICAgIHZhciBsID0gcG9zLmxpbmUgKyBsaW5lRGlyO1xuICAgICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcG9zID0gbmV3IFBvcyhsLCBwb3MuY2gsIHBvcy5zdGlja3kpO1xuICAgICAgcmV0dXJuIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbClcbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZU9uY2UoYm91bmRUb0xpbmUpIHtcbiAgICAgIHZhciBuZXh0O1xuICAgICAgaWYgKHVuaXQgPT0gXCJjb2RlcG9pbnRcIikge1xuICAgICAgICB2YXIgY2ggPSBsaW5lT2JqLnRleHQuY2hhckNvZGVBdChwb3MuY2ggKyAoZGlyID4gMCA/IDAgOiAtMSkpO1xuICAgICAgICBpZiAoaXNOYU4oY2gpKSB7XG4gICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFzdHJhbCA9IGRpciA+IDAgPyBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDAgOiBjaCA+PSAweERDMDAgJiYgY2ggPCAweERGRkY7XG4gICAgICAgICAgbmV4dCA9IG5ldyBQb3MocG9zLmxpbmUsIE1hdGgubWF4KDAsIE1hdGgubWluKGxpbmVPYmoudGV4dC5sZW5ndGgsIHBvcy5jaCArIGRpciAqIChhc3RyYWwgPyAyIDogMSkpKSwgLWRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmlzdWFsbHkpIHtcbiAgICAgICAgbmV4dCA9IG1vdmVWaXN1YWxseShkb2MuY20sIGxpbmVPYmosIHBvcywgZGlyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQgPSBtb3ZlTG9naWNhbGx5KGxpbmVPYmosIHBvcywgZGlyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSlcbiAgICAgICAgICB7IHBvcyA9IGVuZE9mTGluZSh2aXN1YWxseSwgZG9jLmNtLCBsaW5lT2JqLCBwb3MubGluZSwgbGluZURpcik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh1bml0ID09IFwiY2hhclwiIHx8IHVuaXQgPT0gXCJjb2RlcG9pbnRcIikge1xuICAgICAgbW92ZU9uY2UoKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJjb2x1bW5cIikge1xuICAgICAgbW92ZU9uY2UodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwid29yZFwiIHx8IHVuaXQgPT0gXCJncm91cFwiKSB7XG4gICAgICB2YXIgc2F3VHlwZSA9IG51bGwsIGdyb3VwID0gdW5pdCA9PSBcImdyb3VwXCI7XG4gICAgICB2YXIgaGVscGVyID0gZG9jLmNtICYmIGRvYy5jbS5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcbiAgICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxuICAgICAgICB2YXIgY3VyID0gbGluZU9iai50ZXh0LmNoYXJBdChwb3MuY2gpIHx8IFwiXFxuXCI7XG4gICAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcIndcIlxuICAgICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFwiXFxuXCIgPyBcIm5cIlxuICAgICAgICAgIDogIWdyb3VwIHx8IC9cXHMvLnRlc3QoY3VyKSA/IG51bGxcbiAgICAgICAgICA6IFwicFwiO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB7IHR5cGUgPSBcInNcIjsgfVxuICAgICAgICBpZiAoc2F3VHlwZSAmJiBzYXdUeXBlICE9IHR5cGUpIHtcbiAgICAgICAgICBpZiAoZGlyIDwgMCkge2RpciA9IDE7IG1vdmVPbmNlKCk7IHBvcy5zdGlja3kgPSBcImFmdGVyXCI7fVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSkgeyBzYXdUeXBlID0gdHlwZTsgfVxuICAgICAgICBpZiAoZGlyID4gMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIG9yaWdEaXIsIHRydWUpO1xuICAgIGlmIChlcXVhbEN1cnNvclBvcyhvbGRQb3MsIHJlc3VsdCkpIHsgcmVzdWx0LmhpdFNpZGUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gRm9yIHJlbGF0aXZlIHZlcnRpY2FsIG1vdmVtZW50LiBEaXIgbWF5IGJlIC0xIG9yIDEuIFVuaXQgY2FuIGJlXG4gIC8vIFwicGFnZVwiIG9yIFwibGluZVwiLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxuICAvLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zVihjbSwgcG9zLCBkaXIsIHVuaXQpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCB4ID0gcG9zLmxlZnQsIHk7XG4gICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIHZhciBwYWdlU2l6ZSA9IE1hdGgubWluKGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZhciBtb3ZlQW1vdW50ID0gTWF0aC5tYXgocGFnZVNpemUgLSAuNSAqIHRleHRIZWlnaHQoY20uZGlzcGxheSksIDMpO1xuICAgICAgeSA9IChkaXIgPiAwID8gcG9zLmJvdHRvbSA6IHBvcy50b3ApICsgZGlyICogbW92ZUFtb3VudDtcblxuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcImxpbmVcIikge1xuICAgICAgeSA9IGRpciA+IDAgPyBwb3MuYm90dG9tICsgMyA6IHBvcy50b3AgLSAzO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgIHRhcmdldCA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpO1xuICAgICAgaWYgKCF0YXJnZXQub3V0c2lkZSkgeyBicmVhayB9XG4gICAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkgeyB0YXJnZXQuaGl0U2lkZSA9IHRydWU7IGJyZWFrIH1cbiAgICAgIHkgKz0gZGlyICogNTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ09OVEVOVEVESVRBQkxFIElOUFVUIFNUWUxFXG5cbiAgdmFyIENvbnRlbnRFZGl0YWJsZUlucHV0ID0gZnVuY3Rpb24oY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLmdyYWNlUGVyaW9kID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtO1xuICAgIHZhciBkaXYgPSBpbnB1dC5kaXYgPSBkaXNwbGF5LmxpbmVEaXY7XG4gICAgZGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyhkaXYsIGNtLm9wdGlvbnMuc3BlbGxjaGVjaywgY20ub3B0aW9ucy5hdXRvY29ycmVjdCwgY20ub3B0aW9ucy5hdXRvY2FwaXRhbGl6ZSk7XG5cbiAgICBmdW5jdGlvbiBiZWxvbmdzVG9JbnB1dChlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gZS50YXJnZXQ7IHQ7IHQgPSB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHQgPT0gZGl2KSB7IHJldHVybiB0cnVlIH1cbiAgICAgICAgaWYgKC9cXGJDb2RlTWlycm9yLSg/OmxpbmUpP3dpZGdldFxcYi8udGVzdCh0LmNsYXNzTmFtZSkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgb24oZGl2LCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWJlbG9uZ3NUb0lucHV0KGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cbiAgICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudHMsIHNvIHdlIHNjaGVkdWxlIGEgcmVhZCBmb3IgdGhlIHBhc3RlZCBjb250ZW50IGluIHRoaXMgd2F5XG4gICAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLnVwZGF0ZUZyb21ET00oKTsgfSksIDIwKTsgfVxuICAgIH0pO1xuXG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX07XG4gICAgfSk7XG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTsgfVxuICAgIH0pO1xuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgaWYgKGUuZGF0YSAhPSB0aGlzJDEuY29tcG9zaW5nLmRhdGEpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBvbihkaXYsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7IH0pO1xuXG4gICAgb24oZGl2LCBcImlucHV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCk7IH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XG4gICAgICBpZiAoIWJlbG9uZ3NUb0lucHV0KGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIDAsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgZS5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICB2YXIgY29udGVudCA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAvLyBpT1MgZXhwb3NlcyB0aGUgY2xpcGJvYXJkIEFQSSwgYnV0IHNlZW1zIHRvIGRpc2NhcmQgY29udGVudCBpbnNlcnRlZCBpbnRvIGl0XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKSA9PSBjb250ZW50KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbGQtZmFzaGlvbmVkIGJyaWVmbHktZm9jdXMtYS10ZXh0YXJlYSBoYWNrXG4gICAgICB2YXIga2x1ZGdlID0gaGlkZGVuVGV4dGFyZWEoKSwgdGUgPSBrbHVkZ2UuZmlyc3RDaGlsZDtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgIHZhciBoYWRGb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGtsdWRnZSk7XG4gICAgICAgIGhhZEZvY3VzLmZvY3VzKCk7XG4gICAgICAgIGlmIChoYWRGb2N1cyA9PSBkaXYpIHsgaW5wdXQuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKTsgfVxuICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvbihkaXYsIFwiY29weVwiLCBvbkNvcHlDdXQpO1xuICAgIG9uKGRpdiwgXCJjdXRcIiwgb25Db3B5Q3V0KTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgLy8gTGFiZWwgZm9yIHNjcmVlbnJlYWRlcnMsIGFjY2Vzc2liaWxpdHlcbiAgICBpZihsYWJlbCkge1xuICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24odGhpcy5jbSwgZmFsc2UpO1xuICAgIHJlc3VsdC5mb2N1cyA9IGFjdGl2ZUVsdCgpID09IHRoaXMuZGl2O1xuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChpbmZvLCB0YWtlRm9jdXMpIHtcbiAgICBpZiAoIWluZm8gfHwgIXRoaXMuY20uZGlzcGxheS52aWV3Lmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGlmIChpbmZvLmZvY3VzIHx8IHRha2VGb2N1cykgeyB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbyk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbS5kaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93UHJpbWFyeVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtLCBwcmltID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgdmFyIGZyb20gPSBwcmltLmZyb20oKSwgdG8gPSBwcmltLnRvKCk7XG5cbiAgICBpZiAoY20uZGlzcGxheS52aWV3VG8gPT0gY20uZGlzcGxheS52aWV3RnJvbSB8fCBmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgdG8ubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjdXJBbmNob3IgPSBkb21Ub1BvcyhjbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgIHZhciBjdXJGb2N1cyA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmIChjdXJBbmNob3IgJiYgIWN1ckFuY2hvci5iYWQgJiYgY3VyRm9jdXMgJiYgIWN1ckZvY3VzLmJhZCAmJlxuICAgICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBmcm9tKSA9PSAwICYmXG4gICAgICAgIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHRvKSA9PSAwKVxuICAgICAgeyByZXR1cm4gfVxuXG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgdmFyIHN0YXJ0ID0gKGZyb20ubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHBvc1RvRE9NKGNtLCBmcm9tKSkgfHxcbiAgICAgICAge25vZGU6IHZpZXdbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH07XG4gICAgdmFyIGVuZCA9IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdUbyAmJiBwb3NUb0RPTShjbSwgdG8pO1xuICAgIGlmICghZW5kKSB7XG4gICAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlO1xuICAgICAgdmFyIG1hcCA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcDtcbiAgICAgIGVuZCA9IHtub2RlOiBtYXBbbWFwLmxlbmd0aCAtIDFdLCBvZmZzZXQ6IG1hcFttYXAubGVuZ3RoIC0gMl0gLSBtYXBbbWFwLmxlbmd0aCAtIDNdfTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBvbGQgPSBzZWwucmFuZ2VDb3VudCAmJiBzZWwuZ2V0UmFuZ2VBdCgwKSwgcm5nO1xuICAgIHRyeSB7IHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpOyB9XG4gICAgY2F0Y2goZSkge30gLy8gT3VyIG1vZGVsIG9mIHRoZSBET00gbWlnaHQgYmUgb3V0ZGF0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJhbmdlIHdlIHRyeSB0byBzZXQgY2FuIGJlIGltcG9zc2libGVcbiAgICBpZiAocm5nKSB7XG4gICAgICBpZiAoIWdlY2tvICYmIGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgc2VsLmNvbGxhcHNlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIGlmICghcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGQgJiYgc2VsLmFuY2hvck5vZGUgPT0gbnVsbCkgeyBzZWwuYWRkUmFuZ2Uob2xkKTsgfVxuICAgICAgZWxzZSBpZiAoZ2Vja28pIHsgdGhpcy5zdGFydEdyYWNlUGVyaW9kKCk7IH1cbiAgICB9XG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdGFydEdyYWNlUGVyaW9kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCk7XG4gICAgdGhpcy5ncmFjZVBlcmlvZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmdyYWNlUGVyaW9kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcyQxLnNlbGVjdGlvbkNoYW5nZWQoKSlcbiAgICAgICAgeyB0aGlzJDEuY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7IH1cbiAgICB9LCAyMCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsIGluZm8uY3Vyc29ycyk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZW1lbWJlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkluRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIHJldHVybiBjb250YWlucyh0aGlzLmRpdiwgbm9kZSlcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMuZGl2KVxuICAgICAgICB7IHRoaXMuc2hvd1NlbGVjdGlvbih0aGlzLnByZXBhcmVTZWxlY3Rpb24oKSwgdHJ1ZSk7IH1cbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXYuYmx1cigpOyB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpdiB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzO1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLnBvbGxTZWxlY3Rpb24oKTsgfSwgMjApOyB9XG4gICAgZWxzZVxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KTsgfVxuXG4gICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgIGlmIChpbnB1dC5jbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIGlucHV0LnBvbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSAhPSB0aGlzLmxhc3RBbmNob3JOb2RlIHx8IHNlbC5hbmNob3JPZmZzZXQgIT0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0IHx8XG4gICAgICBzZWwuZm9jdXNOb2RlICE9IHRoaXMubGFzdEZvY3VzTm9kZSB8fCBzZWwuZm9jdXNPZmZzZXQgIT0gdGhpcy5sYXN0Rm9jdXNPZmZzZXRcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsIHx8IHRoaXMuZ3JhY2VQZXJpb2QgfHwgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbTtcbiAgICAvLyBPbiBBbmRyb2lkIENocm9tZSAodmVyc2lvbiA1NiwgYXQgbGVhc3QpLCBiYWNrc3BhY2luZyBpbnRvIGFuXG4gICAgLy8gdW5lZGl0YWJsZSBibG9jayBlbGVtZW50IHdpbGwgcHV0IHRoZSBjdXJzb3IgaW4gdGhhdCBlbGVtZW50LFxuICAgIC8vIGFuZCB0aGVuLCBiZWNhdXNlIGl0J3Mgbm90IGVkaXRhYmxlLCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLlxuICAgIC8vIEJlY2F1c2UgQW5kcm9pZCBkb2Vzbid0IGFsbG93IHVzIHRvIGFjdHVhbGx5IGRldGVjdCBiYWNrc3BhY2VcbiAgICAvLyBwcmVzc2VzIGluIGEgc2FuZSB3YXksIHRoaXMgY29kZSBjaGVja3MgZm9yIHdoZW4gdGhhdCBoYXBwZW5zXG4gICAgLy8gYW5kIHNpbXVsYXRlcyBhIGJhY2tzcGFjZSBwcmVzcyBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIHRoaXMuY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGggJiYgaXNJbkd1dHRlcihzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgIHRoaXMuY20udHJpZ2dlck9uS2V5RG93bih7dHlwZTogXCJrZXlkb3duXCIsIGtleUNvZGU6IDgsIHByZXZlbnREZWZhdWx0OiBNYXRoLmFic30pO1xuICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICAgIHZhciBhbmNob3IgPSBkb21Ub1BvcyhjbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgIHZhciBoZWFkID0gZG9tVG9Qb3MoY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICBpZiAoYW5jaG9yLmJhZCB8fCBoZWFkLmJhZCkgeyBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfVxuICAgIH0pOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KTtcbiAgICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzZWwgPSBjbS5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICB2YXIgZnJvbSA9IHNlbC5mcm9tKCksIHRvID0gc2VsLnRvKCk7XG4gICAgaWYgKGZyb20uY2ggPT0gMCAmJiBmcm9tLmxpbmUgPiBjbS5maXJzdExpbmUoKSlcbiAgICAgIHsgZnJvbSA9IFBvcyhmcm9tLmxpbmUgLSAxLCBnZXRMaW5lKGNtLmRvYywgZnJvbS5saW5lIC0gMSkubGVuZ3RoKTsgfVxuICAgIGlmICh0by5jaCA9PSBnZXRMaW5lKGNtLmRvYywgdG8ubGluZSkudGV4dC5sZW5ndGggJiYgdG8ubGluZSA8IGNtLmxhc3RMaW5lKCkpXG4gICAgICB7IHRvID0gUG9zKHRvLmxpbmUgKyAxLCAwKTsgfVxuICAgIGlmIChmcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvLmxpbmUgPiBkaXNwbGF5LnZpZXdUbyAtIDEpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHZhciBmcm9tSW5kZXgsIGZyb21MaW5lLCBmcm9tTm9kZTtcbiAgICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcbiAgICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1swXS5saW5lKTtcbiAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3WzBdLm5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpO1xuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbZnJvbUluZGV4IC0gMV0ubm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgdmFyIHRvSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCB0by5saW5lKTtcbiAgICB2YXIgdG9MaW5lLCB0b05vZGU7XG4gICAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcbiAgICAgIHRvTGluZSA9IGRpc3BsYXkudmlld1RvIC0gMTtcbiAgICAgIHRvTm9kZSA9IGRpc3BsYXkubGluZURpdi5sYXN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMTtcbiAgICAgIHRvTm9kZSA9IGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tTm9kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBuZXdUZXh0ID0gY20uZG9jLnNwbGl0TGluZXMoZG9tVGV4dEJldHdlZW4oY20sIGZyb21Ob2RlLCB0b05vZGUsIGZyb21MaW5lLCB0b0xpbmUpKTtcbiAgICB2YXIgb2xkVGV4dCA9IGdldEJldHdlZW4oY20uZG9jLCBQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lLCBnZXRMaW5lKGNtLmRvYywgdG9MaW5lKS50ZXh0Lmxlbmd0aCkpO1xuICAgIHdoaWxlIChuZXdUZXh0Lmxlbmd0aCA+IDEgJiYgb2xkVGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAobHN0KG5ld1RleHQpID09IGxzdChvbGRUZXh0KSkgeyBuZXdUZXh0LnBvcCgpOyBvbGRUZXh0LnBvcCgpOyB0b0xpbmUtLTsgfVxuICAgICAgZWxzZSBpZiAobmV3VGV4dFswXSA9PSBvbGRUZXh0WzBdKSB7IG5ld1RleHQuc2hpZnQoKTsgb2xkVGV4dC5zaGlmdCgpOyBmcm9tTGluZSsrOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIHZhciBjdXRGcm9udCA9IDAsIGN1dEVuZCA9IDA7XG4gICAgdmFyIG5ld1RvcCA9IG5ld1RleHRbMF0sIG9sZFRvcCA9IG9sZFRleHRbMF0sIG1heEN1dEZyb250ID0gTWF0aC5taW4obmV3VG9wLmxlbmd0aCwgb2xkVG9wLmxlbmd0aCk7XG4gICAgd2hpbGUgKGN1dEZyb250IDwgbWF4Q3V0RnJvbnQgJiYgbmV3VG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpID09IG9sZFRvcC5jaGFyQ29kZUF0KGN1dEZyb250KSlcbiAgICAgIHsgKytjdXRGcm9udDsgfVxuICAgIHZhciBuZXdCb3QgPSBsc3QobmV3VGV4dCksIG9sZEJvdCA9IGxzdChvbGRUZXh0KTtcbiAgICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQm90Lmxlbmd0aCAtIChvbGRUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSk7XG4gICAgd2hpbGUgKGN1dEVuZCA8IG1heEN1dEVuZCAmJlxuICAgICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKVxuICAgICAgeyArK2N1dEVuZDsgfVxuICAgIC8vIFRyeSB0byBtb3ZlIHN0YXJ0IG9mIGNoYW5nZSB0byBzdGFydCBvZiBzZWxlY3Rpb24gaWYgYW1iaWd1b3VzXG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID09IDEgJiYgb2xkVGV4dC5sZW5ndGggPT0gMSAmJiBmcm9tTGluZSA9PSBmcm9tLmxpbmUpIHtcbiAgICAgIHdoaWxlIChjdXRGcm9udCAmJiBjdXRGcm9udCA+IGZyb20uY2ggJiZcbiAgICAgICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKSB7XG4gICAgICAgIGN1dEZyb250LS07XG4gICAgICAgIGN1dEVuZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKS5yZXBsYWNlKC9eXFx1MjAwYisvLCBcIlwiKTtcbiAgICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udCkucmVwbGFjZSgvXFx1MjAwYiskLywgXCJcIik7XG5cbiAgICB2YXIgY2hGcm9tID0gUG9zKGZyb21MaW5lLCBjdXRGcm9udCk7XG4gICAgdmFyIGNoVG8gPSBQb3ModG9MaW5lLCBvbGRUZXh0Lmxlbmd0aCA/IGxzdChvbGRUZXh0KS5sZW5ndGggLSBjdXRFbmQgOiAwKTtcbiAgICBpZiAobmV3VGV4dC5sZW5ndGggPiAxIHx8IG5ld1RleHRbMF0gfHwgY21wKGNoRnJvbSwgY2hUbykpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIG5ld1RleHQsIGNoRnJvbSwgY2hUbywgXCIraW5wdXRcIik7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb3JjZUNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCk7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlRnJvbURPTSgpO1xuICAgIHRoaXMuZGl2LmJsdXIoKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZEZyb21ET01Tb29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7IHJldHVybiB9XG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nLmRvbmUpIHsgdGhpcyQxLmNvbXBvc2luZyA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB9XG4gICAgICB9XG4gICAgICB0aGlzJDEudXBkYXRlRnJvbURPTSgpO1xuICAgIH0sIDgwKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUudXBkYXRlRnJvbURPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuY20uaXNSZWFkT25seSgpIHx8ICF0aGlzLnBvbGxDb250ZW50KCkpXG4gICAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnQ2hhbmdlKHRoaXMkMS5jbSk7IH0pOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5jaGFyQ29kZSA9PSAwIHx8IHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5jbS5pc1JlYWRPbmx5KCkpXG4gICAgICB7IG9wZXJhdGlvbih0aGlzLmNtLCBhcHBseVRleHRJbnB1dCkodGhpcy5jbSwgU3RyaW5nLmZyb21DaGFyQ29kZShlLmNoYXJDb2RlID09IG51bGwgPyBlLmtleUNvZGUgOiBlLmNoYXJDb2RlKSwgMCk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuZGl2LmNvbnRlbnRFZGl0YWJsZSA9IFN0cmluZyh2YWwgIT0gXCJub2N1cnNvclwiKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHt9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHBvc1RvRE9NKGNtLCBwb3MpIHtcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpO1xuICAgIGlmICghdmlldyB8fCB2aWV3LmhpZGRlbikgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBpbmZvID0gbWFwRnJvbUxpbmVWaWV3KHZpZXcsIGxpbmUsIHBvcy5saW5lKTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pLCBzaWRlID0gXCJsZWZ0XCI7XG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIHBvcy5jaCk7XG4gICAgICBzaWRlID0gcGFydFBvcyAlIDIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAoaW5mby5tYXAsIHBvcy5jaCwgc2lkZSk7XG4gICAgcmVzdWx0Lm9mZnNldCA9IHJlc3VsdC5jb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0O1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5HdXR0ZXIobm9kZSkge1xuICAgIGZvciAodmFyIHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKVxuICAgICAgeyBpZiAoL0NvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIvLnRlc3Qoc2Nhbi5jbGFzc05hbWUpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYmFkUG9zKHBvcywgYmFkKSB7IGlmIChiYWQpIHsgcG9zLmJhZCA9IHRydWU7IH0gcmV0dXJuIHBvcyB9XG5cbiAgZnVuY3Rpb24gZG9tVGV4dEJldHdlZW4oY20sIGZyb20sIHRvLCBmcm9tTGluZSwgdG9MaW5lKSB7XG4gICAgdmFyIHRleHQgPSBcIlwiLCBjbG9zaW5nID0gZmFsc2UsIGxpbmVTZXAgPSBjbS5kb2MubGluZVNlcGFyYXRvcigpLCBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHJlY29nbml6ZU1hcmtlcihpZCkgeyByZXR1cm4gZnVuY3Rpb24gKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9IH1cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmIChjbG9zaW5nKSB7XG4gICAgICAgIHRleHQgKz0gbGluZVNlcDtcbiAgICAgICAgaWYgKGV4dHJhTGluZWJyZWFrKSB7IHRleHQgKz0gbGluZVNlcDsgfVxuICAgICAgICBjbG9zaW5nID0gZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVGV4dChzdHIpIHtcbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgdGV4dCArPSBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgY21UZXh0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO1xuICAgICAgICBpZiAoY21UZXh0KSB7XG4gICAgICAgICAgYWRkVGV4dChjbVRleHQpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXJJRCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIpLCByYW5nZTtcbiAgICAgICAgaWYgKG1hcmtlcklEKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY20uZmluZE1hcmtzKFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUgKyAxLCAwKSwgcmVjb2duaXplTWFya2VyKCttYXJrZXJJRCkpO1xuICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGggJiYgKHJhbmdlID0gZm91bmRbMF0uZmluZCgwKSkpXG4gICAgICAgICAgICB7IGFkZFRleHQoZ2V0QmV0d2VlbihjbS5kb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKS5qb2luKGxpbmVTZXApKTsgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSA9PSBcImZhbHNlXCIpIHsgcmV0dXJuIH1cbiAgICAgICAgdmFyIGlzQmxvY2sgPSAvXihwcmV8ZGl2fHB8bGl8dGFibGV8YnIpJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG4gICAgICAgIGlmICghL15iciQvaS50ZXN0KG5vZGUubm9kZU5hbWUpICYmIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoID09IDApIHsgcmV0dXJuIH1cblxuICAgICAgICBpZiAoaXNCbG9jaykgeyBjbG9zZSgpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgd2Fsayhub2RlLmNoaWxkTm9kZXNbaV0pOyB9XG5cbiAgICAgICAgaWYgKC9eKHByZXxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpKSB7IGV4dHJhTGluZWJyZWFrID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoaXNCbG9jaykgeyBjbG9zaW5nID0gdHJ1ZTsgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgYWRkVGV4dChub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9cXHUyMDBiL2csIFwiXCIpLnJlcGxhY2UoL1xcdTAwYTAvZywgXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgd2Fsayhmcm9tKTtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IGJyZWFrIH1cbiAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xuICAgICAgZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbVRvUG9zKGNtLCBub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgbGluZU5vZGU7XG4gICAgaWYgKG5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XG4gICAgICBsaW5lTm9kZSA9IGNtLmRpc3BsYXkubGluZURpdi5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBpZiAoIWxpbmVOb2RlKSB7IHJldHVybiBiYWRQb3MoY20uY2xpcFBvcyhQb3MoY20uZGlzcGxheS52aWV3VG8gLSAxKSksIHRydWUpIH1cbiAgICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTs7IGxpbmVOb2RlID0gbGluZU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoIWxpbmVOb2RlIHx8IGxpbmVOb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIGlmIChsaW5lTm9kZS5wYXJlbnROb2RlICYmIGxpbmVOb2RlLnBhcmVudE5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpXTtcbiAgICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKVxuICAgICAgICB7IHJldHVybiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIHZhciB3cmFwcGVyID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLCBiYWQgPSBmYWxzZTtcbiAgICBpZiAoIW5vZGUgfHwgIWNvbnRhaW5zKHdyYXBwZXIsIG5vZGUpKSB7IHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lVmlldy5saW5lKSwgMCksIHRydWUpIH1cbiAgICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XG4gICAgICBiYWQgPSB0cnVlO1xuICAgICAgbm9kZSA9IHdyYXBwZXIuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVWaWV3LnJlc3QgPyBsc3QobGluZVZpZXcucmVzdCkgOiBsaW5lVmlldy5saW5lO1xuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZSksIGxpbmUudGV4dC5sZW5ndGgpLCBiYWQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlO1xuICAgIGlmICghdGV4dE5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChvZmZzZXQpIHsgb2Zmc2V0ID0gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aDsgfVxuICAgIH1cbiAgICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IHdyYXBwZXIpIHsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTsgfVxuICAgIHZhciBtZWFzdXJlID0gbGluZVZpZXcubWVhc3VyZSwgbWFwcyA9IG1lYXN1cmUubWFwcztcblxuICAgIGZ1bmN0aW9uIGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgKG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcCA9IGkgPCAwID8gbWVhc3VyZS5tYXAgOiBtYXBzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICAgIHZhciBjdXJOb2RlID0gbWFwW2ogKyAyXTtcbiAgICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZU5vKGkgPCAwID8gbGluZVZpZXcubGluZSA6IGxpbmVWaWV3LnJlc3RbaV0pO1xuICAgICAgICAgICAgdmFyIGNoID0gbWFwW2pdICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgY3VyTm9kZSAhPSB0ZXh0Tm9kZSkgeyBjaCA9IG1hcFtqICsgKG9mZnNldCA/IDEgOiAwKV07IH1cbiAgICAgICAgICAgIHJldHVybiBQb3MobGluZSwgY2gpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCk7XG4gICAgaWYgKGZvdW5kKSB7IHJldHVybiBiYWRQb3MoZm91bmQsIGJhZCkgfVxuXG4gICAgLy8gRklYTUUgdGhpcyBpcyBhbGwgcmVhbGx5IHNoYWt5LiBtaWdodCBoYW5kbGUgdGhlIGZldyBjYXNlcyBpdCBuZWVkcyB0byBoYW5kbGUsIGJ1dCBsaWtlbHkgdG8gY2F1c2UgcHJvYmxlbXNcbiAgICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xuICAgICAgZm91bmQgPSBmaW5kKGFmdGVyLCBhZnRlci5maXJzdENoaWxkLCAwKTtcbiAgICAgIGlmIChmb3VuZClcbiAgICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCAtIGRpc3QpLCBiYWQpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBkaXN0ICs9IGFmdGVyLnRleHRDb250ZW50Lmxlbmd0aDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCQxID0gb2Zmc2V0OyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChiZWZvcmUsIGJlZm9yZS5maXJzdENoaWxkLCAtMSk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggKyBkaXN0JDEpLCBiYWQpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBkaXN0JDEgKz0gYmVmb3JlLnRleHRDb250ZW50Lmxlbmd0aDsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRFWFRBUkVBIElOUFVUIFNUWUxFXG5cbiAgdmFyIFRleHRhcmVhSW5wdXQgPSBmdW5jdGlvbihjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICAvLyBTZWUgaW5wdXQucG9sbCBhbmQgaW5wdXQucmVzZXRcbiAgICB0aGlzLnByZXZJbnB1dCA9IFwiXCI7XG5cbiAgICAvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgd2UgZXhwZWN0IGlucHV0IHRvIGFwcGVhciByZWFsIHNvb25cbiAgICAvLyBub3cgKGFmdGVyIHNvbWUgZXZlbnQgbGlrZSAna2V5cHJlc3MnIG9yICdpbnB1dCcpIGFuZCBhcmVcbiAgICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxuICAgIHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTtcbiAgICAvLyBTZWxmLXJlc2V0dGluZyB0aW1lb3V0IGZvciB0aGUgcG9sbGVyXG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcbiAgICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxuICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XG4gICAgdGhpcy5jcmVhdGVGaWVsZChkaXNwbGF5KTtcbiAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhO1xuXG4gICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgIC8vIE5lZWRlZCB0byBoaWRlIGJpZyBibHVlIGJsaW5raW5nIGN1cnNvciBvbiBNb2JpbGUgU2FmYXJpIChkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBpT1MgOCBhbnltb3JlKVxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUud2lkdGggPSBcIjBweFwiOyB9XG5cbiAgICBvbih0ZSwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMkMS5oYXNTZWxlY3Rpb24pIHsgdGhpcyQxLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICAgIGlucHV0LnBvbGwoKTtcbiAgICB9KTtcblxuICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxuXG4gICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gK25ldyBEYXRlO1xuICAgICAgaW5wdXQuZmFzdFBvbGwoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9ICtuZXcgRGF0ZTsgfVxuICAgIH1cbiAgICBvbih0ZSwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xuICAgIG9uKHRlLCBcImNvcHlcIiwgcHJlcGFyZUNvcHlDdXQpO1xuXG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoIXRlLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZTtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhlIGBwYXN0ZWAgZXZlbnQgdG8gdGhlIHRleHRhcmVhIHNvIGl0J3MgaGFuZGxlZCBieSBpdHMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJwYXN0ZVwiKTtcbiAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEgPSBlLmNsaXBib2FyZERhdGE7XG4gICAgICB0ZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIFByZXZlbnQgbm9ybWFsIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yICh3ZSBoYW5kbGUgb3VyIG93bilcbiAgICBvbihkaXNwbGF5LmxpbmVTcGFjZSwgXCJzZWxlY3RzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9KTtcblxuICAgIG9uKHRlLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKTtcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHsgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7IH1cbiAgICAgIGlucHV0LmNvbXBvc2luZyA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBvbih0ZSwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7XG4gICAgICAgIGlucHV0LnBvbGwoKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuY3JlYXRlRmllbGQgPSBmdW5jdGlvbiAoX2Rpc3BsYXkpIHtcbiAgICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcbiAgICB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xuICAgIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAvLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXG4gICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMud3JhcHBlci5maXJzdENoaWxkO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlZHJhdyB0aGUgc2VsZWN0aW9uIGFuZC9vciBjdXJzb3JcbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKGNtKTtcblxuICAgIC8vIE1vdmUgdGhlIGhpZGRlbiB0ZXh0YXJlYSBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCBzY3JvbGxpbmcgYXJ0aWZhY3RzXG4gICAgaWYgKGNtLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xuICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgdmFyIHdyYXBPZmYgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxpbmVPZmYgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKTtcbiAgICAgIHJlc3VsdC50ZUxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChkcmF3bikge1xuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuY3Vyc29yRGl2LCBkcmF3bi5jdXJzb3JzKTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdiwgZHJhd24uc2VsZWN0aW9uKTtcbiAgICBpZiAoZHJhd24udGVUb3AgIT0gbnVsbCkge1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IGRyYXduLnRlVG9wICsgXCJweFwiO1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBkcmF3bi50ZUxlZnQgKyBcInB4XCI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlc2V0IHRoZSBpbnB1dCB0byBjb3JyZXNwb25kIHRvIHRoZSBzZWxlY3Rpb24gKG9yIHRvIGJlIGVtcHR5LFxuICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHR5cGluZykge1xuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCB0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIHZhciBjbSA9IHRoaXMuY207XG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcbiAgICAgIHZhciBjb250ZW50ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNlbGVjdElucHV0KHRoaXMudGV4dGFyZWEpOyB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDsgfVxuICAgIH0gZWxzZSBpZiAoIXR5cGluZykge1xuICAgICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50ZXh0YXJlYSB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZSB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiICYmICghbW9iaWxlIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMudGV4dGFyZWEpKSB7XG4gICAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCk7IH1cbiAgICAgIGNhdGNoIChlKSB7fSAvLyBJRTggd2lsbCB0aHJvdyBpZiB0aGUgdGV4dGFyZWEgaXMgZGlzcGxheTogbm9uZSBvciBub3QgaW4gRE9NXG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMudGV4dGFyZWEuYmx1cigpOyB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnNsb3dQb2xsKCk7IH07XG5cbiAgLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcbiAgLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2xvd1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0KSB7IHJldHVybiB9XG4gICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEucG9sbCgpO1xuICAgICAgaWYgKHRoaXMkMS5jbS5zdGF0ZS5mb2N1c2VkKSB7IHRoaXMkMS5zbG93UG9sbCgpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gV2hlbiBhbiBldmVudCBoYXMganVzdCBjb21lIGluIHRoYXQgaXMgbGlrZWx5IHRvIGFkZCBvciBjaGFuZ2VcbiAgLy8gc29tZXRoaW5nIGluIHRoZSBpbnB1dCB0ZXh0YXJlYSwgd2UgcG9sbCBmYXN0ZXIsIHRvIGVuc3VyZSB0aGF0XG4gIC8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmZhc3RQb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzO1xuICAgIGlucHV0LnBvbGxpbmdGYXN0ID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgdmFyIGNoYW5nZWQgPSBpbnB1dC5wb2xsKCk7XG4gICAgICBpZiAoIWNoYW5nZWQgJiYgIW1pc3NlZCkge21pc3NlZCA9IHRydWU7IGlucHV0LnBvbGxpbmcuc2V0KDYwLCBwKTt9XG4gICAgICBlbHNlIHtpbnB1dC5wb2xsaW5nRmFzdCA9IGZhbHNlOyBpbnB1dC5zbG93UG9sbCgpO31cbiAgICB9XG4gICAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApO1xuICB9O1xuXG4gIC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxuICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxuICAvLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xuICAvLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxuICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcbiAgLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY20gPSB0aGlzLmNtLCBpbnB1dCA9IHRoaXMudGV4dGFyZWEsIHByZXZJbnB1dCA9IHRoaXMucHJldklucHV0O1xuICAgIC8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXG4gICAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxuICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHxcbiAgICAgICAgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCAmJiAhdGhpcy5jb21wb3NpbmcpIHx8XG4gICAgICAgIGNtLmlzUmVhZE9ubHkoKSB8fCBjbS5vcHRpb25zLmRpc2FibGVJbnB1dCB8fCBjbS5zdGF0ZS5rZXlTZXEpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICB2YXIgdGV4dCA9IGlucHV0LnZhbHVlO1xuICAgIC8vIElmIG5vdGhpbmcgY2hhbmdlZCwgYmFpbC5cbiAgICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXG4gICAgLy8gaW5leHBsaWNhYmxlIGFwcGVhcmFuY2Ugb2YgcHJpdmF0ZSBhcmVhIHVuaWNvZGUgY2hhcmFjdGVycyBvblxuICAgIC8vIHNvbWUga2V5IGNvbWJvcyBpbiBNYWMgKCMyNjg5KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMuaGFzU2VsZWN0aW9uID09PSB0ZXh0IHx8XG4gICAgICAgIG1hYyAmJiAvW1xcdWY3MDAtXFx1ZjdmZl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjbS5kb2Muc2VsID09IGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUpIHtcbiAgICAgIHZhciBmaXJzdCA9IHRleHQuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChmaXJzdCA9PSAweDIwMGIgJiYgIXByZXZJbnB1dCkgeyBwcmV2SW5wdXQgPSBcIlxcdTIwMGJcIjsgfVxuICAgICAgaWYgKGZpcnN0ID09IDB4MjFkYSkgeyB0aGlzLnJlc2V0KCk7IHJldHVybiB0aGlzLmNtLmV4ZWNDb21tYW5kKFwidW5kb1wiKSB9XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIHBhcnQgb2YgdGhlIGlucHV0IHRoYXQgaXMgYWN0dWFsbHkgbmV3XG4gICAgdmFyIHNhbWUgPSAwLCBsID0gTWF0aC5taW4ocHJldklucHV0Lmxlbmd0aCwgdGV4dC5sZW5ndGgpO1xuICAgIHdoaWxlIChzYW1lIDwgbCAmJiBwcmV2SW5wdXQuY2hhckNvZGVBdChzYW1lKSA9PSB0ZXh0LmNoYXJDb2RlQXQoc2FtZSkpIHsgKytzYW1lOyB9XG5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseVRleHRJbnB1dChjbSwgdGV4dC5zbGljZShzYW1lKSwgcHJldklucHV0Lmxlbmd0aCAtIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgICBudWxsLCB0aGlzJDEuY29tcG9zaW5nID8gXCIqY29tcG9zZVwiIDogbnVsbCk7XG5cbiAgICAgIC8vIERvbid0IGxlYXZlIGxvbmcgdGV4dCBpbiB0aGUgdGV4dGFyZWEsIHNpbmNlIGl0IG1ha2VzIGZ1cnRoZXIgcG9sbGluZyBzbG93XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAxMDAwIHx8IHRleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xKSB7IGlucHV0LnZhbHVlID0gdGhpcyQxLnByZXZJbnB1dCA9IFwiXCI7IH1cbiAgICAgIGVsc2UgeyB0aGlzJDEucHJldklucHV0ID0gdGV4dDsgfVxuXG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UgPSBjbS5tYXJrVGV4dCh0aGlzJDEuY29tcG9zaW5nLnN0YXJ0LCBjbS5nZXRDdXJzb3IoXCJ0b1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCAmJiB0aGlzLnBvbGwoKSkgeyB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7IH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgdGhpcy5mYXN0UG9sbCgpO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB0ZSA9IGlucHV0LnRleHRhcmVhO1xuICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcpIHsgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKCk7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgaWYgKCFwb3MgfHwgcHJlc3RvKSB7IHJldHVybiB9IC8vIE9wZXJhIGlzIGRpZmZpY3VsdC5cblxuICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXG4gICAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxuICAgIHZhciByZXNldCA9IGNtLm9wdGlvbnMucmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51O1xuICAgIGlmIChyZXNldCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPT0gLTEpXG4gICAgICB7IG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7IH1cblxuICAgIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0O1xuICAgIHZhciB3cmFwcGVyQm94ID0gaW5wdXQud3JhcHBlci5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogc3RhdGljXCI7XG4gICAgdGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMzBweDsgaGVpZ2h0OiAzMHB4O1xcbiAgICAgIHRvcDogXCIgKyAoZS5jbGllbnRZIC0gd3JhcHBlckJveC50b3AgLSA1KSArIFwicHg7IGxlZnQ6IFwiICsgKGUuY2xpZW50WCAtIHdyYXBwZXJCb3gubGVmdCAtIDUpICsgXCJweDtcXG4gICAgICB6LWluZGV4OiAxMDAwOyBiYWNrZ3JvdW5kOiBcIiArIChpZSA/IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXCIgOiBcInRyYW5zcGFyZW50XCIpICsgXCI7XFxuICAgICAgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcIjtcbiAgICB2YXIgb2xkU2Nyb2xsWTtcbiAgICBpZiAod2Via2l0KSB7IG9sZFNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTsgfSAvLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgKCMyNzEyKVxuICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICBpZiAod2Via2l0KSB7IHdpbmRvdy5zY3JvbGxUbyhudWxsLCBvbGRTY3JvbGxZKTsgfVxuICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAvLyBBZGRzIFwiU2VsZWN0IGFsbFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyB0ZS52YWx1ZSA9IGlucHV0LnByZXZJbnB1dCA9IFwiIFwiOyB9XG4gICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gcmVoaWRlO1xuICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgIGNsZWFyVGltZW91dChkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCk7XG5cbiAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xuICAgIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxuICAgIC8vIGl0IGdvdCBzZWxlY3RlZC5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIHZhciBleHR2YWwgPSBcIlxcdTIwMGJcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXCJcIik7XG4gICAgICAgIHRlLnZhbHVlID0gXCJcXHUyMWRhXCI7IC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cbiAgICAgICAgdGUudmFsdWUgPSBleHR2YWw7XG4gICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwYlwiO1xuICAgICAgICB0ZS5zZWxlY3Rpb25TdGFydCA9IDE7IHRlLnNlbGVjdGlvbkVuZCA9IGV4dHZhbC5sZW5ndGg7XG4gICAgICAgIC8vIFJlLXNldCB0aGlzLCBpbiBjYXNlIHNvbWUgb3RoZXIgaGFuZGxlciB0b3VjaGVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVoaWRlKCkge1xuICAgICAgaWYgKGlucHV0LmNvbnRleHRNZW51UGVuZGluZyAhPSByZWhpZGUpIHsgcmV0dXJuIH1cbiAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTUztcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcyk7IH1cblxuICAgICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXG4gICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWllIHx8IChpZSAmJiBpZV92ZXJzaW9uIDwgOSkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPT0gY20uZG9jLnNlbCAmJiB0ZS5zZWxlY3Rpb25TdGFydCA9PSAwICYmXG4gICAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwYlwiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSsrIDwgMTApIHtcbiAgICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgZV9zdG9wKGUpO1xuICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcbiAgICAgIH07XG4gICAgICBvbih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChyZWhpZGUsIDUwKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICghdmFsKSB7IHRoaXMucmVzZXQoKTsgfVxuICAgIHRoaXMudGV4dGFyZWEuZGlzYWJsZWQgPSB2YWwgPT0gXCJub2N1cnNvclwiO1xuICAgIHRoaXMudGV4dGFyZWEucmVhZE9ubHkgPSAhIXZhbDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKCkge307XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XG4gICAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xuICAgIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleClcbiAgICAgIHsgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4OyB9XG4gICAgaWYgKCFvcHRpb25zLnBsYWNlaG9sZGVyICYmIHRleHRhcmVhLnBsYWNlaG9sZGVyKVxuICAgICAgeyBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXI7IH1cbiAgICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcbiAgICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgPT0gbnVsbCkge1xuICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XG4gICAgICAgIHRleHRhcmVhLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCk7fVxuXG4gICAgdmFyIHJlYWxTdWJtaXQ7XG4gICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgIG9uKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcbiAgICAgICAgdmFyIGZvcm0gPSB0ZXh0YXJlYS5mb3JtO1xuICAgICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuZmluaXNoSW5pdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgICAgY20uc2F2ZSA9IHNhdmU7XG4gICAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRleHRhcmVhOyB9O1xuICAgICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20udG9UZXh0QXJlYSA9IGlzTmFOOyAvLyBQcmV2ZW50IHRoaXMgZnJvbSBiZWluZyByYW4gdHdpY2VcbiAgICAgICAgc2F2ZSgpO1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUgJiYgdHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHsgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0OyB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB2YXIgY20gPSBDb2RlTWlycm9yKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7IH0sXG4gICAgICBvcHRpb25zKTtcbiAgICByZXR1cm4gY21cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpIHtcbiAgICBDb2RlTWlycm9yLm9mZiA9IG9mZjtcbiAgICBDb2RlTWlycm9yLm9uID0gb247XG4gICAgQ29kZU1pcnJvci53aGVlbEV2ZW50UGl4ZWxzID0gd2hlZWxFdmVudFBpeGVscztcbiAgICBDb2RlTWlycm9yLkRvYyA9IERvYztcbiAgICBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBzcGxpdExpbmVzQXV0bztcbiAgICBDb2RlTWlycm9yLmNvdW50Q29sdW1uID0gY291bnRDb2x1bW47XG4gICAgQ29kZU1pcnJvci5maW5kQ29sdW1uID0gZmluZENvbHVtbjtcbiAgICBDb2RlTWlycm9yLmlzV29yZENoYXIgPSBpc1dvcmRDaGFyQmFzaWM7XG4gICAgQ29kZU1pcnJvci5QYXNzID0gUGFzcztcbiAgICBDb2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbDtcbiAgICBDb2RlTWlycm9yLkxpbmUgPSBMaW5lO1xuICAgIENvZGVNaXJyb3IuY2hhbmdlRW5kID0gY2hhbmdlRW5kO1xuICAgIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSBzY3JvbGxiYXJNb2RlbDtcbiAgICBDb2RlTWlycm9yLlBvcyA9IFBvcztcbiAgICBDb2RlTWlycm9yLmNtcFBvcyA9IGNtcDtcbiAgICBDb2RlTWlycm9yLm1vZGVzID0gbW9kZXM7XG4gICAgQ29kZU1pcnJvci5taW1lTW9kZXMgPSBtaW1lTW9kZXM7XG4gICAgQ29kZU1pcnJvci5yZXNvbHZlTW9kZSA9IHJlc29sdmVNb2RlO1xuICAgIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGdldE1vZGU7XG4gICAgQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucyA9IG1vZGVFeHRlbnNpb25zO1xuICAgIENvZGVNaXJyb3IuZXh0ZW5kTW9kZSA9IGV4dGVuZE1vZGU7XG4gICAgQ29kZU1pcnJvci5jb3B5U3RhdGUgPSBjb3B5U3RhdGU7XG4gICAgQ29kZU1pcnJvci5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICBDb2RlTWlycm9yLmlubmVyTW9kZSA9IGlubmVyTW9kZTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgQ29kZU1pcnJvci5rZXlNYXAgPSBrZXlNYXA7XG4gICAgQ29kZU1pcnJvci5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBpc01vZGlmaWVyS2V5O1xuICAgIENvZGVNaXJyb3IubG9va3VwS2V5ID0gbG9va3VwS2V5O1xuICAgIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwID0gbm9ybWFsaXplS2V5TWFwO1xuICAgIENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gU3RyaW5nU3RyZWFtO1xuICAgIENvZGVNaXJyb3IuU2hhcmVkVGV4dE1hcmtlciA9IFNoYXJlZFRleHRNYXJrZXI7XG4gICAgQ29kZU1pcnJvci5UZXh0TWFya2VyID0gVGV4dE1hcmtlcjtcbiAgICBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBMaW5lV2lkZ2V0O1xuICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdCA9IGVfcHJldmVudERlZmF1bHQ7XG4gICAgQ29kZU1pcnJvci5lX3N0b3BQcm9wYWdhdGlvbiA9IGVfc3RvcFByb3BhZ2F0aW9uO1xuICAgIENvZGVNaXJyb3IuZV9zdG9wID0gZV9zdG9wO1xuICAgIENvZGVNaXJyb3IuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgICBDb2RlTWlycm9yLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgQ29kZU1pcnJvci5ybUNsYXNzID0gcm1DbGFzcztcbiAgICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXM7XG4gIH1cblxuICAvLyBFRElUT1IgQ09OU1RSVUNUT1JcblxuICBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpO1xuXG4gIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcik7XG5cbiAgLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXG4gIHZhciBkb250RGVsZWdhdGUgPSBcIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclwiLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSB7IGlmIChEb2MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmIGluZGV4T2YoZG9udERlbGVnYXRlLCBwcm9wKSA8IDApXG4gICAgeyBDb2RlTWlycm9yLnByb3RvdHlwZVtwcm9wXSA9IChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpfVxuICAgIH0pKERvYy5wcm90b3R5cGVbcHJvcF0pOyB9IH1cblxuICBldmVudE1peGluKERvYyk7XG4gIENvZGVNaXJyb3IuaW5wdXRTdHlsZXMgPSB7XCJ0ZXh0YXJlYVwiOiBUZXh0YXJlYUlucHV0LCBcImNvbnRlbnRlZGl0YWJsZVwiOiBDb250ZW50RWRpdGFibGVJbnB1dH07XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUvKiwgbW9kZSwg4oCmKi8pIHtcbiAgICBpZiAoIUNvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSAmJiBuYW1lICE9IFwibnVsbFwiKSB7IENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7IH1cbiAgICBkZWZpbmVNb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FID0gZGVmaW5lTUlNRTtcblxuICAvLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibnVsbFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe3Rva2VuOiBmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiBzdHJlYW0uc2tpcFRvRW5kKCk7IH19KTsgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIiwgXCJudWxsXCIpO1xuXG4gIC8vIEVYVEVOU0lPTlNcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgRG9jLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEgPSBmcm9tVGV4dEFyZWE7XG5cbiAgYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcik7XG5cbiAgQ29kZU1pcnJvci52ZXJzaW9uID0gXCI1LjY1LjFcIjtcblxuICByZXR1cm4gQ29kZU1pcnJvcjtcblxufSkpKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJDb2RlTWlycm9yIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJnZWNrbyIsInRlc3QiLCJpZV91cHRvMTAiLCJpZV8xMXVwIiwiZXhlYyIsImVkZ2UiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudCIsImRvY3VtZW50TW9kZSIsIndlYmtpdCIsInF0d2Via2l0IiwiY2hyb21lIiwicHJlc3RvIiwic2FmYXJpIiwidmVuZG9yIiwibWFjX2dlTW91bnRhaW5MaW9uIiwicGhhbnRvbSIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwiYW5kcm9pZCIsIm1vYmlsZSIsIm1hYyIsImNocm9tZU9TIiwid2luZG93cyIsInByZXN0b192ZXJzaW9uIiwibWF0Y2giLCJOdW1iZXIiLCJmbGlwQ3RybENtZCIsImNhcHR1cmVSaWdodENsaWNrIiwiY2xhc3NUZXN0IiwiY2xzIiwiUmVnRXhwIiwicm1DbGFzcyIsIm5vZGUiLCJjdXJyZW50IiwiY2xhc3NOYW1lIiwiYWZ0ZXIiLCJzbGljZSIsImluZGV4IiwibGVuZ3RoIiwicmVtb3ZlQ2hpbGRyZW4iLCJlIiwiY291bnQiLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGRyZW5BbmRBZGQiLCJwYXJlbnQiLCJhcHBlbmRDaGlsZCIsImVsdCIsInRhZyIsImNvbnRlbnQiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJpIiwiZWx0UCIsInNldEF0dHJpYnV0ZSIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzdGFydCIsImVuZCIsImVuZE5vZGUiLCJyIiwic2V0RW5kIiwic2V0U3RhcnQiLCJib2R5IiwiY3JlYXRlVGV4dFJhbmdlIiwibW92ZVRvRWxlbWVudFRleHQiLCJwYXJlbnROb2RlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwibW92ZVN0YXJ0IiwiY29udGFpbnMiLCJjaGlsZCIsIm5vZGVUeXBlIiwiaG9zdCIsImFjdGl2ZUVsdCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiYWRkQ2xhc3MiLCJqb2luQ2xhc3NlcyIsImEiLCJiIiwiYXMiLCJzcGxpdCIsInNlbGVjdElucHV0Iiwic2VsZWN0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJ2YWx1ZSIsIl9lIiwiYmluZCIsImYiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJjb3B5T2JqIiwib2JqIiwidGFyZ2V0Iiwib3ZlcndyaXRlIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiY291bnRDb2x1bW4iLCJzdHJpbmciLCJ0YWJTaXplIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJzZWFyY2giLCJuIiwibmV4dFRhYiIsImluZGV4T2YiLCJEZWxheWVkIiwiaWQiLCJ0aW1lIiwiaGFuZGxlciIsIm9uVGltZW91dCIsIkRhdGUiLCJzZXRUaW1lb3V0Iiwic2V0IiwibXMiLCJjbGVhclRpbWVvdXQiLCJhcnJheSIsInNjcm9sbGVyR2FwIiwiUGFzcyIsInRvU3RyaW5nIiwic2VsX2RvbnRTY3JvbGwiLCJzY3JvbGwiLCJzZWxfbW91c2UiLCJvcmlnaW4iLCJzZWxfbW92ZSIsImZpbmRDb2x1bW4iLCJnb2FsIiwicG9zIiwiY29sIiwic2tpcHBlZCIsIk1hdGgiLCJtaW4iLCJzcGFjZVN0cnMiLCJzcGFjZVN0ciIsInB1c2giLCJsc3QiLCJhcnIiLCJtYXAiLCJvdXQiLCJpbnNlcnRTb3J0ZWQiLCJzY29yZSIsInByaW9yaXR5Iiwic3BsaWNlIiwibm90aGluZyIsImNyZWF0ZU9iaiIsImJhc2UiLCJwcm9wcyIsImluc3QiLCJPYmplY3QiLCJjcmVhdGUiLCJub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciIsImlzV29yZENoYXJCYXNpYyIsImNoIiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImlzV29yZENoYXIiLCJoZWxwZXIiLCJzb3VyY2UiLCJpc0VtcHR5IiwiZXh0ZW5kaW5nQ2hhcnMiLCJpc0V4dGVuZGluZ0NoYXIiLCJjaGFyQ29kZUF0Iiwic2tpcEV4dGVuZGluZ0NoYXJzIiwic3RyIiwiZGlyIiwiY2hhckF0IiwiZmluZEZpcnN0IiwicHJlZCIsImZyb20iLCJ0byIsIm1pZEYiLCJtaWQiLCJjZWlsIiwiZmxvb3IiLCJpdGVyYXRlQmlkaVNlY3Rpb25zIiwib3JkZXIiLCJmb3VuZCIsInBhcnQiLCJtYXgiLCJsZXZlbCIsImJpZGlPdGhlciIsImdldEJpZGlQYXJ0QXQiLCJzdGlja3kiLCJjdXIiLCJiaWRpT3JkZXJpbmciLCJsb3dUeXBlcyIsImFyYWJpY1R5cGVzIiwiY2hhclR5cGUiLCJjb2RlIiwiYmlkaVJFIiwiaXNOZXV0cmFsIiwiaXNTdHJvbmciLCJjb3VudHNBc0xlZnQiLCJjb3VudHNBc051bSIsIkJpZGlTcGFuIiwiZGlyZWN0aW9uIiwib3V0ZXJUeXBlIiwibGVuIiwidHlwZXMiLCJpJDEiLCJwcmV2IiwidHlwZSIsImkkMiIsInR5cGUkMSIsImkkMyIsInByZXYkMSIsInR5cGUkMiIsImkkNCIsInR5cGUkMyIsInJlcGxhY2UiLCJqIiwiaSQ1IiwiY3VyJDEiLCJ0eXBlJDQiLCJpJDYiLCJlbmQkMSIsImJlZm9yZSIsInJlcGxhY2UkMSIsImokMSIsIm0iLCJpJDciLCJhdCIsImlzUlRMIiwiaiQyIiwibnN0YXJ0IiwidW5zaGlmdCIsInJldmVyc2UiLCJnZXRPcmRlciIsImxpbmUiLCJ0ZXh0Iiwibm9IYW5kbGVycyIsIm9uIiwiZW1pdHRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsIl9oYW5kbGVycyIsImNvbmNhdCIsImdldEhhbmRsZXJzIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50Iiwic2lnbmFsIiwiaGFuZGxlcnMiLCJzaWduYWxET01FdmVudCIsImNtIiwib3ZlcnJpZGUiLCJwcmV2ZW50RGVmYXVsdCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJlX2RlZmF1bHRQcmV2ZW50ZWQiLCJjb2RlbWlycm9ySWdub3JlIiwic2lnbmFsQ3Vyc29yQWN0aXZpdHkiLCJjdXJzb3JBY3Rpdml0eSIsImN1ck9wIiwiY3Vyc29yQWN0aXZpdHlIYW5kbGVycyIsImhhc0hhbmRsZXIiLCJldmVudE1peGluIiwiY3RvciIsImVfcHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsImVfc3RvcFByb3BhZ2F0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwiZV9zdG9wIiwiZV90YXJnZXQiLCJzcmNFbGVtZW50IiwiZV9idXR0b24iLCJ3aGljaCIsImJ1dHRvbiIsImN0cmxLZXkiLCJkcmFnQW5kRHJvcCIsImRpdiIsInp3c3BTdXBwb3J0ZWQiLCJ6ZXJvV2lkdGhFbGVtZW50IiwibWVhc3VyZSIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwiYmFkQmlkaVJlY3RzIiwiaGFzQmFkQmlkaVJlY3RzIiwidHh0IiwicjAiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyMSIsImxlZnQiLCJyaWdodCIsInNwbGl0TGluZXNBdXRvIiwicmVzdWx0IiwibCIsIm5sIiwicnQiLCJoYXNTZWxlY3Rpb24iLCJ3aW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJ0ZSIsIm93bmVyRG9jdW1lbnQiLCJzZWxlY3Rpb24iLCJwYXJlbnRFbGVtZW50IiwiY29tcGFyZUVuZFBvaW50cyIsImhhc0NvcHlFdmVudCIsIm9uY29weSIsImJhZFpvb21lZFJlY3RzIiwiaGFzQmFkWm9vbWVkUmVjdHMiLCJub3JtYWwiLCJmcm9tUmFuZ2UiLCJhYnMiLCJtb2RlcyIsIm1pbWVNb2RlcyIsImRlZmluZU1vZGUiLCJuYW1lIiwibW9kZSIsImRlcGVuZGVuY2llcyIsImRlZmluZU1JTUUiLCJtaW1lIiwic3BlYyIsInJlc29sdmVNb2RlIiwiZ2V0TW9kZSIsIm9wdGlvbnMiLCJtZmFjdG9yeSIsIm1vZGVPYmoiLCJtb2RlRXh0ZW5zaW9ucyIsImV4dHMiLCJoZWxwZXJUeXBlIiwibW9kZVByb3BzIiwicHJvcCQxIiwiZXh0ZW5kTW9kZSIsInByb3BlcnRpZXMiLCJjb3B5U3RhdGUiLCJzdGF0ZSIsIm5zdGF0ZSIsInZhbCIsImlubmVyTW9kZSIsImluZm8iLCJzdGFydFN0YXRlIiwiYTEiLCJhMiIsIlN0cmluZ1N0cmVhbSIsImxpbmVPcmFjbGUiLCJsYXN0Q29sdW1uUG9zIiwibGFzdENvbHVtblZhbHVlIiwibGluZVN0YXJ0IiwiZW9sIiwic29sIiwicGVlayIsInVuZGVmaW5lZCIsIm5leHQiLCJlYXQiLCJvayIsImVhdFdoaWxlIiwiZWF0U3BhY2UiLCJza2lwVG9FbmQiLCJza2lwVG8iLCJiYWNrVXAiLCJjb2x1bW4iLCJpbmRlbnRhdGlvbiIsInBhdHRlcm4iLCJjb25zdW1lIiwiY2FzZUluc2Vuc2l0aXZlIiwiY2FzZWQiLCJzdWJzdHIiLCJoaWRlRmlyc3RDaGFycyIsImlubmVyIiwibG9va0FoZWFkIiwib3JhY2xlIiwiYmFzZVRva2VuIiwiZ2V0TGluZSIsImRvYyIsImZpcnN0Iiwic2l6ZSIsIkVycm9yIiwiY2h1bmsiLCJsaW5lcyIsImNoaWxkcmVuIiwic3oiLCJjaHVua1NpemUiLCJnZXRCZXR3ZWVuIiwiaXRlciIsImdldExpbmVzIiwidXBkYXRlTGluZUhlaWdodCIsImhlaWdodCIsImRpZmYiLCJsaW5lTm8iLCJubyIsImxpbmVBdEhlaWdodCIsImgiLCJvdXRlciIsImxoIiwiaXNMaW5lIiwibGluZU51bWJlckZvciIsIlN0cmluZyIsImxpbmVOdW1iZXJGb3JtYXR0ZXIiLCJmaXJzdExpbmVOdW1iZXIiLCJQb3MiLCJjbXAiLCJlcXVhbEN1cnNvclBvcyIsImNvcHlQb3MiLCJ4IiwibWF4UG9zIiwibWluUG9zIiwiY2xpcExpbmUiLCJjbGlwUG9zIiwibGFzdCIsImNsaXBUb0xlbiIsImxpbmVsZW4iLCJjbGlwUG9zQXJyYXkiLCJTYXZlZENvbnRleHQiLCJDb250ZXh0IiwibWF4TG9va0FoZWFkIiwiYmFzZVRva2VucyIsImJhc2VUb2tlblBvcyIsIm5leHRMaW5lIiwiZnJvbVNhdmVkIiwic2F2ZWQiLCJzYXZlIiwiY29weSIsImhpZ2hsaWdodExpbmUiLCJjb250ZXh0IiwiZm9yY2VUb0VuZCIsInN0IiwibW9kZUdlbiIsImxpbmVDbGFzc2VzIiwicnVuTW9kZSIsImxvb3AiLCJvIiwib3ZlcmxheSIsIm92ZXJsYXlzIiwiaV9lbmQiLCJvcGFxdWUiLCJzdHlsZXMiLCJjbGFzc2VzIiwiYmdDbGFzcyIsInRleHRDbGFzcyIsImdldExpbmVTdHlsZXMiLCJ1cGRhdGVGcm9udGllciIsImdldENvbnRleHRCZWZvcmUiLCJyZXNldFN0YXRlIiwibWF4SGlnaGxpZ2h0TGVuZ3RoIiwic3RhdGVBZnRlciIsInN0eWxlQ2xhc3NlcyIsImhpZ2hsaWdodEZyb250aWVyIiwibW9kZUZyb250aWVyIiwicHJlY2lzZSIsImRpc3BsYXkiLCJmaW5kU3RhcnRMaW5lIiwicHJvY2Vzc0xpbmUiLCJ2aWV3RnJvbSIsInZpZXdUbyIsInN0YXJ0QXQiLCJzdHJlYW0iLCJjYWxsQmxhbmtMaW5lIiwicmVhZFRva2VuIiwiYmxhbmtMaW5lIiwidG9rZW4iLCJUb2tlbiIsInRha2VUb2tlbiIsImFzQXJyYXkiLCJ0b2tlbnMiLCJleHRyYWN0TGluZUNsYXNzZXMiLCJvdXRwdXQiLCJsaW5lQ2xhc3MiLCJmbGF0dGVuU3BhbnMiLCJjdXJTdGFydCIsImN1clN0eWxlIiwiYWRkTW9kZUNsYXNzIiwibU5hbWUiLCJtaW5pbmRlbnQiLCJtaW5saW5lIiwibGltIiwiaW5kZW50ZWQiLCJyZXRyZWF0RnJvbnRpZXIiLCJzYXdSZWFkT25seVNwYW5zIiwic2F3Q29sbGFwc2VkU3BhbnMiLCJzZWVSZWFkT25seVNwYW5zIiwic2VlQ29sbGFwc2VkU3BhbnMiLCJNYXJrZWRTcGFuIiwibWFya2VyIiwiZ2V0TWFya2VkU3BhbkZvciIsInNwYW5zIiwic3BhbiIsInJlbW92ZU1hcmtlZFNwYW4iLCJhZGRNYXJrZWRTcGFuIiwib3AiLCJpblRoaXNPcCIsIldlYWtTZXQiLCJtYXJrZWRTcGFucyIsImhhcyIsImFkZCIsImF0dGFjaExpbmUiLCJtYXJrZWRTcGFuc0JlZm9yZSIsIm9sZCIsInN0YXJ0Q2giLCJpc0luc2VydCIsIm53Iiwic3RhcnRzQmVmb3JlIiwiaW5jbHVzaXZlTGVmdCIsImluc2VydExlZnQiLCJlbmRzQWZ0ZXIiLCJpbmNsdXNpdmVSaWdodCIsIm1hcmtlZFNwYW5zQWZ0ZXIiLCJlbmRDaCIsInN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UiLCJjaGFuZ2UiLCJmdWxsIiwib2xkRmlyc3QiLCJvbGRMYXN0Iiwic2FtZUxpbmUiLCJvZmZzZXQiLCJzcGFuJDEiLCJmb3VuZCQxIiwiY2xlYXJFbXB0eVNwYW5zIiwibmV3TWFya2VycyIsImdhcCIsImdhcE1hcmtlcnMiLCJjbGVhcldoZW5FbXB0eSIsInJlbW92ZVJlYWRPbmx5UmFuZ2VzIiwibWFya2VycyIsIm1hcmsiLCJyZWFkT25seSIsInBhcnRzIiwibWsiLCJmaW5kIiwicCIsIm5ld1BhcnRzIiwiZGZyb20iLCJkdG8iLCJkZXRhY2hNYXJrZWRTcGFucyIsImRldGFjaExpbmUiLCJhdHRhY2hNYXJrZWRTcGFucyIsImV4dHJhTGVmdCIsImV4dHJhUmlnaHQiLCJjb21wYXJlQ29sbGFwc2VkTWFya2VycyIsImxlbkRpZmYiLCJhUG9zIiwiYlBvcyIsImZyb21DbXAiLCJ0b0NtcCIsImNvbGxhcHNlZFNwYW5BdFNpZGUiLCJzcHMiLCJzcCIsImNvbGxhcHNlZCIsImNvbGxhcHNlZFNwYW5BdFN0YXJ0IiwiY29sbGFwc2VkU3BhbkF0RW5kIiwiY29sbGFwc2VkU3BhbkFyb3VuZCIsImNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UiLCJ2aXN1YWxMaW5lIiwibWVyZ2VkIiwidmlzdWFsTGluZUVuZCIsInZpc3VhbExpbmVDb250aW51ZWQiLCJ2aXN1YWxMaW5lTm8iLCJsaW5lTiIsInZpcyIsInZpc3VhbExpbmVFbmRObyIsImxhc3RMaW5lIiwibGluZUlzSGlkZGVuIiwid2lkZ2V0Tm9kZSIsImxpbmVJc0hpZGRlbklubmVyIiwiaGVpZ2h0QXRMaW5lIiwibGluZU9iaiIsImxpbmVMZW5ndGgiLCJmaW5kTWF4TGluZSIsImQiLCJtYXhMaW5lIiwibWF4TGluZUxlbmd0aCIsIm1heExpbmVDaGFuZ2VkIiwiTGluZSIsImVzdGltYXRlSGVpZ2h0IiwidXBkYXRlTGluZSIsImVzdEhlaWdodCIsImNsZWFuVXBMaW5lIiwic3R5bGVUb0NsYXNzQ2FjaGUiLCJzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIiwiaW50ZXJwcmV0VG9rZW5TdHlsZSIsImNhY2hlIiwiYnVpbGRMaW5lQ29udGVudCIsImxpbmVWaWV3IiwiYnVpbGRlciIsInByZSIsInRyYWlsaW5nU3BhY2UiLCJzcGxpdFNwYWNlcyIsImdldE9wdGlvbiIsInJlc3QiLCJhZGRUb2tlbiIsImJ1aWxkVG9rZW4iLCJidWlsZFRva2VuQmFkQmlkaSIsImFsbG93RnJvbnRpZXJVcGRhdGUiLCJleHRlcm5hbE1lYXN1cmVkIiwiaW5zZXJ0TGluZUNvbnRlbnQiLCJtYXBzIiwiY2FjaGVzIiwibGFzdENoaWxkIiwicXVlcnlTZWxlY3RvciIsImRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyIiwidGl0bGUiLCJzdGFydFN0eWxlIiwiZW5kU3R5bGUiLCJjc3MiLCJhdHRyaWJ1dGVzIiwiZGlzcGxheVRleHQiLCJzcGVjaWFsIiwic3BlY2lhbENoYXJzIiwibXVzdFdyYXAiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwibGFzdEluZGV4IiwidHh0JDEiLCJ0YWJXaWR0aCIsInNwZWNpYWxDaGFyUGxhY2Vob2xkZXIiLCJmdWxsU3R5bGUiLCJhdHRyIiwidHJhaWxpbmdCZWZvcmUiLCJzcGFjZUJlZm9yZSIsImJ1aWxkQ29sbGFwc2VkU3BhbiIsImlnbm9yZVdpZGdldCIsIndpZGdldCIsImlucHV0IiwibmVlZHNDb250ZW50QXR0cmlidXRlIiwic2V0VW5lZGl0YWJsZSIsImFsbFRleHQiLCJuZXh0Q2hhbmdlIiwic3BhblN0eWxlIiwic3BhbkVuZFN0eWxlIiwic3BhblN0YXJ0U3R5bGUiLCJJbmZpbml0eSIsImZvdW5kQm9va21hcmtzIiwiZW5kU3R5bGVzIiwidXB0byIsInRva2VuVGV4dCIsIkxpbmVWaWV3IiwiaGlkZGVuIiwiYnVpbGRWaWV3QXJyYXkiLCJuZXh0UG9zIiwidmlldyIsIm9wZXJhdGlvbkdyb3VwIiwicHVzaE9wZXJhdGlvbiIsIm9wcyIsIm93bnNHcm91cCIsImRlbGF5ZWRDYWxsYmFja3MiLCJmaXJlQ2FsbGJhY2tzRm9yT3BzIiwiZ3JvdXAiLCJjYWxsYmFja3MiLCJjdXJzb3JBY3Rpdml0eUNhbGxlZCIsImZpbmlzaE9wZXJhdGlvbiIsImVuZENiIiwib3JwaGFuRGVsYXllZENhbGxiYWNrcyIsInNpZ25hbExhdGVyIiwibGlzdCIsImZpcmVPcnBoYW5EZWxheWVkIiwiZGVsYXllZCIsInVwZGF0ZUxpbmVGb3JDaGFuZ2VzIiwiZGltcyIsImNoYW5nZXMiLCJ1cGRhdGVMaW5lVGV4dCIsInVwZGF0ZUxpbmVHdXR0ZXIiLCJ1cGRhdGVMaW5lQ2xhc3NlcyIsInVwZGF0ZUxpbmVXaWRnZXRzIiwiZW5zdXJlTGluZVdyYXBwZWQiLCJyZXBsYWNlQ2hpbGQiLCJ6SW5kZXgiLCJ1cGRhdGVMaW5lQmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ3cmFwIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0TGluZUNvbnRlbnQiLCJleHQiLCJidWlsdCIsIndyYXBDbGFzcyIsImd1dHRlciIsImd1dHRlckJhY2tncm91bmQiLCJndXR0ZXJDbGFzcyIsImZpeGVkR3V0dGVyIiwiZml4ZWRQb3MiLCJndXR0ZXJUb3RhbFdpZHRoIiwiZ3V0dGVyTWFya2VycyIsImxpbmVOdW1iZXJzIiwid3JhcCQxIiwiZ3V0dGVyV3JhcCIsImxpbmVOdW1iZXIiLCJndXR0ZXJMZWZ0IiwibGluZU51bUlubmVyV2lkdGgiLCJrIiwiZ3V0dGVyU3BlY3MiLCJndXR0ZXJXaWR0aCIsImFsaWduYWJsZSIsImlzV2lkZ2V0IiwibmV4dFNpYmxpbmciLCJpbnNlcnRMaW5lV2lkZ2V0cyIsImJ1aWxkTGluZUVsZW1lbnQiLCJpbnNlcnRMaW5lV2lkZ2V0c0ZvciIsImFsbG93QWJvdmUiLCJ3aWRnZXRzIiwid3MiLCJoYW5kbGVNb3VzZUV2ZW50cyIsInBvc2l0aW9uTGluZVdpZGdldCIsImFib3ZlIiwibm9IU2Nyb2xsIiwid2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjb3Zlckd1dHRlciIsInBhZGRpbmdMZWZ0IiwicG9zaXRpb24iLCJtYXJnaW5MZWZ0Iiwid2lkZ2V0SGVpZ2h0IiwicGFyZW50U3R5bGUiLCJndXR0ZXJzIiwid3JhcHBlciIsImNsaWVudFdpZHRoIiwiZXZlbnRJbldpZGdldCIsImdldEF0dHJpYnV0ZSIsInNpemVyIiwibW92ZXIiLCJwYWRkaW5nVG9wIiwibGluZVNwYWNlIiwib2Zmc2V0VG9wIiwicGFkZGluZ1ZlcnQiLCJwYWRkaW5nSCIsImNhY2hlZFBhZGRpbmdIIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsImRhdGEiLCJwYXJzZUludCIsInBhZGRpbmdSaWdodCIsImlzTmFOIiwic2Nyb2xsR2FwIiwibmF0aXZlQmFyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJzY3JvbGxlciIsImJhcldpZHRoIiwiZGlzcGxheUhlaWdodCIsImNsaWVudEhlaWdodCIsImJhckhlaWdodCIsImVuc3VyZUxpbmVIZWlnaHRzIiwicmVjdCIsIndyYXBwaW5nIiwibGluZVdyYXBwaW5nIiwiY3VyV2lkdGgiLCJoZWlnaHRzIiwicmVjdHMiLCJnZXRDbGllbnRSZWN0cyIsImJvdHRvbSIsInRvcCIsIm1hcEZyb21MaW5lVmlldyIsInVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQiLCJsaW5lTWVhc3VyZSIsIm1lYXN1cmVDaGFyIiwiYmlhcyIsIm1lYXN1cmVDaGFyUHJlcGFyZWQiLCJwcmVwYXJlTWVhc3VyZUZvckxpbmUiLCJmaW5kVmlld0ZvckxpbmUiLCJmaW5kVmlld0luZGV4IiwiZ2V0RGltZW5zaW9ucyIsImZvcmNlVXBkYXRlIiwiaGFzSGVpZ2h0cyIsInByZXBhcmVkIiwidmFySGVpZ2h0Iiwia2V5IiwibWVhc3VyZUNoYXJJbm5lciIsImJvZ3VzIiwicnRvcCIsInJib3R0b20iLCJudWxsUmVjdCIsIm5vZGVBbmRPZmZzZXRJbkxpbmVNYXAiLCJtU3RhcnQiLCJtRW5kIiwiY292ZXJTdGFydCIsImNvdmVyRW5kIiwiZ2V0VXNlZnVsUmVjdCIsInBsYWNlIiwibWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyIsInJTcGFuIiwiY2hhcldpZHRoIiwicmJvdCIsImJvdCIsInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUiLCJzY3JlZW4iLCJsb2dpY2FsWERQSSIsImRldmljZVhEUEkiLCJzY2FsZVgiLCJzY2FsZVkiLCJsb2dpY2FsWURQSSIsImRldmljZVlEUEkiLCJjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yIiwiY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSIsImV4dGVybmFsTWVhc3VyZSIsImNsZWFyQ2FjaGVzIiwiY2FjaGVkQ2hhcldpZHRoIiwiY2FjaGVkVGV4dEhlaWdodCIsImxpbmVOdW1DaGFycyIsInBhZ2VTY3JvbGxYIiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxMZWZ0IiwicGFnZVNjcm9sbFkiLCJtYXJnaW5Ub3AiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIndpZGdldFRvcEhlaWdodCIsInJlZiIsImludG9Db29yZFN5c3RlbSIsImluY2x1ZGVXaWRnZXRzIiwieU9mZiIsInZpZXdPZmZzZXQiLCJsT2ZmIiwieE9mZiIsImZyb21Db29yZFN5c3RlbSIsImNvb3JkcyIsImxvY2FsQm94IiwibGluZVNwYWNlQm94IiwiY2hhckNvb3JkcyIsImN1cnNvckNvb3JkcyIsInByZXBhcmVkTWVhc3VyZSIsImdldCIsImdldEJpZGkiLCJwYXJ0UG9zIiwiaW52ZXJ0Iiwib3RoZXIiLCJlc3RpbWF0ZUNvb3JkcyIsIlBvc1dpdGhJbmZvIiwib3V0c2lkZSIsInhSZWwiLCJjb29yZHNDaGFyIiwieSIsImNvb3Jkc0NoYXJJbm5lciIsInJhbmdlRW5kIiwid3JhcHBlZExpbmVFeHRlbnQiLCJiZWdpbiIsIndyYXBwZWRMaW5lRXh0ZW50Q2hhciIsInRhcmdldFRvcCIsImJveElzQWZ0ZXIiLCJib3giLCJsdHIiLCJjb29yZHNCaWRpUGFydFdyYXBwZWQiLCJjb29yZHNCaWRpUGFydCIsImNoQXJvdW5kIiwiYm94QXJvdW5kIiwiYmFzZVgiLCJhdExlZnQiLCJhdFN0YXJ0IiwiX2xpbmVObyIsImNsb3Nlc3REaXN0IiwiZW5kWCIsImRpc3QiLCJtZWFzdXJlVGV4dCIsInRleHRIZWlnaHQiLCJhbmNob3IiLCJjbGllbnRMZWZ0Iiwib2Zmc2V0TGVmdCIsImNvbXBlbnNhdGVGb3JIU2Nyb2xsIiwidGgiLCJwZXJMaW5lIiwid2lkZ2V0c0hlaWdodCIsImVzdGltYXRlTGluZUhlaWdodHMiLCJlc3QiLCJwb3NGcm9tTW91c2UiLCJsaWJlcmFsIiwiZm9yUmVjdCIsInNwYWNlIiwiY2xpZW50WCIsImNsaWVudFkiLCJlJDEiLCJjb2xEaWZmIiwicm91bmQiLCJyZWdDaGFuZ2UiLCJsZW5kaWZmIiwidXBkYXRlTGluZU51bWJlcnMiLCJ2aWV3Q2hhbmdlZCIsInJlc2V0VmlldyIsImN1dCIsInZpZXdDdXR0aW5nUG9pbnQiLCJjdXQkMSIsImN1dFRvcCIsImN1dEJvdCIsInJlZ0xpbmVDaGFuZ2UiLCJvbGROIiwibmV3TiIsImFkanVzdFZpZXciLCJjb3VudERpcnR5VmlldyIsImRpcnR5IiwidXBkYXRlU2VsZWN0aW9uIiwic2hvd1NlbGVjdGlvbiIsInByZXBhcmVTZWxlY3Rpb24iLCJwcmltYXJ5IiwiY3VyRnJhZ21lbnQiLCJjdXJzb3JzIiwic2VsRnJhZ21lbnQiLCJjdXN0b21DdXJzb3IiLCIkY3VzdG9tQ3Vyc29yIiwic2VsIiwicmFuZ2VzIiwicHJpbUluZGV4IiwiZW1wdHkiLCJoZWFkIiwiZHJhd1NlbGVjdGlvbkN1cnNvciIsInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nIiwiZHJhd1NlbGVjdGlvblJhbmdlIiwiY3Vyc29yIiwiY3Vyc29ySGVpZ2h0IiwiZ2V0V3JhcHBlckVsZW1lbnQiLCJjaGFyUG9zIiwiZGVmYXVsdENoYXJXaWR0aCIsIm90aGVyQ3Vyc29yIiwiY21wQ29vcmRzIiwiZnJhZ21lbnQiLCJwYWRkaW5nIiwibGVmdFNpZGUiLCJyaWdodFNpZGUiLCJzaXplcldpZHRoIiwiZG9jTFRSIiwiZHJhd0ZvckxpbmUiLCJmcm9tQXJnIiwidG9BcmciLCJsaW5lTGVuIiwid3JhcFgiLCJzaWRlIiwiZXh0ZW50IiwiZnJvbVBvcyIsInRvUG9zIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm9wZW5MZWZ0Iiwib3BlblJpZ2h0IiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90TGVmdCIsImJvdFJpZ2h0Iiwic0Zyb20iLCJzVG8iLCJmcm9tTGluZSIsInRvTGluZSIsInNpbmdsZVZMaW5lIiwibGVmdEVuZCIsInJpZ2h0U3RhcnQiLCJyZXN0YXJ0QmxpbmsiLCJmb2N1c2VkIiwiY2xlYXJJbnRlcnZhbCIsImJsaW5rZXIiLCJjdXJzb3JEaXYiLCJ2aXNpYmlsaXR5IiwiY3Vyc29yQmxpbmtSYXRlIiwic2V0SW50ZXJ2YWwiLCJoYXNGb2N1cyIsIm9uQmx1ciIsImVuc3VyZUZvY3VzIiwiZm9jdXMiLCJvbkZvY3VzIiwiZGVsYXlCbHVyRXZlbnQiLCJkZWxheWluZ0JsdXJFdmVudCIsImRyYWdnaW5nVGV4dCIsInNlbEZvckNvbnRleHRNZW51IiwicmVzZXQiLCJyZWNlaXZlZEZvY3VzIiwic2hpZnQiLCJ1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydCIsInByZXZCb3R0b20iLCJsaW5lRGl2Iiwidmlld1RvcCIsIm9sZEhlaWdodCIsIm11c3RTY3JvbGwiLCJ1cGRhdGVXaWRnZXRIZWlnaHQiLCJjaFdpZHRoIiwidyIsInZpc2libGVMaW5lcyIsInZpZXdwb3J0IiwiZW5zdXJlIiwiZW5zdXJlRnJvbSIsImVuc3VyZVRvIiwibWF5YmVTY3JvbGxXaW5kb3ciLCJkb1Njcm9sbCIsImlubmVySGVpZ2h0Iiwic2Nyb2xsTm9kZSIsInNjcm9sbEludG9WaWV3Iiwic2Nyb2xsUG9zSW50b1ZpZXciLCJtYXJnaW4iLCJsaW1pdCIsImNoYW5nZWQiLCJlbmRDb29yZHMiLCJzY3JvbGxQb3MiLCJjYWxjdWxhdGVTY3JvbGxQb3MiLCJzdGFydFRvcCIsInN0YXJ0TGVmdCIsInVwZGF0ZVNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzbmFwTWFyZ2luIiwic2NyZWVudG9wIiwiZG9jQm90dG9tIiwiYXRUb3AiLCJhdEJvdHRvbSIsIm5ld1RvcCIsImd1dHRlclNwYWNlIiwic2NyZWVubGVmdCIsInNjcmVlbnciLCJ0b29XaWRlIiwiYWRkVG9TY3JvbGxUb3AiLCJyZXNvbHZlU2Nyb2xsVG9Qb3MiLCJlbnN1cmVDdXJzb3JWaXNpYmxlIiwiZ2V0Q3Vyc29yIiwic2Nyb2xsVG9Qb3MiLCJjdXJzb3JTY3JvbGxNYXJnaW4iLCJzY3JvbGxUb0Nvb3JkcyIsInNjcm9sbFRvUmFuZ2UiLCJzY3JvbGxUb0Nvb3Jkc1JhbmdlIiwic1BvcyIsInVwZGF0ZURpc3BsYXlTaW1wbGUiLCJzZXRTY3JvbGxUb3AiLCJzdGFydFdvcmtlciIsImZvcmNlU2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsYmFycyIsImlzU2Nyb2xsZXIiLCJzY3JvbGxXaWR0aCIsImFsaWduSG9yaXpvbnRhbGx5IiwibWVhc3VyZUZvclNjcm9sbGJhcnMiLCJndXR0ZXJXIiwiZG9jSCIsInZpZXdIZWlnaHQiLCJ2aWV3V2lkdGgiLCJiYXJMZWZ0IiwiZG9jSGVpZ2h0IiwiTmF0aXZlU2Nyb2xsYmFycyIsInZlcnQiLCJob3JpeiIsInRhYkluZGV4IiwiY2hlY2tlZFplcm9XaWR0aCIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwidXBkYXRlIiwibmVlZHNIIiwibmVlZHNWIiwic1dpZHRoIiwidG90YWxIZWlnaHQiLCJ0b3RhbFdpZHRoIiwiemVyb1dpZHRoSGFjayIsImRpc2FibGVIb3JpeiIsImVuYWJsZVplcm9XaWR0aEJhciIsImRpc2FibGVWZXJ0IiwicG9pbnRlckV2ZW50cyIsImJhciIsImRlbGF5IiwibWF5YmVEaXNhYmxlIiwiZWxlbWVudEZyb21Qb2ludCIsImNsZWFyIiwiTnVsbFNjcm9sbGJhcnMiLCJ1cGRhdGVTY3JvbGxiYXJzIiwic3RhcnRXaWR0aCIsInN0YXJ0SGVpZ2h0IiwidXBkYXRlU2Nyb2xsYmFyc0lubmVyIiwic2l6ZXMiLCJwYWRkaW5nQm90dG9tIiwiaGVpZ2h0Rm9yY2VyIiwiYm9yZGVyQm90dG9tIiwic2Nyb2xsYmFyRmlsbGVyIiwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIiLCJndXR0ZXJGaWxsZXIiLCJzY3JvbGxiYXJNb2RlbCIsImluaXRTY3JvbGxiYXJzIiwic2Nyb2xsYmFyU3R5bGUiLCJheGlzIiwibmV4dE9wSWQiLCJzdGFydE9wZXJhdGlvbiIsInVwZGF0ZUlucHV0IiwidHlwaW5nIiwiY2hhbmdlT2JqcyIsInNlbGVjdGlvbkNoYW5nZWQiLCJ1cGRhdGVNYXhMaW5lIiwibWFya0FycmF5cyIsImVuZE9wZXJhdGlvbiIsImVuZE9wZXJhdGlvbnMiLCJlbmRPcGVyYXRpb25fUjEiLCJlbmRPcGVyYXRpb25fVzEiLCJlbmRPcGVyYXRpb25fUjIiLCJlbmRPcGVyYXRpb25fVzIiLCJlbmRPcGVyYXRpb25fZmluaXNoIiwibWF5YmVDbGlwU2Nyb2xsYmFycyIsIm11c3RVcGRhdGUiLCJEaXNwbGF5VXBkYXRlIiwidXBkYXRlZERpc3BsYXkiLCJ1cGRhdGVEaXNwbGF5SWZOZWVkZWQiLCJiYXJNZWFzdXJlIiwiYWRqdXN0V2lkdGhUbyIsIm1heFNjcm9sbExlZnQiLCJwcmVwYXJlZFNlbGVjdGlvbiIsInRha2VGb2N1cyIsInNldERvY3VtZW50SGVpZ2h0IiwicG9zdFVwZGF0ZURpc3BsYXkiLCJ3aGVlbFN0YXJ0WCIsIndoZWVsU3RhcnRZIiwibWF5YmVIaWRkZW5NYXJrZXJzIiwidW5oaWRkZW4iLCJtYXliZVVuaGlkZGVuTWFya2VycyIsImZpbmlzaCIsInJ1bkluT3AiLCJvcGVyYXRpb24iLCJtZXRob2RPcCIsImRvY01ldGhvZE9wIiwiaGlnaGxpZ2h0IiwiaGlnaGxpZ2h0V29ya2VyIiwid29ya1RpbWUiLCJjaGFuZ2VkTGluZXMiLCJvbGRTdHlsZXMiLCJoaWdobGlnaHRlZCIsIm9sZENscyIsIm5ld0NscyIsImlzY2hhbmdlIiwid29ya0RlbGF5IiwiZm9yY2UiLCJ2aXNpYmxlIiwiZWRpdG9ySXNIaWRkZW4iLCJ3cmFwcGVySGVpZ2h0Iiwib2xkRGlzcGxheVdpZHRoIiwiZXZlbnRzIiwic2Nyb2xsYmFyc0NsaXBwZWQiLCJtYXJnaW5Cb3R0b20iLCJib3JkZXJSaWdodFdpZHRoIiwic2VsZWN0aW9uU25hcHNob3QiLCJhY3RpdmUiLCJhbmNob3JOb2RlIiwiZXh0ZW5kIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJyZXN0b3JlU2VsZWN0aW9uIiwic25hcHNob3QiLCJub2RlTmFtZSIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwicmVuZGVyZWRWaWV3IiwibWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgiLCJ2aWV3cG9ydE1hcmdpbiIsImRpZmZlcmVudCIsImxhc3RXcmFwSGVpZ2h0IiwibGFzdFdyYXBXaWR0aCIsInRvVXBkYXRlIiwic2VsU25hcHNob3QiLCJwYXRjaERpc3BsYXkiLCJzZWxlY3Rpb25EaXYiLCJyZXBvcnRlZFZpZXdGcm9tIiwicmVwb3J0ZWRWaWV3VG8iLCJ1cGRhdGVOdW1iZXJzRnJvbSIsImNvbnRhaW5lciIsInJtIiwiY3VycmVudFdoZWVsVGFyZ2V0IiwidXBkYXRlTnVtYmVyIiwidXBkYXRlR3V0dGVyU3BhY2UiLCJhbGlnbldpZGdldHMiLCJjb21wIiwiYWxpZ24iLCJpbm5lclciLCJsaW5lR3V0dGVyIiwibGluZU51bVdpZHRoIiwiZ2V0R3V0dGVycyIsInNhd0xpbmVOdW1iZXJzIiwicmVuZGVyR3V0dGVycyIsInNwZWNzIiwiZ0VsdCIsInVwZGF0ZUd1dHRlcnMiLCJEaXNwbGF5IiwiZHJhZ2dhYmxlIiwid2hlZWxEWCIsIndoZWVsRFkiLCJhY3RpdmVUb3VjaCIsImluaXQiLCJ3aGVlbFNhbXBsZXMiLCJ3aGVlbFBpeGVsc1BlclVuaXQiLCJ3aGVlbEV2ZW50RGVsdGEiLCJkeCIsIndoZWVsRGVsdGFYIiwiZHkiLCJ3aGVlbERlbHRhWSIsImRldGFpbCIsIkhPUklaT05UQUxfQVhJUyIsIlZFUlRJQ0FMX0FYSVMiLCJ3aGVlbERlbHRhIiwid2hlZWxFdmVudFBpeGVscyIsImRlbHRhIiwib25TY3JvbGxXaGVlbCIsInBpeGVsc1BlclVuaXQiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVkiLCJjYW5TY3JvbGxYIiwiY2FuU2Nyb2xsWSIsInBpeGVscyIsIm1vdmVkWCIsIm1vdmVkWSIsInNhbXBsZSIsIlNlbGVjdGlvbiIsImVxdWFscyIsImhlcmUiLCJ0aGVyZSIsImRlZXBDb3B5IiwiUmFuZ2UiLCJzb21ldGhpbmdTZWxlY3RlZCIsIm5vcm1hbGl6ZVNlbGVjdGlvbiIsIm1heVRvdWNoIiwic2VsZWN0aW9uc01heVRvdWNoIiwicHJpbSIsInNvcnQiLCJpbnYiLCJzaW1wbGVTZWxlY3Rpb24iLCJjaGFuZ2VFbmQiLCJhZGp1c3RGb3JDaGFuZ2UiLCJjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UiLCJvZmZzZXRQb3MiLCJjb21wdXRlUmVwbGFjZWRTZWwiLCJoaW50Iiwib2xkUHJldiIsIm5ld1ByZXYiLCJsb2FkTW9kZSIsIm1vZGVPcHRpb24iLCJyZXNldE1vZGVTdGF0ZSIsImlzV2hvbGVMaW5lVXBkYXRlIiwid2hvbGVMaW5lVXBkYXRlQmVmb3JlIiwidXBkYXRlRG9jIiwic3BhbnNGb3IiLCJsaW5lc0ZvciIsImZpcnN0TGluZSIsImxhc3RUZXh0IiwibGFzdFNwYW5zIiwibmxpbmVzIiwiaW5zZXJ0IiwicmVtb3ZlIiwiYWRkZWQiLCJhZGRlZCQxIiwiYWRkZWQkMiIsImxpbmtlZERvY3MiLCJzaGFyZWRIaXN0T25seSIsInByb3BhZ2F0ZSIsInNraXAiLCJzaGFyZWRIaXN0IiwibGlua2VkIiwicmVsIiwic2hhcmVkIiwiYXR0YWNoRG9jIiwic2V0RGlyZWN0aW9uQ2xhc3MiLCJkaXJlY3Rpb25DaGFuZ2VkIiwiSGlzdG9yeSIsImRvbmUiLCJ1bmRvbmUiLCJ1bmRvRGVwdGgiLCJsYXN0TW9kVGltZSIsImxhc3RTZWxUaW1lIiwibGFzdE9wIiwibGFzdFNlbE9wIiwibGFzdE9yaWdpbiIsImxhc3RTZWxPcmlnaW4iLCJnZW5lcmF0aW9uIiwibWF4R2VuZXJhdGlvbiIsImhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlIiwiaGlzdENoYW5nZSIsImF0dGFjaExvY2FsU3BhbnMiLCJjbGVhclNlbGVjdGlvbkV2ZW50cyIsInBvcCIsImxhc3RDaGFuZ2VFdmVudCIsImhpc3QiLCJhZGRDaGFuZ2VUb0hpc3RvcnkiLCJzZWxBZnRlciIsIm9wSWQiLCJoaXN0b3J5IiwiaGlzdG9yeUV2ZW50RGVsYXkiLCJwdXNoU2VsZWN0aW9uVG9IaXN0b3J5Iiwic2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZCIsImFkZFNlbGVjdGlvblRvSGlzdG9yeSIsImNsZWFyUmVkbyIsImRlc3QiLCJleGlzdGluZyIsInJlbW92ZUNsZWFyZWRTcGFucyIsImV4cGxpY2l0bHlDbGVhcmVkIiwiZ2V0T2xkU3BhbnMiLCJtZXJnZU9sZFNwYW5zIiwic3RyZXRjaGVkIiwib2xkQ3VyIiwic3RyZXRjaEN1ciIsImNvcHlIaXN0b3J5QXJyYXkiLCJuZXdHcm91cCIsImluc3RhbnRpYXRlU2VsIiwiZXZlbnQiLCJuZXdDaGFuZ2VzIiwiZXh0ZW5kUmFuZ2UiLCJwb3NCZWZvcmUiLCJleHRlbmRTZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJleHRlbmRTZWxlY3Rpb25zIiwiaGVhZHMiLCJuZXdTZWwiLCJyZXBsYWNlT25lU2VsZWN0aW9uIiwic2V0U2ltcGxlU2VsZWN0aW9uIiwiZmlsdGVyU2VsZWN0aW9uQ2hhbmdlIiwic2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkiLCJzZXRTZWxlY3Rpb25Ob1VuZG8iLCJOYU4iLCJzZXRTZWxlY3Rpb25Jbm5lciIsInNraXBBdG9taWNJblNlbGVjdGlvbiIsInJlQ2hlY2tTZWxlY3Rpb24iLCJtYXlDbGVhciIsIm5ld0FuY2hvciIsInNraXBBdG9taWMiLCJuZXdIZWFkIiwic2tpcEF0b21pY0lubmVyIiwib2xkUG9zIiwicHJldmVudEN1cnNvckxlZnQiLCJzZWxlY3RMZWZ0IiwicHJldmVudEN1cnNvclJpZ2h0Iiwic2VsZWN0UmlnaHQiLCJhdG9taWMiLCJuZWFyIiwibW92ZVBvcyIsImZhciIsImNhbnRFZGl0Iiwic2VsZWN0QWxsIiwiZmlsdGVyQ2hhbmdlIiwiY2FuY2VsZWQiLCJjYW5jZWwiLCJtYWtlQ2hhbmdlIiwiaWdub3JlUmVhZE9ubHkiLCJzdXBwcmVzc0VkaXRzIiwibWFrZUNoYW5nZUlubmVyIiwibWFrZUNoYW5nZVNpbmdsZURvYyIsInJlYmFzZWQiLCJyZWJhc2VIaXN0IiwibWFrZUNoYW5nZUZyb21IaXN0b3J5IiwiYWxsb3dTZWxlY3Rpb25Pbmx5Iiwic3VwcHJlc3MiLCJhbnRpQ2hhbmdlcyIsImZpbHRlciIsInJldHVybmVkIiwidiIsInNoaWZ0RG9jIiwiZGlzdGFuY2UiLCJyZW1vdmVkIiwibWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yIiwicmVjb21wdXRlTWF4TGVuZ3RoIiwiY2hlY2tXaWR0aFN0YXJ0IiwiY2hhbmdlc0hhbmRsZXIiLCJjaGFuZ2VIYW5kbGVyIiwicmVwbGFjZVJhbmdlIiwiYXNzaWduIiwic3BsaXRMaW5lcyIsInJlYmFzZUhpc3RTZWxTaW5nbGUiLCJyZWJhc2VIaXN0QXJyYXkiLCJzdWIiLCJjb3BpZWQiLCJjaGFuZ2VMaW5lIiwiaGFuZGxlIiwiY2hhbmdlVHlwZSIsIkxlYWZDaHVuayIsInJlbW92ZUlubmVyIiwiaW5zZXJ0SW5uZXIiLCJpdGVyTiIsIkJyYW5jaENodW5rIiwicmVtYWluaW5nIiwibGVhZiIsIm1heWJlU3BpbGwiLCJtZSIsInNwaWxsZWQiLCJzaWJsaW5nIiwibXlJbmRleCIsInVzZWQiLCJMaW5lV2lkZ2V0Iiwib3B0IiwiYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZSIsInRoaXMkMSIsIm9sZEgiLCJhZGRMaW5lV2lkZ2V0IiwiaW5zZXJ0QXQiLCJhYm92ZVZpc2libGUiLCJuZXh0TWFya2VySWQiLCJUZXh0TWFya2VyIiwid2l0aE9wIiwidmlzdWFsIiwiZEhlaWdodCIsIm1hcmtUZXh0IiwibWFya1RleHRTaGFyZWQiLCJyZXBsYWNlZFdpdGgiLCJhZGRUb0hpc3RvcnkiLCJjdXJMaW5lIiwiY2xlYXJPbkVudGVyIiwiY2xlYXJIaXN0b3J5IiwiU2hhcmVkVGV4dE1hcmtlciIsImNsb25lTm9kZSIsImlzUGFyZW50IiwiZmluZFNoYXJlZE1hcmtlcnMiLCJmaW5kTWFya3MiLCJjb3B5U2hhcmVkTWFya2VycyIsIm1Gcm9tIiwibVRvIiwic3ViTWFyayIsImRldGFjaFNoYXJlZE1hcmtlcnMiLCJzdWJNYXJrZXIiLCJuZXh0RG9jSWQiLCJEb2MiLCJsaW5lU2VwIiwiY2xlYW5HZW5lcmF0aW9uIiwiY29uc3RydWN0b3IiLCJnZXRWYWx1ZSIsImpvaW4iLCJsaW5lU2VwYXJhdG9yIiwic2V0VmFsdWUiLCJnZXRSYW5nZSIsImdldExpbmVIYW5kbGUiLCJnZXRMaW5lTnVtYmVyIiwiZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0IiwibGluZUNvdW50IiwibGlzdFNlbGVjdGlvbnMiLCJzZXRDdXJzb3IiLCJleHRlbmRTZWxlY3Rpb25zQnkiLCJzZXRTZWxlY3Rpb25zIiwiYWRkU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9ucyIsInJlcGxhY2VTZWxlY3Rpb24iLCJkdXAiLCJyZXBsYWNlU2VsZWN0aW9ucyIsInVuZG8iLCJyZWRvIiwidW5kb1NlbGVjdGlvbiIsInJlZG9TZWxlY3Rpb24iLCJzZXRFeHRlbmRpbmciLCJnZXRFeHRlbmRpbmciLCJoaXN0b3J5U2l6ZSIsIm1hcmtDbGVhbiIsImNoYW5nZUdlbmVyYXRpb24iLCJmb3JjZVNwbGl0IiwiaXNDbGVhbiIsImdlbiIsImdldEhpc3RvcnkiLCJzZXRIaXN0b3J5IiwiaGlzdERhdGEiLCJzZXRHdXR0ZXJNYXJrZXIiLCJndXR0ZXJJRCIsImNsZWFyR3V0dGVyIiwibGluZUluZm8iLCJhZGRMaW5lQ2xhc3MiLCJ3aGVyZSIsInJlbW92ZUxpbmVDbGFzcyIsInJlbW92ZUxpbmVXaWRnZXQiLCJzZXRCb29rbWFyayIsInJlYWxPcHRzIiwiZmluZE1hcmtzQXQiLCJnZXRBbGxNYXJrcyIsInBvc0Zyb21JbmRleCIsInNlcFNpemUiLCJpbmRleEZyb21Qb3MiLCJjb3B5SGlzdG9yeSIsImxpbmtlZERvYyIsInVubGlua0RvYyIsImxpbmsiLCJzcGxpdElkcyIsIml0ZXJMaW5rZWREb2NzIiwiZ2V0RWRpdG9yIiwic2V0RGlyZWN0aW9uIiwiZWFjaExpbmUiLCJsYXN0RHJvcCIsIm9uRHJvcCIsImNsZWFyRHJhZ0N1cnNvciIsImZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiaXNSZWFkT25seSIsIkZpbGVSZWFkZXIiLCJGaWxlIiwicmVhZCIsIm1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkIiwidCIsInJlYWRUZXh0RnJvbUZpbGUiLCJmaWxlIiwiYWxsb3dEcm9wRmlsZVR5cGVzIiwicmVhZGVyIiwib25lcnJvciIsIm9ubG9hZCIsInJlYWRBc1RleHQiLCJ0ZXh0JDEiLCJnZXREYXRhIiwic2VsZWN0ZWQiLCJvbkRyYWdTdGFydCIsInNldERhdGEiLCJlZmZlY3RBbGxvd2VkIiwic2V0RHJhZ0ltYWdlIiwiaW1nIiwic3JjIiwiX3RvcCIsIm9uRHJhZ092ZXIiLCJmcmFnIiwiZHJhZ0N1cnNvciIsImZvckVhY2hDb2RlTWlycm9yIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImJ5Q2xhc3MiLCJlZGl0b3JzIiwiZ2xvYmFsc1JlZ2lzdGVyZWQiLCJlbnN1cmVHbG9iYWxIYW5kbGVycyIsInJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMiLCJyZXNpemVUaW1lciIsIm9uUmVzaXplIiwic2V0U2l6ZSIsImtleU5hbWVzIiwiZnJvbUNoYXJDb2RlIiwia2V5TWFwIiwiYmFzaWMiLCJwY0RlZmF1bHQiLCJlbWFjc3kiLCJtYWNEZWZhdWx0Iiwibm9ybWFsaXplS2V5TmFtZSIsImFsdCIsImN0cmwiLCJjbWQiLCJtb2QiLCJub3JtYWxpemVLZXlNYXAiLCJrZXltYXAiLCJrZXluYW1lIiwia2V5cyIsImxvb2t1cEtleSIsImdldEtleU1hcCIsImZhbGx0aHJvdWdoIiwiaXNNb2RpZmllcktleSIsImtleUNvZGUiLCJhZGRNb2RpZmllck5hbWVzIiwibm9TaGlmdCIsImFsdEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImtleU5hbWUiLCJhbHRHcmFwaEtleSIsImRlbGV0ZU5lYXJTZWxlY3Rpb24iLCJjb21wdXRlIiwia2lsbCIsInRvS2lsbCIsInJlcGxhY2VkIiwibW92ZUNoYXJMb2dpY2FsbHkiLCJtb3ZlTG9naWNhbGx5IiwiZW5kT2ZMaW5lIiwidmlzdWFsbHkiLCJtb3ZlSW5TdG9yYWdlT3JkZXIiLCJwcmVwIiwibW92ZVZpc3VhbGx5IiwiYmlkaSIsIm12IiwiZ2V0V3JhcHBlZExpbmVFeHRlbnQiLCJzZWFyY2hJblZpc3VhbExpbmUiLCJnZXRSZXMiLCJyZXMiLCJuZXh0Q2giLCJjb21tYW5kcyIsInNpbmdsZVNlbGVjdGlvbiIsImtpbGxMaW5lIiwiZGVsZXRlTGluZSIsImRlbExpbmVMZWZ0IiwiZGVsV3JhcHBlZExpbmVMZWZ0IiwibGVmdFBvcyIsImRlbFdyYXBwZWRMaW5lUmlnaHQiLCJyaWdodFBvcyIsImdvRG9jU3RhcnQiLCJnb0RvY0VuZCIsImdvTGluZVN0YXJ0IiwiZ29MaW5lU3RhcnRTbWFydCIsImxpbmVTdGFydFNtYXJ0IiwiZ29MaW5lRW5kIiwibGluZUVuZCIsImdvTGluZVJpZ2h0IiwiZ29MaW5lTGVmdCIsImdvTGluZUxlZnRTbWFydCIsImdvTGluZVVwIiwibW92ZVYiLCJnb0xpbmVEb3duIiwiZ29QYWdlVXAiLCJnb1BhZ2VEb3duIiwiZ29DaGFyTGVmdCIsIm1vdmVIIiwiZ29DaGFyUmlnaHQiLCJnb0NvbHVtbkxlZnQiLCJnb0NvbHVtblJpZ2h0IiwiZ29Xb3JkTGVmdCIsImdvR3JvdXBSaWdodCIsImdvR3JvdXBMZWZ0IiwiZ29Xb3JkUmlnaHQiLCJkZWxDaGFyQmVmb3JlIiwiZGVsZXRlSCIsImRlbENoYXJBZnRlciIsImRlbFdvcmRCZWZvcmUiLCJkZWxXb3JkQWZ0ZXIiLCJkZWxHcm91cEJlZm9yZSIsImRlbEdyb3VwQWZ0ZXIiLCJpbmRlbnRBdXRvIiwiaW5kZW50U2VsZWN0aW9uIiwiaW5kZW50TW9yZSIsImluZGVudExlc3MiLCJpbnNlcnRUYWIiLCJpbnNlcnRTb2Z0VGFiIiwic3BhY2VzIiwiZGVmYXVsdFRhYiIsImV4ZWNDb21tYW5kIiwidHJhbnNwb3NlQ2hhcnMiLCJuZXdsaW5lQW5kSW5kZW50Iiwic2VscyIsImluZGVudExpbmUiLCJvcGVuTGluZSIsInRvZ2dsZU92ZXJ3cml0ZSIsImZpcnN0Tm9uV1MiLCJpbldTIiwiZG9IYW5kbGVCaW5kaW5nIiwiYm91bmQiLCJkcm9wU2hpZnQiLCJlbnN1cmVQb2xsZWQiLCJwcmV2U2hpZnQiLCJsb29rdXBLZXlGb3JFZGl0b3IiLCJrZXlNYXBzIiwiZXh0cmFLZXlzIiwic3RvcFNlcSIsImRpc3BhdGNoS2V5Iiwic2VxIiwia2V5U2VxIiwiZGlzcGF0Y2hLZXlJbm5lciIsImhhbmRsZUtleUJpbmRpbmciLCJtb3Rpb24iLCJoYW5kbGVDaGFyQmluZGluZyIsImxhc3RTdG9wcGVkS2V5Iiwib25LZXlEb3duIiwiZ2V0RmllbGQiLCJoYW5kbGVkIiwic2hvd0Nyb3NzSGFpciIsInVwIiwib25LZXlVcCIsIm9uS2V5UHJlc3MiLCJjaGFyQ29kZSIsIkRPVUJMRUNMSUNLX0RFTEFZIiwiUGFzdENsaWNrIiwiY29tcGFyZSIsImxhc3RDbGljayIsImxhc3REb3VibGVDbGljayIsImNsaWNrUmVwZWF0Iiwibm93Iiwib25Nb3VzZURvd24iLCJzdXBwb3J0c1RvdWNoIiwiY2xpY2tJbkd1dHRlciIsInJlcGVhdCIsInNlbGVjdGluZ1RleHQiLCJoYW5kbGVNYXBwZWRCdXR0b24iLCJsZWZ0QnV0dG9uRG93biIsIm9uQ29udGV4dE1lbnUiLCJjb25maWd1cmVNb3VzZSIsIm9wdGlvbiIsInVuaXQiLCJhZGROZXciLCJtb3ZlT25EcmFnIiwiYmVoYXZpb3IiLCJjb250YWluZWQiLCJkcmFnRHJvcCIsImxlZnRCdXR0b25TdGFydERyYWciLCJsZWZ0QnV0dG9uU2VsZWN0IiwibW92ZWQiLCJkcmFnRW5kIiwibW91c2VNb3ZlIiwiZHJhZ1N0YXJ0IiwicHJldmVudFNjcm9sbCIsImUyIiwicmFuZ2VGb3JVbml0IiwiZmluZFdvcmRBdCIsIm91clJhbmdlIiwib3VySW5kZXgiLCJzdGFydFNlbCIsImxhc3RQb3MiLCJleHRlbmRUbyIsInN0YXJ0Q29sIiwicG9zQ29sIiwib2xkUmFuZ2UiLCJyYW5nZXMkMSIsImJpZGlTaW1wbGlmeSIsImVkaXRvclNpemUiLCJjb3VudGVyIiwiY3VyQ291bnQiLCJtb3ZlIiwiYnV0dG9ucyIsImFuY2hvckxpbmUiLCJib3VuZGFyeSIsImhlYWRJbmRleCIsInVzZVBhcnQiLCJndXR0ZXJFdmVudCIsInByZXZlbnQiLCJtWCIsIm1ZIiwidG91Y2hlcyIsImxpbmVCb3giLCJnIiwiY29udGV4dE1lbnVJbkd1dHRlciIsInRoZW1lQ2hhbmdlZCIsInRoZW1lIiwiSW5pdCIsImRlZmF1bHRzIiwib3B0aW9uSGFuZGxlcnMiLCJkZWZpbmVPcHRpb25zIiwiZGVmbHQiLCJub3RPbkluaXQiLCJkZWZpbmVPcHRpb24iLCJuZXdCcmVha3MiLCJyZWZyZXNoIiwiZ2V0SW5wdXRGaWVsZCIsInNwZWxsY2hlY2siLCJhdXRvY29ycmVjdCIsImF1dG9jYXBpdGFsaXplIiwiZGV0YWNoIiwiYXR0YWNoIiwid3JhcHBpbmdDaGFuZ2VkIiwiaW50ZWdlciIsImJsdXIiLCJyZWFkT25seUNoYW5nZWQiLCJzY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQiLCJkcmFnRHJvcENoYW5nZWQiLCJyZXNldFBvc2l0aW9uIiwid2FzT24iLCJmdW5jcyIsImRyYWdGdW5jdGlvbnMiLCJ0b2dnbGUiLCJlbnRlciIsIm92ZXIiLCJsZWF2ZSIsImRyb3AiLCJpbnB1dFN0eWxlcyIsImlucHV0U3R5bGUiLCJwYXN0ZUluY29taW5nIiwiY3V0SW5jb21pbmciLCJhdXRvZm9jdXMiLCJyZWdpc3RlckV2ZW50SGFuZGxlcnMiLCJmaW5pc2hJbml0IiwiaW5pdEhvb2tzIiwidGV4dFJlbmRlcmluZyIsIndvcmQiLCJ0b3VjaEZpbmlzaGVkIiwicHJldlRvdWNoIiwiZmluaXNoVG91Y2giLCJpc01vdXNlTGlrZVRvdWNoRXZlbnQiLCJ0b3VjaCIsInJhZGl1c1giLCJyYWRpdXNZIiwiZmFyQXdheSIsInBhZ2VYIiwicGFnZVkiLCJpbnAiLCJkZWZpbmVJbml0SG9vayIsImhvdyIsImFnZ3Jlc3NpdmUiLCJpbmRlbnQiLCJjdXJTcGFjZSIsImN1clNwYWNlU3RyaW5nIiwiaW5kZW50VW5pdCIsImluZGVudFN0cmluZyIsImluZGVudFdpdGhUYWJzIiwicG9zJDEiLCJsYXN0Q29waWVkIiwic2V0TGFzdENvcGllZCIsIm5ld0xhc3RDb3BpZWQiLCJhcHBseVRleHRJbnB1dCIsImluc2VydGVkIiwiZGVsZXRlZCIsInJlY2VudCIsInBhc3RlIiwidGV4dExpbmVzIiwibXVsdGlQYXN0ZSIsInBhc3RlTGluZXNQZXJTZWxlY3Rpb24iLCJsaW5lV2lzZSIsImNoYW5nZUV2ZW50IiwidHJpZ2dlckVsZWN0cmljIiwiaGFuZGxlUGFzdGUiLCJwYXN0ZWQiLCJjbGlwYm9hcmREYXRhIiwiZGlzYWJsZUlucHV0IiwiZWxlY3RyaWNDaGFycyIsInNtYXJ0SW5kZW50IiwiZ2V0TW9kZUF0IiwiZWxlY3RyaWNJbnB1dCIsImNvcHlhYmxlUmFuZ2VzIiwibGluZVJhbmdlIiwiZGlzYWJsZUJyb3dzZXJNYWdpYyIsImZpZWxkIiwiaGlkZGVuVGV4dGFyZWEiLCJib3JkZXIiLCJhZGRFZGl0b3JNZXRob2RzIiwiaGVscGVycyIsInNldE9wdGlvbiIsImdldERvYyIsImFkZEtleU1hcCIsInJlbW92ZUtleU1hcCIsImFkZE92ZXJsYXkiLCJtb2RlU3BlYyIsInJlbW92ZU92ZXJsYXkiLCJuZXdSYW5nZXMiLCJnZXRUb2tlbkF0IiwiZ2V0TGluZVRva2VucyIsImdldFRva2VuVHlwZUF0IiwiZ2V0SGVscGVyIiwiZ2V0SGVscGVycyIsImhlbHAiLCJfZ2xvYmFsIiwiZ2V0U3RhdGVBZnRlciIsImRlZmF1bHRUZXh0SGVpZ2h0IiwiZ2V0Vmlld3BvcnQiLCJhZGRXaWRnZXQiLCJ2c3BhY2UiLCJoc3BhY2UiLCJ0cmlnZ2VyT25LZXlEb3duIiwidHJpZ2dlck9uS2V5UHJlc3MiLCJ0cmlnZ2VyT25LZXlVcCIsInRyaWdnZXJPbk1vdXNlRG93biIsImZpbmRQb3NIIiwiYW1vdW50IiwiaGl0U2lkZSIsInJ0bE1vdmVWaXN1YWxseSIsImZpbmRQb3NWIiwiZ29hbENvbHVtbiIsImdvYWxzIiwiaGVhZFBvcyIsInN0YXJ0Q2hhciIsImNoZWNrIiwic2Nyb2xsVG8iLCJnZXRTY3JvbGxJbmZvIiwiaW50ZXJwcmV0Iiwic3dhcERvYyIsInBocmFzZSIsInBocmFzZVRleHQiLCJwaHJhc2VzIiwiZ2V0U2Nyb2xsZXJFbGVtZW50IiwiZ2V0R3V0dGVyRWxlbWVudCIsInJlZ2lzdGVySGVscGVyIiwicmVnaXN0ZXJHbG9iYWxIZWxwZXIiLCJwcmVkaWNhdGUiLCJvcmlnRGlyIiwibGluZURpciIsImZpbmROZXh0TGluZSIsIm1vdmVPbmNlIiwiYm91bmRUb0xpbmUiLCJhc3RyYWwiLCJzYXdUeXBlIiwicGFnZVNpemUiLCJtb3ZlQW1vdW50IiwiQ29udGVudEVkaXRhYmxlSW5wdXQiLCJsYXN0QW5jaG9yTm9kZSIsImxhc3RBbmNob3JPZmZzZXQiLCJsYXN0Rm9jdXNOb2RlIiwibGFzdEZvY3VzT2Zmc2V0IiwicG9sbGluZyIsImNvbXBvc2luZyIsImdyYWNlUGVyaW9kIiwicmVhZERPTVRpbWVvdXQiLCJjb250ZW50RWRpdGFibGUiLCJiZWxvbmdzVG9JbnB1dCIsInVwZGF0ZUZyb21ET00iLCJyZWFkRnJvbURPTVNvb24iLCJmb3JjZUNvbXBvc2l0aW9uRW5kIiwib25Db3B5Q3V0IiwibGluZVdpc2VDb3B5Q3V0IiwiY2xlYXJEYXRhIiwia2x1ZGdlIiwiaGFkRm9jdXMiLCJzaG93UHJpbWFyeVNlbGVjdGlvbiIsImxhYmVsIiwicmVtb3ZlQXR0cmlidXRlIiwic2hvd011bHRpcGxlU2VsZWN0aW9ucyIsImN1ckFuY2hvciIsImRvbVRvUG9zIiwiY3VyRm9jdXMiLCJiYWQiLCJwb3NUb0RPTSIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0Iiwicm5nIiwic3RhcnRHcmFjZVBlcmlvZCIsInJlbWVtYmVyU2VsZWN0aW9uIiwic2VsZWN0aW9uSW5FZGl0b3IiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsInBvbGxTZWxlY3Rpb24iLCJwb2xsIiwicG9sbEludGVydmFsIiwiaXNJbkd1dHRlciIsInBvbGxDb250ZW50IiwiZnJvbUluZGV4IiwiZnJvbU5vZGUiLCJ0b0luZGV4IiwidG9Ob2RlIiwicHJldmlvdXNTaWJsaW5nIiwibmV3VGV4dCIsImRvbVRleHRCZXR3ZWVuIiwib2xkVGV4dCIsImN1dEZyb250IiwiY3V0RW5kIiwib2xkVG9wIiwibWF4Q3V0RnJvbnQiLCJuZXdCb3QiLCJvbGRCb3QiLCJtYXhDdXRFbmQiLCJjaEZyb20iLCJjaFRvIiwic2NhbiIsImJhZFBvcyIsImNsb3NpbmciLCJleHRyYUxpbmVicmVhayIsInJlY29nbml6ZU1hcmtlciIsImNsb3NlIiwiYWRkVGV4dCIsIndhbGsiLCJjbVRleHQiLCJtYXJrZXJJRCIsImlzQmxvY2siLCJ0ZXh0Q29udGVudCIsIm5vZGVWYWx1ZSIsImxpbmVOb2RlIiwibG9jYXRlTm9kZUluTGluZVZpZXciLCJ0ZXh0Tm9kZSIsInRvcE5vZGUiLCJjdXJOb2RlIiwiZGlzdCQxIiwiVGV4dGFyZWFJbnB1dCIsInByZXZJbnB1dCIsInBvbGxpbmdGYXN0IiwiY3JlYXRlRmllbGQiLCJ0ZXh0YXJlYSIsImZhc3RQb2xsIiwicHJlcGFyZUNvcHlDdXQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJfZGlzcGxheSIsIm1vdmVJbnB1dFdpdGhDdXJzb3IiLCJ3cmFwT2ZmIiwibGluZU9mZiIsInRlVG9wIiwidGVMZWZ0IiwiZHJhd24iLCJjb250ZXh0TWVudVBlbmRpbmciLCJzbG93UG9sbCIsIm1pc3NlZCIsInNhbWUiLCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUiLCJvbGRDU1MiLCJvbGRXcmFwcGVyQ1NTIiwid3JhcHBlckJveCIsIm9mZnNldFBhcmVudCIsIm9sZFNjcm9sbFkiLCJzY3JvbGxZIiwicmVoaWRlIiwiZGV0ZWN0aW5nU2VsZWN0QWxsIiwicHJlcGFyZVNlbGVjdEFsbEhhY2siLCJleHR2YWwiLCJtb3VzZXVwIiwiZGlzYWJsZWQiLCJmcm9tVGV4dEFyZWEiLCJ0YWJpbmRleCIsInBsYWNlaG9sZGVyIiwicmVhbFN1Ym1pdCIsImZvcm0iLCJsZWF2ZVN1Ym1pdE1ldGhvZEFsb25lIiwic3VibWl0Iiwid3JhcHBlZFN1Ym1pdCIsImdldFRleHRBcmVhIiwidG9UZXh0QXJlYSIsImFkZExlZ2FjeVByb3BzIiwiY21wUG9zIiwiZG9udERlbGVnYXRlIiwibWV0aG9kIiwiZGVmaW5lRXh0ZW5zaW9uIiwiZnVuYyIsImRlZmluZURvY0V4dGVuc2lvbiIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/codemirror.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/codemirror.js");
/******/ 	
/******/ })()
;