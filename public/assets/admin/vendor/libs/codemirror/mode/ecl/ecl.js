/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/ecl/ecl.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/ecl/ecl.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"ecl\", function (config) {\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n\n    function metaHook(stream, state) {\n      if (!state.startOfLine) return false;\n      stream.skipToEnd();\n      return \"meta\";\n    }\n\n    var indentUnit = config.indentUnit;\n    var keyword = words(\"abs acos allnodes ascii asin asstring atan atan2 ave case choose choosen choosesets clustersize combine correlation cos cosh count covariance cron dataset dedup define denormalize distribute distributed distribution ebcdic enth error evaluate event eventextra eventname exists exp failcode failmessage fetch fromunicode getisvalid global graph group hash hash32 hash64 hashcrc hashmd5 having if index intformat isvalid iterate join keyunicode length library limit ln local log loop map matched matchlength matchposition matchtext matchunicode max merge mergejoin min nolocal nonempty normalize parse pipe power preload process project pull random range rank ranked realformat recordof regexfind regexreplace regroup rejected rollup round roundup row rowdiff sample set sin sinh sizeof soapcall sort sorted sqrt stepped stored sum table tan tanh thisnode topn tounicode transfer trim truncate typeof ungroup unicodeorder variance which workunit xmldecode xmlencode xmltext xmlunicode\");\n    var variable = words(\"apply assert build buildindex evaluate fail keydiff keypatch loadxml nothor notify output parallel sequential soapcall wait\");\n    var variable_2 = words(\"__compressed__ all and any as atmost before beginc++ best between case const counter csv descend encrypt end endc++ endmacro except exclusive expire export extend false few first flat from full function group header heading hole ifblock import in interface joined keep keyed last left limit load local locale lookup macro many maxcount maxlength min skew module named nocase noroot noscan nosort not of only opt or outer overwrite packed partition penalty physicallength pipe quote record relationship repeat return right scan self separator service shared skew skip sql store terminator thor threshold token transform trim true type unicodeorder unsorted validate virtual whole wild within xml xpath\");\n    var variable_3 = words(\"ascii big_endian boolean data decimal ebcdic integer pattern qstring real record rule set of string token udecimal unicode unsigned varstring varunicode\");\n    var builtin = words(\"checkpoint deprecated failcode failmessage failure global independent onwarning persist priority recovery stored success wait when\");\n    var blockKeywords = words(\"catch class do else finally for if switch try while\");\n    var atoms = words(\"true false null\");\n    var hooks = {\n      \"#\": metaHook\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (hooks[ch]) {\n        var result = hooks[ch](stream, state);\n        if (result !== false) return result;\n      }\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w\\.]/);\n        return \"number\";\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_]/);\n      var cur = stream.current().toLowerCase();\n\n      if (keyword.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"keyword\";\n      } else if (variable.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"variable\";\n      } else if (variable_2.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"variable-2\";\n      } else if (variable_3.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"variable-3\";\n      } else if (builtin.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"builtin\";\n      } else {\n        //Data types are of from KEYWORD##\n        var i = cur.length - 1;\n\n        while (i >= 0 && (!isNaN(cur[i]) || cur[i] == '_')) {\n          --i;\n        }\n\n        if (i > 0) {\n          var cur2 = cur.substr(0, i + 1);\n\n          if (variable_3.propertyIsEnumerable(cur2)) {\n            if (blockKeywords.propertyIsEnumerable(cur2)) curPunc = \"newstatement\";\n            return \"variable-3\";\n          }\n        }\n      }\n\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return null;\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type) {\n      return state.context = new Context(state.indented, col, type, null, state.context);\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n      return state.context = state.context.prev;\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n          indented: 0,\n          startOfLine: true\n        };\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if ((curPunc == \";\" || curPunc == \":\") && ctx.type == \"statement\") popContext(state);else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n\n          if (ctx.type == \"}\") ctx = popContext(state);\n\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n        } else if (curPunc == ctx.type) popContext(state);else if (ctx.type == \"}\" || ctx.type == \"top\" || ctx.type == \"statement\" && curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return 0;\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = firstChar == ctx.type;\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : indentUnit);else if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-ecl\", \"ecl\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9lY2wvZWNsLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN4Qjs7RUFFQUEsVUFBVSxDQUFDQyxVQUFYLENBQXNCLEtBQXRCLEVBQTZCLFVBQVNDLE1BQVQsRUFBaUI7SUFFNUMsU0FBU0MsS0FBVCxDQUFlQyxHQUFmLEVBQW9CO01BQ2xCLElBQUlDLEdBQUcsR0FBRyxFQUFWO01BQUEsSUFBY0YsS0FBSyxHQUFHQyxHQUFHLENBQUNFLEtBQUosQ0FBVSxHQUFWLENBQXRCOztNQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osS0FBSyxDQUFDSyxNQUExQixFQUFrQyxFQUFFRCxDQUFwQztRQUF1Q0YsR0FBRyxDQUFDRixLQUFLLENBQUNJLENBQUQsQ0FBTixDQUFILEdBQWdCLElBQWhCO01BQXZDOztNQUNBLE9BQU9GLEdBQVA7SUFDRDs7SUFFRCxTQUFTSSxRQUFULENBQWtCQyxNQUFsQixFQUEwQkMsS0FBMUIsRUFBaUM7TUFDL0IsSUFBSSxDQUFDQSxLQUFLLENBQUNDLFdBQVgsRUFBd0IsT0FBTyxLQUFQO01BQ3hCRixNQUFNLENBQUNHLFNBQVA7TUFDQSxPQUFPLE1BQVA7SUFDRDs7SUFFRCxJQUFJQyxVQUFVLEdB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QUFoQixFQUEyQjtRQUNqQyxJQUFJdkQsS0FBSyxDQUFDa0IsUUFBTixJQUFrQkosU0FBbEIsSUFBK0JkLEtBQUssQ0FBQ2tCLFFBQU4sSUFBa0IsSUFBckQsRUFBMkQsT0FBTyxDQUFQO1FBQzNELElBQUkrQixHQUFHLEdBQUdqRCxLQUFLLENBQUMyQyxPQUFoQjtRQUFBLElBQXlCYSxTQUFTLEdBQUdELFNBQVMsSUFBSUEsU0FBUyxDQUFDRSxNQUFWLENBQWlCLENBQWpCLENBQWxEO1FBQ0EsSUFBSVIsR0FBRyxDQUFDWCxJQUFKLElBQVksV0FBWixJQUEyQmtCLFNBQVMsSUFBSSxHQUE1QyxFQUFpRFAsR0FBRyxHQUFHQSxHQUFHLENBQUNULElBQVY7UUFDakQsSUFBSWtCLE9BQU8sR0FBR0YsU0FBUyxJQUFJUCxHQUFHLENBQUNYLElBQS9CO1FBQ0EsSUFBSVcsR0FBRyxDQUFDWCxJQUFKLElBQVksV0FBaEIsRUFBNkIsT0FBT1csR0FBRyxDQUFDYixRQUFKLElBQWdCb0IsU0FBUyxJQUFJLEdBQWIsR0FBbUIsQ0FBbkIsR0FBdUJyRCxVQUF2QyxDQUFQLENBQTdCLEtBQ0ssSUFBSThDLEdBQUcsQ0FBQ1YsS0FBUixFQUFlLE9BQU9VLEdBQUcsQ0FBQ1osTUFBSixJQUFjcUIsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUE1QixDQUFQLENBQWYsS0FDQSxPQUFPVCxHQUFHLENBQUNiLFFBQUosSUFBZ0JzQixPQUFPLEdBQUcsQ0FBSCxHQUFPdkQsVUFBOUIsQ0FBUDtNQUNOLENBL0NJO01BaURMd0QsYUFBYSxFQUFFO0lBakRWLENBQVA7RUFtREQsQ0E1TEQ7RUE4TEF0RSxVQUFVLENBQUN1RSxVQUFYLENBQXNCLFlBQXRCLEVBQW9DLEtBQXBDO0FBRUMsQ0ExTUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9lY2wvZWNsLmpzP2M0YTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJlY2xcIiwgZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGFIb29rKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLnN0YXJ0T2ZMaW5lKSByZXR1cm4gZmFsc2U7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcIm1ldGFcIjtcbiAgfVxuXG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gIHZhciBrZXl3b3JkID0gd29yZHMoXCJhYnMgYWNvcyBhbGxub2RlcyBhc2NpaSBhc2luIGFzc3RyaW5nIGF0YW4gYXRhbjIgYXZlIGNhc2UgY2hvb3NlIGNob29zZW4gY2hvb3Nlc2V0cyBjbHVzdGVyc2l6ZSBjb21iaW5lIGNvcnJlbGF0aW9uIGNvcyBjb3NoIGNvdW50IGNvdmFyaWFuY2UgY3JvbiBkYXRhc2V0IGRlZHVwIGRlZmluZSBkZW5vcm1hbGl6ZSBkaXN0cmlidXRlIGRpc3RyaWJ1dGVkIGRpc3RyaWJ1dGlvbiBlYmNkaWMgZW50aCBlcnJvciBldmFsdWF0ZSBldmVudCBldmVudGV4dHJhIGV2ZW50bmFtZSBleGlzdHMgZXhwIGZhaWxjb2RlIGZhaWxtZXNzYWdlIGZldGNoIGZyb211bmljb2RlIGdldGlzdmFsaWQgZ2xvYmFsIGdyYXBoIGdyb3VwIGhhc2ggaGFzaDMyIGhhc2g2NCBoYXNoY3JjIGhhc2htZDUgaGF2aW5nIGlmIGluZGV4IGludGZvcm1hdCBpc3ZhbGlkIGl0ZXJhdGUgam9pbiBrZXl1bmljb2RlIGxlbmd0aCBsaWJyYXJ5IGxpbWl0IGxuIGxvY2FsIGxvZyBsb29wIG1hcCBtYXRjaGVkIG1hdGNobGVuZ3RoIG1hdGNocG9zaXRpb24gbWF0Y2h0ZXh0IG1hdGNodW5pY29kZSBtYXggbWVyZ2UgbWVyZ2Vqb2luIG1pbiBub2xvY2FsIG5vbmVtcHR5IG5vcm1hbGl6ZSBwYXJzZSBwaXBlIHBvd2VyIHByZWxvYWQgcHJvY2VzcyBwcm9qZWN0IHB1bGwgcmFuZG9tIHJhbmdlIHJhbmsgcmFua2VkIHJlYWxmb3JtYXQgcmVjb3Jkb2YgcmVnZXhmaW5kIHJlZ2V4cmVwbGFjZSByZWdyb3VwIHJlamVjdGVkIHJvbGx1cCByb3VuZCByb3VuZHVwIHJvdyByb3dkaWZmIHNhbXBsZSBzZXQgc2luIHNpbmggc2l6ZW9mIHNvYXBjYWxsIHNvcnQgc29ydGVkIHNxcnQgc3RlcHBlZCBzdG9yZWQgc3VtIHRhYmxlIHRhbiB0YW5oIHRoaXNub2RlIHRvcG4gdG91bmljb2RlIHRyYW5zZmVyIHRyaW0gdHJ1bmNhdGUgdHlwZW9mIHVuZ3JvdXAgdW5pY29kZW9yZGVyIHZhcmlhbmNlIHdoaWNoIHdvcmt1bml0IHhtbGRlY29kZSB4bWxlbmNvZGUgeG1sdGV4dCB4bWx1bmljb2RlXCIpO1xuICB2YXIgdmFyaWFibGUgPSB3b3JkcyhcImFwcGx5IGFzc2VydCBidWlsZCBidWlsZGluZGV4IGV2YWx1YXRlIGZhaWwga2V5ZGlmZiBrZXlwYXRjaCBsb2FkeG1sIG5vdGhvciBub3RpZnkgb3V0cHV0IHBhcmFsbGVsIHNlcXVlbnRpYWwgc29hcGNhbGwgd2FpdFwiKTtcbiAgdmFyIHZhcmlhYmxlXzIgPSB3b3JkcyhcIl9fY29tcHJlc3NlZF9fIGFsbCBhbmQgYW55IGFzIGF0bW9zdCBiZWZvcmUgYmVnaW5jKysgYmVzdCBiZXR3ZWVuIGNhc2UgY29uc3QgY291bnRlciBjc3YgZGVzY2VuZCBlbmNyeXB0IGVuZCBlbmRjKysgZW5kbWFjcm8gZXhjZXB0IGV4Y2x1c2l2ZSBleHBpcmUgZXhwb3J0IGV4dGVuZCBmYWxzZSBmZXcgZmlyc3QgZmxhdCBmcm9tIGZ1bGwgZnVuY3Rpb24gZ3JvdXAgaGVhZGVyIGhlYWRpbmcgaG9sZSBpZmJsb2NrIGltcG9ydCBpbiBpbnRlcmZhY2Ugam9pbmVkIGtlZXAga2V5ZWQgbGFzdCBsZWZ0IGxpbWl0IGxvYWQgbG9jYWwgbG9jYWxlIGxvb2t1cCBtYWNybyBtYW55IG1heGNvdW50IG1heGxlbmd0aCBtaW4gc2tldyBtb2R1bGUgbmFtZWQgbm9jYXNlIG5vcm9vdCBub3NjYW4gbm9zb3J0IG5vdCBvZiBvbmx5IG9wdCBvciBvdXRlciBvdmVyd3JpdGUgcGFja2VkIHBhcnRpdGlvbiBwZW5hbHR5IHBoeXNpY2FsbGVuZ3RoIHBpcGUgcXVvdGUgcmVjb3JkIHJlbGF0aW9uc2hpcCByZXBlYXQgcmV0dXJuIHJpZ2h0IHNjYW4gc2VsZiBzZXBhcmF0b3Igc2VydmljZSBzaGFyZWQgc2tldyBza2lwIHNxbCBzdG9yZSB0ZXJtaW5hdG9yIHRob3IgdGhyZXNob2xkIHRva2VuIHRyYW5zZm9ybSB0cmltIHRydWUgdHlwZSB1bmljb2Rlb3JkZXIgdW5zb3J0ZWQgdmFsaWRhdGUgdmlydHVhbCB3aG9sZSB3aWxkIHdpdGhpbiB4bWwgeHBhdGhcIik7XG4gIHZhciB2YXJpYWJsZV8zID0gd29yZHMoXCJhc2NpaSBiaWdfZW5kaWFuIGJvb2xlYW4gZGF0YSBkZWNpbWFsIGViY2RpYyBpbnRlZ2VyIHBhdHRlcm4gcXN0cmluZyByZWFsIHJlY29yZCBydWxlIHNldCBvZiBzdHJpbmcgdG9rZW4gdWRlY2ltYWwgdW5pY29kZSB1bnNpZ25lZCB2YXJzdHJpbmcgdmFydW5pY29kZVwiKTtcbiAgdmFyIGJ1aWx0aW4gPSB3b3JkcyhcImNoZWNrcG9pbnQgZGVwcmVjYXRlZCBmYWlsY29kZSBmYWlsbWVzc2FnZSBmYWlsdXJlIGdsb2JhbCBpbmRlcGVuZGVudCBvbndhcm5pbmcgcGVyc2lzdCBwcmlvcml0eSByZWNvdmVyeSBzdG9yZWQgc3VjY2VzcyB3YWl0IHdoZW5cIik7XG4gIHZhciBibG9ja0tleXdvcmRzID0gd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGlmIHN3aXRjaCB0cnkgd2hpbGVcIik7XG4gIHZhciBhdG9tcyA9IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsXCIpO1xuICB2YXIgaG9va3MgPSB7XCIjXCI6IG1ldGFIb29rfTtcbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT98XFwvXS87XG5cbiAgdmFyIGN1clB1bmM7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChob29rc1tjaF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBob29rc1tjaF0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBjaDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChrZXl3b3JkLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHtcbiAgICAgIGlmIChibG9ja0tleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH0gZWxzZSBpZiAodmFyaWFibGUucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH0gZWxzZSBpZiAodmFyaWFibGVfMi5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICB9IGVsc2UgaWYgKHZhcmlhYmxlXzMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0zXCI7XG4gICAgfSBlbHNlIGlmIChidWlsdGluLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHtcbiAgICAgIGlmIChibG9ja0tleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH0gZWxzZSB7IC8vRGF0YSB0eXBlcyBhcmUgb2YgZnJvbSBLRVlXT1JEIyNcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGN1ci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlKGkgPj0gMCAmJiAoIWlzTmFOKGN1cltpXSkgfHwgY3VyW2ldID09ICdfJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXIyID0gY3VyLnN1YnN0cigwLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlXzMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0tleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cjIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhcmlhYmxlLTNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhZXNjYXBlZClcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldikge1xuICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9XG4gIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLmluZGVudGVkLCBjb2wsIHR5cGUsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiKSByZXR1cm4gc3R5bGU7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgIGlmICgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiKSAmJiBjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IGN0eC50eXBlKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN0eC50eXBlID09IFwifVwiIHx8IGN0eC50eXBlID09IFwidG9wXCIgfHwgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSlcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dCwgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBmaXJzdENoYXIgPT0gXCJ9XCIpIGN0eCA9IGN0eC5wcmV2O1xuICAgICAgdmFyIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gY3R4LnR5cGU7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgICBlbHNlIGlmIChjdHguYWxpZ24pIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNDaGFyczogXCJ7fVwiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWVjbFwiLCBcImVjbFwiKTtcblxufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwiZGVmaW5lTW9kZSIsImNvbmZpZyIsIndvcmRzIiwic3RyIiwib2JqIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwibWV0YUhvb2siLCJzdHJlYW0iLCJzdGF0ZSIsInN0YXJ0T2ZMaW5lIiwic2tpcFRvRW5kIiwiaW5kZW50VW5pdCIsImtleXdvcmQiLCJ2YXJpYWJsZSIsInZhcmlhYmxlXzIiLCJ2YXJpYWJsZV8zIiwiYnVpbHRpbiIsImJsb2NrS2V5d29yZHMiLCJhdG9tcyIsImhvb2tzIiwiaXNPcGVyYXRvckNoYXIiLCJjdXJQdW5jIiwidG9rZW5CYXNlIiwiY2giLCJuZXh0IiwicmVzdWx0IiwidG9rZW5pemUiLCJ0b2tlblN0cmluZyIsInRlc3QiLCJlYXRXaGlsZSIsImVhdCIsInRva2VuQ29tbWVudCIsImN1ciIsImN1cnJlbnQiLCJ0b0xvd2VyQ2FzZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNOYU4iLCJjdXIyIiwic3Vic3RyIiwicXVvdGUiLCJlc2NhcGVkIiwiZW5kIiwibWF5YmVFbmQiLCJDb250ZXh0IiwiaW5kZW50ZWQiLCJjb2x1bW4iLCJ0eXBlIiwiYWxpZ24iLCJwcmV2IiwicHVzaENvbnRleHQiLCJjb2wiLCJjb250ZXh0IiwicG9wQ29udGV4dCIsInQiLCJzdGFydFN0YXRlIiwiYmFzZWNvbHVtbiIsInRva2VuIiwiY3R4Iiwic29sIiwiaW5kZW50YXRpb24iLCJlYXRTcGFjZSIsInN0eWxlIiwiaW5kZW50IiwidGV4dEFmdGVyIiwiZmlyc3RDaGFyIiwiY2hhckF0IiwiY2xvc2luZyIsImVsZWN0cmljQ2hhcnMiLCJkZWZpbmVNSU1FIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/ecl/ecl.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/ecl/ecl.js");
/******/ 	
/******/ })()
;