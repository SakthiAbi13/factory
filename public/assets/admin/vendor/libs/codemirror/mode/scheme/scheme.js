/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/scheme/scheme.js":
/*!***********************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/scheme/scheme.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n * Improved by: Jakub T. Jankiewicz\n */\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\",\n        COMMENT = \"comment\",\n        STRING = \"string\",\n        SYMBOL = \"symbol\",\n        ATOM = \"atom\",\n        NUMBER = \"number\",\n        BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n\n    var keywords = makeKeywords(\"Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\n    function stateStack(indent, type, prev) {\n      // represents a state stack object\n      this.indent = indent;\n      this.type = type;\n      this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n      state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n      state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber(stream) {\n      return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber(stream) {\n      return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber(stream, backup) {\n      if (backup === true) {\n        stream.backUp(1);\n      }\n\n      return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber(stream) {\n      return stream.match(hexMatcher);\n    }\n\n    function processEscapedSequence(stream, options) {\n      var next,\n          escaped = false;\n\n      while ((next = stream.next()) != null) {\n        if (next == options.token && !escaped) {\n          options.state.mode = false;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          indentStack: null,\n          indentation: 0,\n          mode: false,\n          sExprComment: false,\n          sExprQuote: false\n        };\n      },\n      token: function token(stream, state) {\n        if (state.indentStack == null && stream.sol()) {\n          // update indentation, but only if indentStack is empty\n          state.indentation = stream.indentation();\n        } // skip spaces\n\n\n        if (stream.eatSpace()) {\n          return null;\n        }\n\n        var returnType = null;\n\n        switch (state.mode) {\n          case \"string\":\n            // multi-line string parsing mode\n            processEscapedSequence(stream, {\n              token: \"\\\"\",\n              state: state\n            });\n            returnType = STRING; // continue on in scheme-string mode\n\n            break;\n\n          case \"symbol\":\n            // escape symbol\n            processEscapedSequence(stream, {\n              token: \"|\",\n              state: state\n            });\n            returnType = SYMBOL; // continue on in scheme-symbol mode\n\n            break;\n\n          case \"comment\":\n            // comment parsing mode\n            var next,\n                maybeEnd = false;\n\n            while ((next = stream.next()) != null) {\n              if (next == \"#\" && maybeEnd) {\n                state.mode = false;\n                break;\n              }\n\n              maybeEnd = next == \"|\";\n            }\n\n            returnType = COMMENT;\n            break;\n\n          case \"s-expr-comment\":\n            // s-expr commenting mode\n            state.mode = false;\n\n            if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n              // actually start scheme s-expr commenting mode\n              state.sExprComment = 0;\n            } else {\n              // if not we just comment the entire of the next token\n              stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n\n              returnType = COMMENT;\n              break;\n            }\n\n          default:\n            // default parsing mode\n            var ch = stream.next();\n\n            if (ch == \"\\\"\") {\n              state.mode = \"string\";\n              returnType = STRING;\n            } else if (ch == \"'\") {\n              if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n                if (typeof state.sExprQuote != \"number\") {\n                  state.sExprQuote = 0;\n                } // else already in a quoted expression\n\n\n                returnType = ATOM;\n              } else {\n                stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                returnType = ATOM;\n              }\n            } else if (ch == '|') {\n              state.mode = \"symbol\";\n              returnType = SYMBOL;\n            } else if (ch == '#') {\n              if (stream.eat(\"|\")) {\n                // Multi-line comment\n                state.mode = \"comment\"; // toggle to comment mode\n\n                returnType = COMMENT;\n              } else if (stream.eat(/[tf]/i)) {\n                // #t/#f (atom)\n                returnType = ATOM;\n              } else if (stream.eat(';')) {\n                // S-Expr comment\n                state.mode = \"s-expr-comment\";\n                returnType = COMMENT;\n              } else {\n                var numTest = null,\n                    hasExactness = false,\n                    hasRadix = true;\n\n                if (stream.eat(/[ei]/i)) {\n                  hasExactness = true;\n                } else {\n                  stream.backUp(1); // must be radix specifier\n                }\n\n                if (stream.match(/^#b/i)) {\n                  numTest = isBinaryNumber;\n                } else if (stream.match(/^#o/i)) {\n                  numTest = isOctalNumber;\n                } else if (stream.match(/^#x/i)) {\n                  numTest = isHexNumber;\n                } else if (stream.match(/^#d/i)) {\n                  numTest = isDecimalNumber;\n                } else if (stream.match(/^[-+0-9.]/, false)) {\n                  hasRadix = false;\n                  numTest = isDecimalNumber; // re-consume the initial # if all matches failed\n                } else if (!hasExactness) {\n                  stream.eat('#');\n                }\n\n                if (numTest != null) {\n                  if (hasRadix && !hasExactness) {\n                    // consume optional exactness after radix\n                    stream.match(/^#[ei]/i);\n                  }\n\n                  if (numTest(stream)) returnType = NUMBER;\n                }\n              }\n            } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n              // match non-prefixed number, must be decimal\n              returnType = NUMBER;\n            } else if (ch == \";\") {\n              // comment\n              stream.skipToEnd(); // rest of the line is a comment\n\n              returnType = COMMENT;\n            } else if (ch == \"(\" || ch == \"[\") {\n              var keyWord = '';\n              var indentTemp = stream.column(),\n                  letter;\n              /**\n              Either\n              (indent-word ..\n              (non-indent-word ..\n              (;something else, bracket, etc.\n              */\n\n              while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                keyWord += letter;\n              }\n\n              if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n                // indent-word\n                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n              } else {\n                // non-indent word\n                // we continue eating the spaces\n                stream.eatSpace();\n\n                if (stream.eol() || stream.peek() == \";\") {\n                  // nothing significant after\n                  // we restart indentation 1 space after\n                  pushStack(state, indentTemp + 1, ch);\n                } else {\n                  pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                }\n              }\n\n              stream.backUp(stream.current().length - 1); // undo all the eating\n\n              if (typeof state.sExprComment == \"number\") state.sExprComment++;\n              if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n              returnType = BRACKET;\n            } else if (ch == \")\" || ch == \"]\") {\n              returnType = BRACKET;\n\n              if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                popStack(state);\n\n                if (typeof state.sExprComment == \"number\") {\n                  if (--state.sExprComment == 0) {\n                    returnType = COMMENT; // final closing bracket\n\n                    state.sExprComment = false; // turn off s-expr commenting mode\n                  }\n                }\n\n                if (typeof state.sExprQuote == \"number\") {\n                  if (--state.sExprQuote == 0) {\n                    returnType = ATOM; // final closing bracket\n\n                    state.sExprQuote = false; // turn off s-expr quote mode\n                  }\n                }\n              }\n            } else {\n              stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n              if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                returnType = BUILTIN;\n              } else returnType = \"variable\";\n            }\n\n        }\n\n        return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n      },\n      indent: function indent(state) {\n        if (state.indentStack == null) return state.indentation;\n        return state.indentStack.indent;\n      },\n      fold: \"brace-paren\",\n      closeBrackets: {\n        pairs: \"()[]{}\\\"\\\"\"\n      },\n      lineComment: \";;\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9zY2hlbWUvc2NoZW1lLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN4Qjs7RUFFQUEsVUFBVSxDQUFDQyxVQUFYLENBQXNCLFFBQXRCLEVBQWdDLFlBQVk7SUFDeEMsSUFBSUMsT0FBTyxHQUFHLFNBQWQ7SUFBQSxJQUF5QkMsT0FBTyxHQUFHLFNBQW5DO0lBQUEsSUFBOENDLE1BQU0sR0FBRyxRQUF2RDtJQUFBLElBQ0lDLE1BQU0sR0FBRyxRQURiO0lBQUEsSUFDdUJDLElBQUksR0FBRyxNQUQ5QjtJQUFBLElBQ3NDQyxNQUFNLEdBQUcsUUFEL0M7SUFBQSxJQUN5REMsT0FBTyxHQUFHLFNBRG5FO0lBRUEsSUFBSUMsZ0JBQWdCLEdBQUcsQ0FBdkI7O0lBRUEsU0FBU0MsWUFBVCxDQUFzQkMsR0FBdEIsRUFBMkI7TUFDdkIsSUFBSUMsR0FBRyxHQUFHLEVBQVY7TUFBQSxJQUFjQyxLQUFLLEdBQUdGLEdBQUcsQ0FBQ0csS0FBSixDQUFVLEdBQVYsQ0FBdEI7O01BQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixLQUFLLENBQUNHLE1BQTFCLEVBQWtDLEVBQUVELENBQXBDO1FBQXVD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LEVBQUUsZ0JBQVVJLEtBQVYsRUFBaUI7UUFDckIsSUFBSUEsS0FBSyxDQUFDQyxXQUFOLElBQXFCLElBQXpCLEVBQStCLE9BQU9ELEtBQUssQ0FBQ3VCLFdBQWI7UUFDL0IsT0FBT3ZCLEtBQUssQ0FBQ0MsV0FBTixDQUFrQkwsTUFBekI7TUFDSCxDQS9MRTtNQWlNSGtELElBQUksRUFBRSxhQWpNSDtNQWtNSEMsYUFBYSxFQUFFO1FBQUNDLEtBQUssRUFBRTtNQUFSLENBbE1aO01BbU1IQyxXQUFXLEVBQUU7SUFuTVYsQ0FBUDtFQXFNSCxDQXJRRDtFQXVRQXpFLFVBQVUsQ0FBQzBFLFVBQVgsQ0FBc0IsZUFBdEIsRUFBdUMsUUFBdkM7QUFFQyxDQW5SRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9tb2RlL3NjaGVtZS9zY2hlbWUuanM/OThjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vKipcbiAqIEF1dGhvcjogS29oIFppIEhhbiwgYmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgS29oIFppIENodW5cbiAqIEltcHJvdmVkIGJ5OiBKYWt1YiBULiBKYW5raWV3aWN6XG4gKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJzY2hlbWVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBCVUlMVElOID0gXCJidWlsdGluXCIsIENPTU1FTlQgPSBcImNvbW1lbnRcIiwgU1RSSU5HID0gXCJzdHJpbmdcIixcbiAgICAgICAgU1lNQk9MID0gXCJzeW1ib2xcIiwgQVRPTSA9IFwiYXRvbVwiLCBOVU1CRVIgPSBcIm51bWJlclwiLCBCUkFDS0VUID0gXCJicmFja2V0XCI7XG4gICAgdmFyIElOREVOVF9XT1JEX1NLSVAgPSAyO1xuXG4gICAgZnVuY3Rpb24gbWFrZUtleXdvcmRzKHN0cikge1xuICAgICAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIGtleXdvcmRzID0gbWFrZUtleXdvcmRzKFwizrsgY2FzZS1sYW1iZGEgY2FsbC9jYyBjbGFzcyBjb25kLWV4cGFuZCBkZWZpbmUtY2xhc3MgZGVmaW5lLXZhbHVlcyBleGl0LWhhbmRsZXIgZmllbGQgaW1wb3J0IGluaGVyaXQgaW5pdC1maWVsZCBpbnRlcmZhY2UgbGV0Ki12YWx1ZXMgbGV0LXZhbHVlcyBsZXQvZWMgbWl4aW4gb3B0LWxhbWJkYSBvdmVycmlkZSBwcm90ZWN0IHByb3ZpZGUgcHVibGljIHJlbmFtZSByZXF1aXJlIHJlcXVpcmUtZm9yLXN5bnRheCBzeW50YXggc3ludGF4LWNhc2Ugc3ludGF4LWVycm9yIHVuaXQvc2lnIHVubGVzcyB3aGVuIHdpdGgtc3ludGF4IGFuZCBiZWdpbiBjYWxsLXdpdGgtY3VycmVudC1jb250aW51YXRpb24gY2FsbC13aXRoLWlucHV0LWZpbGUgY2FsbC13aXRoLW91dHB1dC1maWxlIGNhc2UgY29uZCBkZWZpbmUgZGVmaW5lLXN5bnRheCBkZWZpbmUtbWFjcm8gZGVmbWFjcm8gZGVsYXkgZG8gZHluYW1pYy13aW5kIGVsc2UgZm9yLWVhY2ggaWYgbGFtYmRhIGxldCBsZXQqIGxldC1zeW50YXggbGV0cmVjIGxldHJlYy1zeW50YXggbWFwIG9yIHN5bnRheC1ydWxlcyBhYnMgYWNvcyBhbmdsZSBhcHBlbmQgYXBwbHkgYXNpbiBhc3NvYyBhc3NxIGFzc3YgYXRhbiBib29sZWFuPyBjYWFyIGNhZHIgY2FsbC13aXRoLWlucHV0LWZpbGUgY2FsbC13aXRoLW91dHB1dC1maWxlIGNhbGwtd2l0aC12YWx1ZXMgY2FyIGNkZGRhciBjZGRkZHIgY2RyIGNlaWxpbmcgY2hhci0+aW50ZWdlciBjaGFyLWFscGhhYmV0aWM/IGNoYXItY2k8PT8gY2hhci1jaTw/IGNoYXItY2k9PyBjaGFyLWNpPj0/IGNoYXItY2k+PyBjaGFyLWRvd25jYXNlIGNoYXItbG93ZXItY2FzZT8gY2hhci1udW1lcmljPyBjaGFyLXJlYWR5PyBjaGFyLXVwY2FzZSBjaGFyLXVwcGVyLWNhc2U/IGNoYXItd2hpdGVzcGFjZT8gY2hhcjw9PyBjaGFyPD8gY2hhcj0/IGNoYXI+PT8gY2hhcj4/IGNoYXI/IGNsb3NlLWlucHV0LXBvcnQgY2xvc2Utb3V0cHV0LXBvcnQgY29tcGxleD8gY29ucyBjb3MgY3VycmVudC1pbnB1dC1wb3J0IGN1cnJlbnQtb3V0cHV0LXBvcnQgZGVub21pbmF0b3IgZGlzcGxheSBlb2Ytb2JqZWN0PyBlcT8gZXF1YWw/IGVxdj8gZXZhbCBldmVuPyBleGFjdC0+aW5leGFjdCBleGFjdD8gZXhwIGV4cHQgI2YgZmxvb3IgZm9yY2UgZ2NkIGltYWctcGFydCBpbmV4YWN0LT5leGFjdCBpbmV4YWN0PyBpbnB1dC1wb3J0PyBpbnRlZ2VyLT5jaGFyIGludGVnZXI/IGludGVyYWN0aW9uLWVudmlyb25tZW50IGxjbSBsZW5ndGggbGlzdCBsaXN0LT5zdHJpbmcgbGlzdC0+dmVjdG9yIGxpc3QtcmVmIGxpc3QtdGFpbCBsaXN0PyBsb2FkIGxvZyBtYWduaXR1ZGUgbWFrZS1wb2xhciBtYWtlLXJlY3Rhbmd1bGFyIG1ha2Utc3RyaW5nIG1ha2UtdmVjdG9yIG1heCBtZW1iZXIgbWVtcSBtZW12IG1pbiBtb2R1bG8gbmVnYXRpdmU/IG5ld2xpbmUgbm90IG51bGwtZW52aXJvbm1lbnQgbnVsbD8gbnVtYmVyLT5zdHJpbmcgbnVtYmVyPyBudW1lcmF0b3Igb2RkPyBvcGVuLWlucHV0LWZpbGUgb3Blbi1vdXRwdXQtZmlsZSBvdXRwdXQtcG9ydD8gcGFpcj8gcGVlay1jaGFyIHBvcnQ/IHBvc2l0aXZlPyBwcm9jZWR1cmU/IHF1YXNpcXVvdGUgcXVvdGUgcXVvdGllbnQgcmF0aW9uYWw/IHJhdGlvbmFsaXplIHJlYWQgcmVhZC1jaGFyIHJlYWwtcGFydCByZWFsPyByZW1haW5kZXIgcmV2ZXJzZSByb3VuZCBzY2hlbWUtcmVwb3J0LWVudmlyb25tZW50IHNldCEgc2V0LWNhciEgc2V0LWNkciEgc2luIHNxcnQgc3RyaW5nIHN0cmluZy0+bGlzdCBzdHJpbmctPm51bWJlciBzdHJpbmctPnN5bWJvbCBzdHJpbmctYXBwZW5kIHN0cmluZy1jaTw9PyBzdHJpbmctY2k8PyBzdHJpbmctY2k9PyBzdHJpbmctY2k+PT8gc3RyaW5nLWNpPj8gc3RyaW5nLWNvcHkgc3RyaW5nLWZpbGwhIHN0cmluZy1sZW5ndGggc3RyaW5nLXJlZiBzdHJpbmctc2V0ISBzdHJpbmc8PT8gc3RyaW5nPD8gc3RyaW5nPT8gc3RyaW5nPj0/IHN0cmluZz4/IHN0cmluZz8gc3Vic3RyaW5nIHN5bWJvbC0+c3RyaW5nIHN5bWJvbD8gI3QgdGFuIHRyYW5zY3JpcHQtb2ZmIHRyYW5zY3JpcHQtb24gdHJ1bmNhdGUgdmFsdWVzIHZlY3RvciB2ZWN0b3ItPmxpc3QgdmVjdG9yLWZpbGwhIHZlY3Rvci1sZW5ndGggdmVjdG9yLXJlZiB2ZWN0b3Itc2V0ISB3aXRoLWlucHV0LWZyb20tZmlsZSB3aXRoLW91dHB1dC10by1maWxlIHdyaXRlIHdyaXRlLWNoYXIgemVybz9cIik7XG4gICAgdmFyIGluZGVudEtleXMgPSBtYWtlS2V5d29yZHMoXCJkZWZpbmUgbGV0IGxldHJlYyBsZXQqIGxhbWJkYSBkZWZpbmUtbWFjcm8gZGVmbWFjcm8gbGV0LXN5bnRheCBsZXRyZWMtc3ludGF4IGxldC12YWx1ZXMgbGV0Ki12YWx1ZXMgZGVmaW5lLXN5bnRheCBzeW50YXgtcnVsZXMgZGVmaW5lLXZhbHVlcyB3aGVuIHVubGVzc1wiKTtcblxuICAgIGZ1bmN0aW9uIHN0YXRlU3RhY2soaW5kZW50LCB0eXBlLCBwcmV2KSB7IC8vIHJlcHJlc2VudHMgYSBzdGF0ZSBzdGFjayBvYmplY3RcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnQsIHR5cGUpIHtcbiAgICAgICAgc3RhdGUuaW5kZW50U3RhY2sgPSBuZXcgc3RhdGVTdGFjayhpbmRlbnQsIHR5cGUsIHN0YXRlLmluZGVudFN0YWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3BTdGFjayhzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5pbmRlbnRTdGFjayA9IHN0YXRlLmluZGVudFN0YWNrLnByZXY7XG4gICAgfVxuXG4gICAgdmFyIGJpbmFyeU1hdGNoZXIgPSBuZXcgUmVnRXhwKC9eKD86Wy0rXWl8Wy0rXVswMV0rIyooPzpcXC9bMDFdKyMqKT9pfFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopP0BbLStdP1swMV0rIyooPzpcXC9bMDFdKyMqKT98Wy0rXT9bMDFdKyMqKD86XFwvWzAxXSsjKik/Wy0rXSg/OlswMV0rIyooPzpcXC9bMDFdKyMqKT8pP2l8Wy0rXT9bMDFdKyMqKD86XFwvWzAxXSsjKik/KSg/PVsoKVxccztcIl18JCkvaSk7XG4gICAgdmFyIG9jdGFsTWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdWzAtN10rIyooPzpcXC9bMC03XSsjKik/aXxbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP0BbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP3xbLStdP1swLTddKyMqKD86XFwvWzAtN10rIyopP1stK10oPzpbMC03XSsjKig/OlxcL1swLTddKyMqKT8pP2l8Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT8pKD89WygpXFxzO1wiXXwkKS9pKTtcbiAgICB2YXIgaGV4TWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdW1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/aXxbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP0BbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP3xbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP1stK10oPzpbXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT8pP2l8Wy0rXT9bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT8pKD89WygpXFxzO1wiXXwkKS9pKTtcbiAgICB2YXIgZGVjaW1hbE1hdGNoZXIgPSBuZXcgUmVnRXhwKC9eKD86Wy0rXWl8Wy0rXSg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKWl8Wy0rXT8oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKilAWy0rXT8oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKil8Wy0rXT8oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKilbLStdKD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopP2l8KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopKSg/PVsoKVxccztcIl18JCkvaSk7XG5cbiAgICBmdW5jdGlvbiBpc0JpbmFyeU51bWJlciAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goYmluYXJ5TWF0Y2hlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbE51bWJlciAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2gob2N0YWxNYXRjaGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxOdW1iZXIgKHN0cmVhbSwgYmFja3VwKSB7XG4gICAgICAgIGlmIChiYWNrdXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChkZWNpbWFsTWF0Y2hlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhOdW1iZXIgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKGhleE1hdGNoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NFc2NhcGVkU2VxdWVuY2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZXh0LCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IG9wdGlvbnMudG9rZW4gJiYgIWVzY2FwZWQpIHtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdGUubW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZGVudFN0YWNrOiBudWxsLFxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uOiAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNFeHByQ29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc0V4cHJRdW90ZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCAmJiBzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaW5kZW50YXRpb24sIGJ1dCBvbmx5IGlmIGluZGVudFN0YWNrIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBzcGFjZXNcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2goc3RhdGUubW9kZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiAvLyBtdWx0aS1saW5lIHN0cmluZyBwYXJzaW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0VzY2FwZWRTZXF1ZW5jZShzdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBcIlxcXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IFNUUklORzsgLy8gY29udGludWUgb24gaW4gc2NoZW1lLXN0cmluZyBtb2RlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjogLy8gZXNjYXBlIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXNjYXBlZFNlcXVlbmNlKHN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IFwifFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gU1lNQk9MOyAvLyBjb250aW51ZSBvbiBpbiBzY2hlbWUtc3ltYm9sIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjogLy8gY29tbWVudCBwYXJzaW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQsIG1heWJlRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IFwiI1wiICYmIG1heWJlRW5kKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZUVuZCA9IChuZXh0ID09IFwifFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInMtZXhwci1jb21tZW50XCI6IC8vIHMtZXhwciBjb21tZW50aW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZihzdHJlYW0ucGVlaygpID09IFwiKFwiIHx8IHN0cmVhbS5wZWVrKCkgPT0gXCJbXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgc3RhcnQgc2NoZW1lIHMtZXhwciBjb21tZW50aW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNFeHByQ29tbWVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHdlIGp1c3QgY29tbWVudCB0aGUgZW50aXJlIG9mIHRoZSBuZXh0IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzXFwoXFwpXFxbXFxdXS8pOyAvLyBlYXQgc3ltYm9sIGF0b21cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAvLyBkZWZhdWx0IHBhcnNpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gU1RSSU5HO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiKFwiIHx8IHN0cmVhbS5wZWVrKCkgPT0gXCJbXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUuc0V4cHJRdW90ZSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNFeHByUXVvdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBhbHJlYWR5IGluIGEgcXVvdGVkIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X1xcLSEkJSYqK1xcLlxcLzo8PT4/QFxcXn5dLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEFUT007XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gXCJzeW1ib2xcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBTWU1CT0w7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcInxcIikpIHsgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBcImNvbW1lbnRcIjsgLy8gdG9nZ2xlIHRvIGNvbW1lbnQgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KC9bdGZdL2kpKSB7ICAgICAgICAgICAgLy8gI3QvI2YgKGF0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEFUT007XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoJzsnKSkgeyAgICAgICAgICAgICAgICAvLyBTLUV4cHIgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBcInMtZXhwci1jb21tZW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1UZXN0ID0gbnVsbCwgaGFzRXhhY3RuZXNzID0gZmFsc2UsIGhhc1JhZGl4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmVhdCgvW2VpXS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNFeGFjdG5lc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7ICAgICAgIC8vIG11c3QgYmUgcmFkaXggc3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14jYi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1UZXN0ID0gaXNCaW5hcnlOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14jby9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1UZXN0ID0gaXNPY3RhbE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiN4L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRlc3QgPSBpc0hleE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiNkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRlc3QgPSBpc0RlY2ltYWxOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bLSswLTkuXS8sIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSYWRpeCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1UZXN0ID0gaXNEZWNpbWFsTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWNvbnN1bWUgdGhlIGluaXRpYWwgIyBpZiBhbGwgbWF0Y2hlcyBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFoYXNFeGFjdG5lc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdCgnIycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVGVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNSYWRpeCAmJiAhaGFzRXhhY3RuZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdW1lIG9wdGlvbmFsIGV4YWN0bmVzcyBhZnRlciByYWRpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eI1tlaV0vaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVRlc3Qoc3RyZWFtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBOVU1CRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eWy0rMC05Ll0vLnRlc3QoY2gpICYmIGlzRGVjaW1hbE51bWJlcihzdHJlYW0sIHRydWUpKSB7IC8vIG1hdGNoIG5vbi1wcmVmaXhlZCBudW1iZXIsIG11c3QgYmUgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IE5VTUJFUjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjtcIikgeyAvLyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7IC8vIHJlc3Qgb2YgdGhlIGxpbmUgaXMgYSBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIihcIiB8fCBjaCA9PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlXb3JkID0gJyc7IHZhciBpbmRlbnRUZW1wID0gc3RyZWFtLmNvbHVtbigpLCBsZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgIEVpdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgKGluZGVudC13b3JkIC4uXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9uLWluZGVudC13b3JkIC4uXG4gICAgICAgICAgICAgICAgICAgICAgICAoO3NvbWV0aGluZyBlbHNlLCBicmFja2V0LCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGxldHRlciA9IHN0cmVhbS5lYXQoL1teXFxzXFwoXFxbXFw7XFwpXFxdXS8pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5V29yZCArPSBsZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlXb3JkLmxlbmd0aCA+IDAgJiYgaW5kZW50S2V5cy5wcm9wZXJ0eUlzRW51bWVyYWJsZShrZXlXb3JkKSkgeyAvLyBpbmRlbnQtd29yZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnRUZW1wICsgSU5ERU5UX1dPUkRfU0tJUCwgY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gbm9uLWluZGVudCB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY29udGludWUgZWF0aW5nIHRoZSBzcGFjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmVvbCgpIHx8IHN0cmVhbS5wZWVrKCkgPT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBzaWduaWZpY2FudCBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXN0YXJ0IGluZGVudGF0aW9uIDEgc3BhY2UgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnRUZW1wICsgMSwgY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hTdGFjayhzdGF0ZSwgaW5kZW50VGVtcCArIHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoLCBjaCk7IC8vIGVsc2Ugd2UgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoIC0gMSk7IC8vIHVuZG8gYWxsIHRoZSBlYXRpbmdcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHN0YXRlLnNFeHByQ29tbWVudCA9PSBcIm51bWJlclwiKSBzdGF0ZS5zRXhwckNvbW1lbnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlID09IFwibnVtYmVyXCIpIHN0YXRlLnNFeHByUXVvdGUrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEJSQUNLRVQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIpXCIgfHwgY2ggPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBCUkFDS0VUO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmluZGVudFN0YWNrICE9IG51bGwgJiYgc3RhdGUuaW5kZW50U3RhY2sudHlwZSA9PSAoY2ggPT0gXCIpXCIgPyBcIihcIiA6IFwiW1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcFN0YWNrKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwckNvbW1lbnQgPT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKC0tc3RhdGUuc0V4cHJDb21tZW50ID09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7IC8vIGZpbmFsIGNsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc0V4cHJDb21tZW50ID0gZmFsc2U7IC8vIHR1cm4gb2ZmIHMtZXhwciBjb21tZW50aW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2Ygc3RhdGUuc0V4cHJRdW90ZSA9PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoLS1zdGF0ZS5zRXhwclF1b3RlID09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEFUT007IC8vIGZpbmFsIGNsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc0V4cHJRdW90ZSA9IGZhbHNlOyAvLyB0dXJuIG9mZiBzLWV4cHIgcXVvdGUgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X1xcLSEkJSYqK1xcLlxcLzo8PT4/QFxcXn5dLyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBCVUlMVElOO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHJldHVyblR5cGUgPSBcInZhcmlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHN0YXRlLnNFeHByQ29tbWVudCA9PSBcIm51bWJlclwiKSA/IENPTU1FTlQgOiAoKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlID09IFwibnVtYmVyXCIpID8gQVRPTSA6IHJldHVyblR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCkgcmV0dXJuIHN0YXRlLmluZGVudGF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudFN0YWNrLmluZGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBmb2xkOiBcImJyYWNlLXBhcmVuXCIsXG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHtwYWlyczogXCIoKVtde31cXFwiXFxcIlwifSxcbiAgICAgICAgbGluZUNvbW1lbnQ6IFwiOztcIlxuICAgIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNjaGVtZVwiLCBcInNjaGVtZVwiKTtcblxufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwiZGVmaW5lTW9kZSIsIkJVSUxUSU4iLCJDT01NRU5UIiwiU1RSSU5HIiwiU1lNQk9MIiwiQVRPTSIsIk5VTUJFUiIsIkJSQUNLRVQiLCJJTkRFTlRfV09SRF9TS0lQIiwibWFrZUtleXdvcmRzIiwic3RyIiwib2JqIiwid29yZHMiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJrZXl3b3JkcyIsImluZGVudEtleXMiLCJzdGF0ZVN0YWNrIiwiaW5kZW50IiwidHlwZSIsInByZXYiLCJwdXNoU3RhY2siLCJzdGF0ZSIsImluZGVudFN0YWNrIiwicG9wU3RhY2siLCJiaW5hcnlNYXRjaGVyIiwiUmVnRXhwIiwib2N0YWxNYXRjaGVyIiwiaGV4TWF0Y2hlciIsImRlY2ltYWxNYXRjaGVyIiwiaXNCaW5hcnlOdW1iZXIiLCJzdHJlYW0iLCJtYXRjaCIsImlzT2N0YWxOdW1iZXIiLCJpc0RlY2ltYWxOdW1iZXIiLCJiYWNrdXAiLCJiYWNrVXAiLCJpc0hleE51bWJlciIsInByb2Nlc3NFc2NhcGVkU2VxdWVuY2UiLCJvcHRpb25zIiwibmV4dCIsImVzY2FwZWQiLCJ0b2tlbiIsIm1vZGUiLCJzdGFydFN0YXRlIiwiaW5kZW50YXRpb24iLCJzRXhwckNvbW1lbnQiLCJzRXhwclF1b3RlIiwic29sIiwiZWF0U3BhY2UiLCJyZXR1cm5UeXBlIiwibWF5YmVFbmQiLCJwZWVrIiwiZWF0V2hpbGUiLCJjaCIsImVhdCIsIm51bVRlc3QiLCJoYXNFeGFjdG5lc3MiLCJoYXNSYWRpeCIsInRlc3QiLCJza2lwVG9FbmQiLCJrZXlXb3JkIiwiaW5kZW50VGVtcCIsImNvbHVtbiIsImxldHRlciIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZW9sIiwiY3VycmVudCIsImZvbGQiLCJjbG9zZUJyYWNrZXRzIiwicGFpcnMiLCJsaW5lQ29tbWVudCIsImRlZmluZU1JTUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/scheme/scheme.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/scheme/scheme.js");
/******/ 	
/******/ })()
;