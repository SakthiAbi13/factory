/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/verilog/verilog.js":
/*!*************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/verilog/verilog.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"verilog\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n        dontAlignCalls = parserConfig.dontAlignCalls,\n        // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n    // indentation follows the same rules as everything else. Otherwise if\n    // false, compiler directives will track their own indentation.\n    // For example, `ifdef nested inside another `ifndef will be indented,\n    // but a `ifdef inside a function block may not be indented.\n    compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n        noIndentKeywords = parserConfig.noIndentKeywords || [],\n        multiLineStrings = parserConfig.multiLineStrings,\n        hooks = parserConfig.hooks || {};\n\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n    /**\n     * Keywords from IEEE 1800-2012\n     */\n\n\n    var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n    /** Operators from IEEE 1800-2012\n       unary_operator ::=\n         + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_operator ::=\n         + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n         | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n         | -> | <->\n       inc_or_dec_operator ::= ++ | --\n       unary_module_path_operator ::=\n         ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_module_path_operator ::=\n         == | != | && | || | & | | | ^ | ^~ | ~^\n    */\n\n    var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n    var isBracketChar = /[\\[\\]{}()]/;\n    var unsignedNumber = /\\d[0-9_]*/;\n    var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n    var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n    var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n    var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n    var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n    var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n    var closingBracket = /[)}\\]]/;\n    var compilerDirectiveRegex = new RegExp(\"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" + \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n    var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n    var compilerDirectiveEndRegex = /^(`(?:elsif|else|endif))\\b/;\n    var curPunc;\n    var curKeyword; // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n    // E.g. \"task\" => \"endtask\"\n\n    var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\"); // Opening/closing pairs\n\n    var openClose = {};\n\n    for (var keyword in blockKeywords) {\n      openClose[keyword] = \"end\" + keyword;\n    }\n\n    openClose[\"begin\"] = \"end\";\n    openClose[\"casex\"] = \"endcase\";\n    openClose[\"casez\"] = \"endcase\";\n    openClose[\"do\"] = \"while\";\n    openClose[\"fork\"] = \"join;join_any;join_none\";\n    openClose[\"covergroup\"] = \"endgroup\";\n    openClose[\"macro_begin\"] = \"macro_end\";\n\n    for (var i in noIndentKeywords) {\n      var keyword = noIndentKeywords[i];\n\n      if (openClose[keyword]) {\n        openClose[keyword] = undefined;\n      }\n    } // Keywords which open statements that are ended with a semi-colon\n\n\n    var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(),\n          style;\n      if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n      if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n\n      if (/[,;:\\.]/.test(ch)) {\n        curPunc = stream.next();\n        return null;\n      }\n\n      if (isBracketChar.test(ch)) {\n        curPunc = stream.next();\n        return \"bracket\";\n      } // Macros (tick-defines)\n\n\n      if (ch == '`') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          var cur = stream.current();\n          curKeyword = cur; // Macros that end in _begin, are start of block and end with _end\n\n          if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n            var keywordClose = curKeyword.substr(0, curKeyword.length - 5) + \"end\";\n            openClose[cur] = keywordClose;\n            curPunc = \"newblock\";\n          } else {\n            stream.eatSpace();\n\n            if (stream.peek() == '(') {\n              // Check if this is a block\n              curPunc = \"newmacro\";\n            }\n\n            var withSpace = stream.current(); // Move the stream back before the spaces\n\n            stream.backUp(withSpace.length - cur.length);\n          }\n\n          return \"def\";\n        } else {\n          return null;\n        }\n      } // System calls\n\n\n      if (ch == '$') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          return \"meta\";\n        } else {\n          return null;\n        }\n      } // Time literals\n\n\n      if (ch == '#') {\n        stream.next();\n        stream.eatWhile(/[\\d_.]/);\n        return \"def\";\n      } // Event\n\n\n      if (ch == '@') {\n        stream.next();\n        stream.eatWhile(/[@]/);\n        return \"def\";\n      } // Strings\n\n\n      if (ch == '\"') {\n        stream.next();\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Comments\n\n\n      if (ch == \"/\") {\n        stream.next();\n\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        stream.backUp(1);\n      } // Numeric literals\n\n\n      if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n        return \"number\";\n      } // Operators\n\n\n      if (stream.eatWhile(isOperatorChar)) {\n        curPunc = stream.current();\n        return \"meta\";\n      } // Keywords / plain variables\n\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n\n        if (keywords[cur]) {\n          if (openClose[cur]) {\n            curPunc = \"newblock\";\n\n            if (cur === \"fork\") {\n              // Fork can be a statement instead of block in cases of:\n              // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n              stream.eatSpace();\n\n              if (stream.peek() == ';') {\n                curPunc = \"newstatement\";\n              }\n\n              stream.backUp(stream.current().length - cur.length);\n            }\n          }\n\n          if (statementKeywords[cur]) {\n            curPunc = \"newstatement\";\n          }\n\n          curKeyword = cur;\n          return \"keyword\";\n        }\n\n        return \"variable\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, scopekind, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.scopekind = scopekind;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type, scopekind) {\n      var indent = state.indented;\n      var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n      return state.context = c;\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n\n      if (t == \")\" || t == \"]\" || t == \"}\") {\n        state.indented = state.context.indented;\n      }\n\n      return state.context = state.context.prev;\n    }\n\n    function isClosing(text, contextClosing) {\n      if (text == contextClosing) {\n        return true;\n      } else {\n        // contextClosing may be multiple keywords separated by ;\n        var closingKeywords = contextClosing.split(\";\");\n\n        for (var i in closingKeywords) {\n          if (text == closingKeywords[i]) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }\n\n    function isInsideScopeKind(ctx, scopekind) {\n      if (ctx == null) {\n        return false;\n      }\n\n      if (ctx.scopekind === scopekind) {\n        return true;\n      }\n\n      return isInsideScopeKind(ctx.prev, scopekind);\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on any bracket char: {}()[]\n      // or on a match of any of the block closing keywords, at\n      // the end of a line\n      var allClosings = [];\n\n      for (var i in openClose) {\n        if (openClose[i]) {\n          var closings = openClose[i].split(\";\");\n\n          for (var j in closings) {\n            allClosings.push(closings[j]);\n          }\n        }\n      }\n\n      var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n      return re;\n    } // Interface\n\n\n    return {\n      // Regex to force current line to reindent\n      electricInput: buildElectricInputRegEx(),\n      startState: function startState(basecolumn) {\n        var state = {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n          indented: 0,\n          compilerDirectiveIndented: 0,\n          startOfLine: true\n        };\n        if (hooks.startState) hooks.startState(state);\n        return state;\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (hooks.token) {\n          // Call hook, with an optional return value of a style to override verilog styling.\n          var style = hooks.token(stream, state);\n\n          if (style !== undefined) {\n            return style;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        curKeyword = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n\n        if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n          if ((curPunc === \"=\" || curPunc === \"<=\") && !isInsideScopeKind(ctx, \"assignment\")) {\n            // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n            //      Search through the context to see if we are already in an assignment.\n            // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n            pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n            if (ctx.align == null) ctx.align = true;\n          }\n\n          return style;\n        }\n\n        if (ctx.align == null) ctx.align = true;\n        var isClosingAssignment = ctx.type == \"assignment\" && closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n\n        if (curPunc == ctx.type || isClosingAssignment) {\n          if (isClosingAssignment) {\n            ctx = popContext(state);\n          }\n\n          ctx = popContext(state);\n\n          if (curPunc == \")\") {\n            // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n            if (ctx && ctx.type === \"macro\") {\n              ctx = popContext(state);\n\n              while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) {\n                ctx = popContext(state);\n              }\n            }\n          } else if (curPunc == \"}\") {\n            // Handle closing statements like constraint block: \"foreach () {}\" which\n            // do not have semicolon at end.\n            if (ctx && ctx.type === \"statement\") {\n              while (ctx && ctx.type == \"statement\") {\n                ctx = popContext(state);\n              }\n            }\n          }\n        } else if ((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\") || ctx.type && isClosing(curKeyword, ctx.type)) {\n          ctx = popContext(state);\n\n          while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) {\n            ctx = popContext(state);\n          }\n        } else if (curPunc == \"{\") {\n          pushContext(state, stream.column(), \"}\");\n        } else if (curPunc == \"[\") {\n          pushContext(state, stream.column(), \"]\");\n        } else if (curPunc == \"(\") {\n          pushContext(state, stream.column(), \")\");\n        } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n          pushContext(state, stream.column(), \"statement\", \"case\");\n        } else if (curPunc == \"newstatement\") {\n          pushContext(state, stream.column(), \"statement\", curKeyword);\n        } else if (curPunc == \"newblock\") {\n          if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {// The 'function' keyword can appear in some other contexts where it actually does not\n            // indicate a function (import/export DPI and covergroup definitions).\n            // Do nothing in this case\n          } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {// Same thing for task\n          } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {// Same thing for class (e.g. typedef)\n          } else {\n            var close = openClose[curKeyword];\n            pushContext(state, stream.column(), close, curKeyword);\n          }\n        } else if (curPunc == \"newmacro\" || curKeyword && curKeyword.match(compilerDirectiveRegex)) {\n          if (curPunc == \"newmacro\") {\n            // Macros (especially if they have parenthesis) potentially have a semicolon\n            // or complete statement/block inside, and should be treated as such.\n            pushContext(state, stream.column(), \"macro\", \"macro\");\n          }\n\n          if (curKeyword.match(compilerDirectiveEndRegex)) {\n            state.compilerDirectiveIndented -= statementIndentUnit;\n          }\n\n          if (curKeyword.match(compilerDirectiveBeginRegex)) {\n            state.compilerDirectiveIndented += statementIndentUnit;\n          }\n        }\n\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n\n        if (hooks.indent) {\n          var fromHook = hooks.indent(state);\n          if (fromHook >= 0) return fromHook;\n        }\n\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = false;\n        var possibleClosing = textAfter.match(closingBracketOrWord);\n        if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n\n        if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n          if (textAfter.match(compilerDirectiveEndRegex)) {\n            return state.compilerDirectiveIndented - statementIndentUnit;\n          }\n\n          return state.compilerDirectiveIndented;\n        }\n\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\") && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  }); // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",\n    // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",\n    // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  }; // Lines starting with these characters define scope (result in indentation).\n\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/; // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit; // TODO: Pass this in instead.\n\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  } // Return true if the next thing in the stream is an identifier with a mnemonic.\n\n\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n    hooks: {\n      electricInput: false,\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function token(stream, state) {\n        var style = undefined;\n        var match; // Return value of pattern matches.\n        // Set highlighting mode based on code region (TLV or SV).\n\n        if (stream.sol() && !state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)) {\n              state.tlvCodeActive = true;\n            }\n          } // Correct indentation in the face of a line prefix char.\n\n\n          if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          } // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n\n\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n\n              if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit; // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n\n                  if (tlvTrackStatements) {\n                    state.statementComment = false;\n                  }\n\n                  depth++;\n                }\n              }\n            } // Clear out deeper indentation levels unless line is blank.\n\n\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          } // Set next level of indentation.\n\n\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n          var beginStatement = false;\n\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement = stream.peek() != \" \" && // not a space\n            style === undefined && // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n            stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n\n              state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\");\n          } else if (stream.pos / tlvIndentUnit < state.tlvIndentationStyle.length && (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n            // codemirror from combining spans\n            \"tlv-indent-\" + (stream.pos % 2 == 0 ? \"even\" : \"odd\") + // and style it\n            \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\"); // Style the line prefix character.\n\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            } // Place a class before a scope identifier.\n\n\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n\n            if ( // is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) && ( // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\");\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = match[1] == \"+\" ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)) {\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n\n        return style;\n      },\n      indent: function indent(state) {\n        return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n      },\n      startState: function startState(state) {\n        state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n\n        state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n\n        state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n\n        state.tlvInBlockComment = false; // True inside /**/ comment.\n\n        if (tlvTrackStatements) {\n          state.statementComment = false; // True inside a statement's header comment.\n        }\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS92ZXJpbG9nL3Zlcmlsb2cuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBLENBQUMsVUFBU0EsR0FBVCxFQUFjO0VBQ2IsSUFBSSxzQkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QixzQkFBT0MsTUFBUCxNQUFpQixRQUFuRCxFQUE2RDtJQUMzREYsR0FBRyxDQUFDRyxtQkFBTyxDQUFDLG1KQUFELENBQVIsQ0FBSCxDQURGLEtBRUssSUFBSSxJQUFKLEVBQStDO0lBQ2xEQyxpQ0FBTyxDQUFDLG1KQUFELENBQUQsb0NBQTJCSixHQUEzQjtBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURHLEtBRUE7SUFDSEEsRUFBQTtBQUNILENBUEQsRUFPRyxVQUFTTSxVQUFULEVBQXFCO0VBQ3hCOztFQUVBQSxVQUFVLENBQUNDLFVBQVgsQ0FBc0IsU0FBdEIsRUFBaUMsVUFBU0MsTUFBVCxFQUFpQkMsWUFBakIsRUFBK0I7SUFFOUQsSUFBSUMsVUFBVSxHQUFHRixNQUFNLENBQUNFLFVBQXhCO0lBQUEsSUFDSUMsbUJBQW1CLEdBQUdGLFlBQVksQ0FBQ0UsbUJBQWIsSUFBb0NELFVBRDlEO0lBQUEsSUFFSUUsY0FBYyxHQUFHSCxZQUFZLENBQUNHLGNBRmxDO0lBQUEsSUFHSTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0FDLHVDQUF1QyxHQUFHSixZQUFZLENBQUNJLHVDQVIzRDtJQUFBLElBU0lDLGdCQUFnQixHQUFHTCxZQUFZLENBQUNLLGdCQUFiLElBQWlDLEVBVHhEO0lBQUEsSUFVSUMsZ0JBQWdCLEdBQUdOLFlBQVksQ0FBQ00sZ0JBVnBDO0lBQUEsSUFXSUMsS0FBSyxHQUFHUCxZQUFZLENBQUNPLEtBQWIsSUFBc0IsRUFYbEM7O0lBYUEsU0FBU0MsS0FBVCxDQUFlQyxHQUFmLEVBQW9CO01BQ2xCLElBQUlDLEdBQUcsR0FBRyxFQUFWO01BQUEsSUFBY0YsS0FBSyxHQUFHQyxHQUFHLENBQUNFLEtBQUosQ0FBVSxHQUFWLENBQXRCOztNQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osS0FBSyxDQUFDSyxNQUExQixFQUFrQyxFQUFFRCxDQUFwQztRQUF1Q0YsR0FBRyxDQUFDRixLQUFLLENBQUNJLENBQUQsQ0FBTixDQUFILEdBQWdCLElBQWhCO01BQXZDOztNQUNBLE9BQU9GLEdBQVA7SUFDRDtJQUVEO0FBQ0Y7QUFDQTs7O0lBQ0UsSUFBSUksUUFBUSxHQUFHTixLQUFLLENBQ2xCLG9IQUNBLGdIQURBLEdBRUEsK0dBRkEsR0FHQSwyR0FIQSxHQUlBLGdIQUpBLEdBS0EsK0dBTEEsR0FNQSxpSEFOQSxHQU9BLGdIQVBBLEdBUUEsK0dBUkEsR0FTQSw2R0FUQSxHQVVBLG1HQVZBLEdBV0EsMkdBWEEsR0FZQSxnSEFaQSxHQWFBLDBHQWJBLEdBY0EsNEdBZEEsR0FlQSxnSEFmQSxHQWdCQSxpSEFoQkEsR0FpQkEsb0ZBbEJrQixDQUFwQjtJQW9CQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDRSxJQUFJTyxjQUFjLEdBQUcsdUJBQXJCO0lBQ0EsSUFBSUMsYUFBYSxHQUFHLFlBQXBCO0lBRUEsSUFBSUMsY0FBYyxHQUFHLFdBQXJCO0lBQ0EsSUFBSUMsY0FBYyxHQUFHLHlCQUFyQjtJQUNBLElBQUlDLGFBQWEsR0FBRyw4QkFBcEI7SUFDQSxJQUFJQyxVQUFVLEdBQUcsZ0NBQWpCO0lBQ0EsSUFBSUMsVUFBVSxHQUFHLHdDQUFqQjtJQUNBLElBQUlDLFdBQVcsR0FBRyx3REFBbEI7SUFFQSxJQUFJQyxvQkFBb0IsR0FBRyxtQkFBM0I7SUFDQSxJQUFJQyxjQUFjLEdBQUcsUUFBckI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBUSxJQUFJQyxNQUFKLENBQ2hDLDRHQUNBLDhHQUZnQyxDQUFsQztJQUdBLElBQUlDLDJCQUEyQixHQUFHLG1DQUFsQztJQUNBLElBQUlDLHlCQUF5QixHQUFLLDRCQUFsQztJQUVBLElBQUlDLE9BQUo7SUFDQSxJQUFJQyxVQUFKLENBNUU4RCxDQThFOUQ7SUFDQTs7SUFDQSxJQUFJQyxhQUFhLEdBQUd2QixLQUFLLENBQ3ZCLG1GQUNBLHdEQUZ1QixDQUF6QixDQWhGOEQsQ0FxRjlEOztJQUNBLElBQUl3QixTQUFTLEdBQUcsRUFBaEI7O0lBQ0EsS0FBSyxJQUFJQyxPQUFULElBQW9CRixhQUFwQixFQUFtQztNQUNqQ0MsU0FBUyxDQUFDQyxPQUFELENBQVQsR0FBcUIsUUFBUUEsT0FBN0I7SUFDRDs7SUFDREQsU0FBUyxDQUFDLE9BQUQsQ0FBVCxHQUFxQixLQUFyQjtJQUNBQSxTQUFTLENBQUMsT0FBRCxDQUFULEdBQXFCLFNBQXJCO0lBQ0FBLFNBQVMsQ0FBQyxPQUFELENBQVQsR0FBcUIsU0FBckI7SUFDQUEsU0FBUyxDQUFDLElBQUQsQ0FBVCxHQUFxQixPQUFyQjtJQUNBQSxTQUFTLENBQUMsTUFBRCxDQUFULEdBQXFCLHlCQUFyQjtJQUNBQSxTQUFTLENBQUMsWUFBRCxDQUFULEdBQTBCLFVBQTFCO0lBQ0FBLFNBQVMsQ0FBQyxhQUFELENBQVQsR0FBMkIsV0FBM0I7O0lBRUEsS0FBSyxJQUFJcEIsQ0FBVCxJQUFjUCxnQkFBZCxFQUFnQztNQUM5QixJQUFJNEIsT0FBTyxHQUFHNUIsZ0JBQWdCLENBQUNPLENBQUQsQ0FBOUI7O01BQ0EsSUFBSW9CLFNBQVMsQ0FBQ0MsT0FBRCxDQUFiLEVBQXdCO1FBQ3RCRCxTQUFTLENBQUNDLE9BQUQsQ0FBVCxHQUFxQkMsU0FBckI7TUFDRDtJQUNGLENBdkc2RCxDQXlHOUQ7OztJQUNBLElBQUlDLGlCQUFpQixHQUFHM0IsS0FBSyxDQUFDLDhJQUFELENBQTdCOztJQUVBLFNBQVM0QixTQUFULENBQW1CQyxNQUFuQixFQUEyQkMsS0FBM0IsRUFBa0M7TUFDaEMsSUFBSUMsRUFBRSxHQUFHRixNQUFNLENBQUNHLElBQVAsRUFBVDtNQUFBLElBQXdCQyxLQUF4QjtNQUNBLElBQUlsQyxLQUFLLENBQUNnQyxFQUFELENBQUwsSUFBYSxDQUFDRSxLQUFLLEdBQUdsQyxLQUFLLENBQUNnQyxFQUFELENBQUwsQ0FBVUYsTUFBVixFQUFrQkMsS0FBbEIsQ0FBVCxLQUFzQyxLQUF2RCxFQUE4RCxPQUFPRyxLQUFQO01BQzlELElBQUlsQyxLQUFLLENBQUM2QixTQUFOLElBQW1CLENBQUNLLEtBQUssR0FBR2xDLEtBQUssQ0FBQzZCLFNBQU4sQ0FBZ0JDLE1BQWhCLEVBQXdCQyxLQUF4QixDQUFULEtBQTRDLEtBQW5FLEVBQ0UsT0FBT0csS0FBUDs7TUFFRixJQUFJLFVBQVVDLElBQVYsQ0FBZUgsRUFBZixDQUFKLEVBQXdCO1FBQ3RCVixPQUFPLEdBQUdRLE1BQU0sQ0FBQ00sSUFBUCxFQUFWO1FBQ0EsT0FBTyxJQUFQO01BQ0Q7O01BQ0QsSUFBSTNCLGFBQWEsQ0FBQzBCLElBQWQsQ0FBbUJILEVBQW5CLENBQUosRUFBNEI7UUFDMUJWLE9BQU8sR0FBR1EsTUFBTSxDQUFDTSxJQUFQLEVBQVY7UUFDQSxPQUFPLFNBQVA7TUFDRCxDQWIrQixDQWNoQzs7O01BQ0EsSUFBSUosRUFBRSxJQUFJLEdBQVYsRUFBZTtRQUNiRixNQUFNLENBQUNNLElBQVA7O1FBQ0EsSUFBSU4sTUFBTSxDQUFDTyxRQUFQLENBQWdCLFNBQWhCLENBQUosRUFBZ0M7VUFDOUIsSUFBSUMsR0FBRyxHQUFHUixNQUFNLENBQUNTLE9BQVAsRUFBVjtVQUNBaEIsVUFBVSxHQUFHZSxHQUFiLENBRjhCLENBRzlCOztVQUNBLElBQUlBLEdBQUcsQ0FBQ0UsVUFBSixDQUFlLE9BQWYsS0FBMkJGLEdBQUcsQ0FBQ0csUUFBSixDQUFhLFFBQWIsQ0FBL0IsRUFBdUQ7WUFDckQsSUFBSUMsWUFBWSxHQUFHbkIsVUFBVSxDQUFDb0IsTUFBWCxDQUFrQixDQUFsQixFQUFvQnBCLFVBQVUsQ0FBQ2pCLE1BQVgsR0FBb0IsQ0FBeEMsSUFBNkMsS0FBaEU7WUFDQW1CLFNBQVMsQ0FBQ2EsR0FBRCxDQUFULEdBQWlCSSxZQUFqQjtZQUNBcEIsT0FBTyxHQUFHLFVBQVY7VUFDRCxDQUpELE1BSU87WUFDTFEsTUFBTSxDQUFDYyxRQUFQOztZQUNBLElBQUlkLE1BQU0sQ0FBQ0csSUFBUCxNQUFpQixHQUFyQixFQUEwQjtjQUN4QjtjQUNBWCxPQUFPLEdBQUcsVUFBVjtZQUNEOztZQUNELElBQUl1QixTQUFTLEdBQUdmLE1BQU0sQ0FBQ1MsT0FBUCxFQUFoQixDQU5LLENBT0w7O1lBQ0FULE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBY0QsU0FBUyxDQUFDdkMsTUFBVixHQUFtQmdDLEdBQUcsQ0FBQ2hDLE1BQXJDO1VBQ0Q7O1VBQ0QsT0FBTyxLQUFQO1FBQ0QsQ0FuQkQsTUFtQk87VUFDTCxPQUFPLElBQVA7UUFDRDtNQUNGLENBdkMrQixDQXdDaEM7OztNQUNBLElBQUkwQixFQUFFLElBQUksR0FBVixFQUFlO1FBQ2JGLE1BQU0sQ0FBQ00sSUFBUDs7UUFDQSxJQUFJTixNQUFNLENBQUNPLFFBQVAsQ0FBZ0IsU0FBaEIsQ0FBSixFQUFnQztVQUM5QixPQUFPLE1BQVA7UUFDRCxDQUZELE1BRU87VUFDTCxPQUFPLElBQVA7UUFDRDtNQUNGLENBaEQrQixDQWlEaEM7OztNQUNBLElBQUlMLEVBQUUsSUFBSSxHQUFWLEVBQWU7UUFDYkYsTUFBTSxDQUFDTSxJQUFQO1FBQ0FOLE1BQU0sQ0FBQ08sUUFBUCxDQUFnQixRQUFoQjtRQUNBLE9BQU8sS0FBUDtNQUNELENBdEQrQixDQXVEaEM7OztNQUNBLElBQUlMLEVBQUUsSUFBSSxHQUFWLEVBQWU7UUFDYkYsTUFBTSxDQUFDTSxJQUFQO1FBQ0FOLE1BQU0sQ0FBQ08sUUFBUCxDQUFnQixLQUFoQjtRQUNBLE9BQU8sS0FBUDtNQUNELENBNUQrQixDQTZEaEM7OztNQUNBLElBQUlMLEVBQUUsSUFBSSxHQUFWLEVBQWU7UUFDYkYsTUFBTSxDQUFDTSxJQUFQO1FBQ0FMLEtBQUssQ0FBQ2dCLFFBQU4sR0FBaUJDLFdBQVcsQ0FBQ2hCLEVBQUQsQ0FBNUI7UUFDQSxPQUFPRCxLQUFLLENBQUNnQixRQUFOLENBQWVqQixNQUFmLEVBQXVCQyxLQUF2QixDQUFQO01BQ0QsQ0FsRStCLENBbUVoQzs7O01BQ0EsSUFBSUMsRUFBRSxJQUFJLEdBQVYsRUFBZTtRQUNiRixNQUFNLENBQUNNLElBQVA7O1FBQ0EsSUFBSU4sTUFBTSxDQUFDbUIsR0FBUCxDQUFXLEdBQVgsQ0FBSixFQUFxQjtVQUNuQmxCLEtBQUssQ0FBQ2dCLFFBQU4sR0FBaUJHLFlBQWpCO1VBQ0EsT0FBT0EsWUFBWSxDQUFDcEIsTUFBRCxFQUFTQyxLQUFULENBQW5CO1FBQ0Q7O1FBQ0QsSUFBSUQsTUFBTSxDQUFDbUIsR0FBUCxDQUFXLEdBQVgsQ0FBSixFQUFxQjtVQUNuQm5CLE1BQU0sQ0FBQ3FCLFNBQVA7VUFDQSxPQUFPLFNBQVA7UUFDRDs7UUFDRHJCLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBYyxDQUFkO01BQ0QsQ0EvRStCLENBaUZoQzs7O01BQ0EsSUFBSWhCLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYXJDLFdBQWIsS0FDQWUsTUFBTSxDQUFDc0IsS0FBUCxDQUFhekMsY0FBYixDQURBLElBRUFtQixNQUFNLENBQUNzQixLQUFQLENBQWF4QyxhQUFiLENBRkEsSUFHQWtCLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYXZDLFVBQWIsQ0FIQSxJQUlBaUIsTUFBTSxDQUFDc0IsS0FBUCxDQUFhdEMsVUFBYixDQUpBLElBS0FnQixNQUFNLENBQUNzQixLQUFQLENBQWExQyxjQUFiLENBTEEsSUFNQW9CLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYXJDLFdBQWIsQ0FOSixFQU0rQjtRQUM3QixPQUFPLFFBQVA7TUFDRCxDQTFGK0IsQ0E0RmhDOzs7TUFDQSxJQUFJZSxNQUFNLENBQUNPLFFBQVAsQ0FBZ0I3QixjQUFoQixDQUFKLEVBQXFDO1FBQ25DYyxPQUFPLEdBQUdRLE1BQU0sQ0FBQ1MsT0FBUCxFQUFWO1FBQ0EsT0FBTyxNQUFQO01BQ0QsQ0FoRytCLENBa0doQzs7O01BQ0EsSUFBSVQsTUFBTSxDQUFDTyxRQUFQLENBQWdCLFNBQWhCLENBQUosRUFBZ0M7UUFDOUIsSUFBSUMsR0FBRyxHQUFHUixNQUFNLENBQUNTLE9BQVAsRUFBVjs7UUFDQSxJQUFJaEMsUUFBUSxDQUFDK0IsR0FBRCxDQUFaLEVBQW1CO1VBQ2pCLElBQUliLFNBQVMsQ0FBQ2EsR0FBRCxDQUFiLEVBQW9CO1lBQ2xCaEIsT0FBTyxHQUFHLFVBQVY7O1lBQ0EsSUFBSWdCLEdBQUcsS0FBSyxNQUFaLEVBQW9CO2NBQ2xCO2NBQ0E7Y0FDQVIsTUFBTSxDQUFDYyxRQUFQOztjQUNBLElBQUlkLE1BQU0sQ0FBQ0csSUFBUCxNQUFpQixHQUFyQixFQUEwQjtnQkFDeEJYLE9BQU8sR0FBRyxjQUFWO2NBQ0Q7O2NBQ0RRLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBY2hCLE1BQU0sQ0FBQ1MsT0FBUCxHQUFpQmpDLE1BQWpCLEdBQTBCZ0MsR0FBRyxDQUFDaEMsTUFBNUM7WUFDRDtVQUNGOztVQUNELElBQUlzQixpQkFBaUIsQ0FBQ1UsR0FBRCxDQUFyQixFQUE0QjtZQUMxQmhCLE9BQU8sR0FBRyxjQUFWO1VBQ0Q7O1VBQ0RDLFVBQVUsR0FBR2UsR0FBYjtVQUNBLE9BQU8sU0FBUDtRQUNEOztRQUNELE9BQU8sVUFBUDtNQUNEOztNQUVEUixNQUFNLENBQUNNLElBQVA7TUFDQSxPQUFPLElBQVA7SUFDRDs7SUFFRCxTQUFTWSxXQUFULENBQXFCSyxLQUFyQixFQUE0QjtNQUMxQixPQUFPLFVBQVN2QixNQUFULEVBQWlCQyxLQUFqQixFQUF3QjtRQUM3QixJQUFJdUIsT0FBTyxHQUFHLEtBQWQ7UUFBQSxJQUFxQmxCLElBQXJCO1FBQUEsSUFBMkJtQixHQUFHLEdBQUcsS0FBakM7O1FBQ0EsT0FBTyxDQUFDbkIsSUFBSSxHQUFHTixNQUFNLENBQUNNLElBQVAsRUFBUixLQUEwQixJQUFqQyxFQUF1QztVQUNyQyxJQUFJQSxJQUFJLElBQUlpQixLQUFSLElBQWlCLENBQUNDLE9BQXRCLEVBQStCO1lBQUNDLEdBQUcsR0FBRyxJQUFOO1lBQVk7VUFBTzs7VUFDbkRELE9BQU8sR0FBRyxDQUFDQSxPQUFELElBQVlsQixJQUFJLElBQUksSUFBOUI7UUFDRDs7UUFDRCxJQUFJbUIsR0FBRyxJQUFJLEVBQUVELE9BQU8sSUFBSXZELGdCQUFiLENBQVgsRUFDRWdDLEtBQUssQ0FBQ2dCLFFBQU4sR0FBaUJsQixTQUFqQjtRQUNGLE9BQU8sUUFBUDtNQUNELENBVEQ7SUFVRDs7SUFFRCxTQUFTcUIsWUFBVCxDQUFzQnBCLE1BQXRCLEVBQThCQyxLQUE5QixFQUFxQztNQUNuQyxJQUFJeUIsUUFBUSxHQUFHLEtBQWY7TUFBQSxJQUFzQnhCLEVBQXRCOztNQUNBLE9BQU9BLEVBQUUsR0FBR0YsTUFBTSxDQUFDTSxJQUFQLEVBQVosRUFBMkI7UUFDekIsSUFBSUosRUFBRSxJQUFJLEdBQU4sSUFBYXdCLFFBQWpCLEVBQTJCO1VBQ3pCekIsS0FBSyxDQUFDZ0IsUUFBTixHQUFpQmxCLFNBQWpCO1VBQ0E7UUFDRDs7UUFDRDJCLFFBQVEsR0FBSXhCLEVBQUUsSUFBSSxHQUFsQjtNQUNEOztNQUNELE9BQU8sU0FBUDtJQUNEOztJQUVELFNBQVN5QixPQUFULENBQWlCQyxRQUFqQixFQUEyQkMsTUFBM0IsRUFBbUNDLElBQW5DLEVBQXlDQyxTQUF6QyxFQUFvREMsS0FBcEQsRUFBMkRDLElBQTNELEVBQWlFO01BQy9ELEtBQUtMLFFBQUwsR0FBZ0JBLFFBQWhCO01BQ0EsS0FBS0MsTUFBTCxHQUFjQSxNQUFkO01BQ0EsS0FBS0MsSUFBTCxHQUFZQSxJQUFaO01BQ0EsS0FBS0MsU0FBTCxHQUFpQkEsU0FBakI7TUFDQSxLQUFLQyxLQUFMLEdBQWFBLEtBQWI7TUFDQSxLQUFLQyxJQUFMLEdBQVlBLElBQVo7SUFDRDs7SUFDRCxTQUFTQyxXQUFULENBQXFCakMsS0FBckIsRUFBNEJrQyxHQUE1QixFQUFpQ0wsSUFBakMsRUFBdUNDLFNBQXZDLEVBQWtEO01BQ2hELElBQUlLLE1BQU0sR0FBR25DLEtBQUssQ0FBQzJCLFFBQW5CO01BQ0EsSUFBSVMsQ0FBQyxHQUFHLElBQUlWLE9BQUosQ0FBWVMsTUFBWixFQUFvQkQsR0FBcEIsRUFBeUJMLElBQXpCLEVBQStCQyxTQUFTLEdBQUdBLFNBQUgsR0FBZSxFQUF2RCxFQUEyRCxJQUEzRCxFQUFpRTlCLEtBQUssQ0FBQ3FDLE9BQXZFLENBQVI7TUFDQSxPQUFPckMsS0FBSyxDQUFDcUMsT0FBTixHQUFnQkQsQ0FBdkI7SUFDRDs7SUFDRCxTQUFTRSxVQUFULENBQW9CdEMsS0FBcEIsRUFBMkI7TUFDekIsSUFBSXVDLENBQUMsR0FBR3ZDLEtBQUssQ0FBQ3FDLE9BQU4sQ0FBY1IsSUFBdEI7O01BQ0EsSUFBSVUsQ0FBQyxJQUFJLEdBQUwsSUFBWUEsQ0FBQyxJQUFJLEdBQWpCLElBQXdCQSxDQUFDLElBQUksR0FBakMsRUFBc0M7UUFDcEN2QyxLQUFLLENBQUMyQixRQUFOLEdBQWlCM0IsS0FBSyxDQUFDcUMsT0FBTixDQUFjVixRQUEvQjtNQUNEOztNQUNELE9BQU8zQixLQUFLLENBQUNxQyxPQUFOLEdBQWdCckMsS0FBSyxDQUFDcUMsT0FBTixDQUFjTCxJQUFyQztJQUNEOztJQUVELFNBQVNRLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXlCQyxjQUF6QixFQUF5QztNQUN2QyxJQUFJRCxJQUFJLElBQUlDLGNBQVosRUFBNEI7UUFDMUIsT0FBTyxJQUFQO01BQ0QsQ0FGRCxNQUVPO1FBQ0w7UUFDQSxJQUFJQyxlQUFlLEdBQUdELGNBQWMsQ0FBQ3JFLEtBQWYsQ0FBcUIsR0FBckIsQ0FBdEI7O1FBQ0EsS0FBSyxJQUFJQyxDQUFULElBQWNxRSxlQUFkLEVBQStCO1VBQzdCLElBQUlGLElBQUksSUFBSUUsZUFBZSxDQUFDckUsQ0FBRCxDQUEzQixFQUFnQztZQUM5QixPQUFPLElBQVA7VUFDRDtRQUNGOztRQUNELE9BQU8sS0FBUDtNQUNEO0lBQ0Y7O0lBRUQsU0FBU3NFLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ2YsU0FBaEMsRUFBMkM7TUFDekMsSUFBSWUsR0FBRyxJQUFJLElBQVgsRUFBaUI7UUFDZixPQUFPLEtBQVA7TUFDRDs7TUFDRCxJQUFJQSxHQUFHLENBQUNmLFNBQUosS0FBa0JBLFNBQXRCLEVBQWlDO1FBQy9CLE9BQU8sSUFBUDtNQUNEOztNQUNELE9BQU9jLGlCQUFpQixDQUFDQyxHQUFHLENBQUNiLElBQUwsRUFBV0YsU0FBWCxDQUF4QjtJQUNEOztJQUVELFNBQVNnQix1QkFBVCxHQUFtQztNQUNqQztNQUNBO01BQ0E7TUFDQSxJQUFJQyxXQUFXLEdBQUcsRUFBbEI7O01BQ0EsS0FBSyxJQUFJekUsQ0FBVCxJQUFjb0IsU0FBZCxFQUF5QjtRQUN2QixJQUFJQSxTQUFTLENBQUNwQixDQUFELENBQWIsRUFBa0I7VUFDaEIsSUFBSTBFLFFBQVEsR0FBR3RELFNBQVMsQ0FBQ3BCLENBQUQsQ0FBVCxDQUFhRCxLQUFiLENBQW1CLEdBQW5CLENBQWY7O1VBQ0EsS0FBSyxJQUFJNEUsQ0FBVCxJQUFjRCxRQUFkLEVBQXdCO1lBQ3RCRCxXQUFXLENBQUNHLElBQVosQ0FBaUJGLFFBQVEsQ0FBQ0MsQ0FBRCxDQUF6QjtVQUNEO1FBQ0Y7TUFDRjs7TUFDRCxJQUFJRSxFQUFFLEdBQUcsSUFBSS9ELE1BQUosQ0FBVyxtQkFBbUIyRCxXQUFXLENBQUNLLElBQVosQ0FBaUIsR0FBakIsQ0FBbkIsR0FBMkMsSUFBdEQsQ0FBVDtNQUNBLE9BQU9ELEVBQVA7SUFDRCxDQWpVNkQsQ0FtVTlEOzs7SUFDQSxPQUFPO01BRUw7TUFDQUUsYUFBYSxFQUFFUCx1QkFBdUIsRUFIakM7TUFLTFEsVUFBVSxFQUFFLG9CQUFTQyxVQUFULEVBQXFCO1FBQy9CLElBQUl2RCxLQUFLLEdBQUc7VUFDVmdCLFFBQVEsRUFBRSxJQURBO1VBRVZxQixPQUFPLEVBQUUsSUFBSVgsT0FBSixDQUFZLENBQUM2QixVQUFVLElBQUksQ0FBZixJQUFvQjVGLFVBQWhDLEVBQTRDLENBQTVDLEVBQStDLEtBQS9DLEVBQXNELEtBQXRELEVBQTZELEtBQTdELENBRkM7VUFHVmdFLFFBQVEsRUFBRSxDQUhBO1VBSVY2Qix5QkFBeUIsRUFBRSxDQUpqQjtVQUtWQyxXQUFXLEVBQUU7UUFMSCxDQUFaO1FBT0EsSUFBSXhGLEtBQUssQ0FBQ3FGLFVBQVYsRUFBc0JyRixLQUFLLENBQUNxRixVQUFOLENBQWlCdEQsS0FBakI7UUFDdEIsT0FBT0EsS0FBUDtNQUNELENBZkk7TUFpQkwwRCxLQUFLLEVBQUUsZUFBUzNELE1BQVQsRUFBaUJDLEtBQWpCLEVBQXdCO1FBQzdCLElBQUk2QyxHQUFHLEdBQUc3QyxLQUFLLENBQUNxQyxPQUFoQjs7UUFDQSxJQUFJdEMsTUFBTSxDQUFDNEQsR0FBUCxFQUFKLEVBQWtCO1VBQ2hCLElBQUlkLEdBQUcsQ0FBQ2QsS0FBSixJQUFhLElBQWpCLEVBQXVCYyxHQUFHLENBQUNkLEtBQUosR0FBWSxLQUFaO1VBQ3ZCL0IsS0FBSyxDQUFDMkIsUUFBTixHQUFpQjVCLE1BQU0sQ0FBQzZELFdBQVAsRUFBakI7VUFDQTVELEtBQUssQ0FBQ3lELFdBQU4sR0FBb0IsSUFBcEI7UUFDRDs7UUFDRCxJQUFJeEYsS0FBSyxDQUFDeUYsS0FBVixFQUFpQjtVQUNmO1VBQ0EsSUFBSXZELEtBQUssR0FBR2xDLEtBQUssQ0FBQ3lGLEtBQU4sQ0FBWTNELE1BQVosRUFBb0JDLEtBQXBCLENBQVo7O1VBQ0EsSUFBSUcsS0FBSyxLQUFLUCxTQUFkLEVBQXlCO1lBQ3ZCLE9BQU9PLEtBQVA7VUFDRDtRQUNGOztRQUNELElBQUlKLE1BQU0sQ0FBQ2MsUUFBUCxFQUFKLEVBQXVCLE9BQU8sSUFBUDtRQUN2QnRCLE9BQU8sR0FBRyxJQUFWO1FBQ0FDLFVBQVUsR0FBRyxJQUFiO1FBQ0EsSUFBSVcsS0FBSyxHQUFHLENBQUNILEtBQUssQ0FBQ2dCLFFBQU4sSUFBa0JsQixTQUFuQixFQUE4QkMsTUFBOUIsRUFBc0NDLEtBQXRDLENBQVo7O1FBQ0EsSUFBSUcsS0FBSyxJQUFJLFNBQVQsSUFBc0JBLEtBQUssSUFBSSxNQUEvQixJQUF5Q0EsS0FBSyxJQUFJLFVBQXRELEVBQWtFO1VBQ2hFLElBQUksQ0FBRVosT0FBTyxLQUFLLEdBQWIsSUFBc0JBLE9BQU8sS0FBSyxJQUFuQyxLQUE2QyxDQUFDcUQsaUJBQWlCLENBQUNDLEdBQUQsRUFBTSxZQUFOLENBQW5FLEVBQXdGO1lBQ3RGO1lBQ0E7WUFDQTtZQUNBWixXQUFXLENBQUNqQyxLQUFELEVBQVFELE1BQU0sQ0FBQzZCLE1BQVAsS0FBa0JyQyxPQUFPLENBQUNoQixNQUFsQyxFQUEwQyxZQUExQyxFQUF3RCxZQUF4RCxDQUFYO1lBQ0EsSUFBSXNFLEdBQUcsQ0FBQ2QsS0FBSixJQUFhLElBQWpCLEVBQXVCYyxHQUFHLENBQUNkLEtBQUosR0FBWSxJQUFaO1VBQ3hCOztVQUNELE9BQU81QixLQUFQO1FBQ0Q7O1FBQ0QsSUFBSTBDLEdBQUcsQ0FBQ2QsS0FBSixJQUFhLElBQWpCLEVBQXVCYyxHQUFHLENBQUNkLEtBQUosR0FBWSxJQUFaO1FBRXZCLElBQUk4QixtQkFBbUIsR0FBR2hCLEdBQUcsQ0FBQ2hCLElBQUosSUFBWSxZQUFaLElBQ3hCM0MsY0FBYyxDQUFDa0IsSUFBZixDQUFvQmIsT0FBcEIsQ0FEd0IsSUFDUXNELEdBQUcsQ0FBQ2IsSUFEWixJQUNvQmEsR0FBRyxDQUFDYixJQUFKLENBQVNILElBQVQsS0FBa0J0QyxPQURoRTs7UUFFQSxJQUFJQSxPQUFPLElBQUlzRCxHQUFHLENBQUNoQixJQUFmLElBQXVCZ0MsbUJBQTNCLEVBQWdEO1VBQzlDLElBQUlBLG1CQUFKLEVBQXlCO1lBQ3ZCaEIsR0FBRyxHQUFHUCxVQUFVLENBQUN0QyxLQUFELENBQWhCO1VBQ0Q7O1VBQ0Q2QyxHQUFHLEdBQUdQLFVBQVUsQ0FBQ3RDLEtBQUQsQ0FBaEI7O1VBQ0EsSUFBSVQsT0FBTyxJQUFJLEdBQWYsRUFBb0I7WUFDbEI7WUFDQSxJQUFJc0QsR0FBRyxJQUFLQSxHQUFHLENBQUNoQixJQUFKLEtBQWEsT0FBekIsRUFBbUM7Y0FDakNnQixHQUFHLEdBQUdQLFVBQVUsQ0FBQ3RDLEtBQUQsQ0FBaEI7O2NBQ0EsT0FBTzZDLEdBQUcsS0FBS0EsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFdBQVosSUFBMkJnQixHQUFHLENBQUNoQixJQUFKLElBQVksWUFBNUMsQ0FBVjtnQkFBcUVnQixHQUFHLEdBQUdQLFVBQVUsQ0FBQ3RDLEtBQUQsQ0FBaEI7Y0FBckU7WUFDRDtVQUNGLENBTkQsTUFNTyxJQUFJVCxPQUFPLElBQUksR0FBZixFQUFvQjtZQUN6QjtZQUNBO1lBQ0EsSUFBSXNELEdBQUcsSUFBS0EsR0FBRyxDQUFDaEIsSUFBSixLQUFhLFdBQXpCLEVBQXVDO2NBQ3JDLE9BQU9nQixHQUFHLElBQUtBLEdBQUcsQ0FBQ2hCLElBQUosSUFBWSxXQUEzQjtnQkFBeUNnQixHQUFHLEdBQUdQLFVBQVUsQ0FBQ3RDLEtBQUQsQ0FBaEI7Y0FBekM7WUFDRDtVQUNGO1FBQ0YsQ0FsQkQsTUFrQk8sSUFBSyxDQUFDVCxPQUFPLElBQUksR0FBWCxJQUFrQkEsT0FBTyxJQUFJLEdBQTlCLE1BQXVDc0QsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFdBQVosSUFBMkJnQixHQUFHLENBQUNoQixJQUFKLElBQVksWUFBOUUsQ0FBRCxJQUNEZ0IsR0FBRyxDQUFDaEIsSUFBSixJQUFZVyxTQUFTLENBQUNoRCxVQUFELEVBQWFxRCxHQUFHLENBQUNoQixJQUFqQixDQUR4QixFQUNpRDtVQUN0RGdCLEdBQUcsR0FBR1AsVUFBVSxDQUFDdEMsS0FBRCxDQUFoQjs7VUFDQSxPQUFPNkMsR0FBRyxLQUFLQSxHQUFHLENBQUNoQixJQUFKLElBQVksV0FBWixJQUEyQmdCLEdBQUcsQ0FBQ2hCLElBQUosSUFBWSxZQUE1QyxDQUFWO1lBQXFFZ0IsR0FBRyxHQUFHUCxVQUFVLENBQUN0QyxLQUFELENBQWhCO1VBQXJFO1FBQ0QsQ0FKTSxNQUlBLElBQUlULE9BQU8sSUFBSSxHQUFmLEVBQW9CO1VBQ3pCMEMsV0FBVyxDQUFDakMsS0FBRCxFQUFRRCxNQUFNLENBQUM2QixNQUFQLEVBQVIsRUFBeUIsR0FBekIsQ0FBWDtRQUNELENBRk0sTUFFQSxJQUFJckMsT0FBTyxJQUFJLEdBQWYsRUFBb0I7VUFDekIwQyxXQUFXLENBQUNqQyxLQUFELEVBQVFELE1BQU0sQ0FBQzZCLE1BQVAsRUFBUixFQUF5QixHQUF6QixDQUFYO1FBQ0QsQ0FGTSxNQUVBLElBQUlyQyxPQUFPLElBQUksR0FBZixFQUFvQjtVQUN6QjBDLFdBQVcsQ0FBQ2pDLEtBQUQsRUFBUUQsTUFBTSxDQUFDNkIsTUFBUCxFQUFSLEVBQXlCLEdBQXpCLENBQVg7UUFDRCxDQUZNLE1BRUEsSUFBSWlCLEdBQUcsSUFBSUEsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFNBQW5CLElBQWdDdEMsT0FBTyxJQUFJLEdBQS9DLEVBQW9EO1VBQ3pEMEMsV0FBVyxDQUFDakMsS0FBRCxFQUFRRCxNQUFNLENBQUM2QixNQUFQLEVBQVIsRUFBeUIsV0FBekIsRUFBc0MsTUFBdEMsQ0FBWDtRQUNELENBRk0sTUFFQSxJQUFJckMsT0FBTyxJQUFJLGNBQWYsRUFBK0I7VUFDcEMwQyxXQUFXLENBQUNqQyxLQUFELEVBQVFELE1BQU0sQ0FBQzZCLE1BQVAsRUFBUixFQUF5QixXQUF6QixFQUFzQ3BDLFVBQXRDLENBQVg7UUFDRCxDQUZNLE1BRUEsSUFBSUQsT0FBTyxJQUFJLFVBQWYsRUFBMkI7VUFDaEMsSUFBSUMsVUFBVSxJQUFJLFVBQWQsSUFBNEJxRCxHQUE1QixLQUFvQ0EsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFdBQVosSUFBMkJnQixHQUFHLENBQUNoQixJQUFKLElBQVksVUFBM0UsQ0FBSixFQUE0RixDQUMxRjtZQUNBO1lBQ0E7VUFDRCxDQUpELE1BSU8sSUFBSXJDLFVBQVUsSUFBSSxNQUFkLElBQXdCcUQsR0FBeEIsSUFBK0JBLEdBQUcsQ0FBQ2hCLElBQUosSUFBWSxXQUEvQyxFQUE0RCxDQUNqRTtVQUNELENBRk0sTUFFQSxJQUFJckMsVUFBVSxJQUFJLE9BQWQsSUFBeUJxRCxHQUF6QixJQUFnQ0EsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFdBQWhELEVBQTZELENBQ2xFO1VBQ0QsQ0FGTSxNQUVBO1lBQ0wsSUFBSWlDLEtBQUssR0FBR3BFLFNBQVMsQ0FBQ0YsVUFBRCxDQUFyQjtZQUNBeUMsV0FBVyxDQUFDakMsS0FBRCxFQUFRRCxNQUFNLENBQUM2QixNQUFQLEVBQVIsRUFBeUJrQyxLQUF6QixFQUFnQ3RFLFVBQWhDLENBQVg7VUFDRDtRQUNGLENBYk0sTUFhQSxJQUFJRCxPQUFPLElBQUksVUFBWCxJQUEwQkMsVUFBVSxJQUFJQSxVQUFVLENBQUM2QixLQUFYLENBQWlCbEMsc0JBQWpCLENBQTVDLEVBQXVGO1VBQzVGLElBQUlJLE9BQU8sSUFBSSxVQUFmLEVBQTJCO1lBQ3pCO1lBQ0E7WUFDQTBDLFdBQVcsQ0FBQ2pDLEtBQUQsRUFBUUQsTUFBTSxDQUFDNkIsTUFBUCxFQUFSLEVBQXlCLE9BQXpCLEVBQWtDLE9BQWxDLENBQVg7VUFDRDs7VUFDRCxJQUFJcEMsVUFBVSxDQUFDNkIsS0FBWCxDQUFpQi9CLHlCQUFqQixDQUFKLEVBQWlEO1lBQy9DVSxLQUFLLENBQUN3RCx5QkFBTixJQUFtQzVGLG1CQUFuQztVQUNEOztVQUNELElBQUk0QixVQUFVLENBQUM2QixLQUFYLENBQWlCaEMsMkJBQWpCLENBQUosRUFBbUQ7WUFDakRXLEtBQUssQ0FBQ3dELHlCQUFOLElBQW1DNUYsbUJBQW5DO1VBQ0Q7UUFDRjs7UUFFRG9DLEtBQUssQ0FBQ3lELFdBQU4sR0FBb0IsS0FBcEI7UUFDQSxPQUFPdEQsS0FBUDtNQUNELENBOUdJO01BZ0hMZ0MsTUFBTSxFQUFFLGdCQUFTbkMsS0FBVCxFQUFnQitELFNBQWhCLEVBQTJCO1FBQ2pDLElBQUkvRCxLQUFLLENBQUNnQixRQUFOLElBQWtCbEIsU0FBbEIsSUFBK0JFLEtBQUssQ0FBQ2dCLFFBQU4sSUFBa0IsSUFBckQsRUFBMkQsT0FBT3pELFVBQVUsQ0FBQ3lHLElBQWxCOztRQUMzRCxJQUFJL0YsS0FBSyxDQUFDa0UsTUFBVixFQUFrQjtVQUNoQixJQUFJOEIsUUFBUSxHQUFHaEcsS0FBSyxDQUFDa0UsTUFBTixDQUFhbkMsS0FBYixDQUFmO1VBQ0EsSUFBSWlFLFFBQVEsSUFBSSxDQUFoQixFQUFtQixPQUFPQSxRQUFQO1FBQ3BCOztRQUNELElBQUlwQixHQUFHLEdBQUc3QyxLQUFLLENBQUNxQyxPQUFoQjtRQUFBLElBQXlCNkIsU0FBUyxHQUFHSCxTQUFTLElBQUlBLFNBQVMsQ0FBQ0ksTUFBVixDQUFpQixDQUFqQixDQUFsRDtRQUNBLElBQUl0QixHQUFHLENBQUNoQixJQUFKLElBQVksV0FBWixJQUEyQnFDLFNBQVMsSUFBSSxHQUE1QyxFQUFpRHJCLEdBQUcsR0FBR0EsR0FBRyxDQUFDYixJQUFWO1FBQ2pELElBQUlvQyxPQUFPLEdBQUcsS0FBZDtRQUNBLElBQUlDLGVBQWUsR0FBR04sU0FBUyxDQUFDMUMsS0FBVixDQUFnQnBDLG9CQUFoQixDQUF0QjtRQUNBLElBQUlvRixlQUFKLEVBQ0VELE9BQU8sR0FBRzVCLFNBQVMsQ0FBQzZCLGVBQWUsQ0FBQyxDQUFELENBQWhCLEVBQXFCeEIsR0FBRyxDQUFDaEIsSUFBekIsQ0FBbkI7O1FBQ0YsSUFBSSxDQUFDL0QsdUNBQUQsSUFBNENpRyxTQUFTLENBQUMxQyxLQUFWLENBQWdCbEMsc0JBQWhCLENBQWhELEVBQXlGO1VBQ3ZGLElBQUk0RSxTQUFTLENBQUMxQyxLQUFWLENBQWdCL0IseUJBQWhCLENBQUosRUFBZ0Q7WUFDOUMsT0FBT1UsS0FBSyxDQUFDd0QseUJBQU4sR0FBa0M1RixtQkFBekM7VUFDRDs7VUFDRCxPQUFPb0MsS0FBSyxDQUFDd0QseUJBQWI7UUFDRDs7UUFDRCxJQUFJWCxHQUFHLENBQUNoQixJQUFKLElBQVksV0FBaEIsRUFBNkIsT0FBT2dCLEdBQUcsQ0FBQ2xCLFFBQUosSUFBZ0J1QyxTQUFTLElBQUksR0FBYixHQUFtQixDQUFuQixHQUF1QnRHLG1CQUF2QyxDQUFQLENBQTdCLEtBQ0ssSUFBSSxDQUFDc0IsY0FBYyxDQUFDa0IsSUFBZixDQUFvQnlDLEdBQUcsQ0FBQ2hCLElBQXhCLEtBQWlDZ0IsR0FBRyxDQUFDaEIsSUFBSixJQUFZLFlBQTlDLEtBQ0pnQixHQUFHLENBQUNkLEtBREEsSUFDUyxDQUFDbEUsY0FEZCxFQUM4QixPQUFPZ0YsR0FBRyxDQUFDakIsTUFBSixJQUFjd0MsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUE1QixDQUFQLENBRDlCLEtBRUEsSUFBSXZCLEdBQUcsQ0FBQ2hCLElBQUosSUFBWSxHQUFaLElBQW1CLENBQUN1QyxPQUF4QixFQUFpQyxPQUFPdkIsR0FBRyxDQUFDbEIsUUFBSixHQUFlL0QsbUJBQXRCLENBQWpDLEtBQ0EsT0FBT2lGLEdBQUcsQ0FBQ2xCLFFBQUosSUFBZ0J5QyxPQUFPLEdBQUcsQ0FBSCxHQUFPekcsVUFBOUIsQ0FBUDtNQUNOLENBdklJO01BeUlMMkcsaUJBQWlCLEVBQUUsSUF6SWQ7TUEwSUxDLGVBQWUsRUFBRSxJQTFJWjtNQTJJTEMsV0FBVyxFQUFFLElBM0lSO01BNElMQyxJQUFJLEVBQUU7SUE1SUQsQ0FBUDtFQThJRCxDQWxkRDtFQW9kRWxILFVBQVUsQ0FBQ21ILFVBQVgsQ0FBc0IsZ0JBQXRCLEVBQXdDO0lBQ3RDQyxJQUFJLEVBQUU7RUFEZ0MsQ0FBeEM7RUFJQXBILFVBQVUsQ0FBQ21ILFVBQVgsQ0FBc0Isc0JBQXRCLEVBQThDO0lBQzVDQyxJQUFJLEVBQUU7RUFEc0MsQ0FBOUMsRUEzZHNCLENBaWV0QjtFQUNBO0VBQ0E7RUFDQTtFQUVBO0VBQ0E7RUFDQTs7RUFDQSxJQUFJQyxrQkFBa0IsR0FBRztJQUN2QixLQUFLLE1BRGtCO0lBRXZCLEtBQUssVUFGa0I7SUFFTDtJQUNsQixLQUFLLFVBSGtCO0lBSXZCLE1BQU0sVUFKaUI7SUFLdkIsTUFBTSxXQUxpQjtJQU12QixNQUFNLFdBTmlCO0lBT3ZCLEtBQUssSUFQa0I7SUFRdkIsS0FBSyxVQVJrQjtJQVN2QixNQUFNLFVBVGlCO0lBVXZCLEtBQUssWUFWa0I7SUFXdkIsTUFBTSxZQVhpQjtJQVl2QixPQUFPLFlBWmdCO0lBYXZCLE9BQU8sWUFiZ0I7SUFjdkIsUUFBUSxZQWRlO0lBZXZCLE9BQU8sWUFmZ0I7SUFnQnZCLE9BQU8sWUFoQmdCO0lBaUJ2QixNQUFNLEtBakJpQjtJQWtCdkIsTUFBTSxLQWxCaUI7SUFtQnZCLEtBQUssS0FuQmtCO0lBb0J2QixNQUFNLEtBcEJpQjtJQXFCdkIsTUFBTSxLQXJCaUI7SUFzQnZCLE1BQU0sS0F0QmlCO0lBdUJ2QixLQUFLLEtBdkJrQjtJQXVCVjtJQUNiLEtBQUssV0F4QmtCO0lBeUJ2QixNQUFNLFdBekJpQjtJQTBCdkIsTUFBTSxXQTFCaUI7SUEyQnZCLEtBQUssWUEzQmtCO0lBNEJ2QixNQUFNLFlBNUJpQjtJQTZCdkIsTUFBTSxTQTdCaUI7SUE4QnZCLE1BQU07RUE5QmlCLENBQXpCLENBemVzQixDQTBnQnRCOztFQUNBLElBQUlDLG1CQUFtQixHQUFHO0lBQ3hCLEtBQUssVUFEbUI7SUFFeEIsS0FBSyxVQUZtQjtJQUd4QixLQUFLLFdBSG1CO0lBSXhCLEtBQUssTUFKbUI7SUFLeEIsS0FBSyxNQUxtQjtJQU14QixLQUFLLE9BTm1CO0lBT3hCLE1BQU07RUFQa0IsQ0FBMUI7RUFTQSxJQUFJQyxhQUFhLEdBQUcsQ0FBcEI7RUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxLQUF6QjtFQUNBLElBQUlDLGFBQWEsR0FBRyw4Q0FBcEIsQ0F0aEJzQixDQXNoQitDO0VBQ3JFOztFQUNBLElBQUlDLHdCQUF3QixHQUFHLFNBQS9CO0VBQ0EsSUFBSUMsdUJBQXVCLEdBQUcsU0FBOUI7RUFDQSxJQUFJQyxlQUFlLEdBQUcsV0FBdEIsQ0ExaEJzQixDQTZoQnRCO0VBQ0E7O0VBQ0EsU0FBU0MsYUFBVCxDQUF1QnBGLEtBQXZCLEVBQThCNEQsV0FBOUIsRUFBMkMvQixJQUEzQyxFQUFpRDtJQUMvQztJQUNBLElBQUl3RCxLQUFLLEdBQUd6QixXQUFXLEdBQUdrQixhQUExQixDQUYrQyxDQUVMOztJQUMxQyxPQUFPLFNBQVM5RSxLQUFLLENBQUNzRixtQkFBTixDQUEwQkQsS0FBMUIsQ0FBVCxHQUE0QyxHQUE1QyxHQUFrRHhELElBQXpEO0VBQ0QsQ0FuaUJxQixDQXFpQnRCOzs7RUFDQSxTQUFTMEQsWUFBVCxDQUFzQnhGLE1BQXRCLEVBQThCO0lBQzVCLElBQUlzQixLQUFKO0lBQ0EsT0FBTyxDQUFDQSxLQUFLLEdBQUd0QixNQUFNLENBQUNzQixLQUFQLENBQWEyRCxhQUFiLEVBQTRCLEtBQTVCLENBQVQsS0FBZ0QzRCxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVM5QyxNQUFULEdBQWtCLENBQXpFO0VBQ0Q7O0VBRURoQixVQUFVLENBQUNtSCxVQUFYLENBQXNCLFlBQXRCLEVBQW9DO0lBQ2xDQyxJQUFJLEVBQUUsU0FENEI7SUFHbEMxRyxLQUFLLEVBQUU7TUFFTG9GLGFBQWEsRUFBRSxLQUZWO01BS0w7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0FLLEtBQUssRUFBRSxlQUFTM0QsTUFBVCxFQUFpQkMsS0FBakIsRUFBd0I7UUFDN0IsSUFBSUcsS0FBSyxHQUFHUCxTQUFaO1FBQ0EsSUFBSXlCLEtBQUosQ0FGNkIsQ0FFakI7UUFFWjs7UUFDQSxJQUFJdEIsTUFBTSxDQUFDNEQsR0FBUCxNQUFnQixDQUFFM0QsS0FBSyxDQUFDd0YsaUJBQTVCLEVBQStDO1VBQzdDO1VBQ0EsSUFBSXpGLE1BQU0sQ0FBQ0csSUFBUCxNQUFpQixJQUFyQixFQUEyQjtZQUN6QkMsS0FBSyxHQUFHLEtBQVI7WUFDQUosTUFBTSxDQUFDcUIsU0FBUDs7WUFDQSxJQUFJckIsTUFBTSxDQUFDMEYsTUFBUCxDQUFjcEUsS0FBZCxDQUFvQixNQUFwQixDQUFKLEVBQWlDO2NBQy9CckIsS0FBSyxDQUFDMEYsYUFBTixHQUFzQixLQUF0QjtZQUNELENBRkQsTUFFTyxJQUFJM0YsTUFBTSxDQUFDMEYsTUFBUCxDQUFjcEUsS0FBZCxDQUFvQixPQUFwQixDQUFKLEVBQWlDO2NBQ3RDckIsS0FBSyxDQUFDMEYsYUFBTixHQUFzQixJQUF0QjtZQUNEO1VBQ0YsQ0FWNEMsQ0FXN0M7OztVQUNBLElBQUkxRixLQUFLLENBQUMwRixhQUFOLElBQXVCM0YsTUFBTSxDQUFDNEYsR0FBUCxJQUFjLENBQXJDLElBQ0MzRixLQUFLLENBQUMyQixRQUFOLElBQWtCLENBRG5CLEtBQzBCTixLQUFLLEdBQUd0QixNQUFNLENBQUNzQixLQUFQLENBQWE2RCx1QkFBYixFQUFzQyxLQUF0QyxDQURsQyxDQUFKLEVBQ3FGO1lBQ25GbEYsS0FBSyxDQUFDMkIsUUFBTixHQUFpQk4sS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTOUMsTUFBMUI7VUFDRCxDQWY0QyxDQWlCN0M7VUFDQTtVQUNBOzs7VUFDQSxJQUFJb0QsUUFBUSxHQUFHM0IsS0FBSyxDQUFDMkIsUUFBckI7VUFDQSxJQUFJMEQsS0FBSyxHQUFHMUQsUUFBUSxHQUFHbUQsYUFBdkI7O1VBQ0EsSUFBSU8sS0FBSyxJQUFJckYsS0FBSyxDQUFDc0YsbUJBQU4sQ0FBMEIvRyxNQUF2QyxFQUErQztZQUM3QztZQUVBLElBQUlxSCxTQUFTLEdBQUc3RixNQUFNLENBQUMwRixNQUFQLENBQWNsSCxNQUFkLElBQXdCb0QsUUFBeEM7WUFDQSxJQUFJa0UsS0FBSyxHQUFHUixLQUFLLEdBQUdQLGFBQXBCOztZQUNBLElBQUllLEtBQUssR0FBRzlGLE1BQU0sQ0FBQzBGLE1BQVAsQ0FBY2xILE1BQTFCLEVBQWtDO2NBQ2hDLElBQUl1SCxVQUFVLEdBQUcvRixNQUFNLENBQUMwRixNQUFQLENBQWNNLEtBQWQsQ0FBb0JGLEtBQXBCLENBQWpCO2NBQ0EsSUFBSTVGLEVBQUUsR0FBRzZGLFVBQVUsQ0FBQyxDQUFELENBQW5COztjQUNBLElBQUlqQixtQkFBbUIsQ0FBQzVFLEVBQUQsQ0FBbkIsSUFBNEIsQ0FBQ29CLEtBQUssR0FBR3lFLFVBQVUsQ0FBQ3pFLEtBQVgsQ0FBaUIyRCxhQUFqQixDQUFULEtBQzVCSixrQkFBa0IsQ0FBQ3ZELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FEdEIsRUFDbUM7Z0JBQ2pDO2dCQUNBO2dCQUNBTSxRQUFRLElBQUltRCxhQUFaLENBSGlDLENBSWpDO2dCQUNBOztnQkFDQSxJQUFJLEVBQUU3RSxFQUFFLElBQUksSUFBTixJQUFjNEYsS0FBSyxHQUFHLENBQXhCLENBQUosRUFBZ0M7a0JBQzlCN0YsS0FBSyxDQUFDc0YsbUJBQU4sQ0FBMEJELEtBQTFCLElBQW1DUixtQkFBbUIsQ0FBQzVFLEVBQUQsQ0FBdEQ7O2tCQUNBLElBQUk4RSxrQkFBSixFQUF3QjtvQkFBQy9FLEtBQUssQ0FBQ2dHLGdCQUFOLEdBQXlCLEtBQXpCO2tCQUFnQzs7a0JBQ3pEWCxLQUFLO2dCQUNOO2NBQ0Y7WUFDRixDQXJCNEMsQ0FzQjdDOzs7WUFDQSxJQUFJLENBQUNPLFNBQUwsRUFBZ0I7Y0FDZCxPQUFPNUYsS0FBSyxDQUFDc0YsbUJBQU4sQ0FBMEIvRyxNQUExQixHQUFtQzhHLEtBQTFDLEVBQWlEO2dCQUMvQ3JGLEtBQUssQ0FBQ3NGLG1CQUFOLENBQTBCVyxHQUExQjtjQUNEO1lBQ0Y7VUFDRixDQWxENEMsQ0FtRDdDOzs7VUFDQWpHLEtBQUssQ0FBQ2tHLGFBQU4sR0FBc0J2RSxRQUF0QjtRQUNEOztRQUVELElBQUkzQixLQUFLLENBQUMwRixhQUFWLEVBQXlCO1VBQ3ZCO1VBRUEsSUFBSVMsY0FBYyxHQUFHLEtBQXJCOztVQUNBLElBQUlwQixrQkFBSixFQUF3QjtZQUN0QjtZQUNBO1lBQ0FvQixjQUFjLEdBQ05wRyxNQUFNLENBQUNHLElBQVAsTUFBaUIsR0FBbEIsSUFBNEI7WUFDM0JDLEtBQUssS0FBS1AsU0FEWCxJQUM0QjtZQUM1QixDQUFDSSxLQUFLLENBQUN3RixpQkFGUCxJQUU0QjtZQUM1QjtZQUNDekYsTUFBTSxDQUFDNkIsTUFBUCxNQUFtQjVCLEtBQUssQ0FBQ3NGLG1CQUFOLENBQTBCL0csTUFBMUIsR0FBbUN1RyxhQUw5RCxDQUhzQixDQVF5RDs7WUFDL0UsSUFBSXFCLGNBQUosRUFBb0I7Y0FDbEIsSUFBSW5HLEtBQUssQ0FBQ2dHLGdCQUFWLEVBQTRCO2dCQUMxQjtnQkFDQUcsY0FBYyxHQUFHLEtBQWpCO2NBQ0Q7O2NBQ0RuRyxLQUFLLENBQUNnRyxnQkFBTixHQUNLakcsTUFBTSxDQUFDc0IsS0FBUCxDQUFhOEQsZUFBYixFQUE4QixLQUE5QixDQURMLENBTGtCLENBTXlCO1lBQzVDO1VBQ0Y7O1VBRUQsSUFBSTlELEtBQUo7O1VBQ0EsSUFBSWxCLEtBQUssS0FBS1AsU0FBZCxFQUF5QjtZQUN2QjtZQUNBTyxLQUFLLElBQUksTUFBTWlGLGFBQWEsQ0FBQ3BGLEtBQUQsRUFBUSxDQUFSLEVBQVcsYUFBWCxDQUE1QjtVQUNELENBSEQsTUFHTyxJQUFNRCxNQUFNLENBQUM0RixHQUFQLEdBQWFiLGFBQWQsR0FBK0I5RSxLQUFLLENBQUNzRixtQkFBTixDQUEwQi9HLE1BQTFELEtBQ0M4QyxLQUFLLEdBQUd0QixNQUFNLENBQUNzQixLQUFQLENBQWF0QixNQUFNLENBQUM0RCxHQUFQLEtBQWVzQix3QkFBZixHQUEwQyxNQUF2RCxDQURULENBQUosRUFDOEU7WUFDbkY7WUFDQTlFLEtBQUssR0FBRztZQUNBO1lBQ0EsaUJBQW1CSixNQUFNLENBQUM0RixHQUFQLEdBQWEsQ0FBZCxJQUFvQixDQUFyQixHQUEwQixNQUExQixHQUFtQyxLQUFwRCxJQUNBO1lBQ0EsR0FGQSxHQUVNUCxhQUFhLENBQUNwRixLQUFELEVBQVFELE1BQU0sQ0FBQzRGLEdBQVAsR0FBYWIsYUFBckIsRUFBb0MsUUFBcEMsQ0FKM0IsQ0FGbUYsQ0FPbkY7O1lBQ0EsSUFBSXpELEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzhDLE1BQVQsQ0FBZ0IsQ0FBaEIsS0FBc0IsR0FBMUIsRUFBK0I7Y0FDN0JoRSxLQUFLLElBQUksd0JBQVQ7WUFDRCxDQVZrRixDQVduRjs7O1lBQ0EsSUFBSW9GLFlBQVksQ0FBQ3hGLE1BQUQsQ0FBaEIsRUFBMEI7Y0FDeEJJLEtBQUssSUFBSSxNQUFNaUYsYUFBYSxDQUFDcEYsS0FBRCxFQUFRRCxNQUFNLENBQUM0RixHQUFmLEVBQW9CLG9CQUFwQixDQUE1QjtZQUNEO1VBQ0YsQ0FoQk0sTUFnQkEsSUFBSTNGLEtBQUssQ0FBQ3dGLGlCQUFWLEVBQTZCO1lBQ2xDO1lBQ0EsSUFBSXpGLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYSxVQUFiLENBQUosRUFBOEI7Y0FDNUI7Y0FDQXJCLEtBQUssQ0FBQ3dGLGlCQUFOLEdBQTBCLEtBQTFCOztjQUNBLElBQUlULGtCQUFrQixJQUFJLENBQUNoRixNQUFNLENBQUNxRyxHQUFQLEVBQTNCLEVBQXlDO2dCQUN2QztnQkFDQXBHLEtBQUssQ0FBQ2dHLGdCQUFOLEdBQXlCLEtBQXpCO2NBQ0Q7WUFDRixDQVBELE1BT087Y0FDTGpHLE1BQU0sQ0FBQ3FCLFNBQVA7WUFDRDs7WUFDRGpCLEtBQUssR0FBRyxTQUFSO1VBQ0QsQ0FiTSxNQWFBLElBQUksQ0FBQ2tCLEtBQUssR0FBR3RCLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYThELGVBQWIsQ0FBVCxLQUEyQyxDQUFDbkYsS0FBSyxDQUFDd0YsaUJBQXRELEVBQXlFO1lBQzlFO1lBQ0EsSUFBSW5FLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxJQUFoQixFQUFzQjtjQUNwQjtjQUNBdEIsTUFBTSxDQUFDcUIsU0FBUDtZQUNELENBSEQsTUFHTztjQUNMO2NBQ0FwQixLQUFLLENBQUN3RixpQkFBTixHQUEwQixJQUExQjtZQUNEOztZQUNEckYsS0FBSyxHQUFHLFNBQVI7VUFDRCxDQVZNLE1BVUEsSUFBSWtCLEtBQUssR0FBR3RCLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYTJELGFBQWIsQ0FBWixFQUF5QztZQUM5QztZQUNBLElBQUlxQixNQUFNLEdBQUdoRixLQUFLLENBQUMsQ0FBRCxDQUFsQjtZQUNBLElBQUlpRixRQUFRLEdBQUdqRixLQUFLLENBQUMsQ0FBRCxDQUFwQjs7WUFDQSxLQUFJO1lBQ0F1RCxrQkFBa0IsQ0FBQzJCLGNBQW5CLENBQWtDRixNQUFsQyxPQUNBO1lBQ0NDLFFBQVEsQ0FBQy9ILE1BQVQsR0FBa0IsQ0FBbEIsSUFBdUJ3QixNQUFNLENBQUNxRyxHQUFQLEVBRnhCLENBREosRUFHMkM7Y0FDekNqRyxLQUFLLEdBQUd5RSxrQkFBa0IsQ0FBQ3lCLE1BQUQsQ0FBMUI7O2NBQ0EsSUFBSXRHLE1BQU0sQ0FBQzZCLE1BQVAsTUFBbUI1QixLQUFLLENBQUMyQixRQUE3QixFQUF1QztnQkFDckM7Z0JBQ0F4QixLQUFLLElBQUksTUFBTWlGLGFBQWEsQ0FBQ3BGLEtBQUQsRUFBUUQsTUFBTSxDQUFDNkIsTUFBUCxFQUFSLEVBQXlCLGFBQXpCLENBQTVCO2NBQ0Q7WUFDRixDQVRELE1BU087Y0FDTDtjQUNBO2NBQ0E7Y0FDQTtjQUNBN0IsTUFBTSxDQUFDZ0IsTUFBUCxDQUFjaEIsTUFBTSxDQUFDUyxPQUFQLEdBQWlCakMsTUFBakIsR0FBMEIsQ0FBeEM7Y0FDQTRCLEtBQUssR0FBRyxhQUFSO1lBQ0Q7VUFDRixDQXJCTSxNQXFCQSxJQUFJSixNQUFNLENBQUNzQixLQUFQLENBQWEsTUFBYixDQUFKLEVBQTBCO1lBQy9CO1lBQ0FsQixLQUFLLEdBQUcsU0FBUjtVQUNELENBSE0sTUFHQSxJQUFJSixNQUFNLENBQUNzQixLQUFQLENBQWEsbUJBQWIsQ0FBSixFQUF1QztZQUM1QztZQUNBbEIsS0FBSyxHQUFHLE1BQVI7VUFDRCxDQUhNLE1BR0EsSUFBSWtCLEtBQUssR0FBR3RCLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYSx3QkFBYixDQUFaLEVBQW9EO1lBQ3pEO1lBQ0FsQixLQUFLLEdBQUlrQixLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVksR0FBYixHQUFvQixhQUFwQixHQUFvQyxRQUE1QztVQUNELENBSE0sTUFHQSxJQUFJdEIsTUFBTSxDQUFDc0IsS0FBUCxDQUFhLEtBQWIsQ0FBSixFQUF3QjtZQUM3QjtZQUNBLElBQUl0QixNQUFNLENBQUNxRyxHQUFQLEVBQUosRUFBa0I7Y0FDaEI7Y0FDQWpHLEtBQUssR0FBRyxPQUFSO1lBQ0QsQ0FIRCxNQUdPO2NBQ0w7Y0FDQUEsS0FBSyxHQUFHLGFBQVI7WUFDRDtVQUNGLENBVE0sTUFTQSxJQUFJSixNQUFNLENBQUNzQixLQUFQLENBQWEsV0FBYixDQUFKLEVBQStCO1lBQ3BDO1lBQ0FsQixLQUFLLEdBQUcsUUFBUjtVQUNELENBSE0sTUFHQTtZQUNMO1lBQ0FKLE1BQU0sQ0FBQ00sSUFBUDtZQUNBRixLQUFLLEdBQUcsYUFBUjtVQUNEOztVQUNELElBQUlnRyxjQUFKLEVBQW9CO1lBQ2xCaEcsS0FBSyxJQUFJLGdCQUFUO1VBQ0Q7UUFDRixDQXBIRCxNQW9ITztVQUNMLElBQUlKLE1BQU0sQ0FBQ3NCLEtBQVAsQ0FBYSxrQkFBYixDQUFKLEVBQXNDO1lBQ3BDO1lBQ0FsQixLQUFLLEdBQUcsUUFBUjtVQUNEO1FBQ0Y7O1FBQ0QsT0FBT0EsS0FBUDtNQUNELENBbE1JO01Bb01MZ0MsTUFBTSxFQUFFLGdCQUFTbkMsS0FBVCxFQUFnQjtRQUN0QixPQUFRQSxLQUFLLENBQUMwRixhQUFOLElBQXVCLElBQXhCLEdBQWdDMUYsS0FBSyxDQUFDa0csYUFBdEMsR0FBc0QsQ0FBQyxDQUE5RDtNQUNELENBdE1JO01Bd01MNUMsVUFBVSxFQUFFLG9CQUFTdEQsS0FBVCxFQUFnQjtRQUMxQkEsS0FBSyxDQUFDc0YsbUJBQU4sR0FBNEIsRUFBNUIsQ0FEMEIsQ0FDTzs7UUFDakN0RixLQUFLLENBQUMwRixhQUFOLEdBQXNCLElBQXRCLENBRjBCLENBRUc7O1FBQzdCMUYsS0FBSyxDQUFDa0csYUFBTixHQUFzQixDQUFDLENBQXZCLENBSDBCLENBR0c7O1FBQzdCbEcsS0FBSyxDQUFDd0YsaUJBQU4sR0FBMEIsS0FBMUIsQ0FKMEIsQ0FJUTs7UUFDbEMsSUFBSVQsa0JBQUosRUFBd0I7VUFDdEIvRSxLQUFLLENBQUNnRyxnQkFBTixHQUF5QixLQUF6QixDQURzQixDQUNXO1FBQ2xDO01BQ0Y7SUFoTkk7RUFIMkIsQ0FBcEM7QUF1TkQsQ0F6d0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL21vZGUvdmVyaWxvZy92ZXJpbG9nLmpzPzkwMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJ2ZXJpbG9nXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG5cbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdCxcbiAgICAgIHN0YXRlbWVudEluZGVudFVuaXQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50VW5pdCB8fCBpbmRlbnRVbml0LFxuICAgICAgZG9udEFsaWduQ2FsbHMgPSBwYXJzZXJDb25maWcuZG9udEFsaWduQ2FsbHMsXG4gICAgICAvLyBjb21waWxlckRpcmVjdGl2ZXNVc2VSZWd1bGFySW5kZW50YXRpb24gLSBJZiBzZXQsIENvbXBpbGVyIGRpcmVjdGl2ZVxuICAgICAgLy8gaW5kZW50YXRpb24gZm9sbG93cyB0aGUgc2FtZSBydWxlcyBhcyBldmVyeXRoaW5nIGVsc2UuIE90aGVyd2lzZSBpZlxuICAgICAgLy8gZmFsc2UsIGNvbXBpbGVyIGRpcmVjdGl2ZXMgd2lsbCB0cmFjayB0aGVpciBvd24gaW5kZW50YXRpb24uXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgYGlmZGVmIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBgaWZuZGVmIHdpbGwgYmUgaW5kZW50ZWQsXG4gICAgICAvLyBidXQgYSBgaWZkZWYgaW5zaWRlIGEgZnVuY3Rpb24gYmxvY2sgbWF5IG5vdCBiZSBpbmRlbnRlZC5cbiAgICAgIGNvbXBpbGVyRGlyZWN0aXZlc1VzZVJlZ3VsYXJJbmRlbnRhdGlvbiA9IHBhcnNlckNvbmZpZy5jb21waWxlckRpcmVjdGl2ZXNVc2VSZWd1bGFySW5kZW50YXRpb24sXG4gICAgICBub0luZGVudEtleXdvcmRzID0gcGFyc2VyQ29uZmlnLm5vSW5kZW50S2V5d29yZHMgfHwgW10sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICBob29rcyA9IHBhcnNlckNvbmZpZy5ob29rcyB8fCB7fTtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIEtleXdvcmRzIGZyb20gSUVFRSAxODAwLTIwMTJcbiAgICovXG4gIHZhciBrZXl3b3JkcyA9IHdvcmRzKFxuICAgIFwiYWNjZXB0X29uIGFsaWFzIGFsd2F5cyBhbHdheXNfY29tYiBhbHdheXNfZmYgYWx3YXlzX2xhdGNoIGFuZCBhc3NlcnQgYXNzaWduIGFzc3VtZSBhdXRvbWF0aWMgYmVmb3JlIGJlZ2luIGJpbmQgXCIgK1xuICAgIFwiYmlucyBiaW5zb2YgYml0IGJyZWFrIGJ1ZiBidWZpZjAgYnVmaWYxIGJ5dGUgY2FzZSBjYXNleCBjYXNleiBjZWxsIGNoYW5kbGUgY2hlY2tlciBjbGFzcyBjbG9ja2luZyBjbW9zIGNvbmZpZyBcIiArXG4gICAgXCJjb25zdCBjb25zdHJhaW50IGNvbnRleHQgY29udGludWUgY292ZXIgY292ZXJncm91cCBjb3ZlcnBvaW50IGNyb3NzIGRlYXNzaWduIGRlZmF1bHQgZGVmcGFyYW0gZGVzaWduIGRpc2FibGUgXCIgK1xuICAgIFwiZGlzdCBkbyBlZGdlIGVsc2UgZW5kIGVuZGNhc2UgZW5kY2hlY2tlciBlbmRjbGFzcyBlbmRjbG9ja2luZyBlbmRjb25maWcgZW5kZnVuY3Rpb24gZW5kZ2VuZXJhdGUgZW5kZ3JvdXAgXCIgK1xuICAgIFwiZW5kaW50ZXJmYWNlIGVuZG1vZHVsZSBlbmRwYWNrYWdlIGVuZHByaW1pdGl2ZSBlbmRwcm9ncmFtIGVuZHByb3BlcnR5IGVuZHNwZWNpZnkgZW5kc2VxdWVuY2UgZW5kdGFibGUgZW5kdGFzayBcIiArXG4gICAgXCJlbnVtIGV2ZW50IGV2ZW50dWFsbHkgZXhwZWN0IGV4cG9ydCBleHRlbmRzIGV4dGVybiBmaW5hbCBmaXJzdF9tYXRjaCBmb3IgZm9yY2UgZm9yZWFjaCBmb3JldmVyIGZvcmsgZm9ya2pvaW4gXCIgK1xuICAgIFwiZnVuY3Rpb24gZ2VuZXJhdGUgZ2VudmFyIGdsb2JhbCBoaWdoejAgaGlnaHoxIGlmIGlmZiBpZm5vbmUgaWdub3JlX2JpbnMgaWxsZWdhbF9iaW5zIGltcGxlbWVudHMgaW1wbGllcyBpbXBvcnQgXCIgK1xuICAgIFwiaW5jZGlyIGluY2x1ZGUgaW5pdGlhbCBpbm91dCBpbnB1dCBpbnNpZGUgaW5zdGFuY2UgaW50IGludGVnZXIgaW50ZXJjb25uZWN0IGludGVyZmFjZSBpbnRlcnNlY3Qgam9pbiBqb2luX2FueSBcIiArXG4gICAgXCJqb2luX25vbmUgbGFyZ2UgbGV0IGxpYmxpc3QgbGlicmFyeSBsb2NhbCBsb2NhbHBhcmFtIGxvZ2ljIGxvbmdpbnQgbWFjcm9tb2R1bGUgbWF0Y2hlcyBtZWRpdW0gbW9kcG9ydCBtb2R1bGUgXCIgK1xuICAgIFwibmFuZCBuZWdlZGdlIG5ldHR5cGUgbmV3IG5leHR0aW1lIG5tb3Mgbm9yIG5vc2hvd2NhbmNlbGxlZCBub3Qgbm90aWYwIG5vdGlmMSBudWxsIG9yIG91dHB1dCBwYWNrYWdlIHBhY2tlZCBcIiArXG4gICAgXCJwYXJhbWV0ZXIgcG1vcyBwb3NlZGdlIHByaW1pdGl2ZSBwcmlvcml0eSBwcm9ncmFtIHByb3BlcnR5IHByb3RlY3RlZCBwdWxsMCBwdWxsMSBwdWxsZG93biBwdWxsdXAgXCIgK1xuICAgIFwicHVsc2VzdHlsZV9vbmRldGVjdCBwdWxzZXN0eWxlX29uZXZlbnQgcHVyZSByYW5kIHJhbmRjIHJhbmRjYXNlIHJhbmRzZXF1ZW5jZSByY21vcyByZWFsIHJlYWx0aW1lIHJlZiByZWcgXCIgK1xuICAgIFwicmVqZWN0X29uIHJlbGVhc2UgcmVwZWF0IHJlc3RyaWN0IHJldHVybiBybm1vcyBycG1vcyBydHJhbiBydHJhbmlmMCBydHJhbmlmMSBzX2Fsd2F5cyBzX2V2ZW50dWFsbHkgc19uZXh0dGltZSBcIiArXG4gICAgXCJzX3VudGlsIHNfdW50aWxfd2l0aCBzY2FsYXJlZCBzZXF1ZW5jZSBzaG9ydGludCBzaG9ydHJlYWwgc2hvd2NhbmNlbGxlZCBzaWduZWQgc21hbGwgc29mdCBzb2x2ZSBzcGVjaWZ5IFwiICtcbiAgICBcInNwZWNwYXJhbSBzdGF0aWMgc3RyaW5nIHN0cm9uZyBzdHJvbmcwIHN0cm9uZzEgc3RydWN0IHN1cGVyIHN1cHBseTAgc3VwcGx5MSBzeW5jX2FjY2VwdF9vbiBzeW5jX3JlamVjdF9vbiBcIiArXG4gICAgXCJ0YWJsZSB0YWdnZWQgdGFzayB0aGlzIHRocm91Z2hvdXQgdGltZSB0aW1lcHJlY2lzaW9uIHRpbWV1bml0IHRyYW4gdHJhbmlmMCB0cmFuaWYxIHRyaSB0cmkwIHRyaTEgdHJpYW5kIHRyaW9yIFwiICtcbiAgICBcInRyaXJlZyB0eXBlIHR5cGVkZWYgdW5pb24gdW5pcXVlIHVuaXF1ZTAgdW5zaWduZWQgdW50aWwgdW50aWxfd2l0aCB1bnR5cGVkIHVzZSB1d2lyZSB2YXIgdmVjdG9yZWQgdmlydHVhbCB2b2lkIFwiICtcbiAgICBcIndhaXQgd2FpdF9vcmRlciB3YW5kIHdlYWsgd2VhazAgd2VhazEgd2hpbGUgd2lsZGNhcmQgd2lyZSB3aXRoIHdpdGhpbiB3b3IgeG5vciB4b3JcIik7XG5cbiAgLyoqIE9wZXJhdG9ycyBmcm9tIElFRUUgMTgwMC0yMDEyXG4gICAgIHVuYXJ5X29wZXJhdG9yIDo6PVxuICAgICAgICsgfCAtIHwgISB8IH4gfCAmIHwgfiYgfCB8IHwgfnwgfCBeIHwgfl4gfCBeflxuICAgICBiaW5hcnlfb3BlcmF0b3IgOjo9XG4gICAgICAgKyB8IC0gfCAqIHwgLyB8ICUgfCA9PSB8ICE9IHwgPT09IHwgIT09IHwgPT0/IHwgIT0/IHwgJiYgfCB8fCB8ICoqXG4gICAgICAgfCA8IHwgPD0gfCA+IHwgPj0gfCAmIHwgfCB8IF4gfCBefiB8IH5eIHwgPj4gfCA8PCB8ID4+PiB8IDw8PFxuICAgICAgIHwgLT4gfCA8LT5cbiAgICAgaW5jX29yX2RlY19vcGVyYXRvciA6Oj0gKysgfCAtLVxuICAgICB1bmFyeV9tb2R1bGVfcGF0aF9vcGVyYXRvciA6Oj1cbiAgICAgICAhIHwgfiB8ICYgfCB+JiB8IHwgfCB+fCB8IF4gfCB+XiB8IF5+XG4gICAgIGJpbmFyeV9tb2R1bGVfcGF0aF9vcGVyYXRvciA6Oj1cbiAgICAgICA9PSB8ICE9IHwgJiYgfCB8fCB8ICYgfCB8IHwgXiB8IF5+IHwgfl5cbiAgKi9cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1tcXCtcXC1cXCpcXC8hfiZ8XiU9Pzo8Pl0vO1xuICB2YXIgaXNCcmFja2V0Q2hhciA9IC9bXFxbXFxde30oKV0vO1xuXG4gIHZhciB1bnNpZ25lZE51bWJlciA9IC9cXGRbMC05X10qLztcbiAgdmFyIGRlY2ltYWxMaXRlcmFsID0gL1xcZCpcXHMqJ3M/ZFxccypcXGRbMC05X10qL2k7XG4gIHZhciBiaW5hcnlMaXRlcmFsID0gL1xcZCpcXHMqJ3M/YlxccypbeHowMV1beHowMV9dKi9pO1xuICB2YXIgb2N0TGl0ZXJhbCA9IC9cXGQqXFxzKidzP29cXHMqW3h6MC03XVt4ejAtN19dKi9pO1xuICB2YXIgaGV4TGl0ZXJhbCA9IC9cXGQqXFxzKidzP2hcXHMqWzAtOWEtZnh6P11bMC05YS1meHo/X10qL2k7XG4gIHZhciByZWFsTGl0ZXJhbCA9IC8oXFxkW1xcZF9dKihcXC5cXGRbXFxkX10qKT9FLT9bXFxkX10rKXwoXFxkW1xcZF9dKlxcLlxcZFtcXGRfXSopL2k7XG5cbiAgdmFyIGNsb3NpbmdCcmFja2V0T3JXb3JkID0gL14oKGA/XFx3Kyl8Wyl9XFxdXSkvO1xuICB2YXIgY2xvc2luZ0JyYWNrZXQgPSAvWyl9XFxdXS87XG4gIHZhciBjb21waWxlckRpcmVjdGl2ZVJlZ2V4ICAgICAgPSBuZXcgUmVnRXhwKFxuICAgIFwiXihgKD86aWZkZWZ8aWZuZGVmfGVsc2lmfGVsc2V8ZW5kaWZ8dW5kZWZ8dW5kZWZpbmVhbGx8ZGVmaW5lfGluY2x1ZGV8YmVnaW5fa2V5d29yZHN8Y2VsbGRlZmluZXxkZWZhdWx0fFwiICtcbiAgICBcIm5ldHR5cGV8ZW5kX2tleXdvcmRzfGVuZGNlbGxkZWZpbmV8bGluZXxub3VuY29ubmVjdGVkX2RyaXZlfHByYWdtYXxyZXNldGFsbHx0aW1lc2NhbGV8dW5jb25uZWN0ZWRfZHJpdmUpKVxcXFxiXCIpO1xuICB2YXIgY29tcGlsZXJEaXJlY3RpdmVCZWdpblJlZ2V4ID0gL14oYCg/OmlmZGVmfGlmbmRlZnxlbHNpZnxlbHNlKSlcXGIvO1xuICB2YXIgY29tcGlsZXJEaXJlY3RpdmVFbmRSZWdleCAgID0gL14oYCg/OmVsc2lmfGVsc2V8ZW5kaWYpKVxcYi87XG5cbiAgdmFyIGN1clB1bmM7XG4gIHZhciBjdXJLZXl3b3JkO1xuXG4gIC8vIEJsb2NrIG9wZW5pbmdzIHdoaWNoIGFyZSBjbG9zZWQgYnkgYSBtYXRjaGluZyBrZXl3b3JkIGluIHRoZSBmb3JtIG9mIChcImVuZFwiICsga2V5d29yZClcbiAgLy8gRS5nLiBcInRhc2tcIiA9PiBcImVuZHRhc2tcIlxuICB2YXIgYmxvY2tLZXl3b3JkcyA9IHdvcmRzKFxuICAgIFwiY2FzZSBjaGVja2VyIGNsYXNzIGNsb2NraW5nIGNvbmZpZyBmdW5jdGlvbiBnZW5lcmF0ZSBpbnRlcmZhY2UgbW9kdWxlIHBhY2thZ2UgXCIgK1xuICAgIFwicHJpbWl0aXZlIHByb2dyYW0gcHJvcGVydHkgc3BlY2lmeSBzZXF1ZW5jZSB0YWJsZSB0YXNrXCJcbiAgKTtcblxuICAvLyBPcGVuaW5nL2Nsb3NpbmcgcGFpcnNcbiAgdmFyIG9wZW5DbG9zZSA9IHt9O1xuICBmb3IgKHZhciBrZXl3b3JkIGluIGJsb2NrS2V5d29yZHMpIHtcbiAgICBvcGVuQ2xvc2Vba2V5d29yZF0gPSBcImVuZFwiICsga2V5d29yZDtcbiAgfVxuICBvcGVuQ2xvc2VbXCJiZWdpblwiXSA9IFwiZW5kXCI7XG4gIG9wZW5DbG9zZVtcImNhc2V4XCJdID0gXCJlbmRjYXNlXCI7XG4gIG9wZW5DbG9zZVtcImNhc2V6XCJdID0gXCJlbmRjYXNlXCI7XG4gIG9wZW5DbG9zZVtcImRvXCIgICBdID0gXCJ3aGlsZVwiO1xuICBvcGVuQ2xvc2VbXCJmb3JrXCIgXSA9IFwiam9pbjtqb2luX2FueTtqb2luX25vbmVcIjtcbiAgb3BlbkNsb3NlW1wiY292ZXJncm91cFwiXSA9IFwiZW5kZ3JvdXBcIjtcbiAgb3BlbkNsb3NlW1wibWFjcm9fYmVnaW5cIl0gPSBcIm1hY3JvX2VuZFwiO1xuXG4gIGZvciAodmFyIGkgaW4gbm9JbmRlbnRLZXl3b3Jkcykge1xuICAgIHZhciBrZXl3b3JkID0gbm9JbmRlbnRLZXl3b3Jkc1tpXTtcbiAgICBpZiAob3BlbkNsb3NlW2tleXdvcmRdKSB7XG4gICAgICBvcGVuQ2xvc2Vba2V5d29yZF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gS2V5d29yZHMgd2hpY2ggb3BlbiBzdGF0ZW1lbnRzIHRoYXQgYXJlIGVuZGVkIHdpdGggYSBzZW1pLWNvbG9uXG4gIHZhciBzdGF0ZW1lbnRLZXl3b3JkcyA9IHdvcmRzKFwiYWx3YXlzIGFsd2F5c19jb21iIGFsd2F5c19mZiBhbHdheXNfbGF0Y2ggYXNzZXJ0IGFzc2lnbiBhc3N1bWUgZWxzZSBleHBvcnQgZm9yIGZvcmVhY2ggZm9yZXZlciBpZiBpbXBvcnQgaW5pdGlhbCByZXBlYXQgd2hpbGUgZXh0ZXJuIHR5cGVkZWZcIik7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpLCBzdHlsZTtcbiAgICBpZiAoaG9va3NbY2hdICYmIChzdHlsZSA9IGhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKSkgIT0gZmFsc2UpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoaG9va3MudG9rZW5CYXNlICYmIChzdHlsZSA9IGhvb2tzLnRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSkgIT0gZmFsc2UpXG4gICAgICByZXR1cm4gc3R5bGU7XG5cbiAgICBpZiAoL1ssOzpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzQnJhY2tldENoYXIudGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgIH1cbiAgICAvLyBNYWNyb3MgKHRpY2stZGVmaW5lcylcbiAgICBpZiAoY2ggPT0gJ2AnKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLykpIHtcbiAgICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIGN1cktleXdvcmQgPSBjdXI7XG4gICAgICAgIC8vIE1hY3JvcyB0aGF0IGVuZCBpbiBfYmVnaW4sIGFyZSBzdGFydCBvZiBibG9jayBhbmQgZW5kIHdpdGggX2VuZFxuICAgICAgICBpZiAoY3VyLnN0YXJ0c1dpdGgoXCJgdXZtX1wiKSAmJiBjdXIuZW5kc1dpdGgoXCJfYmVnaW5cIikpIHtcbiAgICAgICAgICB2YXIga2V5d29yZENsb3NlID0gY3VyS2V5d29yZC5zdWJzdHIoMCxjdXJLZXl3b3JkLmxlbmd0aCAtIDUpICsgXCJlbmRcIjtcbiAgICAgICAgICBvcGVuQ2xvc2VbY3VyXSA9IGtleXdvcmRDbG9zZTtcbiAgICAgICAgICBjdXJQdW5jID0gXCJuZXdibG9ja1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09ICcoJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGJsb2NrXG4gICAgICAgICAgICBjdXJQdW5jID0gXCJuZXdtYWNyb1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgd2l0aFNwYWNlID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgICAvLyBNb3ZlIHRoZSBzdHJlYW0gYmFjayBiZWZvcmUgdGhlIHNwYWNlc1xuICAgICAgICAgIHN0cmVhbS5iYWNrVXAod2l0aFNwYWNlLmxlbmd0aCAtIGN1ci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN5c3RlbSBjYWxsc1xuICAgIGlmIChjaCA9PSAnJCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGltZSBsaXRlcmFsc1xuICAgIGlmIChjaCA9PSAnIycpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRfLl0vKTtcbiAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgICAvLyBFdmVudFxuICAgIGlmIChjaCA9PSAnQCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tAXS8pO1xuICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuICAgIC8vIFN0cmluZ3NcbiAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBDb21tZW50c1xuICAgIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgfVxuXG4gICAgLy8gTnVtZXJpYyBsaXRlcmFsc1xuICAgIGlmIChzdHJlYW0ubWF0Y2gocmVhbExpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChkZWNpbWFsTGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKGJpbmFyeUxpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChvY3RMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goaGV4TGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKHVuc2lnbmVkTnVtYmVyKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2gocmVhbExpdGVyYWwpKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG5cbiAgICAvLyBPcGVyYXRvcnNcbiAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKSkge1xuICAgICAgY3VyUHVuYyA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfVxuXG4gICAgLy8gS2V5d29yZHMgLyBwbGFpbiB2YXJpYWJsZXNcbiAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoa2V5d29yZHNbY3VyXSkge1xuICAgICAgICBpZiAob3BlbkNsb3NlW2N1cl0pIHtcbiAgICAgICAgICBjdXJQdW5jID0gXCJuZXdibG9ja1wiO1xuICAgICAgICAgIGlmIChjdXIgPT09IFwiZm9ya1wiKSB7XG4gICAgICAgICAgICAvLyBGb3JrIGNhbiBiZSBhIHN0YXRlbWVudCBpbnN0ZWFkIG9mIGJsb2NrIGluIGNhc2VzIG9mOlxuICAgICAgICAgICAgLy8gXCJkaXNhYmxlIGZvcms7XCIgYW5kIFwid2FpdCBmb3JrO1wiICh0cmFpbGluZyBzZW1pY29sb24pXG4gICAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gJzsnKSB7XG4gICAgICAgICAgICAgIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCAtIGN1ci5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVtZW50S2V5d29yZHNbY3VyXSkge1xuICAgICAgICAgIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIGN1cktleXdvcmQgPSBjdXI7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBtdWx0aUxpbmVTdHJpbmdzKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBzY29wZWtpbmQsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZWtpbmQgPSBzY29wZWtpbmQ7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSwgc2NvcGVraW5kKSB7XG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgIHZhciBjID0gbmV3IENvbnRleHQoaW5kZW50LCBjb2wsIHR5cGUsIHNjb3Bla2luZCA/IHNjb3Bla2luZCA6IFwiXCIsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gYztcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgaWYgKHQgPT0gXCIpXCIgfHwgdCA9PSBcIl1cIiB8fCB0ID09IFwifVwiKSB7XG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDbG9zaW5nKHRleHQsIGNvbnRleHRDbG9zaW5nKSB7XG4gICAgaWYgKHRleHQgPT0gY29udGV4dENsb3NpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb250ZXh0Q2xvc2luZyBtYXkgYmUgbXVsdGlwbGUga2V5d29yZHMgc2VwYXJhdGVkIGJ5IDtcbiAgICAgIHZhciBjbG9zaW5nS2V5d29yZHMgPSBjb250ZXh0Q2xvc2luZy5zcGxpdChcIjtcIik7XG4gICAgICBmb3IgKHZhciBpIGluIGNsb3NpbmdLZXl3b3Jkcykge1xuICAgICAgICBpZiAodGV4dCA9PSBjbG9zaW5nS2V5d29yZHNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5zaWRlU2NvcGVLaW5kKGN0eCwgc2NvcGVraW5kKSB7XG4gICAgaWYgKGN0eCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdHguc2NvcGVraW5kID09PSBzY29wZWtpbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNJbnNpZGVTY29wZUtpbmQoY3R4LnByZXYsIHNjb3Bla2luZCk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEVsZWN0cmljSW5wdXRSZWdFeCgpIHtcbiAgICAvLyBSZWluZGVudGF0aW9uIHNob3VsZCBvY2N1ciBvbiBhbnkgYnJhY2tldCBjaGFyOiB7fSgpW11cbiAgICAvLyBvciBvbiBhIG1hdGNoIG9mIGFueSBvZiB0aGUgYmxvY2sgY2xvc2luZyBrZXl3b3JkcywgYXRcbiAgICAvLyB0aGUgZW5kIG9mIGEgbGluZVxuICAgIHZhciBhbGxDbG9zaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb3BlbkNsb3NlKSB7XG4gICAgICBpZiAob3BlbkNsb3NlW2ldKSB7XG4gICAgICAgIHZhciBjbG9zaW5ncyA9IG9wZW5DbG9zZVtpXS5zcGxpdChcIjtcIik7XG4gICAgICAgIGZvciAodmFyIGogaW4gY2xvc2luZ3MpIHtcbiAgICAgICAgICBhbGxDbG9zaW5ncy5wdXNoKGNsb3NpbmdzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiW3t9KClcXFxcW1xcXFxdXXwoXCIgKyBhbGxDbG9zaW5ncy5qb2luKFwifFwiKSArIFwiKSRcIik7XG4gICAgcmV0dXJuIHJlO1xuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG4gIHJldHVybiB7XG5cbiAgICAvLyBSZWdleCB0byBmb3JjZSBjdXJyZW50IGxpbmUgdG8gcmVpbmRlbnRcbiAgICBlbGVjdHJpY0lucHV0OiBidWlsZEVsZWN0cmljSW5wdXRSZWdFeCgpLFxuXG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcInRvcFwiLCBcInRvcFwiLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiAwLFxuICAgICAgICBjb21waWxlckRpcmVjdGl2ZUluZGVudGVkOiAwLFxuICAgICAgICBzdGFydE9mTGluZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChob29rcy5zdGFydFN0YXRlKSBob29rcy5zdGFydFN0YXRlKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaG9va3MudG9rZW4pIHtcbiAgICAgICAgLy8gQ2FsbCBob29rLCB3aXRoIGFuIG9wdGlvbmFsIHJldHVybiB2YWx1ZSBvZiBhIHN0eWxlIHRvIG92ZXJyaWRlIHZlcmlsb2cgc3R5bGluZy5cbiAgICAgICAgdmFyIHN0eWxlID0gaG9va3MudG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgY3VyUHVuYyA9IG51bGw7XG4gICAgICBjdXJLZXl3b3JkID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiIHx8IHN0eWxlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICBpZiAoKChjdXJQdW5jID09PSBcIj1cIikgfHwgKGN1clB1bmMgPT09IFwiPD1cIikpICYmICFpc0luc2lkZVNjb3BlS2luZChjdHgsIFwiYXNzaWdubWVudFwiKSkge1xuICAgICAgICAgIC8vICc8PScgY291bGQgYmUgbm9uYmxvY2tpbmcgYXNzaWdubWVudCBvciBsZXNzdGhhbi1lcXVhbHMgKHdoaWNoIHNob3VsZG4ndCBjYXVzZSBpbmRlbnQpXG4gICAgICAgICAgLy8gICAgICBTZWFyY2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBzZWUgaWYgd2UgYXJlIGFscmVhZHkgaW4gYW4gYXNzaWdubWVudC5cbiAgICAgICAgICAvLyAnPScgY291bGQgYmUgaW5zaWRlIHBvcnQgZGVjbGFyYXRpb24gd2l0aCBjb21tYSBvciAnKScgYWZ0ZXJ3YXJkLCBvciBpbnNpZGUgZm9yKDs7KSBibG9jay5cbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpICsgY3VyUHVuYy5sZW5ndGgsIFwiYXNzaWdubWVudFwiLCBcImFzc2lnbm1lbnRcIik7XG4gICAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgdmFyIGlzQ2xvc2luZ0Fzc2lnbm1lbnQgPSBjdHgudHlwZSA9PSBcImFzc2lnbm1lbnRcIiAmJlxuICAgICAgICBjbG9zaW5nQnJhY2tldC50ZXN0KGN1clB1bmMpICYmIGN0eC5wcmV2ICYmIGN0eC5wcmV2LnR5cGUgPT09IGN1clB1bmM7XG4gICAgICBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSB8fCBpc0Nsb3NpbmdBc3NpZ25tZW50KSB7XG4gICAgICAgIGlmIChpc0Nsb3NpbmdBc3NpZ25tZW50KSB7XG4gICAgICAgICAgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdXJQdW5jID09IFwiKVwiKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGNsb3NpbmcgbWFjcm9zLCBhc3N1bWluZyB0aGV5IGNvdWxkIGhhdmUgYSBzZW1pY29sb24gb3IgYmVnaW4vZW5kIGJsb2NrIGluc2lkZS5cbiAgICAgICAgICBpZiAoY3R4ICYmIChjdHgudHlwZSA9PT0gXCJtYWNyb1wiKSkge1xuICAgICAgICAgICAgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgICB3aGlsZSAoY3R4ICYmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiIHx8IGN0eC50eXBlID09IFwiYXNzaWdubWVudFwiKSkgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgY2xvc2luZyBzdGF0ZW1lbnRzIGxpa2UgY29uc3RyYWludCBibG9jazogXCJmb3JlYWNoICgpIHt9XCIgd2hpY2hcbiAgICAgICAgICAvLyBkbyBub3QgaGF2ZSBzZW1pY29sb24gYXQgZW5kLlxuICAgICAgICAgIGlmIChjdHggJiYgKGN0eC50eXBlID09PSBcInN0YXRlbWVudFwiKSkge1xuICAgICAgICAgICAgd2hpbGUgKGN0eCAmJiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoKGN1clB1bmMgPT0gXCI7XCIgfHwgY3VyUHVuYyA9PSBcIixcIikgJiYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgfHwgY3R4LnR5cGUgPT0gXCJhc3NpZ25tZW50XCIpKSB8fFxuICAgICAgICAgICAgICAgKGN0eC50eXBlICYmIGlzQ2xvc2luZyhjdXJLZXl3b3JkLCBjdHgudHlwZSkpKSB7XG4gICAgICAgIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB3aGlsZSAoY3R4ICYmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiIHx8IGN0eC50eXBlID09IFwiYXNzaWdubWVudFwiKSkgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICB9IGVsc2UgaWYgKGN0eCAmJiBjdHgudHlwZSA9PSBcImVuZGNhc2VcIiAmJiBjdXJQdW5jID09IFwiOlwiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIsIFwiY2FzZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIsIGN1cktleXdvcmQpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwibmV3YmxvY2tcIikge1xuICAgICAgICBpZiAoY3VyS2V5d29yZCA9PSBcImZ1bmN0aW9uXCIgJiYgY3R4ICYmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiIHx8IGN0eC50eXBlID09IFwiZW5kZ3JvdXBcIikpIHtcbiAgICAgICAgICAvLyBUaGUgJ2Z1bmN0aW9uJyBrZXl3b3JkIGNhbiBhcHBlYXIgaW4gc29tZSBvdGhlciBjb250ZXh0cyB3aGVyZSBpdCBhY3R1YWxseSBkb2VzIG5vdFxuICAgICAgICAgIC8vIGluZGljYXRlIGEgZnVuY3Rpb24gKGltcG9ydC9leHBvcnQgRFBJIGFuZCBjb3Zlcmdyb3VwIGRlZmluaXRpb25zKS5cbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGluIHRoaXMgY2FzZVxuICAgICAgICB9IGVsc2UgaWYgKGN1cktleXdvcmQgPT0gXCJ0YXNrXCIgJiYgY3R4ICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAvLyBTYW1lIHRoaW5nIGZvciB0YXNrXG4gICAgICAgIH0gZWxzZSBpZiAoY3VyS2V5d29yZCA9PSBcImNsYXNzXCIgJiYgY3R4ICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAvLyBTYW1lIHRoaW5nIGZvciBjbGFzcyAoZS5nLiB0eXBlZGVmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjbG9zZSA9IG9wZW5DbG9zZVtjdXJLZXl3b3JkXTtcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBjbG9zZSwgY3VyS2V5d29yZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIm5ld21hY3JvXCIgfHwgKGN1cktleXdvcmQgJiYgY3VyS2V5d29yZC5tYXRjaChjb21waWxlckRpcmVjdGl2ZVJlZ2V4KSkpIHtcbiAgICAgICAgaWYgKGN1clB1bmMgPT0gXCJuZXdtYWNyb1wiKSB7XG4gICAgICAgICAgLy8gTWFjcm9zIChlc3BlY2lhbGx5IGlmIHRoZXkgaGF2ZSBwYXJlbnRoZXNpcykgcG90ZW50aWFsbHkgaGF2ZSBhIHNlbWljb2xvblxuICAgICAgICAgIC8vIG9yIGNvbXBsZXRlIHN0YXRlbWVudC9ibG9jayBpbnNpZGUsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBzdWNoLlxuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwibWFjcm9cIiwgXCJtYWNyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyS2V5d29yZC5tYXRjaChjb21waWxlckRpcmVjdGl2ZUVuZFJlZ2V4KSkge1xuICAgICAgICAgIHN0YXRlLmNvbXBpbGVyRGlyZWN0aXZlSW5kZW50ZWQgLT0gc3RhdGVtZW50SW5kZW50VW5pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyS2V5d29yZC5tYXRjaChjb21waWxlckRpcmVjdGl2ZUJlZ2luUmVnZXgpKSB7XG4gICAgICAgICAgc3RhdGUuY29tcGlsZXJEaXJlY3RpdmVJbmRlbnRlZCArPSBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgaWYgKGhvb2tzLmluZGVudCkge1xuICAgICAgICB2YXIgZnJvbUhvb2sgPSBob29rcy5pbmRlbnQoc3RhdGUpO1xuICAgICAgICBpZiAoZnJvbUhvb2sgPj0gMCkgcmV0dXJuIGZyb21Ib29rO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQsIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBjdHggPSBjdHgucHJldjtcbiAgICAgIHZhciBjbG9zaW5nID0gZmFsc2U7XG4gICAgICB2YXIgcG9zc2libGVDbG9zaW5nID0gdGV4dEFmdGVyLm1hdGNoKGNsb3NpbmdCcmFja2V0T3JXb3JkKTtcbiAgICAgIGlmIChwb3NzaWJsZUNsb3NpbmcpXG4gICAgICAgIGNsb3NpbmcgPSBpc0Nsb3NpbmcocG9zc2libGVDbG9zaW5nWzBdLCBjdHgudHlwZSk7XG4gICAgICBpZiAoIWNvbXBpbGVyRGlyZWN0aXZlc1VzZVJlZ3VsYXJJbmRlbnRhdGlvbiAmJiB0ZXh0QWZ0ZXIubWF0Y2goY29tcGlsZXJEaXJlY3RpdmVSZWdleCkpIHtcbiAgICAgICAgaWYgKHRleHRBZnRlci5tYXRjaChjb21waWxlckRpcmVjdGl2ZUVuZFJlZ2V4KSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5jb21waWxlckRpcmVjdGl2ZUluZGVudGVkIC0gc3RhdGVtZW50SW5kZW50VW5pdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUuY29tcGlsZXJEaXJlY3RpdmVJbmRlbnRlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSByZXR1cm4gY3R4LmluZGVudGVkICsgKGZpcnN0Q2hhciA9PSBcIntcIiA/IDAgOiBzdGF0ZW1lbnRJbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKChjbG9zaW5nQnJhY2tldC50ZXN0KGN0eC50eXBlKSB8fCBjdHgudHlwZSA9PSBcImFzc2lnbm1lbnRcIilcbiAgICAgICAgJiYgY3R4LmFsaWduICYmICFkb250QWxpZ25DYWxscykgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGVsc2UgaWYgKGN0eC50eXBlID09IFwiKVwiICYmICFjbG9zaW5nKSByZXR1cm4gY3R4LmluZGVudGVkICsgc3RhdGVtZW50SW5kZW50VW5pdDtcbiAgICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgZm9sZDogXCJpbmRlbnRcIlxuICB9O1xufSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXZlcmlsb2dcIiwge1xuICAgIG5hbWU6IFwidmVyaWxvZ1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zeXN0ZW12ZXJpbG9nXCIsIHtcbiAgICBuYW1lOiBcInZlcmlsb2dcIlxuICB9KTtcblxuXG5cbiAgLy8gVEwtVmVyaWxvZyBtb2RlLlxuICAvLyBTZWUgdGwteC5vcmcgZm9yIGxhbmd1YWdlIHNwZWMuXG4gIC8vIFNlZSB0aGUgbW9kZSBpbiBhY3Rpb24gYXQgbWFrZXJjaGlwLmNvbS5cbiAgLy8gQ29udGFjdDogc3RldmUuaG9vdmVyQHJlZHdvb2RlZGEuY29tXG5cbiAgLy8gVExWIElkZW50aWZpZXIgcHJlZml4ZXMuXG4gIC8vIE5vdGUgdGhhdCBzaWduIGlzIG5vdCB0cmVhdGVkIHNlcGFyYXRlbHksIHNvIFwiKy8tXCIgdmVyc2lvbnMgb2YgbnVtZXJpYyBpZGVudGlmaWVyc1xuICAvLyBhcmUgaW5jbHVkZWQuXG4gIHZhciB0bHZJZGVudGlmaWVyU3R5bGUgPSB7XG4gICAgXCJ8XCI6IFwibGlua1wiLFxuICAgIFwiPlwiOiBcInByb3BlcnR5XCIsICAvLyBTaG91bGQgY29uZGl0aW9uIHRoaXMgb2ZmIGZvciA+IFRMViAxYy5cbiAgICBcIiRcIjogXCJ2YXJpYWJsZVwiLFxuICAgIFwiJCRcIjogXCJ2YXJpYWJsZVwiLFxuICAgIFwiPyRcIjogXCJxdWFsaWZpZXJcIixcbiAgICBcIj8qXCI6IFwicXVhbGlmaWVyXCIsXG4gICAgXCItXCI6IFwiaHJcIixcbiAgICBcIi9cIjogXCJwcm9wZXJ0eVwiLFxuICAgIFwiLy1cIjogXCJwcm9wZXJ0eVwiLFxuICAgIFwiQFwiOiBcInZhcmlhYmxlLTNcIixcbiAgICBcIkAtXCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQCsrXCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQCs9XCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQCs9LVwiOiBcInZhcmlhYmxlLTNcIixcbiAgICBcIkAtLVwiOiBcInZhcmlhYmxlLTNcIixcbiAgICBcIkAtPVwiOiBcInZhcmlhYmxlLTNcIixcbiAgICBcIiUrXCI6IFwidGFnXCIsXG4gICAgXCIlLVwiOiBcInRhZ1wiLFxuICAgIFwiJVwiOiBcInRhZ1wiLFxuICAgIFwiPj5cIjogXCJ0YWdcIixcbiAgICBcIjw8XCI6IFwidGFnXCIsXG4gICAgXCI8PlwiOiBcInRhZ1wiLFxuICAgIFwiI1wiOiBcInRhZ1wiLCAgLy8gTmVlZCB0byBjaG9vc2UgYSBzdHlsZSBmb3IgdGhpcy5cbiAgICBcIl5cIjogXCJhdHRyaWJ1dGVcIixcbiAgICBcIl5eXCI6IFwiYXR0cmlidXRlXCIsXG4gICAgXCJeIVwiOiBcImF0dHJpYnV0ZVwiLFxuICAgIFwiKlwiOiBcInZhcmlhYmxlLTJcIixcbiAgICBcIioqXCI6IFwidmFyaWFibGUtMlwiLFxuICAgIFwiXFxcXFwiOiBcImtleXdvcmRcIixcbiAgICBcIlxcXCJcIjogXCJjb21tZW50XCJcbiAgfTtcblxuICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHRoZXNlIGNoYXJhY3RlcnMgZGVmaW5lIHNjb3BlIChyZXN1bHQgaW4gaW5kZW50YXRpb24pLlxuICB2YXIgdGx2U2NvcGVQcmVmaXhDaGFycyA9IHtcbiAgICBcIi9cIjogXCJiZWgtaGllclwiLFxuICAgIFwiPlwiOiBcImJlaC1oaWVyXCIsXG4gICAgXCItXCI6IFwicGh5cy1oaWVyXCIsXG4gICAgXCJ8XCI6IFwicGlwZVwiLFxuICAgIFwiP1wiOiBcIndoZW5cIixcbiAgICBcIkBcIjogXCJzdGFnZVwiLFxuICAgIFwiXFxcXFwiOiBcImtleXdvcmRcIlxuICB9O1xuICB2YXIgdGx2SW5kZW50VW5pdCA9IDM7XG4gIHZhciB0bHZUcmFja1N0YXRlbWVudHMgPSBmYWxzZTtcbiAgdmFyIHRsdklkZW50TWF0Y2ggPSAvXihbfiFAI1xcJCVcXF4mXFwqLVxcKz1cXD9cXC9cXFxcXFx8J1wiPD5dKykoW1xcZFxcd19dKikvOyAgLy8gTWF0Y2hlcyBhbiBpZGVudGlmaWVyLlxuICAvLyBOb3RlIHRoYXQgJzonIGlzIGV4Y2x1ZGVkLCBiZWNhdXNlIG9mIGl0J3MgdXNlIGluIFs6XS5cbiAgdmFyIHRsdkZpcnN0TGV2ZWxJbmRlbnRNYXRjaCA9IC9eWyEgXSAgLztcbiAgdmFyIHRsdkxpbmVJbmRlbnRhdGlvbk1hdGNoID0gL15bISBdICovO1xuICB2YXIgdGx2Q29tbWVudE1hdGNoID0gL15cXC9bXFwvXFwqXS87XG5cblxuICAvLyBSZXR1cm5zIGEgc3R5bGUgc3BlY2lmaWMgdG8gdGhlIHNjb3BlIGF0IHRoZSBnaXZlbiBpbmRlbnRhdGlvbiBjb2x1bW4uXG4gIC8vIFR5cGUgaXMgb25lIG9mOiBcImluZGVudFwiLCBcInNjb3BlLWlkZW50XCIsIFwiYmVmb3JlLXNjb3BlLWlkZW50XCIuXG4gIGZ1bmN0aW9uIHRsdlNjb3BlU3R5bGUoc3RhdGUsIGluZGVudGF0aW9uLCB0eXBlKSB7XG4gICAgLy8gQmVnaW4gc2NvcGUuXG4gICAgdmFyIGRlcHRoID0gaW5kZW50YXRpb24gLyB0bHZJbmRlbnRVbml0OyAgLy8gVE9ETzogUGFzcyB0aGlzIGluIGluc3RlYWQuXG4gICAgcmV0dXJuIFwidGx2LVwiICsgc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZVtkZXB0aF0gKyBcIi1cIiArIHR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0aGluZyBpbiB0aGUgc3RyZWFtIGlzIGFuIGlkZW50aWZpZXIgd2l0aCBhIG1uZW1vbmljLlxuICBmdW5jdGlvbiB0bHZJZGVudE5leHQoc3RyZWFtKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHJldHVybiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2godGx2SWRlbnRNYXRjaCwgZmFsc2UpKSAmJiBtYXRjaFsyXS5sZW5ndGggPiAwO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXRsdlwiLCB7XG4gICAgbmFtZTogXCJ2ZXJpbG9nXCIsXG5cbiAgICBob29rczoge1xuXG4gICAgICBlbGVjdHJpY0lucHV0OiBmYWxzZSxcblxuXG4gICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGZvciB2ZXJpbG9nIHRva2VuaXppbmcsIG9yIHN0eWxlIGZvciBUTFYgdG9rZW4gKG51bGwgbm90IHVzZWQpLlxuICAgICAgLy8gU3RhbmRhcmQgQ00gc3R5bGVzIGFyZSB1c2VkIGZvciBtb3N0IGZvcm1hdHRpbmcsIGJ1dCBzb21lIFRMLVZlcmlsb2ctc3BlY2lmaWMgaGlnaGxpZ2h0aW5nXG4gICAgICAvLyBjYW4gYmUgZW5hYmxlZCB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIGNtLXRsdi0qIHN0eWxlcywgaW5jbHVkaW5nIGhpZ2hsaWdodGluZyBmb3I6XG4gICAgICAvLyAgIC0gTTQgdG9rZW5zXG4gICAgICAvLyAgIC0gVExWIHNjb3BlIGluZGVudGF0aW9uXG4gICAgICAvLyAgIC0gU3RhdGVtZW50IGRlbGltaXRhdGlvbiAoZW5hYmxlZCBieSB0bHZUcmFja1N0YXRlbWVudHMpXG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBtYXRjaDsgIC8vIFJldHVybiB2YWx1ZSBvZiBwYXR0ZXJuIG1hdGNoZXMuXG5cbiAgICAgICAgLy8gU2V0IGhpZ2hsaWdodGluZyBtb2RlIGJhc2VkIG9uIGNvZGUgcmVnaW9uIChUTFYgb3IgU1YpLlxuICAgICAgICBpZiAoc3RyZWFtLnNvbCgpICYmICEgc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQpIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHJlZ2lvbi5cbiAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHN0eWxlID0gXCJkZWZcIjtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uc3RyaW5nLm1hdGNoKC9cXFxcU1YvKSkge1xuICAgICAgICAgICAgICBzdGF0ZS50bHZDb2RlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5zdHJpbmcubWF0Y2goL1xcXFxUTFYvKSl7XG4gICAgICAgICAgICAgIHN0YXRlLnRsdkNvZGVBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb3JyZWN0IGluZGVudGF0aW9uIGluIHRoZSBmYWNlIG9mIGEgbGluZSBwcmVmaXggY2hhci5cbiAgICAgICAgICBpZiAoc3RhdGUudGx2Q29kZUFjdGl2ZSAmJiBzdHJlYW0ucG9zID09IDAgJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmluZGVudGVkID09IDApICYmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZMaW5lSW5kZW50YXRpb25NYXRjaCwgZmFsc2UpKSkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29tcHV0ZSBpbmRlbnRhdGlvbiBzdGF0ZTpcbiAgICAgICAgICAvLyAgIG8gQXV0byBpbmRlbnRhdGlvbiBvbiBuZXh0IGxpbmVcbiAgICAgICAgICAvLyAgIG8gSW5kZW50YXRpb24gc2NvcGUgc3R5bGVzXG4gICAgICAgICAgdmFyIGluZGVudGVkID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICAgICAgdmFyIGRlcHRoID0gaW5kZW50ZWQgLyB0bHZJbmRlbnRVbml0O1xuICAgICAgICAgIGlmIChkZXB0aCA8PSBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbm90IGRlZXBlciB0aGFuIGN1cnJlbnQgc2NvcGVcblxuICAgICAgICAgICAgdmFyIGJsYW5rbGluZSA9IHN0cmVhbS5zdHJpbmcubGVuZ3RoID09IGluZGVudGVkO1xuICAgICAgICAgICAgdmFyIGNoUG9zID0gZGVwdGggKiB0bHZJbmRlbnRVbml0O1xuICAgICAgICAgICAgaWYgKGNoUG9zIDwgc3RyZWFtLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGJvZHlTdHJpbmcgPSBzdHJlYW0uc3RyaW5nLnNsaWNlKGNoUG9zKTtcbiAgICAgICAgICAgICAgdmFyIGNoID0gYm9keVN0cmluZ1swXTtcbiAgICAgICAgICAgICAgaWYgKHRsdlNjb3BlUHJlZml4Q2hhcnNbY2hdICYmICgobWF0Y2ggPSBib2R5U3RyaW5nLm1hdGNoKHRsdklkZW50TWF0Y2gpKSAmJlxuICAgICAgICAgICAgICAgICAgdGx2SWRlbnRpZmllclN0eWxlW21hdGNoWzFdXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxpbmUgYmVnaW5zIHNjb3BlLlxuICAgICAgICAgICAgICAgIC8vIE5leHQgbGluZSBnZXRzIGluZGVudGVkIG9uZSBsZXZlbC5cbiAgICAgICAgICAgICAgICBpbmRlbnRlZCArPSB0bHZJbmRlbnRVbml0O1xuICAgICAgICAgICAgICAgIC8vIFN0eWxlIHRoZSBuZXh0IGxldmVsIG9mIGluZGVudGF0aW9uIChleGNlcHQgbm9uLXJlZ2lvbiBrZXl3b3JkIGlkZW50aWZpZXJzLFxuICAgICAgICAgICAgICAgIC8vICAgd2hpY2ggYXJlIHN0YXRlbWVudHMgdGhlbXNlbHZlcylcbiAgICAgICAgICAgICAgICBpZiAoIShjaCA9PSBcIlxcXFxcIiAmJiBjaFBvcyA+IDApKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlW2RlcHRoXSA9IHRsdlNjb3BlUHJlZml4Q2hhcnNbY2hdO1xuICAgICAgICAgICAgICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cykge3N0YXRlLnN0YXRlbWVudENvbW1lbnQgPSBmYWxzZTt9XG4gICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IGRlZXBlciBpbmRlbnRhdGlvbiBsZXZlbHMgdW5sZXNzIGxpbmUgaXMgYmxhbmsuXG4gICAgICAgICAgICBpZiAoIWJsYW5rbGluZSkge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZS5sZW5ndGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2V0IG5leHQgbGV2ZWwgb2YgaW5kZW50YXRpb24uXG4gICAgICAgICAgc3RhdGUudGx2TmV4dEluZGVudCA9IGluZGVudGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnRsdkNvZGVBY3RpdmUpIHtcbiAgICAgICAgICAvLyBIaWdobGlnaHQgYXMgVExWLlxuXG4gICAgICAgICAgdmFyIGJlZ2luU3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cykge1xuICAgICAgICAgICAgLy8gVGhpcyBzdGFydHMgYSBzdGF0ZW1lbnQgaWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBzY29wZSBsZXZlbFxuICAgICAgICAgICAgLy8gYW5kIHdlJ3JlIG5vdCB3aXRoaW4gYSBzdGF0ZW1lbnQgbGVhZGluZyBjb21tZW50LlxuICAgICAgICAgICAgYmVnaW5TdGF0ZW1lbnQgPVxuICAgICAgICAgICAgICAgICAgIChzdHJlYW0ucGVlaygpICE9IFwiIFwiKSAmJiAgIC8vIG5vdCBhIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgKHN0eWxlID09PSB1bmRlZmluZWQpICYmICAgIC8vIG5vdCBhIHJlZ2lvbiBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIXN0YXRlLnRsdkluQmxvY2tDb21tZW50ICYmIC8vIG5vdCBpbiBibG9jayBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgLy8hc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCwgZmFsc2UpICYmIC8vIG5vdCBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgKHN0cmVhbS5jb2x1bW4oKSA9PSBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCAqIHRsdkluZGVudFVuaXQpOyAgLy8gYXQgc2NvcGUgbGV2ZWxcbiAgICAgICAgICAgIGlmIChiZWdpblN0YXRlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RhdGVtZW50Q29tbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXRlbWVudCBhbHJlYWR5IHN0YXJ0ZWQgYnkgY29tbWVudFxuICAgICAgICAgICAgICAgIGJlZ2luU3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9XG4gICAgICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCwgZmFsc2UpOyAvLyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBSZWdpb24gbGluZS5cbiAgICAgICAgICAgIHN0eWxlICs9IFwiIFwiICsgdGx2U2NvcGVTdHlsZShzdGF0ZSwgMCwgXCJzY29wZS1pZGVudFwiKVxuICAgICAgICAgIH0gZWxzZSBpZiAoKChzdHJlYW0ucG9zIC8gdGx2SW5kZW50VW5pdCkgPCBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIChtYXRjaCA9IHN0cmVhbS5tYXRjaChzdHJlYW0uc29sKCkgPyB0bHZGaXJzdExldmVsSW5kZW50TWF0Y2ggOiAvXiAgIC8pKSkge1xuICAgICAgICAgICAgLy8gSW5kZW50YXRpb25cbiAgICAgICAgICAgIHN0eWxlID0gLy8gbWFrZSB0aGlzIHN0eWxlIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIG9uZSB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGVtaXJyb3IgZnJvbSBjb21iaW5pbmcgc3BhbnNcbiAgICAgICAgICAgICAgICAgICAgXCJ0bHYtaW5kZW50LVwiICsgKCgoc3RyZWFtLnBvcyAlIDIpID09IDApID8gXCJldmVuXCIgOiBcIm9kZFwiKSArXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzdHlsZSBpdFxuICAgICAgICAgICAgICAgICAgICBcIiBcIiArIHRsdlNjb3BlU3R5bGUoc3RhdGUsIHN0cmVhbS5wb3MgLSB0bHZJbmRlbnRVbml0LCBcImluZGVudFwiKTtcbiAgICAgICAgICAgIC8vIFN0eWxlIHRoZSBsaW5lIHByZWZpeCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMF0uY2hhckF0KDApID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgIHN0eWxlICs9IFwiIHRsdi1hbGVydC1saW5lLXByZWZpeFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGxhY2UgYSBjbGFzcyBiZWZvcmUgYSBzY29wZSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgaWYgKHRsdklkZW50TmV4dChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHN0eWxlICs9IFwiIFwiICsgdGx2U2NvcGVTdHlsZShzdGF0ZSwgc3RyZWFtLnBvcywgXCJiZWZvcmUtc2NvcGUtaWRlbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAgICAgLy8gSW4gYSBibG9jayBjb21tZW50LlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXi4qP1xcKlxcLy8pKSB7XG4gICAgICAgICAgICAgIC8vIEV4aXQgYmxvY2sgY29tbWVudC5cbiAgICAgICAgICAgICAgc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cyAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQW55dGhpbmcgYWZ0ZXIgY29tbWVudCBpcyBhc3N1bWVkIHRvIGJlIHJlYWwgc3RhdGVtZW50IGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZSA9IFwiY29tbWVudFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCkpICYmICFzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAgICAgLy8gU3RhcnQgY29tbWVudC5cbiAgICAgICAgICAgIGlmIChtYXRjaFswXSA9PSBcIi8vXCIpIHtcbiAgICAgICAgICAgICAgLy8gTGluZSBjb21tZW50LlxuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50LlxuICAgICAgICAgICAgICBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZSA9IFwiY29tbWVudFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2godGx2SWRlbnRNYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgYW4gaWRlbnRpZmllciAob3IgaWRlbnRpZmllciBwcmVmaXgpXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbW5lbW9uaWMgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGlmICgvLyBpcyBpZGVudGlmaWVyIHByZWZpeFxuICAgICAgICAgICAgICAgIHRsdklkZW50aWZpZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpICYmXG4gICAgICAgICAgICAgICAgLy8gaGFzIG1uZW1vbmljIG9yIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKG1heWJlIGl0IGhhc24ndCBiZWVuIHR5cGVkIHlldClcbiAgICAgICAgICAgICAgICAobW5lbW9uaWMubGVuZ3RoID4gMCB8fCBzdHJlYW0uZW9sKCkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlID0gdGx2SWRlbnRpZmllclN0eWxlW3ByZWZpeF07XG4gICAgICAgICAgICAgIGlmIChzdHJlYW0uY29sdW1uKCkgPT0gc3RhdGUuaW5kZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWdpbiBzY29wZS5cbiAgICAgICAgICAgICAgICBzdHlsZSArPSBcIiBcIiArIHRsdlNjb3BlU3R5bGUoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzY29wZS1pZGVudFwiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBKdXN0IHN3YWxsb3cgb25lIGNoYXJhY3RlciBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAgICAgICAvLyBUaGlzIGVuYWJsZXMgc3Vic2VxdWVudCBpZGVudGlmaWVyIG1hdGNoIHdpdGggcHJlY2VkaW5nIHN5bWJvbCBjaGFyYWN0ZXIsIHdoaWNoXG4gICAgICAgICAgICAgIC8vICAgaXMgbGVnYWwgd2l0aGluIGEgc3RhdGVtZW50LiAgKEUuZy4sICEkcmVzZXQpLiAgSXQgYWxzbyBlbmFibGVzIGRldGVjdGlvbiBvZlxuICAgICAgICAgICAgICAvLyAgIGNvbW1lbnQgc3RhcnQgd2l0aCBwcmVjZWRpbmcgc3ltYm9scy5cbiAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBzdHlsZSA9IFwidGx2LWRlZmF1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlxcdCsvKSkge1xuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRhYnMsIHdoaWNoIGFyZSBpbGxlZ2FsLlxuICAgICAgICAgICAgc3R5bGUgPSBcInRsdi10YWJcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXltcXFtcXF17fVxcKFxcKTtcXDpdKy8pKSB7XG4gICAgICAgICAgICAvLyBbOl0sICgpLCB7fSwgOy5cbiAgICAgICAgICAgIHN0eWxlID0gXCJtZXRhXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXlttTV00KFtcXCtfXSk/W1xcd1xcZF9dKi8pKSB7XG4gICAgICAgICAgICAvLyBtNCBwcmUgcHJvY1xuICAgICAgICAgICAgc3R5bGUgPSAobWF0Y2hbMV0gPT0gXCIrXCIpID8gXCJ0bHYtbTQtcGx1c1wiIDogXCJ0bHYtbTRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiArLykpe1xuICAgICAgICAgICAgLy8gU2tpcCBvdmVyIHNwYWNlcy5cbiAgICAgICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgLy8gVHJhaWxpbmcgc3BhY2VzLlxuICAgICAgICAgICAgICBzdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vbi10cmFpbGluZyBzcGFjZXMuXG4gICAgICAgICAgICAgIHN0eWxlID0gXCJ0bHYtZGVmYXVsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcd1xcZF9dKy8pKSB7XG4gICAgICAgICAgICAvLyBhbHBoYS1udW1lcmljIHRva2VuLlxuICAgICAgICAgICAgc3R5bGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFYXQgdGhlIG5leHQgY2hhciB3LyBubyBmb3JtYXR0aW5nLlxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHN0eWxlID0gXCJ0bHYtZGVmYXVsdFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmVnaW5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHN0eWxlICs9IFwiIHRsdi1zdGF0ZW1lbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlttTV00KFtcXHdcXGRfXSopLykpIHtcbiAgICAgICAgICAgIC8vIG00IHByZSBwcm9jXG4gICAgICAgICAgICBzdHlsZSA9IFwidGx2LW00XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZS50bHZDb2RlQWN0aXZlID09IHRydWUpID8gc3RhdGUudGx2TmV4dEluZGVudCA6IC0xO1xuICAgICAgfSxcblxuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZSA9IFtdOyAgLy8gU3R5bGVzIHRvIHVzZSBmb3IgZWFjaCBsZXZlbCBvZiBpbmRlbnRhdGlvbi5cbiAgICAgICAgc3RhdGUudGx2Q29kZUFjdGl2ZSA9IHRydWU7ICAvLyBUcnVlIHdoZW4gd2UncmUgaW4gYSBUTFYgcmVnaW9uIChhbmQgYXQgYmVnaW5uaW5nIG9mIGZpbGUpLlxuICAgICAgICBzdGF0ZS50bHZOZXh0SW5kZW50ID0gLTE7ICAgIC8vIFRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGF1dG9pbmRlbnQgdGhlIG5leHQgbGluZSBpZiB0bHZDb2RlQWN0aXZlLlxuICAgICAgICBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCA9IGZhbHNlOyAgLy8gVHJ1ZSBpbnNpZGUgLyoqLyBjb21tZW50LlxuICAgICAgICBpZiAodGx2VHJhY2tTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9IGZhbHNlOyAgLy8gVHJ1ZSBpbnNpZGUgYSBzdGF0ZW1lbnQncyBoZWFkZXIgY29tbWVudC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsImRlZmluZU1vZGUiLCJjb25maWciLCJwYXJzZXJDb25maWciLCJpbmRlbnRVbml0Iiwic3RhdGVtZW50SW5kZW50VW5pdCIsImRvbnRBbGlnbkNhbGxzIiwiY29tcGlsZXJEaXJlY3RpdmVzVXNlUmVndWxhckluZGVudGF0aW9uIiwibm9JbmRlbnRLZXl3b3JkcyIsIm11bHRpTGluZVN0cmluZ3MiLCJob29rcyIsIndvcmRzIiwic3RyIiwib2JqIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwia2V5d29yZHMiLCJpc09wZXJhdG9yQ2hhciIsImlzQnJhY2tldENoYXIiLCJ1bnNpZ25lZE51bWJlciIsImRlY2ltYWxMaXRlcmFsIiwiYmluYXJ5TGl0ZXJhbCIsIm9jdExpdGVyYWwiLCJoZXhMaXRlcmFsIiwicmVhbExpdGVyYWwiLCJjbG9zaW5nQnJhY2tldE9yV29yZCIsImNsb3NpbmdCcmFja2V0IiwiY29tcGlsZXJEaXJlY3RpdmVSZWdleCIsIlJlZ0V4cCIsImNvbXBpbGVyRGlyZWN0aXZlQmVnaW5SZWdleCIsImNvbXBpbGVyRGlyZWN0aXZlRW5kUmVnZXgiLCJjdXJQdW5jIiwiY3VyS2V5d29yZCIsImJsb2NrS2V5d29yZHMiLCJvcGVuQ2xvc2UiLCJrZXl3b3JkIiwidW5kZWZpbmVkIiwic3RhdGVtZW50S2V5d29yZHMiLCJ0b2tlbkJhc2UiLCJzdHJlYW0iLCJzdGF0ZSIsImNoIiwicGVlayIsInN0eWxlIiwidGVzdCIsIm5leHQiLCJlYXRXaGlsZSIsImN1ciIsImN1cnJlbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJrZXl3b3JkQ2xvc2UiLCJzdWJzdHIiLCJlYXRTcGFjZSIsIndpdGhTcGFjZSIsImJhY2tVcCIsInRva2VuaXplIiwidG9rZW5TdHJpbmciLCJlYXQiLCJ0b2tlbkNvbW1lbnQiLCJza2lwVG9FbmQiLCJtYXRjaCIsInF1b3RlIiwiZXNjYXBlZCIsImVuZCIsIm1heWJlRW5kIiwiQ29udGV4dCIsImluZGVudGVkIiwiY29sdW1uIiwidHlwZSIsInNjb3Bla2luZCIsImFsaWduIiwicHJldiIsInB1c2hDb250ZXh0IiwiY29sIiwiaW5kZW50IiwiYyIsImNvbnRleHQiLCJwb3BDb250ZXh0IiwidCIsImlzQ2xvc2luZyIsInRleHQiLCJjb250ZXh0Q2xvc2luZyIsImNsb3NpbmdLZXl3b3JkcyIsImlzSW5zaWRlU2NvcGVLaW5kIiwiY3R4IiwiYnVpbGRFbGVjdHJpY0lucHV0UmVnRXgiLCJhbGxDbG9zaW5ncyIsImNsb3NpbmdzIiwiaiIsInB1c2giLCJyZSIsImpvaW4iLCJlbGVjdHJpY0lucHV0Iiwic3RhcnRTdGF0ZSIsImJhc2Vjb2x1bW4iLCJjb21waWxlckRpcmVjdGl2ZUluZGVudGVkIiwic3RhcnRPZkxpbmUiLCJ0b2tlbiIsInNvbCIsImluZGVudGF0aW9uIiwiaXNDbG9zaW5nQXNzaWdubWVudCIsImNsb3NlIiwidGV4dEFmdGVyIiwiUGFzcyIsImZyb21Ib29rIiwiZmlyc3RDaGFyIiwiY2hhckF0IiwiY2xvc2luZyIsInBvc3NpYmxlQ2xvc2luZyIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwibGluZUNvbW1lbnQiLCJmb2xkIiwiZGVmaW5lTUlNRSIsIm5hbWUiLCJ0bHZJZGVudGlmaWVyU3R5bGUiLCJ0bHZTY29wZVByZWZpeENoYXJzIiwidGx2SW5kZW50VW5pdCIsInRsdlRyYWNrU3RhdGVtZW50cyIsInRsdklkZW50TWF0Y2giLCJ0bHZGaXJzdExldmVsSW5kZW50TWF0Y2giLCJ0bHZMaW5lSW5kZW50YXRpb25NYXRjaCIsInRsdkNvbW1lbnRNYXRjaCIsInRsdlNjb3BlU3R5bGUiLCJkZXB0aCIsInRsdkluZGVudGF0aW9uU3R5bGUiLCJ0bHZJZGVudE5leHQiLCJ0bHZJbkJsb2NrQ29tbWVudCIsInN0cmluZyIsInRsdkNvZGVBY3RpdmUiLCJwb3MiLCJibGFua2xpbmUiLCJjaFBvcyIsImJvZHlTdHJpbmciLCJzbGljZSIsInN0YXRlbWVudENvbW1lbnQiLCJwb3AiLCJ0bHZOZXh0SW5kZW50IiwiYmVnaW5TdGF0ZW1lbnQiLCJlb2wiLCJwcmVmaXgiLCJtbmVtb25pYyIsImhhc093blByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/verilog/verilog.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/verilog/verilog.js");
/******/ 	
/******/ })()
;