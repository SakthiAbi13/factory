/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/clike/clike.js":
/*!*********************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/clike/clike.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function Context(indented, column, type, info, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.info = info;\n    this.align = align;\n    this.prev = prev;\n  }\n\n  function pushContext(state, col, type, info) {\n    var indent = state.indented;\n    if (state.context && state.context.type == \"statement\" && type != \"statement\") indent = state.context.indented;\n    return state.context = new Context(indent, col, type, info, null, state.context);\n  }\n\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  }\n\n  function typeBefore(stream, state, pos) {\n    if (state.prevToken == \"variable\" || state.prevToken == \"type\") return true;\n    if (/\\S(?:[^- ]>|[*\\]])\\s*$|\\*$/.test(stream.string.slice(0, pos))) return true;\n    if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;\n  }\n\n  function isTopScope(context) {\n    for (;;) {\n      if (!context || context.type == \"top\") return true;\n      if (context.type == \"}\" && context.prev.info != \"namespace\") return false;\n      context = context.prev;\n    }\n  }\n\n  CodeMirror.defineMode(\"clike\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n        dontAlignCalls = parserConfig.dontAlignCalls,\n        keywords = parserConfig.keywords || {},\n        types = parserConfig.types || {},\n        builtin = parserConfig.builtin || {},\n        blockKeywords = parserConfig.blockKeywords || {},\n        defKeywords = parserConfig.defKeywords || {},\n        atoms = parserConfig.atoms || {},\n        hooks = parserConfig.hooks || {},\n        multiLineStrings = parserConfig.multiLineStrings,\n        indentStatements = parserConfig.indentStatements !== false,\n        indentSwitch = parserConfig.indentSwitch !== false,\n        namespaceSeparator = parserConfig.namespaceSeparator,\n        isPunctuationChar = parserConfig.isPunctuationChar || /[\\[\\]{}\\(\\),;\\:\\.]/,\n        numberStart = parserConfig.numberStart || /[\\d\\.]/,\n        number = parserConfig.number || /^(?:0x[a-f\\d]+|0b[01]+|(?:\\d+\\.?\\d*|\\.\\d+)(?:e[-+]?\\d+)?)(u|ll?|l|f)?/i,\n        isOperatorChar = parserConfig.isOperatorChar || /[+\\-*&%=<>!?|\\/]/,\n        isIdentifierChar = parserConfig.isIdentifierChar || /[\\w\\$_\\xa1-\\uffff]/,\n        // An optional function that takes a {string} token and returns true if it\n    // should be treated as a builtin.\n    isReservedIdentifier = parserConfig.isReservedIdentifier || false;\n    var curPunc, isDefKeyword;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (hooks[ch]) {\n        var result = hooks[ch](stream, state);\n        if (result !== false) return result;\n      }\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (numberStart.test(ch)) {\n        stream.backUp(1);\n        if (stream.match(number)) return \"number\";\n        stream.next();\n      }\n\n      if (isPunctuationChar.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        while (!stream.match(/^\\/[\\/*]/, false) && stream.eat(isOperatorChar)) {}\n\n        return \"operator\";\n      }\n\n      stream.eatWhile(isIdentifierChar);\n      if (namespaceSeparator) while (stream.match(namespaceSeparator)) {\n        stream.eatWhile(isIdentifierChar);\n      }\n      var cur = stream.current();\n\n      if (contains(keywords, cur)) {\n        if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n        if (contains(defKeywords, cur)) isDefKeyword = true;\n        return \"keyword\";\n      }\n\n      if (contains(types, cur)) return \"type\";\n\n      if (contains(builtin, cur) || isReservedIdentifier && isReservedIdentifier(cur)) {\n        if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n        return \"builtin\";\n      }\n\n      if (contains(atoms, cur)) return \"atom\";\n      return \"variable\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = null;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function maybeEOL(stream, state) {\n      if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context)) state.typeAtEndOfLine = typeBefore(stream, state, stream.pos);\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", null, false),\n          indented: 0,\n          startOfLine: true,\n          prevToken: null\n        };\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (stream.eatSpace()) {\n          maybeEOL(stream, state);\n          return null;\n        }\n\n        curPunc = isDefKeyword = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if (curPunc == \";\" || curPunc == \":\" || curPunc == \",\" && stream.match(/^\\s*(?:\\/\\/.*)?$/, false)) while (state.context.type == \"statement\") {\n          popContext(state);\n        } else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n\n          if (ctx.type == \"}\") ctx = popContext(state);\n\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n        } else if (curPunc == ctx.type) popContext(state);else if (indentStatements && ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != \";\" || ctx.type == \"statement\" && curPunc == \"newstatement\")) {\n          pushContext(state, stream.column(), \"statement\", stream.current());\n        }\n        if (style == \"variable\" && (state.prevToken == \"def\" || parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) && isTopScope(state.context) && stream.match(/^\\s*\\(/, false))) style = \"def\";\n\n        if (hooks.token) {\n          var result = hooks.token(stream, state, style);\n          if (result !== undefined) style = result;\n        }\n\n        if (style == \"def\" && parserConfig.styleDefs === false) style = \"variable\";\n        state.startOfLine = false;\n        state.prevToken = isDefKeyword ? \"def\" : style || curPunc;\n        maybeEOL(stream, state);\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        var closing = firstChar == ctx.type;\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        if (parserConfig.dontIndentStatements) while (ctx.type == \"statement\" && parserConfig.dontIndentStatements.test(ctx.info)) {\n          ctx = ctx.prev;\n        }\n\n        if (hooks.indent) {\n          var hook = hooks.indent(state, ctx, textAfter, indentUnit);\n          if (typeof hook == \"number\") return hook;\n        }\n\n        var switchBlock = ctx.prev && ctx.prev.info == \"switch\";\n\n        if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {\n          while (ctx.type != \"top\" && ctx.type != \"}\") {\n            ctx = ctx.prev;\n          }\n\n          return ctx.indented;\n        }\n\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n        if (ctx.align && (!dontAlignCalls || ctx.type != \")\")) return ctx.column + (closing ? 0 : 1);\n        if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n        return ctx.indented + (closing ? 0 : indentUnit) + (!closing && switchBlock && !/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 0);\n      },\n      electricInput: indentSwitch ? /^\\s*(?:case .*?:|default:|\\{\\}?|\\})$/ : /^\\s*[{}]$/,\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      blockCommentContinue: \" * \",\n      lineComment: \"//\",\n      fold: \"brace\"\n    };\n  });\n\n  function words(str) {\n    var obj = {},\n        words = str.split(\" \");\n\n    for (var i = 0; i < words.length; ++i) {\n      obj[words[i]] = true;\n    }\n\n    return obj;\n  }\n\n  function contains(words, word) {\n    if (typeof words === \"function\") {\n      return words(word);\n    } else {\n      return words.propertyIsEnumerable(word);\n    }\n  }\n\n  var cKeywords = \"auto if break case register continue return default do sizeof \" + \"static else struct switch extern typedef union for goto while enum const \" + \"volatile inline restrict asm fortran\"; // Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.\n\n  var cppKeywords = \"alignas alignof and and_eq audit axiom bitand bitor catch \" + \"class compl concept constexpr const_cast decltype delete dynamic_cast \" + \"explicit export final friend import module mutable namespace new noexcept \" + \"not not_eq operator or or_eq override private protected public \" + \"reinterpret_cast requires static_assert static_cast template this \" + \"thread_local throw try typeid typename using virtual xor xor_eq\";\n  var objCKeywords = \"bycopy byref in inout oneway out self super atomic nonatomic retain copy \" + \"readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd \" + \"@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class \" + \"@public @package @private @protected @required @optional @try @catch @finally @import \" + \"@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available\";\n  var objCBuiltins = \"FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION \" + \" NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER \" + \"NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION \" + \"NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT\"; // Do not use this. Use the cTypes function below. This is global just to avoid\n  // excessive calls when cTypes is being called multiple times during a parse.\n\n  var basicCTypes = words(\"int long char short double float unsigned signed \" + \"void bool\"); // Do not use this. Use the objCTypes function below. This is global just to avoid\n  // excessive calls when objCTypes is being called multiple times during a parse.\n\n  var basicObjCTypes = words(\"SEL instancetype id Class Protocol BOOL\"); // Returns true if identifier is a \"C\" type.\n  // C type is defined as those that are reserved by the compiler (basicTypes),\n  // and those that end in _t (Reserved by POSIX for types)\n  // http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html\n\n  function cTypes(identifier) {\n    return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);\n  } // Returns true if identifier is a \"Objective C\" type.\n\n\n  function objCTypes(identifier) {\n    return cTypes(identifier) || contains(basicObjCTypes, identifier);\n  }\n\n  var cBlockKeywords = \"case do else for if switch while struct enum union\";\n  var cDefKeywords = \"struct enum union\";\n\n  function cppHook(stream, state) {\n    if (!state.startOfLine) return false;\n\n    for (var ch, next = null; ch = stream.peek();) {\n      if (ch == \"\\\\\" && stream.match(/^.$/)) {\n        next = cppHook;\n        break;\n      } else if (ch == \"/\" && stream.match(/^\\/[\\/\\*]/, false)) {\n        break;\n      }\n\n      stream.next();\n    }\n\n    state.tokenize = next;\n    return \"meta\";\n  }\n\n  function pointerHook(_stream, state) {\n    if (state.prevToken == \"type\") return \"type\";\n    return false;\n  } // For C and C++ (and ObjC): identifiers starting with __\n  // or _ followed by a capital letter are reserved for the compiler.\n\n\n  function cIsReservedIdentifier(token) {\n    if (!token || token.length < 2) return false;\n    if (token[0] != '_') return false;\n    return token[1] == '_' || token[1] !== token[1].toLowerCase();\n  }\n\n  function cpp14Literal(stream) {\n    stream.eatWhile(/[\\w\\.']/);\n    return \"number\";\n  }\n\n  function cpp11StringHook(stream, state) {\n    stream.backUp(1); // Raw strings.\n\n    if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {\n      var match = stream.match(/^\"([^\\s\\\\()]{0,16})\\(/);\n\n      if (!match) {\n        return false;\n      }\n\n      state.cpp11RawStringDelim = match[1];\n      state.tokenize = tokenRawString;\n      return tokenRawString(stream, state);\n    } // Unicode strings/chars.\n\n\n    if (stream.match(/^(?:u8|u|U|L)/)) {\n      if (stream.match(/^[\"']/,\n      /* eat */\n      false)) {\n        return \"string\";\n      }\n\n      return false;\n    } // Ignore this hook.\n\n\n    stream.next();\n    return false;\n  }\n\n  function cppLooksLikeConstructor(word) {\n    var lastTwo = /(\\w+)::~?(\\w+)$/.exec(word);\n    return lastTwo && lastTwo[1] == lastTwo[2];\n  } // C#-style strings where \"\" escapes a quote.\n\n\n  function tokenAtString(stream, state) {\n    var next;\n\n    while ((next = stream.next()) != null) {\n      if (next == '\"' && !stream.eat('\"')) {\n        state.tokenize = null;\n        break;\n      }\n    }\n\n    return \"string\";\n  } // C++11 raw string literal is <prefix>\"<delim>( anything )<delim>\", where\n  // <delim> can be a string up to 16 characters long.\n\n\n  function tokenRawString(stream, state) {\n    // Escape characters that have special regex meanings.\n    var delim = state.cpp11RawStringDelim.replace(/[^\\w\\s]/g, '\\\\$&');\n    var match = stream.match(new RegExp(\".*?\\\\)\" + delim + '\"'));\n    if (match) state.tokenize = null;else stream.skipToEnd();\n    return \"string\";\n  }\n\n  function def(mimes, mode) {\n    if (typeof mimes == \"string\") mimes = [mimes];\n    var words = [];\n\n    function add(obj) {\n      if (obj) for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) words.push(prop);\n      }\n    }\n\n    add(mode.keywords);\n    add(mode.types);\n    add(mode.builtin);\n    add(mode.atoms);\n\n    if (words.length) {\n      mode.helperType = mimes[0];\n      CodeMirror.registerHelper(\"hintWords\", mimes[0], words);\n    }\n\n    for (var i = 0; i < mimes.length; ++i) {\n      CodeMirror.defineMIME(mimes[i], mode);\n    }\n  }\n\n  def([\"text/x-csrc\", \"text/x-c\", \"text/x-chdr\"], {\n    name: \"clike\",\n    keywords: words(cKeywords),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords),\n    defKeywords: words(cDefKeywords),\n    typeFirstDefinitions: true,\n    atoms: words(\"NULL true false\"),\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook\n    },\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def([\"text/x-c++src\", \"text/x-c++hdr\"], {\n    name: \"clike\",\n    keywords: words(cKeywords + \" \" + cppKeywords),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords + \" class try catch\"),\n    defKeywords: words(cDefKeywords + \" class namespace\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false NULL nullptr\"),\n    dontIndentStatements: /^template$/,\n    isIdentifierChar: /[\\w\\$_~\\xa1-\\uffff]/,\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n      \"u\": cpp11StringHook,\n      \"U\": cpp11StringHook,\n      \"L\": cpp11StringHook,\n      \"R\": cpp11StringHook,\n      \"0\": cpp14Literal,\n      \"1\": cpp14Literal,\n      \"2\": cpp14Literal,\n      \"3\": cpp14Literal,\n      \"4\": cpp14Literal,\n      \"5\": cpp14Literal,\n      \"6\": cpp14Literal,\n      \"7\": cpp14Literal,\n      \"8\": cpp14Literal,\n      \"9\": cpp14Literal,\n      token: function token(stream, state, style) {\n        if (style == \"variable\" && stream.peek() == \"(\" && (state.prevToken == \";\" || state.prevToken == null || state.prevToken == \"}\") && cppLooksLikeConstructor(stream.current())) return \"def\";\n      }\n    },\n    namespaceSeparator: \"::\",\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def(\"text/x-java\", {\n    name: \"clike\",\n    keywords: words(\"abstract assert break case catch class const continue default \" + \"do else enum extends final finally for goto if implements import \" + \"instanceof interface native new package private protected public \" + \"return static strictfp super switch synchronized this throw throws transient \" + \"try volatile while @interface\"),\n    types: words(\"var byte short int long float double boolean char void Boolean Byte Character Double Float \" + \"Integer Long Number Object Short String StringBuffer StringBuilder Void\"),\n    blockKeywords: words(\"catch class do else finally for if switch try while\"),\n    defKeywords: words(\"class interface enum @interface\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    hooks: {\n      \"@\": function _(stream) {\n        // Don't match the @interface keyword.\n        if (stream.match('interface', false)) return false;\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    },\n    modeProps: {\n      fold: [\"brace\", \"import\"]\n    }\n  });\n  def(\"text/x-csharp\", {\n    name: \"clike\",\n    keywords: words(\"abstract as async await base break case catch checked class const continue\" + \" default delegate do else enum event explicit extern finally fixed for\" + \" foreach goto if implicit in interface internal is lock namespace new\" + \" operator out override params private protected public readonly ref return sealed\" + \" sizeof stackalloc static struct switch this throw try typeof unchecked\" + \" unsafe using virtual void volatile while add alias ascending descending dynamic from get\" + \" global group into join let orderby partial remove select set value var yield\"),\n    types: words(\"Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func\" + \" Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32\" + \" UInt64 bool byte char decimal double short int long object\" + \" sbyte float string ushort uint ulong\"),\n    blockKeywords: words(\"catch class do else finally for foreach if struct switch try while\"),\n    defKeywords: words(\"class interface namespace struct var\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"@\": function _(stream, state) {\n        if (stream.eat('\"')) {\n          state.tokenize = tokenAtString;\n          return tokenAtString(stream, state);\n        }\n\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n\n  function tokenTripleString(stream, state) {\n    var escaped = false;\n\n    while (!stream.eol()) {\n      if (!escaped && stream.match('\"\"\"')) {\n        state.tokenize = null;\n        break;\n      }\n\n      escaped = stream.next() == \"\\\\\" && !escaped;\n    }\n\n    return \"string\";\n  }\n\n  function tokenNestedComment(depth) {\n    return function (stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"*\" && stream.eat(\"/\")) {\n          if (depth == 1) {\n            state.tokenize = null;\n            break;\n          } else {\n            state.tokenize = tokenNestedComment(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        } else if (ch == \"/\" && stream.eat(\"*\")) {\n          state.tokenize = tokenNestedComment(depth + 1);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      return \"comment\";\n    };\n  }\n\n  def(\"text/x-scala\", {\n    name: \"clike\",\n    keywords: words(\n    /* scala */\n    \"abstract case catch class def do else extends final finally for forSome if \" + \"implicit import lazy match new null object override package private protected return \" + \"sealed super this throw trait try type val var while with yield _ \" +\n    /* package scala */\n    \"assert assume require print println printf readLine readBoolean readByte readShort \" + \"readChar readInt readLong readFloat readDouble\"),\n    types: words(\"AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either \" + \"Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable \" + \"Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering \" + \"Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder \" + \"StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector \" +\n    /* package java.lang */\n    \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" + \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" + \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" + \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void\"),\n    multiLineStrings: true,\n    blockKeywords: words(\"catch class enum do else finally for forSome if match switch try while\"),\n    defKeywords: words(\"class enum def object package trait type val var\"),\n    atoms: words(\"true false null\"),\n    indentStatements: false,\n    indentSwitch: false,\n    isOperatorChar: /[+\\-*&%=<>!?|\\/#:@]/,\n    hooks: {\n      \"@\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function _(stream, state) {\n        if (!stream.match('\"\"')) return false;\n        state.tokenize = tokenTripleString;\n        return state.tokenize(stream, state);\n      },\n      \"'\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      \"=\": function _(stream, state) {\n        var cx = state.context;\n\n        if (cx.type == \"}\" && cx.align && stream.eat(\">\")) {\n          state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev);\n          return \"operator\";\n        } else {\n          return false;\n        }\n      },\n      \"/\": function _(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenNestedComment(1);\n        return state.tokenize(stream, state);\n      }\n    },\n    modeProps: {\n      closeBrackets: {\n        pairs: '()[]{}\"\"',\n        triples: '\"'\n      }\n    }\n  });\n\n  function tokenKotlinString(tripleString) {\n    return function (stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while (!stream.eol()) {\n        if (!tripleString && !escaped && stream.match('\"')) {\n          end = true;\n          break;\n        }\n\n        if (tripleString && stream.match('\"\"\"')) {\n          end = true;\n          break;\n        }\n\n        next = stream.next();\n        if (!escaped && next == \"$\" && stream.match('{')) stream.skipTo(\"}\");\n        escaped = !escaped && next == \"\\\\\" && !tripleString;\n      }\n\n      if (end || !tripleString) state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  def(\"text/x-kotlin\", {\n    name: \"clike\",\n    keywords: words(\n    /*keywords*/\n    \"package as typealias class interface this super val operator \" + \"var fun for is in This throw return annotation \" + \"break continue object if else while do try when !in !is as? \" +\n    /*soft keywords*/\n    \"file import where by get set abstract enum open inner override private public internal \" + \"protected catch finally out final vararg reified dynamic companion constructor init \" + \"sealed field property receiver param sparam lateinit data inline noinline tailrec \" + \"external annotation crossinline const operator infix suspend actual expect setparam value\"),\n    types: words(\n    /* package java.lang */\n    \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" + \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" + \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" + \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray \" + \"ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy \" + \"LazyThreadSafetyMode LongArray Nothing ShortArray Unit\"),\n    intendSwitch: false,\n    indentStatements: false,\n    multiLineStrings: true,\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+(\\.\\d+)?|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    blockKeywords: words(\"catch class do else finally for if where try while enum\"),\n    defKeywords: words(\"class val var object interface fun\"),\n    atoms: words(\"true false null this\"),\n    hooks: {\n      \"@\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '*': function _(_stream, state) {\n        return state.prevToken == '.' ? 'variable' : 'operator';\n      },\n      '\"': function _(stream, state) {\n        state.tokenize = tokenKotlinString(stream.match('\"\"'));\n        return state.tokenize(stream, state);\n      },\n      \"/\": function _(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenNestedComment(1);\n        return state.tokenize(stream, state);\n      },\n      indent: function indent(state, ctx, textAfter, indentUnit) {\n        var firstChar = textAfter && textAfter.charAt(0);\n        if ((state.prevToken == \"}\" || state.prevToken == \")\") && textAfter == \"\") return state.indented;\n        if (state.prevToken == \"operator\" && textAfter != \"}\" && state.context.type != \"}\" || state.prevToken == \"variable\" && firstChar == \".\" || (state.prevToken == \"}\" || state.prevToken == \")\") && firstChar == \".\") return indentUnit * 2 + ctx.indented;\n        if (ctx.align && ctx.type == \"}\") return ctx.indented + (state.context.type == (textAfter || \"\").charAt(0) ? 0 : indentUnit);\n      }\n    },\n    modeProps: {\n      closeBrackets: {\n        triples: '\"'\n      }\n    }\n  });\n  def([\"x-shader/x-vertex\", \"x-shader/x-fragment\"], {\n    name: \"clike\",\n    keywords: words(\"sampler1D sampler2D sampler3D samplerCube \" + \"sampler1DShadow sampler2DShadow \" + \"const attribute uniform varying \" + \"break continue discard return \" + \"for while do if else struct \" + \"in out inout\"),\n    types: words(\"float int bool void \" + \"vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 \" + \"mat2 mat3 mat4\"),\n    blockKeywords: words(\"for while do if else struct\"),\n    builtin: words(\"radians degrees sin cos tan asin acos atan \" + \"pow exp log exp2 sqrt inversesqrt \" + \"abs sign floor ceil fract mod min max clamp mix step smoothstep \" + \"length distance dot cross normalize ftransform faceforward \" + \"reflect refract matrixCompMult \" + \"lessThan lessThanEqual greaterThan greaterThanEqual \" + \"equal notEqual any all not \" + \"texture1D texture1DProj texture1DLod texture1DProjLod \" + \"texture2D texture2DProj texture2DLod texture2DProjLod \" + \"texture3D texture3DProj texture3DLod texture3DProjLod \" + \"textureCube textureCubeLod \" + \"shadow1D shadow2D shadow1DProj shadow2DProj \" + \"shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod \" + \"dFdx dFdy fwidth \" + \"noise1 noise2 noise3 noise4\"),\n    atoms: words(\"true false \" + \"gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex \" + \"gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 \" + \"gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 \" + \"gl_FogCoord gl_PointCoord \" + \"gl_Position gl_PointSize gl_ClipVertex \" + \"gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor \" + \"gl_TexCoord gl_FogFragCoord \" + \"gl_FragCoord gl_FrontFacing \" + \"gl_FragData gl_FragDepth \" + \"gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix \" + \"gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse \" + \"gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse \" + \"gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose \" + \"gl_ProjectionMatrixInverseTranspose \" + \"gl_ModelViewProjectionMatrixInverseTranspose \" + \"gl_TextureMatrixInverseTranspose \" + \"gl_NormalScale gl_DepthRange gl_ClipPlane \" + \"gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel \" + \"gl_FrontLightModelProduct gl_BackLightModelProduct \" + \"gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ \" + \"gl_FogParameters \" + \"gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords \" + \"gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats \" + \"gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits \" + \"gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits \" + \"gl_MaxDrawBuffers\"),\n    indentSwitch: false,\n    hooks: {\n      \"#\": cppHook\n    },\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def(\"text/x-nesc\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" as atomic async call command component components configuration event generic \" + \"implementation includes interface module new norace nx_struct nx_union post provides \" + \"signal task uses abstract extends\"),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords),\n    atoms: words(\"null true false\"),\n    hooks: {\n      \"#\": cppHook\n    },\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def(\"text/x-objectivec\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" \" + objCKeywords),\n    types: objCTypes,\n    builtin: words(objCBuiltins),\n    blockKeywords: words(cBlockKeywords + \" @synthesize @try @catch @finally @autoreleasepool @synchronized\"),\n    defKeywords: words(cDefKeywords + \" @interface @implementation @protocol @class\"),\n    dontIndentStatements: /^@.*$/,\n    typeFirstDefinitions: true,\n    atoms: words(\"YES NO NULL Nil nil true false nullptr\"),\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook\n    },\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def(\"text/x-objectivec++\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" \" + objCKeywords + \" \" + cppKeywords),\n    types: objCTypes,\n    builtin: words(objCBuiltins),\n    blockKeywords: words(cBlockKeywords + \" @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch\"),\n    defKeywords: words(cDefKeywords + \" @interface @implementation @protocol @class class namespace\"),\n    dontIndentStatements: /^@.*$|^template$/,\n    typeFirstDefinitions: true,\n    atoms: words(\"YES NO NULL Nil nil true false nullptr\"),\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n      \"u\": cpp11StringHook,\n      \"U\": cpp11StringHook,\n      \"L\": cpp11StringHook,\n      \"R\": cpp11StringHook,\n      \"0\": cpp14Literal,\n      \"1\": cpp14Literal,\n      \"2\": cpp14Literal,\n      \"3\": cpp14Literal,\n      \"4\": cpp14Literal,\n      \"5\": cpp14Literal,\n      \"6\": cpp14Literal,\n      \"7\": cpp14Literal,\n      \"8\": cpp14Literal,\n      \"9\": cpp14Literal,\n      token: function token(stream, state, style) {\n        if (style == \"variable\" && stream.peek() == \"(\" && (state.prevToken == \";\" || state.prevToken == null || state.prevToken == \"}\") && cppLooksLikeConstructor(stream.current())) return \"def\";\n      }\n    },\n    namespaceSeparator: \"::\",\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  });\n  def(\"text/x-squirrel\", {\n    name: \"clike\",\n    keywords: words(\"base break clone continue const default delete enum extends function in class\" + \" foreach local resume return this throw typeof yield constructor instanceof static\"),\n    types: cTypes,\n    blockKeywords: words(\"case catch class else for foreach if switch try while\"),\n    defKeywords: words(\"function local class\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"#\": cppHook\n    },\n    modeProps: {\n      fold: [\"brace\", \"include\"]\n    }\n  }); // Ceylon Strings need to deal with interpolation\n\n  var stringTokenizer = null;\n\n  function tokenCeylonString(type) {\n    return function (stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while (!stream.eol()) {\n        if (!escaped && stream.match('\"') && (type == \"single\" || stream.match('\"\"'))) {\n          end = true;\n          break;\n        }\n\n        if (!escaped && stream.match('``')) {\n          stringTokenizer = tokenCeylonString(type);\n          end = true;\n          break;\n        }\n\n        next = stream.next();\n        escaped = type == \"single\" && !escaped && next == \"\\\\\";\n      }\n\n      if (end) state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  def(\"text/x-ceylon\", {\n    name: \"clike\",\n    keywords: words(\"abstracts alias assembly assert assign break case catch class continue dynamic else\" + \" exists extends finally for function given if import in interface is let module new\" + \" nonempty object of out outer package return satisfies super switch then this throw\" + \" try value void while\"),\n    types: function types(word) {\n      // In Ceylon all identifiers that start with an uppercase are types\n      var first = word.charAt(0);\n      return first === first.toUpperCase() && first !== first.toLowerCase();\n    },\n    blockKeywords: words(\"case catch class dynamic else finally for function if interface module new object switch try while\"),\n    defKeywords: words(\"class dynamic function interface module object package value\"),\n    builtin: words(\"abstract actual aliased annotation by default deprecated doc final formal late license\" + \" native optional sealed see serializable shared suppressWarnings tagged throws variable\"),\n    isPunctuationChar: /[\\[\\]{}\\(\\),;\\:\\.`]/,\n    isOperatorChar: /[+\\-*&%=<>!?|^~:\\/]/,\n    numberStart: /[\\d#$]/,\n    number: /^(?:#[\\da-fA-F_]+|\\$[01_]+|[\\d_]+[kMGTPmunpf]?|[\\d_]+\\.[\\d_]+(?:[eE][-+]?\\d+|[kMGTPmunpf]|)|)/i,\n    multiLineStrings: true,\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null larger smaller equal empty finished\"),\n    indentSwitch: false,\n    styleDefs: false,\n    hooks: {\n      \"@\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function _(stream, state) {\n        state.tokenize = tokenCeylonString(stream.match('\"\"') ? \"triple\" : \"single\");\n        return state.tokenize(stream, state);\n      },\n      '`': function _(stream, state) {\n        if (!stringTokenizer || !stream.match('`')) return false;\n        state.tokenize = stringTokenizer;\n        stringTokenizer = null;\n        return state.tokenize(stream, state);\n      },\n      \"'\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      token: function token(_stream, state, style) {\n        if ((style == \"variable\" || style == \"type\") && state.prevToken == \".\") {\n          return \"variable-2\";\n        }\n      }\n    },\n    modeProps: {\n      fold: [\"brace\", \"import\"],\n      closeBrackets: {\n        triples: '\"'\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9jbGlrZS9jbGlrZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsQ0FBRCxvQ0FBMkJKLEdBQTNCO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREcsS0FFQTtJQUNIQSxFQUFBO0FBQ0gsQ0FQRCxFQU9HLFVBQVNNLFVBQVQsRUFBcUI7RUFDeEI7O0VBRUEsU0FBU0MsT0FBVCxDQUFpQkMsUUFBakIsRUFBMkJDLE1BQTNCLEVBQW1DQyxJQUFuQyxFQUF5Q0MsSUFBekMsRUFBK0NDLEtBQS9DLEVBQXNEQyxJQUF0RCxFQUE0RDtJQUMxRCxLQUFLTCxRQUFMLEdBQWdCQSxRQUFoQjtJQUNBLEtBQUtDLE1BQUwsR0FBY0EsTUFBZDtJQUNBLEtBQUtDLElBQUwsR0FBWUEsSUFBWjtJQUNBLEtBQUtDLElBQUwsR0FBWUEsSUFBWjtJQUNBLEtBQUtDLEtBQUwsR0FBYUEsS0FBYjtJQUNBLEtBQUtDLElBQUwsR0FBWUEsSUFBWjtFQUNEOztFQUNELFNBQVNDLFdBQVQsQ0FBcUJDLEtBQXJCLEVBQTRCQyxHQUE1QixFQUFpQ04sSUFBakMsRUFBdUNDLElBQXZDLEVBQTZDO0lBQzNDLElBQUlNLE1BQU0sR0FBR0YsS0FBSyxDQUFDUCxRQUFuQjtJQUNBLElBQUlPLEtBQUssQ0FBQ0csT0FBTixJQUFpQkgsS0FBSyxDQUFDRyxPQUFOLENBQWNSLElBQWQsSUFBc0IsV0FBdkMsSUFBc0RBLElBQUksSUFBSSxXQUFsRSxFQUNFTyxNQUFNLEdBQUdG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QUF1QlAsS0FBdkIsQ0FBUDtNQUNELENBUkU7TUFTTCxLQUFLLFdBQVNPLE1BQVQsRUFBaUJQLEtBQWpCLEVBQXdCO1FBQ3pCLElBQUksQ0FBQ29KLGVBQUQsSUFBb0IsQ0FBQzdJLE1BQU0sQ0FBQ3lDLEtBQVAsQ0FBYSxHQUFiLENBQXpCLEVBQTRDLE9BQU8sS0FBUDtRQUM1Q2hELEtBQUssQ0FBQzZDLFFBQU4sR0FBaUJ1RyxlQUFqQjtRQUNBQSxlQUFlLEdBQUcsSUFBbEI7UUFDQSxPQUFPcEosS0FBSyxDQUFDNkMsUUFBTixDQUFldEMsTUFBZixFQUF1QlAsS0FBdkIsQ0FBUDtNQUNELENBZEU7TUFlTCxLQUFLLFdBQVNPLE1BQVQsRUFBaUI7UUFDcEJBLE1BQU0sQ0FBQzZDLFFBQVAsQ0FBZ0Isb0JBQWhCO1FBQ0EsT0FBTyxNQUFQO01BQ0QsQ0FsQkk7TUFtQkxjLEtBQUssRUFBRSxlQUFTNkMsT0FBVCxFQUFrQi9HLEtBQWxCLEVBQXlCc0UsS0FBekIsRUFBZ0M7UUFDbkMsSUFBSSxDQUFDQSxLQUFLLElBQUksVUFBVCxJQUF1QkEsS0FBSyxJQUFJLE1BQWpDLEtBQ0F0RSxLQUFLLENBQUNTLFNBQU4sSUFBbUIsR0FEdkIsRUFDNEI7VUFDMUIsT0FBTyxZQUFQO1FBQ0Q7TUFDRjtJQXhCRSxDQXhCWTtJQWtEbkIrSCxTQUFTLEVBQUU7TUFDUGhELElBQUksRUFBRSxDQUFDLE9BQUQsRUFBVSxRQUFWLENBREM7TUFFUHFELGFBQWEsRUFBRTtRQUFDRSxPQUFPLEVBQUU7TUFBVjtJQUZSO0VBbERRLENBQWxCLENBQUg7QUF3REQsQ0FuNkJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL21vZGUvY2xpa2UvY2xpa2UuanM/NWNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgaW5mbywgYWxpZ24sIHByZXYpIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5pbmZvID0gaW5mbztcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSwgaW5mbykge1xuICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIHR5cGUgIT0gXCJzdGF0ZW1lbnRcIilcbiAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICByZXR1cm4gc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGluZGVudCwgY29sLCB0eXBlLCBpbmZvLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xufVxuXG5mdW5jdGlvbiB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHBvcykge1xuICBpZiAoc3RhdGUucHJldlRva2VuID09IFwidmFyaWFibGVcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ0eXBlXCIpIHJldHVybiB0cnVlO1xuICBpZiAoL1xcUyg/OlteLSBdPnxbKlxcXV0pXFxzKiR8XFwqJC8udGVzdChzdHJlYW0uc3RyaW5nLnNsaWNlKDAsIHBvcykpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHN0YXRlLnR5cGVBdEVuZE9mTGluZSAmJiBzdHJlYW0uY29sdW1uKCkgPT0gc3RyZWFtLmluZGVudGF0aW9uKCkpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RvcFNjb3BlKGNvbnRleHQpIHtcbiAgZm9yICg7Oykge1xuICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0LnR5cGUgPT0gXCJ0b3BcIikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PSBcIn1cIiAmJiBjb250ZXh0LnByZXYuaW5mbyAhPSBcIm5hbWVzcGFjZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgfVxufVxuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJjbGlrZVwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgc3RhdGVtZW50SW5kZW50VW5pdCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGluZGVudFVuaXQsXG4gICAgICBkb250QWxpZ25DYWxscyA9IHBhcnNlckNvbmZpZy5kb250QWxpZ25DYWxscyxcbiAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgdHlwZXMgPSBwYXJzZXJDb25maWcudHlwZXMgfHwge30sXG4gICAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgICBibG9ja0tleXdvcmRzID0gcGFyc2VyQ29uZmlnLmJsb2NrS2V5d29yZHMgfHwge30sXG4gICAgICBkZWZLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5kZWZLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9LFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge30sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICBpbmRlbnRTdGF0ZW1lbnRzID0gcGFyc2VyQ29uZmlnLmluZGVudFN0YXRlbWVudHMgIT09IGZhbHNlLFxuICAgICAgaW5kZW50U3dpdGNoID0gcGFyc2VyQ29uZmlnLmluZGVudFN3aXRjaCAhPT0gZmFsc2UsXG4gICAgICBuYW1lc3BhY2VTZXBhcmF0b3IgPSBwYXJzZXJDb25maWcubmFtZXNwYWNlU2VwYXJhdG9yLFxuICAgICAgaXNQdW5jdHVhdGlvbkNoYXIgPSBwYXJzZXJDb25maWcuaXNQdW5jdHVhdGlvbkNoYXIgfHwgL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8sXG4gICAgICBudW1iZXJTdGFydCA9IHBhcnNlckNvbmZpZy5udW1iZXJTdGFydCB8fCAvW1xcZFxcLl0vLFxuICAgICAgbnVtYmVyID0gcGFyc2VyQ29uZmlnLm51bWJlciB8fCAvXig/OjB4W2EtZlxcZF0rfDBiWzAxXSt8KD86XFxkK1xcLj9cXGQqfFxcLlxcZCspKD86ZVstK10/XFxkKyk/KSh1fGxsP3xsfGYpPy9pLFxuICAgICAgaXNPcGVyYXRvckNoYXIgPSBwYXJzZXJDb25maWcuaXNPcGVyYXRvckNoYXIgfHwgL1srXFwtKiYlPTw+IT98XFwvXS8sXG4gICAgICBpc0lkZW50aWZpZXJDaGFyID0gcGFyc2VyQ29uZmlnLmlzSWRlbnRpZmllckNoYXIgfHwgL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vLFxuICAgICAgLy8gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtzdHJpbmd9IHRva2VuIGFuZCByZXR1cm5zIHRydWUgaWYgaXRcbiAgICAgIC8vIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgYnVpbHRpbi5cbiAgICAgIGlzUmVzZXJ2ZWRJZGVudGlmaWVyID0gcGFyc2VyQ29uZmlnLmlzUmVzZXJ2ZWRJZGVudGlmaWVyIHx8IGZhbHNlO1xuXG4gIHZhciBjdXJQdW5jLCBpc0RlZktleXdvcmQ7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChob29rc1tjaF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBob29rc1tjaF0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyU3RhcnQudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSlcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVyKSkgcmV0dXJuIFwibnVtYmVyXCJcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICB9XG4gICAgaWYgKGlzUHVuY3R1YXRpb25DaGFyLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0ubWF0Y2goL15cXC9bXFwvKl0vLCBmYWxzZSkgJiYgc3RyZWFtLmVhdChpc09wZXJhdG9yQ2hhcikpIHt9XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNJZGVudGlmaWVyQ2hhcik7XG4gICAgaWYgKG5hbWVzcGFjZVNlcGFyYXRvcikgd2hpbGUgKHN0cmVhbS5tYXRjaChuYW1lc3BhY2VTZXBhcmF0b3IpKVxuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzSWRlbnRpZmllckNoYXIpO1xuXG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKGNvbnRhaW5zKGtleXdvcmRzLCBjdXIpKSB7XG4gICAgICBpZiAoY29udGFpbnMoYmxvY2tLZXl3b3JkcywgY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICBpZiAoY29udGFpbnMoZGVmS2V5d29yZHMsIGN1cikpIGlzRGVmS2V5d29yZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGlmIChjb250YWlucyh0eXBlcywgY3VyKSkgcmV0dXJuIFwidHlwZVwiO1xuICAgIGlmIChjb250YWlucyhidWlsdGluLCBjdXIpXG4gICAgICAgIHx8IChpc1Jlc2VydmVkSWRlbnRpZmllciAmJiBpc1Jlc2VydmVkSWRlbnRpZmllcihjdXIpKSkge1xuICAgICAgaWYgKGNvbnRhaW5zKGJsb2NrS2V5d29yZHMsIGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnMoYXRvbXMsIGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAocGFyc2VyQ29uZmlnLnR5cGVGaXJzdERlZmluaXRpb25zICYmIHN0cmVhbS5lb2woKSAmJiBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpKVxuICAgICAgc3RhdGUudHlwZUF0RW5kT2ZMaW5lID0gdHlwZUJlZm9yZShzdHJlYW0sIHN0YXRlLCBzdHJlYW0ucG9zKVxuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcInRvcFwiLCBudWxsLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiAwLFxuICAgICAgICBzdGFydE9mTGluZTogdHJ1ZSxcbiAgICAgICAgcHJldlRva2VuOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgeyBtYXliZUVPTChzdHJlYW0sIHN0YXRlKTsgcmV0dXJuIG51bGw7IH1cbiAgICAgIGN1clB1bmMgPSBpc0RlZktleXdvcmQgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIgfHwgc3R5bGUgPT0gXCJtZXRhXCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKGN1clB1bmMgPT0gXCI7XCIgfHwgY3VyUHVuYyA9PSBcIjpcIiB8fCAoY3VyUHVuYyA9PSBcIixcIiAmJiBzdHJlYW0ubWF0Y2goL15cXHMqKD86XFwvXFwvLiopPyQvLCBmYWxzZSkpKVxuICAgICAgICB3aGlsZSAoc3RhdGUuY29udGV4dC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdHgudHlwZSA9PSBcIn1cIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoaW5kZW50U3RhdGVtZW50cyAmJlxuICAgICAgICAgICAgICAgKCgoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIikgJiYgY3VyUHVuYyAhPSBcIjtcIikgfHxcbiAgICAgICAgICAgICAgICAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKSkge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIiAmJlxuICAgICAgICAgICgoc3RhdGUucHJldlRva2VuID09IFwiZGVmXCIgfHxcbiAgICAgICAgICAgIChwYXJzZXJDb25maWcudHlwZUZpcnN0RGVmaW5pdGlvbnMgJiYgdHlwZUJlZm9yZShzdHJlYW0sIHN0YXRlLCBzdHJlYW0uc3RhcnQpICYmXG4gICAgICAgICAgICAgaXNUb3BTY29wZShzdGF0ZS5jb250ZXh0KSAmJiBzdHJlYW0ubWF0Y2goL15cXHMqXFwoLywgZmFsc2UpKSkpKVxuICAgICAgICBzdHlsZSA9IFwiZGVmXCI7XG5cbiAgICAgIGlmIChob29rcy50b2tlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaG9va3MudG9rZW4oc3RyZWFtLCBzdGF0ZSwgc3R5bGUpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0eWxlID0gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUgPT0gXCJkZWZcIiAmJiBwYXJzZXJDb25maWcuc3R5bGVEZWZzID09PSBmYWxzZSkgc3R5bGUgPSBcInZhcmlhYmxlXCI7XG5cbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICBzdGF0ZS5wcmV2VG9rZW4gPSBpc0RlZktleXdvcmQgPyBcImRlZlwiIDogc3R5bGUgfHwgY3VyUHVuYztcbiAgICAgIG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCB8fCBzdGF0ZS50eXBlQXRFbmRPZkxpbmUpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dCwgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmRvbnRJbmRlbnRTdGF0ZW1lbnRzKVxuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBwYXJzZXJDb25maWcuZG9udEluZGVudFN0YXRlbWVudHMudGVzdChjdHguaW5mbykpXG4gICAgICAgICAgY3R4ID0gY3R4LnByZXZcbiAgICAgIGlmIChob29rcy5pbmRlbnQpIHtcbiAgICAgICAgdmFyIGhvb2sgPSBob29rcy5pbmRlbnQoc3RhdGUsIGN0eCwgdGV4dEFmdGVyLCBpbmRlbnRVbml0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBob29rID09IFwibnVtYmVyXCIpIHJldHVybiBob29rXG4gICAgICB9XG4gICAgICB2YXIgc3dpdGNoQmxvY2sgPSBjdHgucHJldiAmJiBjdHgucHJldi5pbmZvID09IFwic3dpdGNoXCI7XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmFsbG1hbkluZGVudGF0aW9uICYmIC9beyhdLy50ZXN0KGZpcnN0Q2hhcikpIHtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlICE9IFwidG9wXCIgJiYgY3R4LnR5cGUgIT0gXCJ9XCIpIGN0eCA9IGN0eC5wcmV2XG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWRcbiAgICAgIH1cbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKVxuICAgICAgICByZXR1cm4gY3R4LmluZGVudGVkICsgKGZpcnN0Q2hhciA9PSBcIntcIiA/IDAgOiBzdGF0ZW1lbnRJbmRlbnRVbml0KTtcbiAgICAgIGlmIChjdHguYWxpZ24gJiYgKCFkb250QWxpZ25DYWxscyB8fCBjdHgudHlwZSAhPSBcIilcIikpXG4gICAgICAgIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCIpXCIgJiYgIWNsb3NpbmcpXG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuXG4gICAgICByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCkgK1xuICAgICAgICAoIWNsb3NpbmcgJiYgc3dpdGNoQmxvY2sgJiYgIS9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gaW5kZW50VW5pdCA6IDApO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0lucHV0OiBpbmRlbnRTd2l0Y2ggPyAvXlxccyooPzpjYXNlIC4qPzp8ZGVmYXVsdDp8XFx7XFx9P3xcXH0pJC8gOiAvXlxccypbe31dJC8sXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBibG9ja0NvbW1lbnRDb250aW51ZTogXCIgKiBcIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiLFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9O1xufSk7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBjb250YWlucyh3b3Jkcywgd29yZCkge1xuICAgIGlmICh0eXBlb2Ygd29yZHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHdvcmRzKHdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCk7XG4gICAgfVxuICB9XG4gIHZhciBjS2V5d29yZHMgPSBcImF1dG8gaWYgYnJlYWsgY2FzZSByZWdpc3RlciBjb250aW51ZSByZXR1cm4gZGVmYXVsdCBkbyBzaXplb2YgXCIgK1xuICAgIFwic3RhdGljIGVsc2Ugc3RydWN0IHN3aXRjaCBleHRlcm4gdHlwZWRlZiB1bmlvbiBmb3IgZ290byB3aGlsZSBlbnVtIGNvbnN0IFwiICtcbiAgICBcInZvbGF0aWxlIGlubGluZSByZXN0cmljdCBhc20gZm9ydHJhblwiO1xuXG4gIC8vIEtleXdvcmRzIGZyb20gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2tleXdvcmQgaW5jbHVkZXMgQysrMjAuXG4gIHZhciBjcHBLZXl3b3JkcyA9IFwiYWxpZ25hcyBhbGlnbm9mIGFuZCBhbmRfZXEgYXVkaXQgYXhpb20gYml0YW5kIGJpdG9yIGNhdGNoIFwiICtcbiAgXCJjbGFzcyBjb21wbCBjb25jZXB0IGNvbnN0ZXhwciBjb25zdF9jYXN0IGRlY2x0eXBlIGRlbGV0ZSBkeW5hbWljX2Nhc3QgXCIgK1xuICBcImV4cGxpY2l0IGV4cG9ydCBmaW5hbCBmcmllbmQgaW1wb3J0IG1vZHVsZSBtdXRhYmxlIG5hbWVzcGFjZSBuZXcgbm9leGNlcHQgXCIgK1xuICBcIm5vdCBub3RfZXEgb3BlcmF0b3Igb3Igb3JfZXEgb3ZlcnJpZGUgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIFwiICtcbiAgXCJyZWludGVycHJldF9jYXN0IHJlcXVpcmVzIHN0YXRpY19hc3NlcnQgc3RhdGljX2Nhc3QgdGVtcGxhdGUgdGhpcyBcIiArXG4gIFwidGhyZWFkX2xvY2FsIHRocm93IHRyeSB0eXBlaWQgdHlwZW5hbWUgdXNpbmcgdmlydHVhbCB4b3IgeG9yX2VxXCI7XG5cbiAgdmFyIG9iakNLZXl3b3JkcyA9IFwiYnljb3B5IGJ5cmVmIGluIGlub3V0IG9uZXdheSBvdXQgc2VsZiBzdXBlciBhdG9taWMgbm9uYXRvbWljIHJldGFpbiBjb3B5IFwiICtcbiAgXCJyZWFkd3JpdGUgcmVhZG9ubHkgc3Ryb25nIHdlYWsgYXNzaWduIHR5cGVvZiBudWxsYWJsZSBub25udWxsIG51bGxfcmVzZXR0YWJsZSBfY21kIFwiICtcbiAgXCJAaW50ZXJmYWNlIEBpbXBsZW1lbnRhdGlvbiBAZW5kIEBwcm90b2NvbCBAZW5jb2RlIEBwcm9wZXJ0eSBAc3ludGhlc2l6ZSBAZHluYW1pYyBAY2xhc3MgXCIgK1xuICBcIkBwdWJsaWMgQHBhY2thZ2UgQHByaXZhdGUgQHByb3RlY3RlZCBAcmVxdWlyZWQgQG9wdGlvbmFsIEB0cnkgQGNhdGNoIEBmaW5hbGx5IEBpbXBvcnQgXCIgK1xuICBcIkBzZWxlY3RvciBAZW5jb2RlIEBkZWZzIEBzeW5jaHJvbml6ZWQgQGF1dG9yZWxlYXNlcG9vbCBAY29tcGF0aWJpbGl0eV9hbGlhcyBAYXZhaWxhYmxlXCI7XG5cbiAgdmFyIG9iakNCdWlsdGlucyA9IFwiRk9VTkRBVElPTl9FWFBPUlQgRk9VTkRBVElPTl9FWFRFUk4gTlNfSU5MSU5FIE5TX0ZPUk1BVF9GVU5DVElPTiBcIiArXG4gIFwiIE5TX1JFVFVSTlNfUkVUQUlORUROU19FUlJPUl9FTlVNIE5TX1JFVFVSTlNfTk9UX1JFVEFJTkVEIE5TX1JFVFVSTlNfSU5ORVJfUE9JTlRFUiBcIiArXG4gIFwiTlNfREVTSUdOQVRFRF9JTklUSUFMSVpFUiBOU19FTlVNIE5TX09QVElPTlMgTlNfUkVRVUlSRVNfTklMX1RFUk1JTkFUSU9OIFwiICtcbiAgXCJOU19BU1NVTUVfTk9OTlVMTF9CRUdJTiBOU19BU1NVTUVfTk9OTlVMTF9FTkQgTlNfU1dJRlRfTkFNRSBOU19SRUZJTkVEX0ZPUl9TV0lGVFwiXG5cbiAgLy8gRG8gbm90IHVzZSB0aGlzLiBVc2UgdGhlIGNUeXBlcyBmdW5jdGlvbiBiZWxvdy4gVGhpcyBpcyBnbG9iYWwganVzdCB0byBhdm9pZFxuICAvLyBleGNlc3NpdmUgY2FsbHMgd2hlbiBjVHlwZXMgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIHBhcnNlLlxuICB2YXIgYmFzaWNDVHlwZXMgPSB3b3JkcyhcImludCBsb25nIGNoYXIgc2hvcnQgZG91YmxlIGZsb2F0IHVuc2lnbmVkIHNpZ25lZCBcIiArXG4gICAgXCJ2b2lkIGJvb2xcIik7XG5cbiAgLy8gRG8gbm90IHVzZSB0aGlzLiBVc2UgdGhlIG9iakNUeXBlcyBmdW5jdGlvbiBiZWxvdy4gVGhpcyBpcyBnbG9iYWwganVzdCB0byBhdm9pZFxuICAvLyBleGNlc3NpdmUgY2FsbHMgd2hlbiBvYmpDVHlwZXMgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIHBhcnNlLlxuICB2YXIgYmFzaWNPYmpDVHlwZXMgPSB3b3JkcyhcIlNFTCBpbnN0YW5jZXR5cGUgaWQgQ2xhc3MgUHJvdG9jb2wgQk9PTFwiKTtcblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaWRlbnRpZmllciBpcyBhIFwiQ1wiIHR5cGUuXG4gIC8vIEMgdHlwZSBpcyBkZWZpbmVkIGFzIHRob3NlIHRoYXQgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb21waWxlciAoYmFzaWNUeXBlcyksXG4gIC8vIGFuZCB0aG9zZSB0aGF0IGVuZCBpbiBfdCAoUmVzZXJ2ZWQgYnkgUE9TSVggZm9yIHR5cGVzKVxuICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvbGliYy9tYW51YWwvaHRtbF9ub2RlL1Jlc2VydmVkLU5hbWVzLmh0bWxcbiAgZnVuY3Rpb24gY1R5cGVzKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gY29udGFpbnMoYmFzaWNDVHlwZXMsIGlkZW50aWZpZXIpIHx8IC8uK190JC8udGVzdChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpZGVudGlmaWVyIGlzIGEgXCJPYmplY3RpdmUgQ1wiIHR5cGUuXG4gIGZ1bmN0aW9uIG9iakNUeXBlcyhpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGNUeXBlcyhpZGVudGlmaWVyKSB8fCBjb250YWlucyhiYXNpY09iakNUeXBlcywgaWRlbnRpZmllcik7XG4gIH1cblxuICB2YXIgY0Jsb2NrS2V5d29yZHMgPSBcImNhc2UgZG8gZWxzZSBmb3IgaWYgc3dpdGNoIHdoaWxlIHN0cnVjdCBlbnVtIHVuaW9uXCI7XG4gIHZhciBjRGVmS2V5d29yZHMgPSBcInN0cnVjdCBlbnVtIHVuaW9uXCI7XG5cbiAgZnVuY3Rpb24gY3BwSG9vayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5zdGFydE9mTGluZSkgcmV0dXJuIGZhbHNlXG4gICAgZm9yICh2YXIgY2gsIG5leHQgPSBudWxsOyBjaCA9IHN0cmVhbS5wZWVrKCk7KSB7XG4gICAgICBpZiAoY2ggPT0gXCJcXFxcXCIgJiYgc3RyZWFtLm1hdGNoKC9eLiQvKSkge1xuICAgICAgICBuZXh0ID0gY3BwSG9va1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0ubWF0Y2goL15cXC9bXFwvXFwqXS8sIGZhbHNlKSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKVxuICAgIH1cbiAgICBzdGF0ZS50b2tlbml6ZSA9IG5leHRcbiAgICByZXR1cm4gXCJtZXRhXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50ZXJIb29rKF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnByZXZUb2tlbiA9PSBcInR5cGVcIikgcmV0dXJuIFwidHlwZVwiO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZvciBDIGFuZCBDKysgKGFuZCBPYmpDKTogaWRlbnRpZmllcnMgc3RhcnRpbmcgd2l0aCBfX1xuICAvLyBvciBfIGZvbGxvd2VkIGJ5IGEgY2FwaXRhbCBsZXR0ZXIgYXJlIHJlc2VydmVkIGZvciB0aGUgY29tcGlsZXIuXG4gIGZ1bmN0aW9uIGNJc1Jlc2VydmVkSWRlbnRpZmllcih0b2tlbikge1xuICAgIGlmICghdG9rZW4gfHwgdG9rZW4ubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0b2tlblswXSAhPSAnXycpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKHRva2VuWzFdID09ICdfJykgfHwgKHRva2VuWzFdICE9PSB0b2tlblsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNwcDE0TGl0ZXJhbChzdHJlYW0pIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC4nXS8pO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY3BwMTFTdHJpbmdIb29rKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgIC8vIFJhdyBzdHJpbmdzLlxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oPzpSfHU4Unx1UnxVUnxMUikvKSkge1xuICAgICAgdmFyIG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXCIoW15cXHNcXFxcKCldezAsMTZ9KVxcKC8pO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jcHAxMVJhd1N0cmluZ0RlbGltID0gbWF0Y2hbMV07XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUmF3U3RyaW5nO1xuICAgICAgcmV0dXJuIHRva2VuUmF3U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBVbmljb2RlIHN0cmluZ3MvY2hhcnMuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OnU4fHV8VXxMKS8pKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1wiJ10vLCAvKiBlYXQgKi8gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgdGhpcyBob29rLlxuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3BwTG9va3NMaWtlQ29uc3RydWN0b3Iod29yZCkge1xuICAgIHZhciBsYXN0VHdvID0gLyhcXHcrKTo6fj8oXFx3KykkLy5leGVjKHdvcmQpO1xuICAgIHJldHVybiBsYXN0VHdvICYmIGxhc3RUd29bMV0gPT0gbGFzdFR3b1syXTtcbiAgfVxuXG4gIC8vIEMjLXN0eWxlIHN0cmluZ3Mgd2hlcmUgXCJcIiBlc2NhcGVzIGEgcXVvdGUuXG4gIGZ1bmN0aW9uIHRva2VuQXRTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0O1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09ICdcIicgJiYgIXN0cmVhbS5lYXQoJ1wiJykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cblxuICAvLyBDKysxMSByYXcgc3RyaW5nIGxpdGVyYWwgaXMgPHByZWZpeD5cIjxkZWxpbT4oIGFueXRoaW5nICk8ZGVsaW0+XCIsIHdoZXJlXG4gIC8vIDxkZWxpbT4gY2FuIGJlIGEgc3RyaW5nIHVwIHRvIDE2IGNoYXJhY3RlcnMgbG9uZy5cbiAgZnVuY3Rpb24gdG9rZW5SYXdTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBzcGVjaWFsIHJlZ2V4IG1lYW5pbmdzLlxuICAgIHZhciBkZWxpbSA9IHN0YXRlLmNwcDExUmF3U3RyaW5nRGVsaW0ucmVwbGFjZSgvW15cXHdcXHNdL2csICdcXFxcJCYnKTtcbiAgICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2gobmV3IFJlZ0V4cChcIi4qP1xcXFwpXCIgKyBkZWxpbSArICdcIicpKTtcbiAgICBpZiAobWF0Y2gpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmKG1pbWVzLCBtb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBtaW1lcyA9PSBcInN0cmluZ1wiKSBtaW1lcyA9IFttaW1lc107XG4gICAgdmFyIHdvcmRzID0gW107XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgaWYgKG9iaikgZm9yICh2YXIgcHJvcCBpbiBvYmopIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgIHdvcmRzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIGFkZChtb2RlLmtleXdvcmRzKTtcbiAgICBhZGQobW9kZS50eXBlcyk7XG4gICAgYWRkKG1vZGUuYnVpbHRpbik7XG4gICAgYWRkKG1vZGUuYXRvbXMpO1xuICAgIGlmICh3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIG1vZGUuaGVscGVyVHlwZSA9IG1pbWVzWzBdO1xuICAgICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBtaW1lc1swXSwgd29yZHMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWltZXMubGVuZ3RoOyArK2kpXG4gICAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUobWltZXNbaV0sIG1vZGUpO1xuICB9XG5cbiAgZGVmKFtcInRleHQveC1jc3JjXCIsIFwidGV4dC94LWNcIiwgXCJ0ZXh0L3gtY2hkclwiXSwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzKSxcbiAgICB0eXBlczogY1R5cGVzLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzKSxcbiAgICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzKSxcbiAgICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgICBhdG9tczogd29yZHMoXCJOVUxMIHRydWUgZmFsc2VcIiksXG4gICAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgICBob29rczoge1xuICAgICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gICAgfSxcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuXG4gIGRlZihbXCJ0ZXh0L3gtYysrc3JjXCIsIFwidGV4dC94LWMrK2hkclwiXSwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBjcHBLZXl3b3JkcyksXG4gICAgdHlwZXM6IGNUeXBlcyxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhjQmxvY2tLZXl3b3JkcyArIFwiIGNsYXNzIHRyeSBjYXRjaFwiKSxcbiAgICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgY2xhc3MgbmFtZXNwYWNlXCIpLFxuICAgIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgTlVMTCBudWxscHRyXCIpLFxuICAgIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXnRlbXBsYXRlJC8sXG4gICAgaXNJZGVudGlmaWVyQ2hhcjogL1tcXHdcXCRfflxceGExLVxcdWZmZmZdLyxcbiAgICBpc1Jlc2VydmVkSWRlbnRpZmllcjogY0lzUmVzZXJ2ZWRJZGVudGlmaWVyLFxuICAgIGhvb2tzOiB7XG4gICAgICBcIiNcIjogY3BwSG9vayxcbiAgICAgIFwiKlwiOiBwb2ludGVySG9vayxcbiAgICAgIFwidVwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgICBcIlVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgICAgXCJMXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICAgIFwiUlwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgICBcIjBcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCIxXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiMlwiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjNcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCI0XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiNVwiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjZcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCI3XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiOFwiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjlcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUsIHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIihcIiAmJlxuICAgICAgICAgICAgKHN0YXRlLnByZXZUb2tlbiA9PSBcIjtcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgIHN0YXRlLnByZXZUb2tlbiA9PSBcIn1cIikgJiZcbiAgICAgICAgICAgIGNwcExvb2tzTGlrZUNvbnN0cnVjdG9yKHN0cmVhbS5jdXJyZW50KCkpKVxuICAgICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZXNwYWNlU2VwYXJhdG9yOiBcIjo6XCIsXG4gICAgbW9kZVByb3BzOiB7Zm9sZDogW1wiYnJhY2VcIiwgXCJpbmNsdWRlXCJdfVxuICB9KTtcblxuICBkZWYoXCJ0ZXh0L3gtamF2YVwiLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhcImFic3RyYWN0IGFzc2VydCBicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNvbnN0IGNvbnRpbnVlIGRlZmF1bHQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImRvIGVsc2UgZW51bSBleHRlbmRzIGZpbmFsIGZpbmFsbHkgZm9yIGdvdG8gaWYgaW1wbGVtZW50cyBpbXBvcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImluc3RhbmNlb2YgaW50ZXJmYWNlIG5hdGl2ZSBuZXcgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInJldHVybiBzdGF0aWMgc3RyaWN0ZnAgc3VwZXIgc3dpdGNoIHN5bmNocm9uaXplZCB0aGlzIHRocm93IHRocm93cyB0cmFuc2llbnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRyeSB2b2xhdGlsZSB3aGlsZSBAaW50ZXJmYWNlXCIpLFxuICAgIHR5cGVzOiB3b3JkcyhcInZhciBieXRlIHNob3J0IGludCBsb25nIGZsb2F0IGRvdWJsZSBib29sZWFuIGNoYXIgdm9pZCBCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIERvdWJsZSBGbG9hdCBcIiArXG4gICAgICAgICAgICAgICAgIFwiSW50ZWdlciBMb25nIE51bWJlciBPYmplY3QgU2hvcnQgU3RyaW5nIFN0cmluZ0J1ZmZlciBTdHJpbmdCdWlsZGVyIFZvaWRcIiksXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGlmIHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gICAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgaW50ZXJmYWNlIGVudW0gQGludGVyZmFjZVwiKSxcbiAgICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gICAgbnVtYmVyOiAvXig/OjB4W2EtZlxcZF9dK3wwYlswMV9dK3woPzpbXFxkX10rXFwuP1xcZCp8XFwuXFxkKykoPzplWy0rXT9bXFxkX10rKT8pKHV8bGw/fGx8Zik/L2ksXG4gICAgaG9va3M6IHtcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgLy8gRG9uJ3QgbWF0Y2ggdGhlIEBpbnRlcmZhY2Uga2V5d29yZC5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnaW50ZXJmYWNlJywgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kZVByb3BzOiB7Zm9sZDogW1wiYnJhY2VcIiwgXCJpbXBvcnRcIl19XG4gIH0pO1xuXG4gIGRlZihcInRleHQveC1jc2hhcnBcIiwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoXCJhYnN0cmFjdCBhcyBhc3luYyBhd2FpdCBiYXNlIGJyZWFrIGNhc2UgY2F0Y2ggY2hlY2tlZCBjbGFzcyBjb25zdCBjb250aW51ZVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBlbHNlIGVudW0gZXZlbnQgZXhwbGljaXQgZXh0ZXJuIGZpbmFsbHkgZml4ZWQgZm9yXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50ZXJmYWNlIGludGVybmFsIGlzIGxvY2sgbmFtZXNwYWNlIG5ld1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHJldHVybiBzZWFsZWRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIHNpemVvZiBzdGFja2FsbG9jIHN0YXRpYyBzdHJ1Y3Qgc3dpdGNoIHRoaXMgdGhyb3cgdHJ5IHR5cGVvZiB1bmNoZWNrZWRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIHVuc2FmZSB1c2luZyB2aXJ0dWFsIHZvaWQgdm9sYXRpbGUgd2hpbGUgYWRkIGFsaWFzIGFzY2VuZGluZyBkZXNjZW5kaW5nIGR5bmFtaWMgZnJvbSBnZXRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIGdsb2JhbCBncm91cCBpbnRvIGpvaW4gbGV0IG9yZGVyYnkgcGFydGlhbCByZW1vdmUgc2VsZWN0IHNldCB2YWx1ZSB2YXIgeWllbGRcIiksXG4gICAgdHlwZXM6IHdvcmRzKFwiQWN0aW9uIEJvb2xlYW4gQnl0ZSBDaGFyIERhdGVUaW1lIERhdGVUaW1lT2Zmc2V0IERlY2ltYWwgRG91YmxlIEZ1bmNcIiArXG4gICAgICAgICAgICAgICAgIFwiIEd1aWQgSW50MTYgSW50MzIgSW50NjQgT2JqZWN0IFNCeXRlIFNpbmdsZSBTdHJpbmcgVGFzayBUaW1lU3BhbiBVSW50MTYgVUludDMyXCIgK1xuICAgICAgICAgICAgICAgICBcIiBVSW50NjQgYm9vbCBieXRlIGNoYXIgZGVjaW1hbCBkb3VibGUgc2hvcnQgaW50IGxvbmcgb2JqZWN0XCIgICtcbiAgICAgICAgICAgICAgICAgXCIgc2J5dGUgZmxvYXQgc3RyaW5nIHVzaG9ydCB1aW50IHVsb25nXCIpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZG8gZWxzZSBmaW5hbGx5IGZvciBmb3JlYWNoIGlmIHN0cnVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICAgIGRlZktleXdvcmRzOiB3b3JkcyhcImNsYXNzIGludGVyZmFjZSBuYW1lc3BhY2Ugc3RydWN0IHZhclwiKSxcbiAgICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gICAgaG9va3M6IHtcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KCdcIicpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkF0U3RyaW5nO1xuICAgICAgICAgIHJldHVybiB0b2tlbkF0U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHRva2VuVHJpcGxlU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdcIlwiXCInKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9IHN0cmVhbS5uZXh0KCkgPT0gXCJcXFxcXCIgJiYgIWVzY2FwZWQ7XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2hcbiAgICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgaWYgKGNoID09IFwiKlwiICYmIHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGggLSAxKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGggKyAxKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJjb21tZW50XCJcbiAgICB9XG4gIH1cblxuICBkZWYoXCJ0ZXh0L3gtc2NhbGFcIiwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoXG4gICAgICAvKiBzY2FsYSAqL1xuICAgICAgXCJhYnN0cmFjdCBjYXNlIGNhdGNoIGNsYXNzIGRlZiBkbyBlbHNlIGV4dGVuZHMgZmluYWwgZmluYWxseSBmb3IgZm9yU29tZSBpZiBcIiArXG4gICAgICBcImltcGxpY2l0IGltcG9ydCBsYXp5IG1hdGNoIG5ldyBudWxsIG9iamVjdCBvdmVycmlkZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHJldHVybiBcIiArXG4gICAgICBcInNlYWxlZCBzdXBlciB0aGlzIHRocm93IHRyYWl0IHRyeSB0eXBlIHZhbCB2YXIgd2hpbGUgd2l0aCB5aWVsZCBfIFwiICtcblxuICAgICAgLyogcGFja2FnZSBzY2FsYSAqL1xuICAgICAgXCJhc3NlcnQgYXNzdW1lIHJlcXVpcmUgcHJpbnQgcHJpbnRsbiBwcmludGYgcmVhZExpbmUgcmVhZEJvb2xlYW4gcmVhZEJ5dGUgcmVhZFNob3J0IFwiICtcbiAgICAgIFwicmVhZENoYXIgcmVhZEludCByZWFkTG9uZyByZWFkRmxvYXQgcmVhZERvdWJsZVwiXG4gICAgKSxcbiAgICB0eXBlczogd29yZHMoXG4gICAgICBcIkFueVZhbCBBcHAgQXBwbGljYXRpb24gQXJyYXkgQnVmZmVyZWRJdGVyYXRvciBCaWdEZWNpbWFsIEJpZ0ludCBDaGFyIENvbnNvbGUgRWl0aGVyIFwiICtcbiAgICAgIFwiRW51bWVyYXRpb24gRXF1aXYgRXJyb3IgRXhjZXB0aW9uIEZyYWN0aW9uYWwgRnVuY3Rpb24gSW5kZXhlZFNlcSBJbnQgSW50ZWdyYWwgSXRlcmFibGUgXCIgK1xuICAgICAgXCJJdGVyYXRvciBMaXN0IE1hcCBOdW1lcmljIE5pbCBOb3ROdWxsIE9wdGlvbiBPcmRlcmVkIE9yZGVyaW5nIFBhcnRpYWxGdW5jdGlvbiBQYXJ0aWFsT3JkZXJpbmcgXCIgK1xuICAgICAgXCJQcm9kdWN0IFByb3h5IFJhbmdlIFJlc3BvbmRlciBTZXEgU2VyaWFsaXphYmxlIFNldCBTcGVjaWFsaXphYmxlIFN0cmVhbSBTdHJpbmdCdWlsZGVyIFwiICtcbiAgICAgIFwiU3RyaW5nQ29udGV4dCBTeW1ib2wgVGhyb3dhYmxlIFRyYXZlcnNhYmxlIFRyYXZlcnNhYmxlT25jZSBUdXBsZSBVbml0IFZlY3RvciBcIiArXG5cbiAgICAgIC8qIHBhY2thZ2UgamF2YS5sYW5nICovXG4gICAgICBcIkJvb2xlYW4gQnl0ZSBDaGFyYWN0ZXIgQ2hhclNlcXVlbmNlIENsYXNzIENsYXNzTG9hZGVyIENsb25lYWJsZSBDb21wYXJhYmxlIFwiICtcbiAgICAgIFwiQ29tcGlsZXIgRG91YmxlIEV4Y2VwdGlvbiBGbG9hdCBJbnRlZ2VyIExvbmcgTWF0aCBOdW1iZXIgT2JqZWN0IFBhY2thZ2UgUGFpciBQcm9jZXNzIFwiICtcbiAgICAgIFwiUnVudGltZSBSdW5uYWJsZSBTZWN1cml0eU1hbmFnZXIgU2hvcnQgU3RhY2tUcmFjZUVsZW1lbnQgU3RyaWN0TWF0aCBTdHJpbmcgXCIgK1xuICAgICAgXCJTdHJpbmdCdWZmZXIgU3lzdGVtIFRocmVhZCBUaHJlYWRHcm91cCBUaHJlYWRMb2NhbCBUaHJvd2FibGUgVHJpcGxlIFZvaWRcIlxuICAgICksXG4gICAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGVudW0gZG8gZWxzZSBmaW5hbGx5IGZvciBmb3JTb21lIGlmIG1hdGNoIHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gICAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgZW51bSBkZWYgb2JqZWN0IHBhY2thZ2UgdHJhaXQgdHlwZSB2YWwgdmFyXCIpLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBpbmRlbnRTdGF0ZW1lbnRzOiBmYWxzZSxcbiAgICBpbmRlbnRTd2l0Y2g6IGZhbHNlLFxuICAgIGlzT3BlcmF0b3JDaGFyOiAvWytcXC0qJiU9PD4hP3xcXC8jOkBdLyxcbiAgICBob29rczoge1xuICAgICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9LFxuICAgICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5tYXRjaCgnXCJcIicpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5UcmlwbGVTdHJpbmc7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBcIidcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9LFxuICAgICAgXCI9XCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGN4ID0gc3RhdGUuY29udGV4dFxuICAgICAgICBpZiAoY3gudHlwZSA9PSBcIn1cIiAmJiBjeC5hbGlnbiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5pbmRlbnRlZCwgY3guY29sdW1uLCBjeC50eXBlLCBjeC5pbmZvLCBudWxsLCBjeC5wcmV2KVxuICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpXG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfVxuICAgIH0sXG4gICAgbW9kZVByb3BzOiB7Y2xvc2VCcmFja2V0czoge3BhaXJzOiAnKClbXXt9XCJcIicsIHRyaXBsZXM6ICdcIid9fVxuICB9KTtcblxuICBmdW5jdGlvbiB0b2tlbktvdGxpblN0cmluZyh0cmlwbGVTdHJpbmcpe1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoIXRyaXBsZVN0cmluZyAmJiAhZXNjYXBlZCAmJiBzdHJlYW0ubWF0Y2goJ1wiJykgKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBpZiAodHJpcGxlU3RyaW5nICYmIHN0cmVhbS5tYXRjaCgnXCJcIlwiJykpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICAgIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZighZXNjYXBlZCAmJiBuZXh0ID09IFwiJFwiICYmIHN0cmVhbS5tYXRjaCgneycpKVxuICAgICAgICAgIHN0cmVhbS5za2lwVG8oXCJ9XCIpO1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIiAmJiAhdHJpcGxlU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhdHJpcGxlU3RyaW5nKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gIH1cblxuICBkZWYoXCJ0ZXh0L3gta290bGluXCIsIHtcbiAgICBuYW1lOiBcImNsaWtlXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFxuICAgICAgLyprZXl3b3JkcyovXG4gICAgICBcInBhY2thZ2UgYXMgdHlwZWFsaWFzIGNsYXNzIGludGVyZmFjZSB0aGlzIHN1cGVyIHZhbCBvcGVyYXRvciBcIiArXG4gICAgICBcInZhciBmdW4gZm9yIGlzIGluIFRoaXMgdGhyb3cgcmV0dXJuIGFubm90YXRpb24gXCIgK1xuICAgICAgXCJicmVhayBjb250aW51ZSBvYmplY3QgaWYgZWxzZSB3aGlsZSBkbyB0cnkgd2hlbiAhaW4gIWlzIGFzPyBcIiArXG5cbiAgICAgIC8qc29mdCBrZXl3b3JkcyovXG4gICAgICBcImZpbGUgaW1wb3J0IHdoZXJlIGJ5IGdldCBzZXQgYWJzdHJhY3QgZW51bSBvcGVuIGlubmVyIG92ZXJyaWRlIHByaXZhdGUgcHVibGljIGludGVybmFsIFwiICtcbiAgICAgIFwicHJvdGVjdGVkIGNhdGNoIGZpbmFsbHkgb3V0IGZpbmFsIHZhcmFyZyByZWlmaWVkIGR5bmFtaWMgY29tcGFuaW9uIGNvbnN0cnVjdG9yIGluaXQgXCIgK1xuICAgICAgXCJzZWFsZWQgZmllbGQgcHJvcGVydHkgcmVjZWl2ZXIgcGFyYW0gc3BhcmFtIGxhdGVpbml0IGRhdGEgaW5saW5lIG5vaW5saW5lIHRhaWxyZWMgXCIgK1xuICAgICAgXCJleHRlcm5hbCBhbm5vdGF0aW9uIGNyb3NzaW5saW5lIGNvbnN0IG9wZXJhdG9yIGluZml4IHN1c3BlbmQgYWN0dWFsIGV4cGVjdCBzZXRwYXJhbSB2YWx1ZVwiXG4gICAgKSxcbiAgICB0eXBlczogd29yZHMoXG4gICAgICAvKiBwYWNrYWdlIGphdmEubGFuZyAqL1xuICAgICAgXCJCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIENoYXJTZXF1ZW5jZSBDbGFzcyBDbGFzc0xvYWRlciBDbG9uZWFibGUgQ29tcGFyYWJsZSBcIiArXG4gICAgICBcIkNvbXBpbGVyIERvdWJsZSBFeGNlcHRpb24gRmxvYXQgSW50ZWdlciBMb25nIE1hdGggTnVtYmVyIE9iamVjdCBQYWNrYWdlIFBhaXIgUHJvY2VzcyBcIiArXG4gICAgICBcIlJ1bnRpbWUgUnVubmFibGUgU2VjdXJpdHlNYW5hZ2VyIFNob3J0IFN0YWNrVHJhY2VFbGVtZW50IFN0cmljdE1hdGggU3RyaW5nIFwiICtcbiAgICAgIFwiU3RyaW5nQnVmZmVyIFN5c3RlbSBUaHJlYWQgVGhyZWFkR3JvdXAgVGhyZWFkTG9jYWwgVGhyb3dhYmxlIFRyaXBsZSBWb2lkIEFubm90YXRpb24gQW55IEJvb2xlYW5BcnJheSBcIiArXG4gICAgICBcIkJ5dGVBcnJheSBDaGFyIENoYXJBcnJheSBEZXByZWNhdGlvbkxldmVsIERvdWJsZUFycmF5IEVudW0gRmxvYXRBcnJheSBGdW5jdGlvbiBJbnQgSW50QXJyYXkgTGF6eSBcIiArXG4gICAgICBcIkxhenlUaHJlYWRTYWZldHlNb2RlIExvbmdBcnJheSBOb3RoaW5nIFNob3J0QXJyYXkgVW5pdFwiXG4gICAgKSxcbiAgICBpbnRlbmRTd2l0Y2g6IGZhbHNlLFxuICAgIGluZGVudFN0YXRlbWVudHM6IGZhbHNlLFxuICAgIG11bHRpTGluZVN0cmluZ3M6IHRydWUsXG4gICAgbnVtYmVyOiAvXig/OjB4W2EtZlxcZF9dK3wwYlswMV9dK3woPzpbXFxkX10rKFxcLlxcZCspP3xcXC5cXGQrKSg/OmVbLStdP1tcXGRfXSspPykodXxsbD98bHxmKT8vaSxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgaWYgd2hlcmUgdHJ5IHdoaWxlIGVudW1cIiksXG4gICAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgdmFsIHZhciBvYmplY3QgaW50ZXJmYWNlIGZ1blwiKSxcbiAgICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGwgdGhpc1wiKSxcbiAgICBob29rczoge1xuICAgICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9LFxuICAgICAgJyonOiBmdW5jdGlvbihfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUucHJldlRva2VuID09ICcuJyA/ICd2YXJpYWJsZScgOiAnb3BlcmF0b3InO1xuICAgICAgfSxcbiAgICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbktvdGxpblN0cmluZyhzdHJlYW0ubWF0Y2goJ1wiXCInKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIqXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIH0sXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCBjdHgsIHRleHRBZnRlciwgaW5kZW50VW5pdCkge1xuICAgICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICAgIGlmICgoc3RhdGUucHJldlRva2VuID09IFwifVwiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBcIilcIikgJiYgdGV4dEFmdGVyID09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkO1xuICAgICAgICBpZiAoKHN0YXRlLnByZXZUb2tlbiA9PSBcIm9wZXJhdG9yXCIgJiYgdGV4dEFmdGVyICE9IFwifVwiICYmIHN0YXRlLmNvbnRleHQudHlwZSAhPSBcIn1cIikgfHxcbiAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ2YXJpYWJsZVwiICYmIGZpcnN0Q2hhciA9PSBcIi5cIiB8fFxuICAgICAgICAgIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIgfHwgc3RhdGUucHJldlRva2VuID09IFwiKVwiKSAmJiBmaXJzdENoYXIgPT0gXCIuXCIpXG4gICAgICAgICAgcmV0dXJuIGluZGVudFVuaXQgKiAyICsgY3R4LmluZGVudGVkO1xuICAgICAgICBpZiAoY3R4LmFsaWduICYmIGN0eC50eXBlID09IFwifVwiKVxuICAgICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoc3RhdGUuY29udGV4dC50eXBlID09ICh0ZXh0QWZ0ZXIgfHwgXCJcIikuY2hhckF0KDApID8gMCA6IGluZGVudFVuaXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kZVByb3BzOiB7Y2xvc2VCcmFja2V0czoge3RyaXBsZXM6ICdcIid9fVxuICB9KTtcblxuICBkZWYoW1wieC1zaGFkZXIveC12ZXJ0ZXhcIiwgXCJ4LXNoYWRlci94LWZyYWdtZW50XCJdLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhcInNhbXBsZXIxRCBzYW1wbGVyMkQgc2FtcGxlcjNEIHNhbXBsZXJDdWJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzYW1wbGVyMURTaGFkb3cgc2FtcGxlcjJEU2hhZG93IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJjb25zdCBhdHRyaWJ1dGUgdW5pZm9ybSB2YXJ5aW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJicmVhayBjb250aW51ZSBkaXNjYXJkIHJldHVybiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3RydWN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJpbiBvdXQgaW5vdXRcIiksXG4gICAgdHlwZXM6IHdvcmRzKFwiZmxvYXQgaW50IGJvb2wgdm9pZCBcIiArXG4gICAgICAgICAgICAgICAgIFwidmVjMiB2ZWMzIHZlYzQgaXZlYzIgaXZlYzMgaXZlYzQgYnZlYzIgYnZlYzMgYnZlYzQgXCIgK1xuICAgICAgICAgICAgICAgICBcIm1hdDIgbWF0MyBtYXQ0XCIpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3RydWN0XCIpLFxuICAgIGJ1aWx0aW46IHdvcmRzKFwicmFkaWFucyBkZWdyZWVzIHNpbiBjb3MgdGFuIGFzaW4gYWNvcyBhdGFuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3cgZXhwIGxvZyBleHAyIHNxcnQgaW52ZXJzZXNxcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFicyBzaWduIGZsb29yIGNlaWwgZnJhY3QgbW9kIG1pbiBtYXggY2xhbXAgbWl4IHN0ZXAgc21vb3Roc3RlcCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoIGRpc3RhbmNlIGRvdCBjcm9zcyBub3JtYWxpemUgZnRyYW5zZm9ybSBmYWNlZm9yd2FyZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicmVmbGVjdCByZWZyYWN0IG1hdHJpeENvbXBNdWx0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsZXNzVGhhbiBsZXNzVGhhbkVxdWFsIGdyZWF0ZXJUaGFuIGdyZWF0ZXJUaGFuRXF1YWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImVxdWFsIG5vdEVxdWFsIGFueSBhbGwgbm90IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlMUQgdGV4dHVyZTFEUHJvaiB0ZXh0dXJlMURMb2QgdGV4dHVyZTFEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZTJEIHRleHR1cmUyRFByb2ogdGV4dHVyZTJETG9kIHRleHR1cmUyRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRleHR1cmUzRCB0ZXh0dXJlM0RQcm9qIHRleHR1cmUzRExvZCB0ZXh0dXJlM0RQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlQ3ViZSB0ZXh0dXJlQ3ViZUxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic2hhZG93MUQgc2hhZG93MkQgc2hhZG93MURQcm9qIHNoYWRvdzJEUHJvaiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic2hhZG93MURMb2Qgc2hhZG93MkRMb2Qgc2hhZG93MURQcm9qTG9kIHNoYWRvdzJEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiZEZkeCBkRmR5IGZ3aWR0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibm9pc2UxIG5vaXNlMiBub2lzZTMgbm9pc2U0XCIpLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yIGdsX1NlY29uZGFyeUNvbG9yIGdsX05vcm1hbCBnbF9WZXJ0ZXggXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDAgZ2xfTXVsdGlUZXhDb29yZDEgZ2xfTXVsdGlUZXhDb29yZDIgZ2xfTXVsdGlUZXhDb29yZDMgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDQgZ2xfTXVsdGlUZXhDb29yZDUgZ2xfTXVsdGlUZXhDb29yZDYgZ2xfTXVsdGlUZXhDb29yZDcgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRm9nQ29vcmQgZ2xfUG9pbnRDb29yZCBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiBnbF9Qb2ludFNpemUgZ2xfQ2xpcFZlcnRleCBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Gcm9udENvbG9yIGdsX0JhY2tDb2xvciBnbF9Gcm9udFNlY29uZGFyeUNvbG9yIGdsX0JhY2tTZWNvbmRhcnlDb2xvciBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9UZXhDb29yZCBnbF9Gb2dGcmFnQ29vcmQgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0Nvb3JkIGdsX0Zyb250RmFjaW5nIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX0ZyYWdEYXRhIGdsX0ZyYWdEZXB0aCBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Nb2RlbFZpZXdNYXRyaXggZ2xfUHJvamVjdGlvbk1hdHJpeCBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4IFwiICtcbiAgICAgICAgICAgICAgICBcImdsX1RleHR1cmVNYXRyaXggZ2xfTm9ybWFsTWF0cml4IGdsX01vZGVsVmlld01hdHJpeEludmVyc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfUHJvamVjdGlvbk1hdHJpeEludmVyc2UgZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeEludmVyc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZU1hdHJpeFRyYW5zcG9zZSBnbF9Nb2RlbFZpZXdNYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX1RleHR1cmVNYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX05vcm1hbFNjYWxlIGdsX0RlcHRoUmFuZ2UgZ2xfQ2xpcFBsYW5lIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX1BvaW50IGdsX0Zyb250TWF0ZXJpYWwgZ2xfQmFja01hdGVyaWFsIGdsX0xpZ2h0U291cmNlIGdsX0xpZ2h0TW9kZWwgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRnJvbnRMaWdodE1vZGVsUHJvZHVjdCBnbF9CYWNrTGlnaHRNb2RlbFByb2R1Y3QgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZUNvbG9yIGdsX0V5ZVBsYW5lUyBnbF9FeWVQbGFuZVQgZ2xfRXllUGxhbmVSIGdsX0V5ZVBsYW5lUSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Gb2dQYXJhbWV0ZXJzIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX01heExpZ2h0cyBnbF9NYXhDbGlwUGxhbmVzIGdsX01heFRleHR1cmVVbml0cyBnbF9NYXhUZXh0dXJlQ29vcmRzIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX01heFZlcnRleEF0dHJpYnMgZ2xfTWF4VmVydGV4VW5pZm9ybUNvbXBvbmVudHMgZ2xfTWF4VmFyeWluZ0Zsb2F0cyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9NYXhWZXJ0ZXhUZXh0dXJlSW1hZ2VVbml0cyBnbF9NYXhUZXh0dXJlSW1hZ2VVbml0cyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9NYXhGcmFnbWVudFVuaWZvcm1Db21wb25lbnRzIGdsX01heENvbWJpbmVUZXh0dXJlSW1hZ2VVbml0cyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9NYXhEcmF3QnVmZmVyc1wiKSxcbiAgICBpbmRlbnRTd2l0Y2g6IGZhbHNlLFxuICAgIGhvb2tzOiB7XCIjXCI6IGNwcEhvb2t9LFxuICAgIG1vZGVQcm9wczoge2ZvbGQ6IFtcImJyYWNlXCIsIFwiaW5jbHVkZVwiXX1cbiAgfSk7XG5cbiAgZGVmKFwidGV4dC94LW5lc2NcIiwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgYXMgYXRvbWljIGFzeW5jIGNhbGwgY29tbWFuZCBjb21wb25lbnQgY29tcG9uZW50cyBjb25maWd1cmF0aW9uIGV2ZW50IGdlbmVyaWMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImltcGxlbWVudGF0aW9uIGluY2x1ZGVzIGludGVyZmFjZSBtb2R1bGUgbmV3IG5vcmFjZSBueF9zdHJ1Y3QgbnhfdW5pb24gcG9zdCBwcm92aWRlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic2lnbmFsIHRhc2sgdXNlcyBhYnN0cmFjdCBleHRlbmRzXCIpLFxuICAgIHR5cGVzOiBjVHlwZXMsXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMpLFxuICAgIGF0b21zOiB3b3JkcyhcIm51bGwgdHJ1ZSBmYWxzZVwiKSxcbiAgICBob29rczoge1wiI1wiOiBjcHBIb29rfSxcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuXG4gIGRlZihcInRleHQveC1vYmplY3RpdmVjXCIsIHtcbiAgICBuYW1lOiBcImNsaWtlXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKGNLZXl3b3JkcyArIFwiIFwiICsgb2JqQ0tleXdvcmRzKSxcbiAgICB0eXBlczogb2JqQ1R5cGVzLFxuICAgIGJ1aWx0aW46IHdvcmRzKG9iakNCdWlsdGlucyksXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMgKyBcIiBAc3ludGhlc2l6ZSBAdHJ5IEBjYXRjaCBAZmluYWxseSBAYXV0b3JlbGVhc2Vwb29sIEBzeW5jaHJvbml6ZWRcIiksXG4gICAgZGVmS2V5d29yZHM6IHdvcmRzKGNEZWZLZXl3b3JkcyArIFwiIEBpbnRlcmZhY2UgQGltcGxlbWVudGF0aW9uIEBwcm90b2NvbCBAY2xhc3NcIiksXG4gICAgZG9udEluZGVudFN0YXRlbWVudHM6IC9eQC4qJC8sXG4gICAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gICAgYXRvbXM6IHdvcmRzKFwiWUVTIE5PIE5VTEwgTmlsIG5pbCB0cnVlIGZhbHNlIG51bGxwdHJcIiksXG4gICAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgICBob29rczoge1xuICAgICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gICAgfSxcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuXG4gIGRlZihcInRleHQveC1vYmplY3RpdmVjKytcIiwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBvYmpDS2V5d29yZHMgKyBcIiBcIiArIGNwcEtleXdvcmRzKSxcbiAgICB0eXBlczogb2JqQ1R5cGVzLFxuICAgIGJ1aWx0aW46IHdvcmRzKG9iakNCdWlsdGlucyksXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMgKyBcIiBAc3ludGhlc2l6ZSBAdHJ5IEBjYXRjaCBAZmluYWxseSBAYXV0b3JlbGVhc2Vwb29sIEBzeW5jaHJvbml6ZWQgY2xhc3MgdHJ5IGNhdGNoXCIpLFxuICAgIGRlZktleXdvcmRzOiB3b3JkcyhjRGVmS2V5d29yZHMgKyBcIiBAaW50ZXJmYWNlIEBpbXBsZW1lbnRhdGlvbiBAcHJvdG9jb2wgQGNsYXNzIGNsYXNzIG5hbWVzcGFjZVwiKSxcbiAgICBkb250SW5kZW50U3RhdGVtZW50czogL15ALiokfF50ZW1wbGF0ZSQvLFxuICAgIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICAgIGF0b21zOiB3b3JkcyhcIllFUyBOTyBOVUxMIE5pbCBuaWwgdHJ1ZSBmYWxzZSBudWxscHRyXCIpLFxuICAgIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gICAgaG9va3M6IHtcbiAgICAgIFwiI1wiOiBjcHBIb29rLFxuICAgICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICAgICAgXCJ1XCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICAgIFwiVVwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgICBcIkxcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgICAgXCJSXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICAgIFwiMFwiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjFcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCIyXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiM1wiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjRcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCI1XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiNlwiOiBjcHAxNExpdGVyYWwsXG4gICAgICBcIjdcIjogY3BwMTRMaXRlcmFsLFxuICAgICAgXCI4XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICAgIFwiOVwiOiBjcHAxNExpdGVyYWwsXG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSwgc3R5bGUpIHtcbiAgICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIiAmJiBzdHJlYW0ucGVlaygpID09IFwiKFwiICYmXG4gICAgICAgICAgICAoc3RhdGUucHJldlRva2VuID09IFwiO1wiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwifVwiKSAmJlxuICAgICAgICAgICAgY3BwTG9va3NMaWtlQ29uc3RydWN0b3Ioc3RyZWFtLmN1cnJlbnQoKSkpXG4gICAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lc3BhY2VTZXBhcmF0b3I6IFwiOjpcIixcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuXG4gIGRlZihcInRleHQveC1zcXVpcnJlbFwiLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhcImJhc2UgYnJlYWsgY2xvbmUgY29udGludWUgY29uc3QgZGVmYXVsdCBkZWxldGUgZW51bSBleHRlbmRzIGZ1bmN0aW9uIGluIGNsYXNzXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBmb3JlYWNoIGxvY2FsIHJlc3VtZSByZXR1cm4gdGhpcyB0aHJvdyB0eXBlb2YgeWllbGQgY29uc3RydWN0b3IgaW5zdGFuY2VvZiBzdGF0aWNcIiksXG4gICAgdHlwZXM6IGNUeXBlcyxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhc2UgY2F0Y2ggY2xhc3MgZWxzZSBmb3IgZm9yZWFjaCBpZiBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICAgIGRlZktleXdvcmRzOiB3b3JkcyhcImZ1bmN0aW9uIGxvY2FsIGNsYXNzXCIpLFxuICAgIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBob29rczoge1wiI1wiOiBjcHBIb29rfSxcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuXG4gIC8vIENleWxvbiBTdHJpbmdzIG5lZWQgdG8gZGVhbCB3aXRoIGludGVycG9sYXRpb25cbiAgdmFyIHN0cmluZ1Rva2VuaXplciA9IG51bGw7XG4gIGZ1bmN0aW9uIHRva2VuQ2V5bG9uU3RyaW5nKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdcIicpICYmXG4gICAgICAgICAgICAgICh0eXBlID09IFwic2luZ2xlXCIgfHwgc3RyZWFtLm1hdGNoKCdcIlwiJykpKSB7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdgYCcpKSB7XG4gICAgICAgICAgc3RyaW5nVG9rZW5pemVyID0gdG9rZW5DZXlsb25TdHJpbmcodHlwZSk7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gc3RyZWFtLm5leHQoKTtcbiAgICAgICAgZXNjYXBlZCA9IHR5cGUgPT0gXCJzaW5nbGVcIiAmJiAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZClcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gIH1cblxuICBkZWYoXCJ0ZXh0L3gtY2V5bG9uXCIsIHtcbiAgICBuYW1lOiBcImNsaWtlXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3RzIGFsaWFzIGFzc2VtYmx5IGFzc2VydCBhc3NpZ24gYnJlYWsgY2FzZSBjYXRjaCBjbGFzcyBjb250aW51ZSBkeW5hbWljIGVsc2VcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIGV4aXN0cyBleHRlbmRzIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGdpdmVuIGlmIGltcG9ydCBpbiBpbnRlcmZhY2UgaXMgbGV0IG1vZHVsZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIG5vbmVtcHR5IG9iamVjdCBvZiBvdXQgb3V0ZXIgcGFja2FnZSByZXR1cm4gc2F0aXNmaWVzIHN1cGVyIHN3aXRjaCB0aGVuIHRoaXMgdGhyb3dcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIHRyeSB2YWx1ZSB2b2lkIHdoaWxlXCIpLFxuICAgIHR5cGVzOiBmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgIC8vIEluIENleWxvbiBhbGwgaWRlbnRpZmllcnMgdGhhdCBzdGFydCB3aXRoIGFuIHVwcGVyY2FzZSBhcmUgdHlwZXNcbiAgICAgICAgdmFyIGZpcnN0ID0gd29yZC5jaGFyQXQoMCk7XG4gICAgICAgIHJldHVybiAoZmlyc3QgPT09IGZpcnN0LnRvVXBwZXJDYXNlKCkgJiYgZmlyc3QgIT09IGZpcnN0LnRvTG93ZXJDYXNlKCkpO1xuICAgIH0sXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXNlIGNhdGNoIGNsYXNzIGR5bmFtaWMgZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbnRlcmZhY2UgbW9kdWxlIG5ldyBvYmplY3Qgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBkeW5hbWljIGZ1bmN0aW9uIGludGVyZmFjZSBtb2R1bGUgb2JqZWN0IHBhY2thZ2UgdmFsdWVcIiksXG4gICAgYnVpbHRpbjogd29yZHMoXCJhYnN0cmFjdCBhY3R1YWwgYWxpYXNlZCBhbm5vdGF0aW9uIGJ5IGRlZmF1bHQgZGVwcmVjYXRlZCBkb2MgZmluYWwgZm9ybWFsIGxhdGUgbGljZW5zZVwiICtcbiAgICAgICAgICAgICAgICAgICBcIiBuYXRpdmUgb3B0aW9uYWwgc2VhbGVkIHNlZSBzZXJpYWxpemFibGUgc2hhcmVkIHN1cHByZXNzV2FybmluZ3MgdGFnZ2VkIHRocm93cyB2YXJpYWJsZVwiKSxcbiAgICBpc1B1bmN0dWF0aW9uQ2hhcjogL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuYF0vLFxuICAgIGlzT3BlcmF0b3JDaGFyOiAvWytcXC0qJiU9PD4hP3xefjpcXC9dLyxcbiAgICBudW1iZXJTdGFydDogL1tcXGQjJF0vLFxuICAgIG51bWJlcjogL14oPzojW1xcZGEtZkEtRl9dK3xcXCRbMDFfXSt8W1xcZF9dK1trTUdUUG11bnBmXT98W1xcZF9dK1xcLltcXGRfXSsoPzpbZUVdWy0rXT9cXGQrfFtrTUdUUG11bnBmXXwpfCkvaSxcbiAgICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlLFxuICAgIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbCBsYXJnZXIgc21hbGxlciBlcXVhbCBlbXB0eSBmaW5pc2hlZFwiKSxcbiAgICBpbmRlbnRTd2l0Y2g6IGZhbHNlLFxuICAgIHN0eWxlRGVmczogZmFsc2UsXG4gICAgaG9va3M6IHtcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfSxcbiAgICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ2V5bG9uU3RyaW5nKHN0cmVhbS5tYXRjaCgnXCJcIicpID8gXCJ0cmlwbGVcIiA6IFwic2luZ2xlXCIpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICdgJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgIGlmICghc3RyaW5nVG9rZW5pemVyIHx8ICFzdHJlYW0ubWF0Y2goJ2AnKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gc3RyaW5nVG9rZW5pemVyO1xuICAgICAgICAgIHN0cmluZ1Rva2VuaXplciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgXCInXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbihfc3RyZWFtLCBzdGF0ZSwgc3R5bGUpIHtcbiAgICAgICAgICBpZiAoKHN0eWxlID09IFwidmFyaWFibGVcIiB8fCBzdHlsZSA9PSBcInR5cGVcIikgJiZcbiAgICAgICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwiLlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtb2RlUHJvcHM6IHtcbiAgICAgICAgZm9sZDogW1wiYnJhY2VcIiwgXCJpbXBvcnRcIl0sXG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHt0cmlwbGVzOiAnXCInfVxuICAgIH1cbiAgfSk7XG5cbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsIkNvbnRleHQiLCJpbmRlbnRlZCIsImNvbHVtbiIsInR5cGUiLCJpbmZvIiwiYWxpZ24iLCJwcmV2IiwicHVzaENvbnRleHQiLCJzdGF0ZSIsImNvbCIsImluZGVudCIsImNvbnRleHQiLCJwb3BDb250ZXh0IiwidCIsInR5cGVCZWZvcmUiLCJzdHJlYW0iLCJwb3MiLCJwcmV2VG9rZW4iLCJ0ZXN0Iiwic3RyaW5nIiwic2xpY2UiLCJ0eXBlQXRFbmRPZkxpbmUiLCJpbmRlbnRhdGlvbiIsImlzVG9wU2NvcGUiLCJkZWZpbmVNb2RlIiwiY29uZmlnIiwicGFyc2VyQ29uZmlnIiwiaW5kZW50VW5pdCIsInN0YXRlbWVudEluZGVudFVuaXQiLCJkb250QWxpZ25DYWxscyIsImtleXdvcmRzIiwidHlwZXMiLCJidWlsdGluIiwiYmxvY2tLZXl3b3JkcyIsImRlZktleXdvcmRzIiwiYXRvbXMiLCJob29rcyIsIm11bHRpTGluZVN0cmluZ3MiLCJpbmRlbnRTdGF0ZW1lbnRzIiwiaW5kZW50U3dpdGNoIiwibmFtZXNwYWNlU2VwYXJhdG9yIiwiaXNQdW5jdHVhdGlvbkNoYXIiLCJudW1iZXJTdGFydCIsIm51bWJlciIsImlzT3BlcmF0b3JDaGFyIiwiaXNJZGVudGlmaWVyQ2hhciIsImlzUmVzZXJ2ZWRJZGVudGlmaWVyIiwiY3VyUHVuYyIsImlzRGVmS2V5d29yZCIsInRva2VuQmFzZSIsImNoIiwibmV4dCIsInJlc3VsdCIsInRva2VuaXplIiwidG9rZW5TdHJpbmciLCJiYWNrVXAiLCJtYXRjaCIsImVhdCIsInRva2VuQ29tbWVudCIsInNraXBUb0VuZCIsImVhdFdoaWxlIiwiY3VyIiwiY3VycmVudCIsImNvbnRhaW5zIiwicXVvdGUiLCJlc2NhcGVkIiwiZW5kIiwibWF5YmVFbmQiLCJtYXliZUVPTCIsInR5cGVGaXJzdERlZmluaXRpb25zIiwiZW9sIiwic3RhcnRTdGF0ZSIsImJhc2Vjb2x1bW4iLCJzdGFydE9mTGluZSIsInRva2VuIiwiY3R4Iiwic29sIiwiZWF0U3BhY2UiLCJzdHlsZSIsInN0YXJ0IiwidW5kZWZpbmVkIiwic3R5bGVEZWZzIiwidGV4dEFmdGVyIiwiUGFzcyIsImZpcnN0Q2hhciIsImNoYXJBdCIsImNsb3NpbmciLCJkb250SW5kZW50U3RhdGVtZW50cyIsImhvb2siLCJzd2l0Y2hCbG9jayIsImFsbG1hbkluZGVudGF0aW9uIiwiZWxlY3RyaWNJbnB1dCIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwiYmxvY2tDb21tZW50Q29udGludWUiLCJsaW5lQ29tbWVudCIsImZvbGQiLCJ3b3JkcyIsInN0ciIsIm9iaiIsInNwbGl0IiwiaSIsImxlbmd0aCIsIndvcmQiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNLZXl3b3JkcyIsImNwcEtleXdvcmRzIiwib2JqQ0tleXdvcmRzIiwib2JqQ0J1aWx0aW5zIiwiYmFzaWNDVHlwZXMiLCJiYXNpY09iakNUeXBlcyIsImNUeXBlcyIsImlkZW50aWZpZXIiLCJvYmpDVHlwZXMiLCJjQmxvY2tLZXl3b3JkcyIsImNEZWZLZXl3b3JkcyIsImNwcEhvb2siLCJwZWVrIiwicG9pbnRlckhvb2siLCJfc3RyZWFtIiwiY0lzUmVzZXJ2ZWRJZGVudGlmaWVyIiwidG9Mb3dlckNhc2UiLCJjcHAxNExpdGVyYWwiLCJjcHAxMVN0cmluZ0hvb2siLCJjcHAxMVJhd1N0cmluZ0RlbGltIiwidG9rZW5SYXdTdHJpbmciLCJjcHBMb29rc0xpa2VDb25zdHJ1Y3RvciIsImxhc3RUd28iLCJleGVjIiwidG9rZW5BdFN0cmluZyIsImRlbGltIiwicmVwbGFjZSIsIlJlZ0V4cCIsImRlZiIsIm1pbWVzIiwibW9kZSIsImFkZCIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJoZWxwZXJUeXBlIiwicmVnaXN0ZXJIZWxwZXIiLCJkZWZpbmVNSU1FIiwibmFtZSIsIm1vZGVQcm9wcyIsInRva2VuVHJpcGxlU3RyaW5nIiwidG9rZW5OZXN0ZWRDb21tZW50IiwiZGVwdGgiLCJjeCIsImNsb3NlQnJhY2tldHMiLCJwYWlycyIsInRyaXBsZXMiLCJ0b2tlbktvdGxpblN0cmluZyIsInRyaXBsZVN0cmluZyIsInNraXBUbyIsImludGVuZFN3aXRjaCIsInN0cmluZ1Rva2VuaXplciIsInRva2VuQ2V5bG9uU3RyaW5nIiwiZmlyc3QiLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/clike/clike.js\n");

/***/ }),

/***/ "./resources/assets/vendor/libs/codemirror/mode/dart/dart.js":
/*!*******************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/dart/dart.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), __webpack_require__(/*! ../clike/clike */ \"./resources/assets/vendor/libs/codemirror/mode/clike/clike.js\"));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__(/*! ../clike/clike */ \"./resources/assets/vendor/libs/codemirror/mode/clike/clike.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var keywords = (\"this super static final const abstract class extends external factory \" + \"implements mixin get native set typedef with enum throw rethrow \" + \"assert break case continue default in return new deferred async await covariant \" + \"try catch finally do else for if switch while import library export \" + \"part of show hide is as extension on yield late required\").split(\" \");\n  var blockKeywords = \"try catch finally do else for if switch while\".split(\" \");\n  var atoms = \"true false null\".split(\" \");\n  var builtins = \"void bool num int double dynamic var String Null Never\".split(\" \");\n\n  function set(words) {\n    var obj = {};\n\n    for (var i = 0; i < words.length; ++i) {\n      obj[words[i]] = true;\n    }\n\n    return obj;\n  }\n\n  function pushInterpolationStack(state) {\n    (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);\n  }\n\n  function popInterpolationStack(state) {\n    return (state.interpolationStack || (state.interpolationStack = [])).pop();\n  }\n\n  function sizeInterpolationStack(state) {\n    return state.interpolationStack ? state.interpolationStack.length : 0;\n  }\n\n  CodeMirror.defineMIME(\"application/dart\", {\n    name: \"clike\",\n    keywords: set(keywords),\n    blockKeywords: set(blockKeywords),\n    builtin: set(builtins),\n    atoms: set(atoms),\n    hooks: {\n      \"@\": function _(stream) {\n        stream.eatWhile(/[\\w\\$_\\.]/);\n        return \"meta\";\n      },\n      // custom string handling to deal with triple-quoted strings and string interpolation\n      \"'\": function _(stream, state) {\n        return tokenString(\"'\", stream, state, false);\n      },\n      \"\\\"\": function _(stream, state) {\n        return tokenString(\"\\\"\", stream, state, false);\n      },\n      \"r\": function r(stream, state) {\n        var peek = stream.peek();\n\n        if (peek == \"'\" || peek == \"\\\"\") {\n          return tokenString(stream.next(), stream, state, true);\n        }\n\n        return false;\n      },\n      \"}\": function _(_stream, state) {\n        // \"}\" is end of interpolation, if interpolation stack is non-empty\n        if (sizeInterpolationStack(state) > 0) {\n          state.tokenize = popInterpolationStack(state);\n          return null;\n        }\n\n        return false;\n      },\n      \"/\": function _(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenNestedComment(1);\n        return state.tokenize(stream, state);\n      },\n      token: function token(stream, _, style) {\n        if (style == \"variable\") {\n          // Assume uppercase symbols are classes using variable-2\n          var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$', 'g');\n\n          if (isUpper.test(stream.current())) {\n            return 'variable-2';\n          }\n        }\n      }\n    }\n  });\n\n  function tokenString(quote, stream, state, raw) {\n    var tripleQuoted = false;\n\n    if (stream.eat(quote)) {\n      if (stream.eat(quote)) tripleQuoted = true;else return \"string\"; //empty string\n    }\n\n    function tokenStringHelper(stream, state) {\n      var escaped = false;\n\n      while (!stream.eol()) {\n        if (!raw && !escaped && stream.peek() == \"$\") {\n          pushInterpolationStack(state);\n          state.tokenize = tokenInterpolation;\n          return \"string\";\n        }\n\n        var next = stream.next();\n\n        if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {\n          state.tokenize = null;\n          break;\n        }\n\n        escaped = !raw && !escaped && next == \"\\\\\";\n      }\n\n      return \"string\";\n    }\n\n    state.tokenize = tokenStringHelper;\n    return tokenStringHelper(stream, state);\n  }\n\n  function tokenInterpolation(stream, state) {\n    stream.eat(\"$\");\n\n    if (stream.eat(\"{\")) {\n      // let clike handle the content of ${...},\n      // we take over again when \"}\" appears (see hooks).\n      state.tokenize = null;\n    } else {\n      state.tokenize = tokenInterpolationIdentifier;\n    }\n\n    return null;\n  }\n\n  function tokenInterpolationIdentifier(stream, state) {\n    stream.eatWhile(/[\\w_]/);\n    state.tokenize = popInterpolationStack(state);\n    return \"variable\";\n  }\n\n  function tokenNestedComment(depth) {\n    return function (stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"*\" && stream.eat(\"/\")) {\n          if (depth == 1) {\n            state.tokenize = null;\n            break;\n          } else {\n            state.tokenize = tokenNestedComment(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        } else if (ch == \"/\" && stream.eat(\"*\")) {\n          state.tokenize = tokenNestedComment(depth + 1);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      return \"comment\";\n    };\n  }\n\n  CodeMirror.registerHelper(\"hintWords\", \"application/dart\", keywords.concat(atoms).concat(builtins)); // This is needed to make loading through meta.js work.\n\n  CodeMirror.defineMode(\"dart\", function (conf) {\n    return CodeMirror.getMode(conf, \"application/dart\");\n  }, \"clike\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9kYXJ0L2RhcnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBLENBQUMsVUFBU0EsR0FBVCxFQUFjO0VBQ2IsSUFBSSxzQkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QixzQkFBT0MsTUFBUCxNQUFpQixRQUFuRCxFQUE2RDtJQUMzREYsR0FBRyxDQUFDRyxtQkFBTyxDQUFDLG1KQUFELENBQVIsRUFBa0NBLG1CQUFPLENBQUMscUZBQUQsQ0FBekMsQ0FBSCxDQURGLEtBRUssSUFBSSxJQUFKLEVBQStDO0lBQ2xEQyxpQ0FBTyxDQUFDLG1KQUFELEVBQXlCLDBHQUF6QixDQUFELG9DQUE2Q0osR0FBN0M7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN0Qjs7RUFFQSxJQUFJQyxRQUFRLEdBQUcsQ0FBQywyRUFDZCxrRUFEYyxHQUVkLGtGQUZjLEdBR2Qsc0VBSGMsR0FJZCwwREFKYSxFQUkrQ0MsS0FKL0MsQ0FJcUQsR0FKckQsQ0FBZjtFQUtBLElBQUlDLGFBQWEsR0FBRyxnREFBZ0RELEtBQWhELENBQXNELEdBQXRELENBQXBCO0VBQ0EsSUFBSUUsS0FBSyxHQUFHLGtCQUFrQkYsS0FBbEIsQ0FBd0IsR0FBeEIsQ0FBWjtFQUNBLElBQUlHLFFBQVEsR0FBRyx5REFBeURILEtBQXpELENBQStELEdBQS9ELENBQWY7O0VBRUEsU0FBU0ksR0FBVCxDQUFhQyxLQUFiLEVBQW9CO0lBQ2xCLElBQUlDLEdBQUcsR0FBRyxFQUFWOztJQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsS0FBSyxDQUFDRyxNQUExQixFQUFrQyxFQUFFRCxDQUFwQztNQUF1Q0QsR0FBRyxDQUFDRCxLQUFLLENBQUNFLENBQUQsQ0FBTixDQUFILEdBQWdCLElB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Q2RuQyxLQUFLLENBQUNHLFFBQU4sR0FBaUIsSUFBakI7WUFDQTtVQUNELENBSEQsTUFHTztZQUNMSCxLQUFLLENBQUNHLFFBQU4sR0FBaUJlLGtCQUFrQixDQUFDaUIsS0FBSyxHQUFHLENBQVQsQ0FBbkM7WUFDQSxPQUFPbkMsS0FBSyxDQUFDRyxRQUFOLENBQWVRLE1BQWYsRUFBdUJYLEtBQXZCLENBQVA7VUFDRDtRQUNGLENBUkQsTUFRTyxJQUFJb0MsRUFBRSxJQUFJLEdBQU4sSUFBYXpCLE1BQU0sQ0FBQ00sR0FBUCxDQUFXLEdBQVgsQ0FBakIsRUFBa0M7VUFDdkNqQixLQUFLLENBQUNHLFFBQU4sR0FBaUJlLGtCQUFrQixDQUFDaUIsS0FBSyxHQUFHLENBQVQsQ0FBbkM7VUFDQSxPQUFPbkMsS0FBSyxDQUFDRyxRQUFOLENBQWVRLE1BQWYsRUFBdUJYLEtBQXZCLENBQVA7UUFDRDtNQUNGOztNQUNELE9BQU8sU0FBUDtJQUNELENBakJEO0VBa0JEOztFQUVEWixVQUFVLENBQUNpRCxjQUFYLENBQTBCLFdBQTFCLEVBQXVDLGtCQUF2QyxFQUEyRGhELFFBQVEsQ0FBQ2lELE1BQVQsQ0FBZ0I5QyxLQUFoQixFQUF1QjhDLE1BQXZCLENBQThCN0MsUUFBOUIsQ0FBM0QsRUFySnNCLENBdUp0Qjs7RUFDQUwsVUFBVSxDQUFDbUQsVUFBWCxDQUFzQixNQUF0QixFQUE4QixVQUFTQyxJQUFULEVBQWU7SUFDM0MsT0FBT3BELFVBQVUsQ0FBQ3FELE9BQVgsQ0FBbUJELElBQW5CLEVBQXlCLGtCQUF6QixDQUFQO0VBQ0QsQ0FGRCxFQUVHLE9BRkg7QUFHRCxDQWxLRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9tb2RlL2RhcnQvZGFydC5qcz84OTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9jbGlrZS9jbGlrZVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2NsaWtlL2NsaWtlXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIga2V5d29yZHMgPSAoXCJ0aGlzIHN1cGVyIHN0YXRpYyBmaW5hbCBjb25zdCBhYnN0cmFjdCBjbGFzcyBleHRlbmRzIGV4dGVybmFsIGZhY3RvcnkgXCIgK1xuICAgIFwiaW1wbGVtZW50cyBtaXhpbiBnZXQgbmF0aXZlIHNldCB0eXBlZGVmIHdpdGggZW51bSB0aHJvdyByZXRocm93IFwiICtcbiAgICBcImFzc2VydCBicmVhayBjYXNlIGNvbnRpbnVlIGRlZmF1bHQgaW4gcmV0dXJuIG5ldyBkZWZlcnJlZCBhc3luYyBhd2FpdCBjb3ZhcmlhbnQgXCIgK1xuICAgIFwidHJ5IGNhdGNoIGZpbmFsbHkgZG8gZWxzZSBmb3IgaWYgc3dpdGNoIHdoaWxlIGltcG9ydCBsaWJyYXJ5IGV4cG9ydCBcIiArXG4gICAgXCJwYXJ0IG9mIHNob3cgaGlkZSBpcyBhcyBleHRlbnNpb24gb24geWllbGQgbGF0ZSByZXF1aXJlZFwiKS5zcGxpdChcIiBcIik7XG4gIHZhciBibG9ja0tleXdvcmRzID0gXCJ0cnkgY2F0Y2ggZmluYWxseSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGVcIi5zcGxpdChcIiBcIik7XG4gIHZhciBhdG9tcyA9IFwidHJ1ZSBmYWxzZSBudWxsXCIuc3BsaXQoXCIgXCIpO1xuICB2YXIgYnVpbHRpbnMgPSBcInZvaWQgYm9vbCBudW0gaW50IGRvdWJsZSBkeW5hbWljIHZhciBTdHJpbmcgTnVsbCBOZXZlclwiLnNwbGl0KFwiIFwiKTtcblxuICBmdW5jdGlvbiBzZXQod29yZHMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpIHtcbiAgICAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrIHx8IChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgPSBbXSkpLnB1c2goc3RhdGUudG9rZW5pemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gICAgcmV0dXJuIChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgfHwgKHN0YXRlLmludGVycG9sYXRpb25TdGFjayA9IFtdKSkucG9wKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmludGVycG9sYXRpb25TdGFjayA/IHN0YXRlLmludGVycG9sYXRpb25TdGFjay5sZW5ndGggOiAwO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZGFydFwiLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiBzZXQoa2V5d29yZHMpLFxuICAgIGJsb2NrS2V5d29yZHM6IHNldChibG9ja0tleXdvcmRzKSxcbiAgICBidWlsdGluOiBzZXQoYnVpbHRpbnMpLFxuICAgIGF0b21zOiBzZXQoYXRvbXMpLFxuICAgIGhvb2tzOiB7XG4gICAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXC5dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGN1c3RvbSBzdHJpbmcgaGFuZGxpbmcgdG8gZGVhbCB3aXRoIHRyaXBsZS1xdW90ZWQgc3RyaW5ncyBhbmQgc3RyaW5nIGludGVycG9sYXRpb25cbiAgICAgIFwiJ1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlblN0cmluZyhcIidcIiwgc3RyZWFtLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIFwiXFxcIlwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlblN0cmluZyhcIlxcXCJcIiwgc3RyZWFtLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIFwiclwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKHBlZWsgPT0gXCInXCIgfHwgcGVlayA9PSBcIlxcXCJcIikge1xuICAgICAgICAgIHJldHVybiB0b2tlblN0cmluZyhzdHJlYW0ubmV4dCgpLCBzdHJlYW0sIHN0YXRlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBcIn1cIjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgLy8gXCJ9XCIgaXMgZW5kIG9mIGludGVycG9sYXRpb24sIGlmIGludGVycG9sYXRpb24gc3RhY2sgaXMgbm9uLWVtcHR5XG4gICAgICAgIGlmIChzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSA+IDApIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpXG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIF8sIHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAvLyBBc3N1bWUgdXBwZXJjYXNlIHN5bWJvbHMgYXJlIGNsYXNzZXMgdXNpbmcgdmFyaWFibGUtMlxuICAgICAgICAgIHZhciBpc1VwcGVyID0gUmVnRXhwKCdeW18kXSpbQS1aXVthLXpBLVowLTlfJF0qJCcsJ2cnKTtcbiAgICAgICAgICBpZiAoaXNVcHBlci50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIHN0cmVhbSwgc3RhdGUsIHJhdykge1xuICAgIHZhciB0cmlwbGVRdW90ZWQgPSBmYWxzZTtcbiAgICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KHF1b3RlKSkgdHJpcGxlUXVvdGVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgcmV0dXJuIFwic3RyaW5nXCI7IC8vZW1wdHkgc3RyaW5nXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nSGVscGVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoIXJhdyAmJiAhZXNjYXBlZCAmJiBzdHJlYW0ucGVlaygpID09IFwiJFwiKSB7XG4gICAgICAgICAgcHVzaEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkludGVycG9sYXRpb247XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCAmJiAoIXRyaXBsZVF1b3RlZCB8fCBzdHJlYW0ubWF0Y2gocXVvdGUgKyBxdW90ZSkpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhcmF3ICYmICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0hlbHBlcjtcbiAgICByZXR1cm4gdG9rZW5TdHJpbmdIZWxwZXIoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkludGVycG9sYXRpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5lYXQoXCIkXCIpO1xuICAgIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgLy8gbGV0IGNsaWtlIGhhbmRsZSB0aGUgY29udGVudCBvZiAkey4uLn0sXG4gICAgICAvLyB3ZSB0YWtlIG92ZXIgYWdhaW4gd2hlbiBcIn1cIiBhcHBlYXJzIChzZWUgaG9va3MpLlxuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSW50ZXJwb2xhdGlvbklkZW50aWZpZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5JbnRlcnBvbGF0aW9uSWRlbnRpZmllcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuTmVzdGVkQ29tbWVudChkZXB0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoXG4gICAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIipcIiAmJiBzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGxcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoIC0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoICsgMSlcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiY29tbWVudFwiXG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcImFwcGxpY2F0aW9uL2RhcnRcIiwga2V5d29yZHMuY29uY2F0KGF0b21zKS5jb25jYXQoYnVpbHRpbnMpKTtcblxuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIGxvYWRpbmcgdGhyb3VnaCBtZXRhLmpzIHdvcmsuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImRhcnRcIiwgZnVuY3Rpb24oY29uZikge1xuICAgIHJldHVybiBDb2RlTWlycm9yLmdldE1vZGUoY29uZiwgXCJhcHBsaWNhdGlvbi9kYXJ0XCIpO1xuICB9LCBcImNsaWtlXCIpO1xufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwia2V5d29yZHMiLCJzcGxpdCIsImJsb2NrS2V5d29yZHMiLCJhdG9tcyIsImJ1aWx0aW5zIiwic2V0Iiwid29yZHMiLCJvYmoiLCJpIiwibGVuZ3RoIiwicHVzaEludGVycG9sYXRpb25TdGFjayIsInN0YXRlIiwiaW50ZXJwb2xhdGlvblN0YWNrIiwicHVzaCIsInRva2VuaXplIiwicG9wSW50ZXJwb2xhdGlvblN0YWNrIiwicG9wIiwic2l6ZUludGVycG9sYXRpb25TdGFjayIsImRlZmluZU1JTUUiLCJuYW1lIiwiYnVpbHRpbiIsImhvb2tzIiwic3RyZWFtIiwiZWF0V2hpbGUiLCJ0b2tlblN0cmluZyIsInBlZWsiLCJuZXh0IiwiX3N0cmVhbSIsImVhdCIsInRva2VuTmVzdGVkQ29tbWVudCIsInRva2VuIiwiXyIsInN0eWxlIiwiaXNVcHBlciIsIlJlZ0V4cCIsInRlc3QiLCJjdXJyZW50IiwicXVvdGUiLCJyYXciLCJ0cmlwbGVRdW90ZWQiLCJ0b2tlblN0cmluZ0hlbHBlciIsImVzY2FwZWQiLCJlb2wiLCJ0b2tlbkludGVycG9sYXRpb24iLCJtYXRjaCIsInRva2VuSW50ZXJwb2xhdGlvbklkZW50aWZpZXIiLCJkZXB0aCIsImNoIiwicmVnaXN0ZXJIZWxwZXIiLCJjb25jYXQiLCJkZWZpbmVNb2RlIiwiY29uZiIsImdldE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/dart/dart.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/dart/dart.js");
/******/ 	
/******/ })()
;