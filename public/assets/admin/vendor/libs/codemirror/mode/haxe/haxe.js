/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/haxe/haxe.js":
/*!*******************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/haxe/haxe.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haxe\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit; // Tokenizer\n\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n\n    var A = kw(\"keyword a\"),\n        B = kw(\"keyword b\"),\n        C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n        atom = {\n      type: \"atom\",\n      style: \"atom\"\n    },\n        attribute = {\n      type: \"attribute\",\n      style: \"attribute\"\n    };\n    var type = kw(\"typedef\");\n    var keywords = {\n      \"if\": A,\n      \"while\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"inline\": attribute,\n      \"static\": attribute,\n      \"using\": kw(\"import\"),\n      \"public\": attribute,\n      \"private\": attribute,\n      \"cast\": kw(\"cast\"),\n      \"import\": kw(\"import\"),\n      \"macro\": kw(\"macro\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"untyped\": kw(\"untyped\"),\n      \"callback\": kw(\"cb\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"never\": kw(\"property_access\"),\n      \"trace\": kw(\"trace\"),\n      \"class\": type,\n      \"abstract\": type,\n      \"enum\": type,\n      \"interface\": type,\n      \"typedef\": type,\n      \"extends\": type,\n      \"implements\": type,\n      \"dynamic\": type,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n\n    function toUnescaped(stream, end) {\n      var escaped = false,\n          next;\n\n      while ((next = stream.next()) != null) {\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n      }\n    } // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n\n\n    var type, content;\n\n    function ret(tp, style, cont) {\n      type = tp;\n      content = cont;\n      return style;\n    }\n\n    function haxeTokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\") {\n        return chain(stream, state, haxeTokenString(ch));\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return ret(\"number\", \"number\");\n      } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return ret(\"regexp\", \"string-2\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, haxeTokenComment);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret(\"operator\", null, stream.current());\n        }\n      } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n      } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return ret(\"metadata\", \"meta\");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      } else {\n        var word;\n\n        if (/[A-Z]/.test(ch)) {\n          stream.eatWhile(/[\\w_<>]/);\n          word = stream.current();\n          return ret(\"type\", \"variable-3\", word);\n        } else {\n          stream.eatWhile(/[\\w_]/);\n          var word = stream.current(),\n              known = keywords.propertyIsEnumerable(word) && keywords[word];\n          return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n        }\n      }\n    }\n\n    function haxeTokenString(quote) {\n      return function (stream, state) {\n        if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n\n    function haxeTokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = haxeTokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return ret(\"comment\", \"comment\");\n    } // Parser\n\n\n    var atomicTypes = {\n      \"atom\": true,\n      \"number\": true,\n      \"variable\": true,\n      \"string\": true,\n      \"regexp\": true\n    };\n\n    function HaxeLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) {\n        if (v.name == varname) return true;\n      }\n    }\n\n    function parseHaxe(state, style, type, content, stream) {\n      var cc = state.cc; // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n\n      cx.state = state;\n      cx.stream = stream;\n      cx.marked = null, cx.cc = cc;\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n      while (true) {\n        var combinator = cc.length ? cc.pop() : statement;\n\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) {\n            cc.pop()();\n          }\n\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n          return style;\n        }\n      }\n    }\n\n    function imported(state, typename) {\n      if (/[a-z]/.test(typename.charAt(0))) return false;\n      var len = state.importedtypes.length;\n\n      for (var i = 0; i < len; i++) {\n        if (state.importedtypes[i] == typename) return true;\n      }\n    }\n\n    function registerimport(importname) {\n      var state = cx.state;\n\n      for (var t = state.importedtypes; t; t = t.next) {\n        if (t.name == importname) return;\n      }\n\n      state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n      };\n    } // Combinator utils\n\n\n    var cx = {\n      state: null,\n      column: null,\n      marked: null,\n      cc: null\n    };\n\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) {\n        cx.cc.push(arguments[i]);\n      }\n    }\n\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) {\n        if (v.name == name) return true;\n      }\n\n      return false;\n    }\n\n    function register(varname) {\n      var state = cx.state;\n\n      if (state.context) {\n        cx.marked = \"def\";\n        if (inList(varname, state.localVars)) return;\n        state.localVars = {\n          name: varname,\n          next: state.localVars\n        };\n      } else if (state.globalVars) {\n        if (inList(varname, state.globalVars)) return;\n        state.globalVars = {\n          name: varname,\n          next: state.globalVars\n        };\n      }\n    } // Combinators\n\n\n    var defaultVars = {\n      name: \"this\",\n      next: null\n    };\n\n    function pushcontext() {\n      if (!cx.state.context) cx.state.localVars = defaultVars;\n      cx.state.context = {\n        prev: cx.state.context,\n        vars: cx.state.localVars\n      };\n    }\n\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n\n    popcontext.lex = true;\n\n    function pushlex(type, info) {\n      var result = function result() {\n        var state = cx.state;\n        state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n      };\n\n      result.lex = true;\n      return result;\n    }\n\n    function poplex() {\n      var state = cx.state;\n\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function f(type) {\n        if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n      }\n\n      return f;\n    }\n\n    function statement(type) {\n      if (type == \"@\") return cont(metadef);\n      if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n      if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n      if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n      if (type == \"import\") return cont(importdef, expect(\";\"));\n      if (type == \"typedef\") return cont(typedef);\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n\n    function expression(type) {\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n      if (type == \"type\") return cont(maybeoperator);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"keyword c\") return cont(maybeexpression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n      if (type == \"operator\") return cont(expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n      return cont();\n    }\n\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n\n    function maybeoperator(type, value) {\n      if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (type == \"operator\" || type == \":\") return cont(expression);\n      if (type == \";\") return;\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n      if (type == \".\") return cont(property, maybeoperator);\n      if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n    }\n\n    function maybeattribute(type) {\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"var\") return cont(vardef1);\n    }\n\n    function metadef(type) {\n      if (type == \":\") return cont(metadef);\n      if (type == \"variable\") return cont(metadef);\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n    }\n\n    function metaargs(type) {\n      if (type == \"variable\") return cont();\n    }\n\n    function importdef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n    }\n\n    function typedef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n        return cont();\n      }\n    }\n\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperator, expect(\";\"), poplex);\n    }\n\n    function property(type) {\n      if (type == \"variable\") {\n        cx.marked = \"property\";\n        return cont();\n      }\n    }\n\n    function objprop(type) {\n      if (type == \"variable\") cx.marked = \"property\";\n      if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n    }\n\n    function commasep(what, end) {\n      function proceed(type) {\n        if (type == \",\") return cont(what, proceed);\n        if (type == end) return cont();\n        return cont(expect(end));\n      }\n\n      return function (type) {\n        if (type == end) return cont();else return pass(what, proceed);\n      };\n    }\n\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n\n    function vardef1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse, vardef2);\n      }\n\n      return cont();\n    }\n\n    function vardef2(type, value) {\n      if (value == \"=\") return cont(expression, vardef2);\n      if (type == \",\") return cont(vardef1);\n    }\n\n    function forspec1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(forin, expression);\n      } else {\n        return pass();\n      }\n    }\n\n    function forin(_type, value) {\n      if (value == \"in\") return cont();\n    }\n\n    function functiondef(type, value) {\n      //function names starting with upper-case letters are recognised as types, so cludging them together here.\n      if (type == \"variable\" || type == \"type\") {\n        register(value);\n        return cont(functiondef);\n      }\n\n      if (value == \"new\") return cont(functiondef);\n      if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n    }\n\n    function typeuse(type) {\n      if (type == \":\") return cont(typestring);\n    }\n\n    function typestring(type) {\n      if (type == \"type\") return cont();\n      if (type == \"variable\") return cont();\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n    }\n\n    function typeprop(type) {\n      if (type == \"variable\") return cont(typeuse);\n    }\n\n    function funarg(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse);\n      }\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n        var state = {\n          tokenize: haxeTokenBase,\n          reAllowed: true,\n          kwAllowed: true,\n          cc: [],\n          lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          importedtypes: defaulttypes,\n          context: parserConfig.localVars && {\n            vars: parserConfig.localVars\n          },\n          indented: 0\n        };\n        if (parserConfig.globalVars && _typeof(parserConfig.globalVars) == \"object\") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n          state.indented = stream.indentation();\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = type != '.';\n        return parseHaxe(state, style, type, content, stream);\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type,\n            closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n  CodeMirror.defineMode(\"hxml\", function () {\n    return {\n      startState: function startState() {\n        return {\n          define: false,\n          inString: false\n        };\n      },\n      token: function token(stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol(); ///* comments */\n\n        if (ch == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        if (sol && ch == \"-\") {\n          var style = \"variable-2\";\n          stream.eat(/-/);\n\n          if (stream.peek() == \"-\") {\n            stream.eat(/-/);\n            style = \"keyword a\";\n          }\n\n          if (stream.peek() == \"D\") {\n            stream.eat(/[D]/);\n            style = \"keyword c\";\n            state.define = true;\n          }\n\n          stream.eatWhile(/[A-Z]/i);\n          return style;\n        }\n\n        var ch = stream.peek();\n\n        if (state.inString == false && ch == \"'\") {\n          state.inString = true;\n          stream.next();\n        }\n\n        if (state.inString == true) {\n          if (stream.skipTo(\"'\")) {} else {\n            stream.skipToEnd();\n          }\n\n          if (stream.peek() == \"'\") {\n            stream.next();\n            state.inString = false;\n          }\n\n          return \"string\";\n        }\n\n        stream.next();\n        return null;\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9oYXhlL2hheGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBLENBQUMsVUFBU0EsR0FBVCxFQUFjO0VBQ2IsSUFBSSxzQkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QixzQkFBT0MsTUFBUCxNQUFpQixRQUFuRCxFQUE2RDtJQUMzREYsR0FBRyxDQUFDRyxtQkFBTyxDQUFDLG1KQUFELENBQVIsQ0FBSCxDQURGLEtBRUssSUFBSSxJQUFKLEVBQStDO0lBQ2xEQyxpQ0FBTyxDQUFDLG1KQUFELENBQUQsb0NBQTJCSixHQUEzQjtBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURHLEtBRUE7SUFDSEEsRUFBQTtBQUNILENBUEQsRUFPRyxVQUFTTSxVQUFULEVBQXFCO0VBQ3hCOztFQUVBQSxVQUFVLENBQUNDLFVBQVgsQ0FBc0IsTUFBdEIsRUFBOEIsVUFBU0MsTUFBVCxFQUFpQkMsWUFBakIsRUFBK0I7SUFDM0QsSUFBSUMsVUFBVSxHQUFHRixNQUFNLENBQUNFLFVBQXhCLENBRDJELENBRzNEOztJQUVBLFNBQVNDLEVBQVQsQ0FBWUMsSUFBWixFQUFrQjtNQUFDLE9BQU87UUFBQ0EsSUFBSSxFQUFFQSxJQUFQO1FBQWFDLEtBQUssRUFBRTtNQUFwQixDQUFQO0lBQXVDOztJQUMxRCxJQUFJQyxDQUFDLEdBQUdILEVBQUUsQ0FBQyxXQUFELENBQVY7SUFBQSxJQUF5QkksQ0FBQyxHQUFHSixFQUFFLENBQUMsV0FBRCxDQUEvQjtJQUFBLElBQThDSyxDQUFDLEdBQUdMLEVBQUUsQ0FBQyxXQUFELENBQXBEO0lBQ0EsSUFBSU0sUUFBUSxHQUFHTixFQUFFLENBQUMsVUFBRCxDQUFqQjtJQUFBLElBQStCTyxJQUFJLEdBQUc7TUFBQ04sSUFBSSxFQUFFLE1BQVA7TUFBZUMsS0FBSyxFQUFFO0lBQXRCLENBQXRDO0lBQUEsSUFBcUVNLFNBQVMsR0FBRztNQUFDUCxJQUFJ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QU0sQ0FBQ08sSUFBUDtRQUNEOztRQUVELElBQUlOLEtBQUssQ0FBQ3dILFFBQU4sSUFBa0IsSUFBdEIsRUFBNEI7VUFDMUIsSUFBSXpILE1BQU0sQ0FBQzJILE1BQVAsQ0FBYyxHQUFkLENBQUosRUFBd0IsQ0FFdkIsQ0FGRCxNQUVPO1lBQ0wzSCxNQUFNLENBQUNxQixTQUFQO1VBQ0Q7O1VBRUQsSUFBSXJCLE1BQU0sQ0FBQzBILElBQVAsTUFBaUIsR0FBckIsRUFBMEI7WUFDeEIxSCxNQUFNLENBQUNPLElBQVA7WUFDQU4sS0FBSyxDQUFDd0gsUUFBTixHQUFpQixLQUFqQjtVQUNEOztVQUVELE9BQU8sUUFBUDtRQUNEOztRQUVEekgsTUFBTSxDQUFDTyxJQUFQO1FBQ0EsT0FBTyxJQUFQO01BQ0QsQ0E1REk7TUE2RExnSCxXQUFXLEVBQUU7SUE3RFIsQ0FBUDtFQStERCxDQWpFRDtFQW1FQXhJLFVBQVUsQ0FBQ3lJLFVBQVgsQ0FBc0IsYUFBdEIsRUFBcUMsTUFBckM7QUFFQyxDQS9mRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9tb2RlL2hheGUvaGF4ZS5qcz9hNGJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiaGF4ZVwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0O1xuXG4gIC8vIFRva2VuaXplclxuXG4gIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICB2YXIgQSA9IGt3KFwia2V5d29yZCBhXCIpLCBCID0ga3coXCJrZXl3b3JkIGJcIiksIEMgPSBrdyhcImtleXdvcmQgY1wiKTtcbiAgdmFyIG9wZXJhdG9yID0ga3coXCJvcGVyYXRvclwiKSwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifSwgYXR0cmlidXRlID0ge3R5cGU6XCJhdHRyaWJ1dGVcIiwgc3R5bGU6IFwiYXR0cmlidXRlXCJ9O1xuICB2YXIgdHlwZSA9IGt3KFwidHlwZWRlZlwiKTtcbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIFwiaWZcIjogQSwgXCJ3aGlsZVwiOiBBLCBcImVsc2VcIjogQiwgXCJkb1wiOiBCLCBcInRyeVwiOiBCLFxuICAgIFwicmV0dXJuXCI6IEMsIFwiYnJlYWtcIjogQywgXCJjb250aW51ZVwiOiBDLCBcIm5ld1wiOiBDLCBcInRocm93XCI6IEMsXG4gICAgXCJ2YXJcIjoga3coXCJ2YXJcIiksIFwiaW5saW5lXCI6YXR0cmlidXRlLCBcInN0YXRpY1wiOiBhdHRyaWJ1dGUsIFwidXNpbmdcIjprdyhcImltcG9ydFwiKSxcbiAgICBcInB1YmxpY1wiOiBhdHRyaWJ1dGUsIFwicHJpdmF0ZVwiOiBhdHRyaWJ1dGUsIFwiY2FzdFwiOiBrdyhcImNhc3RcIiksIFwiaW1wb3J0XCI6IGt3KFwiaW1wb3J0XCIpLCBcIm1hY3JvXCI6IGt3KFwibWFjcm9cIiksXG4gICAgXCJmdW5jdGlvblwiOiBrdyhcImZ1bmN0aW9uXCIpLCBcImNhdGNoXCI6IGt3KFwiY2F0Y2hcIiksIFwidW50eXBlZFwiOiBrdyhcInVudHlwZWRcIiksIFwiY2FsbGJhY2tcIjoga3coXCJjYlwiKSxcbiAgICBcImZvclwiOiBrdyhcImZvclwiKSwgXCJzd2l0Y2hcIjoga3coXCJzd2l0Y2hcIiksIFwiY2FzZVwiOiBrdyhcImNhc2VcIiksIFwiZGVmYXVsdFwiOiBrdyhcImRlZmF1bHRcIiksXG4gICAgXCJpblwiOiBvcGVyYXRvciwgXCJuZXZlclwiOiBrdyhcInByb3BlcnR5X2FjY2Vzc1wiKSwgXCJ0cmFjZVwiOmt3KFwidHJhY2VcIiksXG4gICAgXCJjbGFzc1wiOiB0eXBlLCBcImFic3RyYWN0XCI6dHlwZSwgXCJlbnVtXCI6dHlwZSwgXCJpbnRlcmZhY2VcIjp0eXBlLCBcInR5cGVkZWZcIjp0eXBlLCBcImV4dGVuZHNcIjp0eXBlLCBcImltcGxlbWVudHNcIjp0eXBlLCBcImR5bmFtaWNcIjp0eXBlLFxuICAgIFwidHJ1ZVwiOiBhdG9tLCBcImZhbHNlXCI6IGF0b20sIFwibnVsbFwiOiBhdG9tXG4gIH07XG5cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT98XS87XG5cbiAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvVW5lc2NhcGVkKHN0cmVhbSwgZW5kKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobmV4dCA9PSBlbmQgJiYgIWVzY2FwZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAvLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbiAgdmFyIHR5cGUsIGNvbnRlbnQ7XG4gIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhheGVUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCBoYXhlVG9rZW5TdHJpbmcoY2gpKTtcbiAgICB9IGVsc2UgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICByZXR1cm4gcmV0KGNoKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiMFwiICYmIHN0cmVhbS5lYXQoL3gvaSkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSk7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgfHwgY2ggPT0gXCItXCIgJiYgc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKD8hXFwuKSk/KD86W2VFXVsrXFwtXT9cXGQrKT8vKTtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5yZUFsbG93ZWQgJiYgKGNoID09IFwiflwiICYmIHN0cmVhbS5lYXQoL1xcLy8pKSkge1xuICAgICAgdG9VbmVzY2FwZWQoc3RyZWFtLCBcIi9cIik7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tnaW1zdV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIGhheGVUb2tlbkNvbW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBudWxsLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIHJldChcImNvbmRpdGlvbmFsXCIsIFwibWV0YVwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiQFwiKSB7XG4gICAgICBzdHJlYW0uZWF0KC86Lyk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICAgICAgcmV0dXJuIHJldCAoXCJtZXRhZGF0YVwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBudWxsLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdvcmQ7XG4gICAgICBpZigvW0EtWl0vLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd188Pl0vKTtcbiAgICAgICAgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiByZXQoXCJ0eXBlXCIsIFwidmFyaWFibGUtM1wiLCB3b3JkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19dLyk7XG4gICAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKSwga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJiBrZXl3b3Jkc1t3b3JkXTtcbiAgICAgICAgcmV0dXJuIChrbm93biAmJiBzdGF0ZS5rd0FsbG93ZWQpID8gcmV0KGtub3duLnR5cGUsIGtub3duLnN0eWxlLCB3b3JkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgIHJldChcInZhcmlhYmxlXCIsIFwidmFyaWFibGVcIiwgd29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGF4ZVRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0b1VuZXNjYXBlZChzdHJlYW0sIHF1b3RlKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBoYXhlVG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIHJldChcInN0cmluZ1wiLCBcInN0cmluZ1wiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGF4ZVRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGhheGVUb2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICB2YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSwgXCJyZWdleHBcIjogdHJ1ZX07XG5cbiAgZnVuY3Rpb24gSGF4ZUxleGljYWwoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYsIGluZm8pIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgaWYgKGFsaWduICE9IG51bGwpIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluU2NvcGUoc3RhdGUsIHZhcm5hbWUpIHtcbiAgICBmb3IgKHZhciB2ID0gc3RhdGUubG9jYWxWYXJzOyB2OyB2ID0gdi5uZXh0KVxuICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSkge1xuICAgIHZhciBjYyA9IHN0YXRlLmNjO1xuICAgIC8vIENvbW11bmljYXRlIG91ciBjb250ZXh0IHRvIHRoZSBjb21iaW5hdG9ycy5cbiAgICAvLyAoTGVzcyB3YXN0ZWZ1bCB0aGFuIGNvbnNpbmcgdXAgYSBodW5kcmVkIGNsb3N1cmVzIG9uIGV2ZXJ5IGNhbGwuKVxuICAgIGN4LnN0YXRlID0gc3RhdGU7IGN4LnN0cmVhbSA9IHN0cmVhbTsgY3gubWFya2VkID0gbnVsbCwgY3guY2MgPSBjYztcblxuICAgIGlmICghc3RhdGUubGV4aWNhbC5oYXNPd25Qcm9wZXJ0eShcImFsaWduXCIpKVxuICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IHRydWU7XG5cbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB2YXIgY29tYmluYXRvciA9IGNjLmxlbmd0aCA/IGNjLnBvcCgpIDogc3RhdGVtZW50O1xuICAgICAgaWYgKGNvbWJpbmF0b3IodHlwZSwgY29udGVudCkpIHtcbiAgICAgICAgd2hpbGUoY2MubGVuZ3RoICYmIGNjW2NjLmxlbmd0aCAtIDFdLmxleClcbiAgICAgICAgICBjYy5wb3AoKSgpO1xuICAgICAgICBpZiAoY3gubWFya2VkKSByZXR1cm4gY3gubWFya2VkO1xuICAgICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgaW5TY29wZShzdGF0ZSwgY29udGVudCkpIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGltcG9ydGVkKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW1wb3J0ZWQoc3RhdGUsIHR5cGVuYW1lKSB7XG4gICAgaWYgKC9bYS16XS8udGVzdCh0eXBlbmFtZS5jaGFyQXQoMCkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5pbXBvcnRlZHR5cGVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaTxsZW47IGkrKylcbiAgICAgIGlmKHN0YXRlLmltcG9ydGVkdHlwZXNbaV09PXR5cGVuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyaW1wb3J0KGltcG9ydG5hbWUpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBmb3IgKHZhciB0ID0gc3RhdGUuaW1wb3J0ZWR0eXBlczsgdDsgdCA9IHQubmV4dClcbiAgICAgIGlmKHQubmFtZSA9PSBpbXBvcnRuYW1lKSByZXR1cm47XG4gICAgc3RhdGUuaW1wb3J0ZWR0eXBlcyA9IHsgbmFtZTogaW1wb3J0bmFtZSwgbmV4dDogc3RhdGUuaW1wb3J0ZWR0eXBlcyB9O1xuICB9XG4gIC8vIENvbWJpbmF0b3IgdXRpbHNcblxuICB2YXIgY3ggPSB7c3RhdGU6IG51bGwsIGNvbHVtbjogbnVsbCwgbWFya2VkOiBudWxsLCBjYzogbnVsbH07XG4gIGZ1bmN0aW9uIHBhc3MoKSB7XG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY3guY2MucHVzaChhcmd1bWVudHNbaV0pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnQoKSB7XG4gICAgcGFzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGluTGlzdChuYW1lLCBsaXN0KSB7XG4gICAgZm9yICh2YXIgdiA9IGxpc3Q7IHY7IHYgPSB2Lm5leHQpXG4gICAgICBpZiAodi5uYW1lID09IG5hbWUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwiZGVmXCI7XG4gICAgICBpZiAoaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmxvY2FsVmFycykpIHJldHVybjtcbiAgICAgIHN0YXRlLmxvY2FsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5sb2NhbFZhcnN9O1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZ2xvYmFsVmFycykge1xuICAgICAgaWYgKGluTGlzdCh2YXJuYW1lLCBzdGF0ZS5nbG9iYWxWYXJzKSkgcmV0dXJuO1xuICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5nbG9iYWxWYXJzfTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21iaW5hdG9yc1xuXG4gIHZhciBkZWZhdWx0VmFycyA9IHtuYW1lOiBcInRoaXNcIiwgbmV4dDogbnVsbH07XG4gIGZ1bmN0aW9uIHB1c2hjb250ZXh0KCkge1xuICAgIGlmICghY3guc3RhdGUuY29udGV4dCkgY3guc3RhdGUubG9jYWxWYXJzID0gZGVmYXVsdFZhcnM7XG4gICAgY3guc3RhdGUuY29udGV4dCA9IHtwcmV2OiBjeC5zdGF0ZS5jb250ZXh0LCB2YXJzOiBjeC5zdGF0ZS5sb2NhbFZhcnN9O1xuICB9XG4gIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzO1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBjeC5zdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cbiAgcG9wY29udGV4dC5sZXggPSB0cnVlO1xuICBmdW5jdGlvbiBwdXNobGV4KHR5cGUsIGluZm8pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICAgIHN0YXRlLmxleGljYWwgPSBuZXcgSGF4ZUxleGljYWwoc3RhdGUuaW5kZW50ZWQsIGN4LnN0cmVhbS5jb2x1bW4oKSwgdHlwZSwgbnVsbCwgc3RhdGUubGV4aWNhbCwgaW5mbyk7XG4gICAgfTtcbiAgICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC5wcmV2KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gc3RhdGUubGV4aWNhbC5wcmV2O1xuICAgIH1cbiAgfVxuICBwb3BsZXgubGV4ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gICAgZnVuY3Rpb24gZih0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSB3YW50ZWQpIHJldHVybiBjb250KCk7XG4gICAgICBlbHNlIGlmICh3YW50ZWQgPT0gXCI7XCIpIHJldHVybiBwYXNzKCk7XG4gICAgICBlbHNlIHJldHVybiBjb250KGYpO1xuICAgIH1cbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJAXCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICAgIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ2YXJkZWZcIiksIHZhcmRlZjEsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGFcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgcHVzaGNvbnRleHQsIGJsb2NrLCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udCgpO1xuICAgIGlmICh0eXBlID09IFwiYXR0cmlidXRlXCIpIHJldHVybiBjb250KG1heWJlYXR0cmlidXRlKTtcbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcImZvclwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwZWN0KFwiKFwiKSwgcHVzaGxleChcIilcIiksIGZvcnNwZWMxLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BsZXgsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWxhYmVsKTtcbiAgICBpZiAodHlwZSA9PSBcInN3aXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgcHVzaGxleChcIn1cIiwgXCJzd2l0Y2hcIiksIGV4cGVjdChcIntcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLCBwb3BsZXgsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJjYXNlXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiZGVmYXVsdFwiKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcImNhdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgZXhwZWN0KFwiKFwiKSwgZnVuYXJnLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcImltcG9ydFwiKSByZXR1cm4gY29udChpbXBvcnRkZWYsIGV4cGVjdChcIjtcIikpO1xuICAgIGlmICh0eXBlID09IFwidHlwZWRlZlwiKSByZXR1cm4gY29udCh0eXBlZGVmKTtcbiAgICByZXR1cm4gcGFzcyhwdXNobGV4KFwic3RhdFwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uKHR5cGUpIHtcbiAgICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KG1heWJlb3BlcmF0b3IpO1xuICAgIGlmICh0eXBlID09IFwidHlwZVwiICkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGNcIikgcmV0dXJuIGNvbnQobWF5YmVleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgY29tbWFzZXAobWF5YmVleHByZXNzaW9uLCBcIl1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBjb21tYXNlcChvYmpwcm9wLCBcIn1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZWV4cHJlc3Npb24odHlwZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbik7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZW9wZXJhdG9yKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiICYmIC9cXCtcXCt8LS0vLnRlc3QodmFsdWUpKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGNvbW1hc2VwKGV4cHJlc3Npb24sIFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgICBpZiAodHlwZSA9PSBcIi5cIikgcmV0dXJuIGNvbnQocHJvcGVydHksIG1heWJlb3BlcmF0b3IpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlYXR0cmlidXRlKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcImF0dHJpYnV0ZVwiKSByZXR1cm4gY29udChtYXliZWF0dHJpYnV0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQodmFyZGVmMSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRhZGVmKHR5cGUpIHtcbiAgICBpZih0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChtZXRhZGVmKTtcbiAgICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gICAgaWYodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGNvbW1hc2VwKG1ldGFhcmdzLCBcIilcIiksIHBvcGxleCwgc3RhdGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBtZXRhYXJncyh0eXBlKSB7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbXBvcnRkZWYgKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgL1tBLVpdLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHsgcmVnaXN0ZXJpbXBvcnQodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gICAgZWxzZSBpZih0eXBlID09IFwidmFyaWFibGVcIiB8fCB0eXBlID09IFwicHJvcGVydHlcIiB8fCB0eXBlID09IFwiLlwiIHx8IHZhbHVlID09IFwiKlwiKSByZXR1cm4gY29udChpbXBvcnRkZWYpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHlwZWRlZiAodHlwZSwgdmFsdWUpXG4gIHtcbiAgICBpZih0eXBlID09IFwidmFyaWFibGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZWdpc3RlcmltcG9ydCh2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09IFwidHlwZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJldHVybiBjb250KCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gICAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvciwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wZXJ0eSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7Y3gubWFya2VkID0gXCJwcm9wZXJ0eVwiOyByZXR1cm4gY29udCgpO31cbiAgfVxuICBmdW5jdGlvbiBvYmpwcm9wKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbW1hc2VwKHdoYXQsIGVuZCkge1xuICAgIGZ1bmN0aW9uIHByb2NlZWQodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KHdoYXQsIHByb2NlZWQpO1xuICAgICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgZWxzZSByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJsb2NrKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiB2YXJkZWYxKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKXtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KHR5cGV1c2UsIHZhcmRlZjIpO31cbiAgICByZXR1cm4gY29udCgpO1xuICB9XG4gIGZ1bmN0aW9uIHZhcmRlZjIodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI9XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIHZhcmRlZjIpO1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYxKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjMSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgcmVnaXN0ZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGNvbnQoZm9yaW4sIGV4cHJlc3Npb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXNzKClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZm9yaW4oX3R5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiaW5cIikgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbmRlZih0eXBlLCB2YWx1ZSkge1xuICAgIC8vZnVuY3Rpb24gbmFtZXMgc3RhcnRpbmcgd2l0aCB1cHBlci1jYXNlIGxldHRlcnMgYXJlIHJlY29nbmlzZWQgYXMgdHlwZXMsIHNvIGNsdWRnaW5nIHRoZW0gdG9nZXRoZXIgaGVyZS5cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdHlwZSA9PSBcInR5cGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO31cbiAgICBpZiAodmFsdWUgPT0gXCJuZXdcIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgcHVzaGNvbnRleHQsIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIHR5cGV1c2UsIHN0YXRlbWVudCwgcG9wY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gdHlwZXVzZSh0eXBlKSB7XG4gICAgaWYodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZXN0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gdHlwZXN0cmluZyh0eXBlKSB7XG4gICAgaWYodHlwZSA9PSBcInR5cGVcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZih0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY29tbWFzZXAodHlwZXByb3AsIFwifVwiKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiB0eXBlcHJvcCh0eXBlKSB7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHR5cGV1c2UpO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmFyZyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQodHlwZXVzZSk7fVxuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgdmFyIGRlZmF1bHR0eXBlcyA9IFtcIkludFwiLCBcIkZsb2F0XCIsIFwiU3RyaW5nXCIsIFwiVm9pZFwiLCBcIlN0ZFwiLCBcIkJvb2xcIiwgXCJEeW5hbWljXCIsIFwiQXJyYXlcIl07XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHRva2VuaXplOiBoYXhlVG9rZW5CYXNlLFxuICAgICAgICByZUFsbG93ZWQ6IHRydWUsXG4gICAgICAgIGt3QWxsb3dlZDogdHJ1ZSxcbiAgICAgICAgY2M6IFtdLFxuICAgICAgICBsZXhpY2FsOiBuZXcgSGF4ZUxleGljYWwoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcImJsb2NrXCIsIGZhbHNlKSxcbiAgICAgICAgbG9jYWxWYXJzOiBwYXJzZXJDb25maWcubG9jYWxWYXJzLFxuICAgICAgICBpbXBvcnRlZHR5cGVzOiBkZWZhdWx0dHlwZXMsXG4gICAgICAgIGNvbnRleHQ6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMgJiYge3ZhcnM6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnN9LFxuICAgICAgICBpbmRlbnRlZDogMFxuICAgICAgfTtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZ2xvYmFsVmFycyAmJiB0eXBlb2YgcGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgc3RhdGUucmVBbGxvd2VkID0gISEodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcImtleXdvcmQgY1wiIHx8IHR5cGUubWF0Y2goL15bXFxbe31cXCgsOzpdJC8pKTtcbiAgICAgIHN0YXRlLmt3QWxsb3dlZCA9IHR5cGUgIT0gJy4nO1xuICAgICAgcmV0dXJuIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IGhheGVUb2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbDtcbiAgICAgIGlmIChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTtcbiAgICAgIGlmICh0eXBlID09IFwidmFyZGVmXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgNDtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJzdGF0XCIgfHwgdHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSBpZiAobGV4aWNhbC5pbmZvID09IFwic3dpdGNoXCIgJiYgIWNsb3NpbmcpXG4gICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gaW5kZW50VW5pdCA6IDIgKiBpbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuYWxpZ24pIHJldHVybiBsZXhpY2FsLmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCIsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWhheGVcIiwgXCJoYXhlXCIpO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJoeG1sXCIsIGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZmluZTogZmFsc2UsXG4gICAgICAgIGluU3RyaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG5cbiAgICAgIC8vLyogY29tbWVudHMgKi9cbiAgICAgIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzb2wgJiYgY2ggPT0gXCItXCIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gXCJ2YXJpYWJsZS0yXCI7XG5cbiAgICAgICAgc3RyZWFtLmVhdCgvLS8pO1xuXG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiLVwiKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdCgvLS8pO1xuICAgICAgICAgIHN0eWxlID0gXCJrZXl3b3JkIGFcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiRFwiKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdCgvW0RdLyk7XG4gICAgICAgICAgc3R5bGUgPSBcImtleXdvcmQgY1wiO1xuICAgICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tBLVpdL2kpO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAgIGlmIChzdGF0ZS5pblN0cmluZyA9PSBmYWxzZSAmJiBjaCA9PSBcIidcIikge1xuICAgICAgICBzdGF0ZS5pblN0cmluZyA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5pblN0cmluZyA9PSB0cnVlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uc2tpcFRvKFwiJ1wiKSkge1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHN0YXRlLmluU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWh4bWxcIiwgXCJoeG1sXCIpO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVNb2RlIiwiY29uZmlnIiwicGFyc2VyQ29uZmlnIiwiaW5kZW50VW5pdCIsImt3IiwidHlwZSIsInN0eWxlIiwiQSIsIkIiLCJDIiwib3BlcmF0b3IiLCJhdG9tIiwiYXR0cmlidXRlIiwia2V5d29yZHMiLCJpc09wZXJhdG9yQ2hhciIsImNoYWluIiwic3RyZWFtIiwic3RhdGUiLCJmIiwidG9rZW5pemUiLCJ0b1VuZXNjYXBlZCIsImVuZCIsImVzY2FwZWQiLCJuZXh0IiwiY29udGVudCIsInJldCIsInRwIiwiY29udCIsImhheGVUb2tlbkJhc2UiLCJjaCIsImhheGVUb2tlblN0cmluZyIsInRlc3QiLCJlYXQiLCJlYXRXaGlsZSIsIm1hdGNoIiwicmVBbGxvd2VkIiwiaGF4ZVRva2VuQ29tbWVudCIsInNraXBUb0VuZCIsImN1cnJlbnQiLCJ3b3JkIiwia25vd24iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImt3QWxsb3dlZCIsInF1b3RlIiwibWF5YmVFbmQiLCJhdG9taWNUeXBlcyIsIkhheGVMZXhpY2FsIiwiaW5kZW50ZWQiLCJjb2x1bW4iLCJhbGlnbiIsInByZXYiLCJpbmZvIiwiaW5TY29wZSIsInZhcm5hbWUiLCJ2IiwibG9jYWxWYXJzIiwibmFtZSIsInBhcnNlSGF4ZSIsImNjIiwiY3giLCJtYXJrZWQiLCJsZXhpY2FsIiwiaGFzT3duUHJvcGVydHkiLCJjb21iaW5hdG9yIiwibGVuZ3RoIiwicG9wIiwic3RhdGVtZW50IiwibGV4IiwiaW1wb3J0ZWQiLCJ0eXBlbmFtZSIsImNoYXJBdCIsImxlbiIsImltcG9ydGVkdHlwZXMiLCJpIiwicmVnaXN0ZXJpbXBvcnQiLCJpbXBvcnRuYW1lIiwidCIsInBhc3MiLCJhcmd1bWVudHMiLCJwdXNoIiwiYXBwbHkiLCJpbkxpc3QiLCJsaXN0IiwicmVnaXN0ZXIiLCJjb250ZXh0IiwiZ2xvYmFsVmFycyIsImRlZmF1bHRWYXJzIiwicHVzaGNvbnRleHQiLCJ2YXJzIiwicG9wY29udGV4dCIsInB1c2hsZXgiLCJyZXN1bHQiLCJwb3BsZXgiLCJleHBlY3QiLCJ3YW50ZWQiLCJtZXRhZGVmIiwidmFyZGVmMSIsImV4cHJlc3Npb24iLCJibG9jayIsIm1heWJlYXR0cmlidXRlIiwiZnVuY3Rpb25kZWYiLCJmb3JzcGVjMSIsIm1heWJlbGFiZWwiLCJmdW5hcmciLCJpbXBvcnRkZWYiLCJ0eXBlZGVmIiwibWF5YmVvcGVyYXRvciIsIm1heWJlZXhwcmVzc2lvbiIsImNvbW1hc2VwIiwib2JqcHJvcCIsInZhbHVlIiwicHJvcGVydHkiLCJtZXRhYXJncyIsIndoYXQiLCJwcm9jZWVkIiwidHlwZXVzZSIsInZhcmRlZjIiLCJmb3JpbiIsIl90eXBlIiwidHlwZXN0cmluZyIsInR5cGVwcm9wIiwic3RhcnRTdGF0ZSIsImJhc2Vjb2x1bW4iLCJkZWZhdWx0dHlwZXMiLCJ0b2tlbiIsInNvbCIsImluZGVudGF0aW9uIiwiZWF0U3BhY2UiLCJpbmRlbnQiLCJ0ZXh0QWZ0ZXIiLCJmaXJzdENoYXIiLCJjbG9zaW5nIiwiZWxlY3RyaWNDaGFycyIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwibGluZUNvbW1lbnQiLCJkZWZpbmVNSU1FIiwiaW5TdHJpbmciLCJwZWVrIiwic2tpcFRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/haxe/haxe.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/haxe/haxe.js");
/******/ 	
/******/ })()
;