/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/xquery/xquery.js":
/*!***********************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/xquery/xquery.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"xquery\", function () {\n    // The keywords object is set to the result of this self executing\n    // function. Each keyword is a property of the keywords object whose\n    // value is {type: atype, style: astyle}\n    var keywords = function () {\n      // convenience functions used to build keywords object\n      function kw(type) {\n        return {\n          type: type,\n          style: \"keyword\"\n        };\n      }\n\n      var operator = kw(\"operator\"),\n          atom = {\n        type: \"atom\",\n        style: \"atom\"\n      },\n          punctuation = {\n        type: \"punctuation\",\n        style: null\n      },\n          qualifier = {\n        type: \"axis_specifier\",\n        style: \"qualifier\"\n      }; // kwObj is what is return from this function at the end\n\n      var kwObj = {\n        ',': punctuation\n      }; // a list of 'basic' keywords. For each add a property to kwObj with the value of\n      // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n\n      var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n\n      for (var i = 0, l = basic.length; i < l; i++) {\n        kwObj[basic[i]] = kw(basic[i]);\n      }\n\n      ; // a list of types. For each add a property to kwObj with the value of\n      // {type: \"atom\", style: \"atom\"}\n\n      var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n\n      for (var i = 0, l = types.length; i < l; i++) {\n        kwObj[types[i]] = atom;\n      }\n\n      ; // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n\n      var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n\n      for (var i = 0, l = operators.length; i < l; i++) {\n        kwObj[operators[i]] = operator;\n      }\n\n      ; // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n\n      var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n\n      for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n        kwObj[axis_specifiers[i]] = qualifier;\n      }\n\n      ;\n      return kwObj;\n    }();\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    } // the primary mode tokenizer\n\n\n    function tokenBase(stream, state) {\n      var ch = stream.next(),\n          mightBeFunction = false,\n          isEQName = isEQNameAhead(stream); // an XML tag (if not in some sub, chained tokenizer)\n\n      if (ch == \"<\") {\n        if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n\n        if (stream.match(\"![CDATA\", false)) {\n          state.tokenize = tokenCDATA;\n          return \"tag\";\n        }\n\n        if (stream.match(\"?\", false)) {\n          return chain(stream, state, tokenPreProcessing);\n        }\n\n        var isclose = stream.eat(\"/\");\n        stream.eatSpace();\n        var tagName = \"\",\n            c;\n\n        while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) {\n          tagName += c;\n        }\n\n        return chain(stream, state, tokenTag(tagName, isclose));\n      } // start code block\n      else if (ch == \"{\") {\n        pushStateStack(state, {\n          type: \"codeblock\"\n        });\n        return null;\n      } // end code block\n      else if (ch == \"}\") {\n        popStateStack(state);\n        return null;\n      } // if we're in an XML block\n      else if (isInXmlBlock(state)) {\n        if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n          popStateStack(state);\n          return \"tag\";\n        } else return \"variable\";\n      } // if a number\n      else if (/\\d/.test(ch)) {\n        stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n        return \"atom\";\n      } // comment start\n      else if (ch === \"(\" && stream.eat(\":\")) {\n        pushStateStack(state, {\n          type: \"comment\"\n        });\n        return chain(stream, state, tokenComment);\n      } // quoted string\n      else if (!isEQName && (ch === '\"' || ch === \"'\")) return chain(stream, state, tokenString(ch)); // variable\n      else if (ch === \"$\") {\n        return chain(stream, state, tokenVariable);\n      } // assignment\n      else if (ch === \":\" && stream.eat(\"=\")) {\n        return \"keyword\";\n      } // open paren\n      else if (ch === \"(\") {\n        pushStateStack(state, {\n          type: \"paren\"\n        });\n        return null;\n      } // close paren\n      else if (ch === \")\") {\n        popStateStack(state);\n        return null;\n      } // open paren\n      else if (ch === \"[\") {\n        pushStateStack(state, {\n          type: \"bracket\"\n        });\n        return null;\n      } // close paren\n      else if (ch === \"]\") {\n        popStateStack(state);\n        return null;\n      } else {\n        var known = keywords.propertyIsEnumerable(ch) && keywords[ch]; // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n\n        if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n        if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {} // gobble up a word if the character is not known\n\n        if (!known) stream.eatWhile(/[\\w\\$_-]/); // gobble a colon in the case that is a lib func type call fn:doc\n\n        var foundColon = stream.eat(\":\"); // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n        // which should get matched as a keyword\n\n        if (!stream.eat(\":\") && foundColon) {\n          stream.eatWhile(/[\\w\\$_-]/);\n        } // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n\n\n        if (stream.match(/^[ \\t]*\\(/, false)) {\n          mightBeFunction = true;\n        } // is the word a keyword?\n\n\n        var word = stream.current();\n        known = keywords.propertyIsEnumerable(word) && keywords[word]; // if we think it's a function call but not yet known,\n        // set style to variable for now for lack of something better\n\n        if (mightBeFunction && !known) known = {\n          type: \"function_call\",\n          style: \"variable def\"\n        }; // if the previous word was element, attribute, axis specifier, this word should be the name of that\n\n        if (isInXmlConstructor(state)) {\n          popStateStack(state);\n          return \"variable\";\n        } // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n        // push the stack so we know to look for it on the next word\n\n\n        if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n          type: \"xmlconstructor\"\n        }); // if the word is known, return the details of that else just call this a generic 'word'\n\n        return known ? known.style : \"variable\";\n      }\n    } // handle comments, including nested\n\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          maybeNested = false,\n          nestedCount = 0,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          if (nestedCount > 0) nestedCount--;else {\n            popStateStack(state);\n            break;\n          }\n        } else if (ch == \":\" && maybeNested) {\n          nestedCount++;\n        }\n\n        maybeEnd = ch == \":\";\n        maybeNested = ch == \"(\";\n      }\n\n      return \"comment\";\n    } // tokenizer for string literals\n    // optionally pass a tokenizer function to set state.tokenize back to when finished\n\n\n    function tokenString(quote, f) {\n      return function (stream, state) {\n        var ch;\n\n        if (isInString(state) && stream.current() == quote) {\n          popStateStack(state);\n          if (f) state.tokenize = f;\n          return \"string\";\n        }\n\n        pushStateStack(state, {\n          type: \"string\",\n          name: quote,\n          tokenize: tokenString(quote, f)\n        }); // if we're in a string and in an XML block, allow an embedded code block\n\n        if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n        while (ch = stream.next()) {\n          if (ch == quote) {\n            popStateStack(state);\n            if (f) state.tokenize = f;\n            break;\n          } else {\n            // if we're in a string and in an XML block, allow an embedded code block in an attribute\n            if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n              state.tokenize = tokenBase;\n              return \"string\";\n            }\n          }\n        }\n\n        return \"string\";\n      };\n    } // tokenizer for variables\n\n\n    function tokenVariable(stream, state) {\n      var isVariableChar = /[\\w\\$_-]/; // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n\n      if (stream.eat(\"\\\"\")) {\n        while (stream.next() !== '\\\"') {}\n\n        ;\n        stream.eat(\":\");\n      } else {\n        stream.eatWhile(isVariableChar);\n        if (!stream.match(\":=\", false)) stream.eat(\":\");\n      }\n\n      stream.eatWhile(isVariableChar);\n      state.tokenize = tokenBase;\n      return \"variable\";\n    } // tokenizer for XML tags\n\n\n    function tokenTag(name, isclose) {\n      return function (stream, state) {\n        stream.eatSpace();\n\n        if (isclose && stream.eat(\">\")) {\n          popStateStack(state);\n          state.tokenize = tokenBase;\n          return \"tag\";\n        } // self closing tag without attributes?\n\n\n        if (!stream.eat(\"/\")) pushStateStack(state, {\n          type: \"tag\",\n          name: name,\n          tokenize: tokenBase\n        });\n\n        if (!stream.eat(\">\")) {\n          state.tokenize = tokenAttribute;\n          return \"tag\";\n        } else {\n          state.tokenize = tokenBase;\n        }\n\n        return \"tag\";\n      };\n    } // tokenizer for XML attributes\n\n\n    function tokenAttribute(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"/\" && stream.eat(\">\")) {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        if (isInXmlBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \">\") {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \"=\") return null; // quoted string\n\n      if (ch == '\"' || ch == \"'\") return chain(stream, state, tokenString(ch, tokenAttribute));\n      if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n        type: \"attribute\",\n        tokenize: tokenAttribute\n      });\n      stream.eat(/[a-zA-Z_:]/);\n      stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n      stream.eatSpace(); // the case where the attribute has not value and the tag was closed\n\n      if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n      }\n\n      return \"attribute\";\n    } // handle comments, including nested\n\n\n    function tokenXMLComment(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"-\" && stream.match(\"->\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle CDATA\n\n\n    function tokenCDATA(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"]\" && stream.match(\"]\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle preprocessing instructions\n\n\n    function tokenPreProcessing(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"?\" && stream.match(\">\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment meta\";\n        }\n      }\n    } // functions to test the current context of the state\n\n\n    function isInXmlBlock(state) {\n      return isIn(state, \"tag\");\n    }\n\n    function isInXmlAttributeBlock(state) {\n      return isIn(state, \"attribute\");\n    }\n\n    function isInXmlConstructor(state) {\n      return isIn(state, \"xmlconstructor\");\n    }\n\n    function isInString(state) {\n      return isIn(state, \"string\");\n    }\n\n    function isEQNameAhead(stream) {\n      // assume we've already eaten a quote (\")\n      if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n    }\n\n    function isIn(state, type) {\n      return state.stack.length && state.stack[state.stack.length - 1].type == type;\n    }\n\n    function pushStateStack(state, newState) {\n      state.stack.push(newState);\n    }\n\n    function popStateStack(state) {\n      state.stack.pop();\n      var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n      state.tokenize = reinstateTokenize || tokenBase;\n    } // the interface for the mode API\n\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          cc: [],\n          stack: []\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        return style;\n      },\n      blockCommentStart: \"(:\",\n      blockCommentEnd: \":)\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS94cXVlcnkveHF1ZXJ5LmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN4Qjs7RUFFQUEsVUFBVSxDQUFDQyxVQUFYLENBQXNCLFFBQXRCLEVBQWdDLFlBQVc7SUFFekM7SUFDQTtJQUNBO0lBQ0EsSUFBSUMsUUFBUSxHQUFHLFlBQVU7TUFDdkI7TUFDQSxTQUFTQyxFQUFULENBQVlDLElBQVosRUFBa0I7UUFBQyxPQUFPO1VBQUNBLElBQUksRUFBRUEsSUFBUDtVQUFhQyxLQUFLLEVBQUU7UUFBcEIsQ0FBUDtNQUF1Qzs7TUFDMUQsSUFBSUMsUUFBUSxHQUFHSCxFQUFFLENBQUMsVUFBRCxDQUFqQjtNQUFBLElBQ0lJLElBQUksR0FBRztRQUFDSCxJQUFJLEVBQUUsTUFBUDtRQUFlQyxLQUFLLEVBQUU7TUFBdEIsQ0FEWDtNQUFBLElBRUlHLFdBQVcsR0FBRztRQUFDSixJQUFJLEVBQUUsYUFBUDtRQUFzQkMsS0FBSyxFQUFFO01BQTdCLENBRmxCO01BQUEsSUFHSUksU0FBUyxHQUFHO1FBQUNMLElBQUksRUFBRSxnQkFBUDtRQUF5QkMsS0FBSyxFQUFFO01BQWhDLENBSGhCLENBSHVCLENBUXZCOztNQUNBLElBQUlLLEtBQUssR0FBRztRQUNWLEtBQUtGO01B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SUMsaUJBQWlCLEdBQUcvQyxLQUFLLENBQUMyQyxLQUFOLENBQVlqRCxNQUFaLElBQXNCTSxLQUFLLENBQUMyQyxLQUFOLENBQVkzQyxLQUFLLENBQUMyQyxLQUFOLENBQVlqRCxNQUFaLEdBQW1CLENBQS9CLEVBQWtDUSxRQUFoRjtNQUNBRixLQUFLLENBQUNFLFFBQU4sR0FBaUI2QyxpQkFBaUIsSUFBSTVDLFNBQXRDO0lBQ0QsQ0F2WndDLENBeVp6Qzs7O0lBQ0EsT0FBTztNQUNMNkMsVUFBVSxFQUFFLHNCQUFXO1FBQ3JCLE9BQU87VUFDTDlDLFFBQVEsRUFBRUMsU0FETDtVQUVMOEMsRUFBRSxFQUFFLEVBRkM7VUFHTE4sS0FBSyxFQUFFO1FBSEYsQ0FBUDtNQUtELENBUEk7TUFTTE8sS0FBSyxFQUFFLGVBQVNuRCxNQUFULEVBQWlCQyxLQUFqQixFQUF3QjtRQUM3QixJQUFJRCxNQUFNLENBQUNnQixRQUFQLEVBQUosRUFBdUIsT0FBTyxJQUFQO1FBQ3ZCLElBQUk5QixLQUFLLEdBQUdlLEtBQUssQ0FBQ0UsUUFBTixDQUFlSCxNQUFmLEVBQXVCQyxLQUF2QixDQUFaO1FBQ0EsT0FBT2YsS0FBUDtNQUNELENBYkk7TUFlTGtFLGlCQUFpQixFQUFFLElBZmQ7TUFnQkxDLGVBQWUsRUFBRTtJQWhCWixDQUFQO0VBb0JELENBOWFEO0VBZ2JBeEUsVUFBVSxDQUFDeUUsVUFBWCxDQUFzQixvQkFBdEIsRUFBNEMsUUFBNUM7QUFFQyxDQTViRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9tb2RlL3hxdWVyeS94cXVlcnkuanM/ZDUwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInhxdWVyeVwiLCBmdW5jdGlvbigpIHtcblxuICAvLyBUaGUga2V5d29yZHMgb2JqZWN0IGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoaXMgc2VsZiBleGVjdXRpbmdcbiAgLy8gZnVuY3Rpb24uIEVhY2gga2V5d29yZCBpcyBhIHByb3BlcnR5IG9mIHRoZSBrZXl3b3JkcyBvYmplY3Qgd2hvc2VcbiAgLy8gdmFsdWUgaXMge3R5cGU6IGF0eXBlLCBzdHlsZTogYXN0eWxlfVxuICB2YXIga2V5d29yZHMgPSBmdW5jdGlvbigpe1xuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyB1c2VkIHRvIGJ1aWxkIGtleXdvcmRzIG9iamVjdFxuICAgIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICAgIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIilcbiAgICAgICwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICAgICAgLCBwdW5jdHVhdGlvbiA9IHt0eXBlOiBcInB1bmN0dWF0aW9uXCIsIHN0eWxlOiBudWxsfVxuICAgICAgLCBxdWFsaWZpZXIgPSB7dHlwZTogXCJheGlzX3NwZWNpZmllclwiLCBzdHlsZTogXCJxdWFsaWZpZXJcIn07XG5cbiAgICAvLyBrd09iaiBpcyB3aGF0IGlzIHJldHVybiBmcm9tIHRoaXMgZnVuY3Rpb24gYXQgdGhlIGVuZFxuICAgIHZhciBrd09iaiA9IHtcbiAgICAgICcsJzogcHVuY3R1YXRpb25cbiAgICB9O1xuXG4gICAgLy8gYSBsaXN0IG9mICdiYXNpYycga2V5d29yZHMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gICAgLy8ge3R5cGU6IGJhc2ljW2ldLCBzdHlsZTogXCJrZXl3b3JkXCJ9IGUuZy4gJ2FmdGVyJyAtLT4ge3R5cGU6IFwiYWZ0ZXJcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICAgIHZhciBiYXNpYyA9IFsnYWZ0ZXInLCAnYWxsJywgJ2FsbG93aW5nJywgJ2FuY2VzdG9yJywgJ2FuY2VzdG9yLW9yLXNlbGYnLCAnYW55JywgJ2FycmF5JywgJ2FzJyxcbiAgICAnYXNjZW5kaW5nJywgJ2F0JywgJ2F0dHJpYnV0ZScsICdiYXNlLXVyaScsICdiZWZvcmUnLCAnYm91bmRhcnktc3BhY2UnLCAnYnknLCAnY2FzZScsICdjYXN0JyxcbiAgICAnY2FzdGFibGUnLCAnY2F0Y2gnLCAnY2hpbGQnLCAnY29sbGF0aW9uJywgJ2NvbW1lbnQnLCAnY29uc3RydWN0aW9uJywgJ2NvbnRhaW5zJywgJ2NvbnRlbnQnLFxuICAgICdjb250ZXh0JywgJ2NvcHknLCAnY29weS1uYW1lc3BhY2VzJywgJ2NvdW50JywgJ2RlY2ltYWwtZm9ybWF0JywgJ2RlY2xhcmUnLCAnZGVmYXVsdCcsICdkZWxldGUnLFxuICAgICdkZXNjZW5kYW50JywgJ2Rlc2NlbmRhbnQtb3Itc2VsZicsICdkZXNjZW5kaW5nJywgJ2RpYWNyaXRpY3MnLCAnZGlmZmVyZW50JywgJ2Rpc3RhbmNlJyxcbiAgICAnZG9jdW1lbnQnLCAnZG9jdW1lbnQtbm9kZScsICdlbGVtZW50JywgJ2Vsc2UnLCAnZW1wdHknLCAnZW1wdHktc2VxdWVuY2UnLCAnZW5jb2RpbmcnLCAnZW5kJyxcbiAgICAnZW50aXJlJywgJ2V2ZXJ5JywgJ2V4YWN0bHknLCAnZXhjZXB0JywgJ2V4dGVybmFsJywgJ2ZpcnN0JywgJ2ZvbGxvd2luZycsICdmb2xsb3dpbmctc2libGluZycsXG4gICAgJ2ZvcicsICdmcm9tJywgJ2Z0YW5kJywgJ2Z0bm90JywgJ2Z0LW9wdGlvbicsICdmdG9yJywgJ2Z1bmN0aW9uJywgJ2Z1enp5JywgJ2dyZWF0ZXN0JywgJ2dyb3VwJyxcbiAgICAnaWYnLCAnaW1wb3J0JywgJ2luJywgJ2luaGVyaXQnLCAnaW5zZW5zaXRpdmUnLCAnaW5zZXJ0JywgJ2luc3RhbmNlJywgJ2ludGVyc2VjdCcsICdpbnRvJyxcbiAgICAnaW52b2tlJywgJ2lzJywgJ2l0ZW0nLCAnbGFuZ3VhZ2UnLCAnbGFzdCcsICdsYXgnLCAnbGVhc3QnLCAnbGV0JywgJ2xldmVscycsICdsb3dlcmNhc2UnLCAnbWFwJyxcbiAgICAnbW9kaWZ5JywgJ21vZHVsZScsICdtb3N0JywgJ25hbWVzcGFjZScsICduZXh0JywgJ25vJywgJ25vZGUnLCAnbm9kZXMnLCAnbm8taW5oZXJpdCcsXG4gICAgJ25vLXByZXNlcnZlJywgJ25vdCcsICdvY2N1cnMnLCAnb2YnLCAnb25seScsICdvcHRpb24nLCAnb3JkZXInLCAnb3JkZXJlZCcsICdvcmRlcmluZycsXG4gICAgJ3BhcmFncmFwaCcsICdwYXJhZ3JhcGhzJywgJ3BhcmVudCcsICdwaHJhc2UnLCAncHJlY2VkaW5nJywgJ3ByZWNlZGluZy1zaWJsaW5nJywgJ3ByZXNlcnZlJyxcbiAgICAncHJldmlvdXMnLCAncHJvY2Vzc2luZy1pbnN0cnVjdGlvbicsICdyZWxhdGlvbnNoaXAnLCAncmVuYW1lJywgJ3JlcGxhY2UnLCAncmV0dXJuJyxcbiAgICAncmV2YWxpZGF0aW9uJywgJ3NhbWUnLCAnc2F0aXNmaWVzJywgJ3NjaGVtYScsICdzY2hlbWEtYXR0cmlidXRlJywgJ3NjaGVtYS1lbGVtZW50JywgJ3Njb3JlJyxcbiAgICAnc2VsZicsICdzZW5zaXRpdmUnLCAnc2VudGVuY2UnLCAnc2VudGVuY2VzJywgJ3NlcXVlbmNlJywgJ3NraXAnLCAnc2xpZGluZycsICdzb21lJywgJ3N0YWJsZScsXG4gICAgJ3N0YXJ0JywgJ3N0ZW1taW5nJywgJ3N0b3AnLCAnc3RyaWN0JywgJ3N0cmlwJywgJ3N3aXRjaCcsICd0ZXh0JywgJ3RoZW4nLCAndGhlc2F1cnVzJywgJ3RpbWVzJyxcbiAgICAndG8nLCAndHJhbnNmb3JtJywgJ3RyZWF0JywgJ3RyeScsICd0dW1ibGluZycsICd0eXBlJywgJ3R5cGVzd2l0Y2gnLCAndW5pb24nLCAndW5vcmRlcmVkJyxcbiAgICAndXBkYXRlJywgJ3VwZGF0aW5nJywgJ3VwcGVyY2FzZScsICd1c2luZycsICd2YWxpZGF0ZScsICd2YWx1ZScsICd2YXJpYWJsZScsICd2ZXJzaW9uJyxcbiAgICAnd2VpZ2h0JywgJ3doZW4nLCAnd2hlcmUnLCAnd2lsZGNhcmRzJywgJ3dpbmRvdycsICd3aXRoJywgJ3dpdGhvdXQnLCAnd29yZCcsICd3b3JkcycsICd4cXVlcnknXTtcbiAgICBmb3IodmFyIGk9MCwgbD1iYXNpYy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbYmFzaWNbaV1dID0ga3coYmFzaWNbaV0pO307XG5cbiAgICAvLyBhIGxpc3Qgb2YgdHlwZXMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gICAgLy8ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9XG4gICAgdmFyIHR5cGVzID0gWyd4czphbnlBdG9taWNUeXBlJywgJ3hzOmFueVNpbXBsZVR5cGUnLCAneHM6YW55VHlwZScsICd4czphbnlVUkknLFxuICAgICd4czpiYXNlNjRCaW5hcnknLCAneHM6Ym9vbGVhbicsICd4czpieXRlJywgJ3hzOmRhdGUnLCAneHM6ZGF0ZVRpbWUnLCAneHM6ZGF0ZVRpbWVTdGFtcCcsXG4gICAgJ3hzOmRheVRpbWVEdXJhdGlvbicsICd4czpkZWNpbWFsJywgJ3hzOmRvdWJsZScsICd4czpkdXJhdGlvbicsICd4czpFTlRJVElFUycsICd4czpFTlRJVFknLFxuICAgICd4czpmbG9hdCcsICd4czpnRGF5JywgJ3hzOmdNb250aCcsICd4czpnTW9udGhEYXknLCAneHM6Z1llYXInLCAneHM6Z1llYXJNb250aCcsICd4czpoZXhCaW5hcnknLFxuICAgICd4czpJRCcsICd4czpJRFJFRicsICd4czpJRFJFRlMnLCAneHM6aW50JywgJ3hzOmludGVnZXInLCAneHM6aXRlbScsICd4czpqYXZhJywgJ3hzOmxhbmd1YWdlJyxcbiAgICAneHM6bG9uZycsICd4czpOYW1lJywgJ3hzOk5DTmFtZScsICd4czpuZWdhdGl2ZUludGVnZXInLCAneHM6Tk1UT0tFTicsICd4czpOTVRPS0VOUycsXG4gICAgJ3hzOm5vbk5lZ2F0aXZlSW50ZWdlcicsICd4czpub25Qb3NpdGl2ZUludGVnZXInLCAneHM6bm9ybWFsaXplZFN0cmluZycsICd4czpOT1RBVElPTicsXG4gICAgJ3hzOm51bWVyaWMnLCAneHM6cG9zaXRpdmVJbnRlZ2VyJywgJ3hzOnByZWNpc2lvbkRlY2ltYWwnLCAneHM6UU5hbWUnLCAneHM6c2hvcnQnLCAneHM6c3RyaW5nJyxcbiAgICAneHM6dGltZScsICd4czp0b2tlbicsICd4czp1bnNpZ25lZEJ5dGUnLCAneHM6dW5zaWduZWRJbnQnLCAneHM6dW5zaWduZWRMb25nJyxcbiAgICAneHM6dW5zaWduZWRTaG9ydCcsICd4czp1bnR5cGVkJywgJ3hzOnVudHlwZWRBdG9taWMnLCAneHM6eWVhck1vbnRoRHVyYXRpb24nXTtcbiAgICBmb3IodmFyIGk9MCwgbD10eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbdHlwZXNbaV1dID0gYXRvbTt9O1xuXG4gICAgLy8gZWFjaCBvcGVyYXRvciB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwib3BlcmF0b3JcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICAgIHZhciBvcGVyYXRvcnMgPSBbJ2VxJywgJ25lJywgJ2x0JywgJ2xlJywgJ2d0JywgJ2dlJywgJzo9JywgJz0nLCAnPicsICc+PScsICc8JywgJzw9JywgJy4nLCAnfCcsICc/JywgJ2FuZCcsICdvcicsICdkaXYnLCAnaWRpdicsICdtb2QnLCAnKicsICcvJywgJysnLCAnLSddO1xuICAgIGZvcih2YXIgaT0wLCBsPW9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbb3BlcmF0b3JzW2ldXSA9IG9wZXJhdG9yO307XG5cbiAgICAvLyBlYWNoIGF4aXNfc3BlY2lmaWVycyB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9XG4gICAgdmFyIGF4aXNfc3BlY2lmaWVycyA9IFtcInNlbGY6OlwiLCBcImF0dHJpYnV0ZTo6XCIsIFwiY2hpbGQ6OlwiLCBcImRlc2NlbmRhbnQ6OlwiLCBcImRlc2NlbmRhbnQtb3Itc2VsZjo6XCIsIFwicGFyZW50OjpcIixcbiAgICBcImFuY2VzdG9yOjpcIiwgXCJhbmNlc3Rvci1vci1zZWxmOjpcIiwgXCJmb2xsb3dpbmc6OlwiLCBcInByZWNlZGluZzo6XCIsIFwiZm9sbG93aW5nLXNpYmxpbmc6OlwiLCBcInByZWNlZGluZy1zaWJsaW5nOjpcIl07XG4gICAgZm9yKHZhciBpPTAsIGw9YXhpc19zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtheGlzX3NwZWNpZmllcnNbaV1dID0gcXVhbGlmaWVyOyB9O1xuXG4gICAgcmV0dXJuIGt3T2JqO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIHRoZSBwcmltYXJ5IG1vZGUgdG9rZW5pemVyXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKSxcbiAgICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gZmFsc2UsXG4gICAgICAgIGlzRVFOYW1lID0gaXNFUU5hbWVBaGVhZChzdHJlYW0pO1xuXG4gICAgLy8gYW4gWE1MIHRhZyAoaWYgbm90IGluIHNvbWUgc3ViLCBjaGFpbmVkIHRva2VuaXplcilcbiAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgIGlmKHN0cmVhbS5tYXRjaChcIiEtLVwiLCB0cnVlKSlcbiAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuWE1MQ29tbWVudCk7XG5cbiAgICAgIGlmKHN0cmVhbS5tYXRjaChcIiFbQ0RBVEFcIiwgZmFsc2UpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DREFUQTtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9XG5cbiAgICAgIGlmKHN0cmVhbS5tYXRjaChcIj9cIiwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblByZVByb2Nlc3NpbmcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNjbG9zZSA9IHN0cmVhbS5lYXQoXCIvXCIpO1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICB2YXIgdGFnTmFtZSA9IFwiXCIsIGM7XG4gICAgICB3aGlsZSAoKGMgPSBzdHJlYW0uZWF0KC9bXlxcc1xcdTAwYTA9PD5cXFwiXFwnXFwvP10vKSkpIHRhZ05hbWUgKz0gYztcblxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVGFnKHRhZ05hbWUsIGlzY2xvc2UpKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgY29kZSBibG9ja1xuICAgIGVsc2UgaWYoY2ggPT0gXCJ7XCIpIHtcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29kZWJsb2NrXCJ9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBlbmQgY29kZSBibG9ja1xuICAgIGVsc2UgaWYoY2ggPT0gXCJ9XCIpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHdlJ3JlIGluIGFuIFhNTCBibG9ja1xuICAgIGVsc2UgaWYoaXNJblhtbEJsb2NrKHN0YXRlKSkge1xuICAgICAgaWYoY2ggPT0gXCI+XCIpXG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgZWxzZSBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICAgIC8vIGlmIGEgbnVtYmVyXG4gICAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKT8oPzpFWytcXC1dP1xcZCspPy8pO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH1cbiAgICAvLyBjb21tZW50IHN0YXJ0XG4gICAgZWxzZSBpZiAoY2ggPT09IFwiKFwiICYmIHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvbW1lbnRcIn0pO1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQ29tbWVudCk7XG4gICAgfVxuICAgIC8vIHF1b3RlZCBzdHJpbmdcbiAgICBlbHNlIGlmICghaXNFUU5hbWUgJiYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gpKTtcbiAgICAvLyB2YXJpYWJsZVxuICAgIGVsc2UgaWYoY2ggPT09IFwiJFwiKSB7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5WYXJpYWJsZSk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnRcbiAgICBlbHNlIGlmKGNoID09PVwiOlwiICYmIHN0cmVhbS5lYXQoXCI9XCIpKSB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIC8vIG9wZW4gcGFyZW5cbiAgICBlbHNlIGlmKGNoID09PSBcIihcIikge1xuICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJwYXJlblwifSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gY2xvc2UgcGFyZW5cbiAgICBlbHNlIGlmKGNoID09PSBcIilcIikge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gb3BlbiBwYXJlblxuICAgIGVsc2UgaWYoY2ggPT09IFwiW1wiKSB7XG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImJyYWNrZXRcIn0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGNsb3NlIHBhcmVuXG4gICAgZWxzZSBpZihjaCA9PT0gXCJdXCIpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY2gpICYmIGtleXdvcmRzW2NoXTtcblxuICAgICAgLy8gaWYgdGhlcmUncyBhIEVRTmFtZSBhaGVhZCwgY29uc3VtZSB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHBvcnRpb24sIGl0J3MgbGlrZWx5IGEgZnVuY3Rpb25cbiAgICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFxcIicpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcIicpe31cbiAgICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFwnJykgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcJycpe31cblxuICAgICAgLy8gZ29iYmxlIHVwIGEgd29yZCBpZiB0aGUgY2hhcmFjdGVyIGlzIG5vdCBrbm93blxuICAgICAgaWYoIWtub3duKSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcblxuICAgICAgLy8gZ29iYmxlIGEgY29sb24gaW4gdGhlIGNhc2UgdGhhdCBpcyBhIGxpYiBmdW5jIHR5cGUgY2FsbCBmbjpkb2NcbiAgICAgIHZhciBmb3VuZENvbG9uID0gc3RyZWFtLmVhdChcIjpcIik7XG5cbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm90IGEgc2Vjb25kIGNvbG9uLCBnb2JibGUgYW5vdGhlciB3b3JkLiBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgYW4gYXhpcyBzcGVjaWZpZXJcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBnZXQgbWF0Y2hlZCBhcyBhIGtleXdvcmRcbiAgICAgIGlmKCFzdHJlYW0uZWF0KFwiOlwiKSAmJiBmb3VuZENvbG9uKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF8tXS8pO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIG5leHQgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGFuIG9wZW4gcGFyZW4sIHRoaXMgaXMgcHJvYmFibHkgYSBmdW5jdGlvbiAoaWYgbm90IGEga2V5d29yZCBvZiBvdGhlciBzb3J0KVxuICAgICAgaWYoc3RyZWFtLm1hdGNoKC9eWyBcXHRdKlxcKC8sIGZhbHNlKSkge1xuICAgICAgICBtaWdodEJlRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIHdvcmQgYSBrZXl3b3JkP1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJiBrZXl3b3Jkc1t3b3JkXTtcblxuICAgICAgLy8gaWYgd2UgdGhpbmsgaXQncyBhIGZ1bmN0aW9uIGNhbGwgYnV0IG5vdCB5ZXQga25vd24sXG4gICAgICAvLyBzZXQgc3R5bGUgdG8gdmFyaWFibGUgZm9yIG5vdyBmb3IgbGFjayBvZiBzb21ldGhpbmcgYmV0dGVyXG4gICAgICBpZihtaWdodEJlRnVuY3Rpb24gJiYgIWtub3duKSBrbm93biA9IHt0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIiwgc3R5bGU6IFwidmFyaWFibGUgZGVmXCJ9O1xuXG4gICAgICAvLyBpZiB0aGUgcHJldmlvdXMgd29yZCB3YXMgZWxlbWVudCwgYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgdGhpcyB3b3JkIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGF0XG4gICAgICBpZihpc0luWG1sQ29uc3RydWN0b3Ioc3RhdGUpKSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgfVxuICAgICAgLy8gYXMgcHJldmlvdXNseSBjaGVja2VkLCBpZiB0aGUgd29yZCBpcyBlbGVtZW50LGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIGNhbGwgaXQgYW4gXCJ4bWxjb25zdHJ1Y3RvclwiIGFuZFxuICAgICAgLy8gcHVzaCB0aGUgc3RhY2sgc28gd2Uga25vdyB0byBsb29rIGZvciBpdCBvbiB0aGUgbmV4dCB3b3JkXG4gICAgICBpZih3b3JkID09IFwiZWxlbWVudFwiIHx8IHdvcmQgPT0gXCJhdHRyaWJ1dGVcIiB8fCBrbm93bi50eXBlID09IFwiYXhpc19zcGVjaWZpZXJcIikgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHt0eXBlOiBcInhtbGNvbnN0cnVjdG9yXCJ9KTtcblxuICAgICAgLy8gaWYgdGhlIHdvcmQgaXMga25vd24sIHJldHVybiB0aGUgZGV0YWlscyBvZiB0aGF0IGVsc2UganVzdCBjYWxsIHRoaXMgYSBnZW5lcmljICd3b3JkJ1xuICAgICAgcmV0dXJuIGtub3duID8ga25vd24uc3R5bGUgOiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIG1heWJlTmVzdGVkID0gZmFsc2UsIG5lc3RlZENvdW50ID0gMCwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiKVwiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIGlmKG5lc3RlZENvdW50ID4gMClcbiAgICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZihjaCA9PSBcIjpcIiAmJiBtYXliZU5lc3RlZCkge1xuICAgICAgICBuZXN0ZWRDb3VudCsrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCI6XCIpO1xuICAgICAgbWF5YmVOZXN0ZWQgPSAoY2ggPT0gXCIoXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIHRva2VuaXplciBmb3Igc3RyaW5nIGxpdGVyYWxzXG4gIC8vIG9wdGlvbmFsbHkgcGFzcyBhIHRva2VuaXplciBmdW5jdGlvbiB0byBzZXQgc3RhdGUudG9rZW5pemUgYmFjayB0byB3aGVuIGZpbmlzaGVkXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlLCBmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaDtcblxuICAgICAgaWYoaXNJblN0cmluZyhzdGF0ZSkgJiYgc3RyZWFtLmN1cnJlbnQoKSA9PSBxdW90ZSkge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgaWYoZikgc3RhdGUudG9rZW5pemUgPSBmO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cblxuICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogcXVvdGUsIHRva2VuaXplOiB0b2tlblN0cmluZyhxdW90ZSwgZikgfSk7XG5cbiAgICAgIC8vIGlmIHdlJ3JlIGluIGEgc3RyaW5nIGFuZCBpbiBhbiBYTUwgYmxvY2ssIGFsbG93IGFuIGVtYmVkZGVkIGNvZGUgYmxvY2tcbiAgICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuXG5cbiAgICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgaWYgKGNoID09ICBxdW90ZSkge1xuICAgICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBhIHN0cmluZyBhbmQgaW4gYW4gWE1MIGJsb2NrLCBhbGxvdyBhbiBlbWJlZGRlZCBjb2RlIGJsb2NrIGluIGFuIGF0dHJpYnV0ZVxuICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHRva2VuaXplciBmb3IgdmFyaWFibGVzXG4gIGZ1bmN0aW9uIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBpc1ZhcmlhYmxlQ2hhciA9IC9bXFx3XFwkXy1dLztcblxuICAgIC8vIGEgdmFyaWFibGUgbWF5IHN0YXJ0IHdpdGggYSBxdW90ZWQgRVFOYW1lIHNvIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBxdW90ZSwgY29uc3VtZSB0byB0aGUgbmV4dCBxdW90ZVxuICAgIGlmKHN0cmVhbS5lYXQoXCJcXFwiXCIpKSB7XG4gICAgICB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXFxcIicpe307XG4gICAgICBzdHJlYW0uZWF0KFwiOlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgICAgIGlmKCFzdHJlYW0ubWF0Y2goXCI6PVwiLCBmYWxzZSkpIHN0cmVhbS5lYXQoXCI6XCIpO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNWYXJpYWJsZUNoYXIpO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICAvLyB0b2tlbml6ZXIgZm9yIFhNTCB0YWdzXG4gIGZ1bmN0aW9uIHRva2VuVGFnKG5hbWUsIGlzY2xvc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICBpZihpc2Nsb3NlICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9XG4gICAgICAvLyBzZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlcz9cbiAgICAgIGlmKCFzdHJlYW0uZWF0KFwiL1wiKSlcbiAgICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJ0YWdcIiwgbmFtZTogbmFtZSwgdG9rZW5pemU6IHRva2VuQmFzZX0pO1xuICAgICAgaWYoIXN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdHRyaWJ1dGU7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHRva2VuaXplciBmb3IgWE1MIGF0dHJpYnV0ZXNcbiAgZnVuY3Rpb24gdG9rZW5BdHRyaWJ1dGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICBpZihpc0luWG1sQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cbiAgICBpZihjaCA9PSBcIj5cIikge1xuICAgICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgaWYoY2ggPT0gXCI9XCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBxdW90ZWQgc3RyaW5nXG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gsIHRva2VuQXR0cmlidXRlKSk7XG5cbiAgICBpZighaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSlcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiYXR0cmlidXRlXCIsIHRva2VuaXplOiB0b2tlbkF0dHJpYnV0ZX0pO1xuXG4gICAgc3RyZWFtLmVhdCgvW2EtekEtWl86XS8pO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvWy1hLXpBLVowLTlfOi5dLyk7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgICAvLyB0aGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIGhhcyBub3QgdmFsdWUgYW5kIHRoZSB0YWcgd2FzIGNsb3NlZFxuICAgIGlmKHN0cmVhbS5tYXRjaChcIj5cIiwgZmFsc2UpIHx8IHN0cmVhbS5tYXRjaChcIi9cIiwgZmFsc2UpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cblxuICAgIHJldHVybiBcImF0dHJpYnV0ZVwiO1xuICB9XG5cbiAgLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG4gIGZ1bmN0aW9uIHRva2VuWE1MQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0ubWF0Y2goXCItPlwiLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gaGFuZGxlIENEQVRBXG4gIGZ1bmN0aW9uIHRva2VuQ0RBVEEoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCJdXCIgJiYgc3RyZWFtLm1hdGNoKFwiXVwiLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBwcmVwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuICBmdW5jdGlvbiB0b2tlblByZVByb2Nlc3Npbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCI/XCIgJiYgc3RyZWFtLm1hdGNoKFwiPlwiLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudCBtZXRhXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBmdW5jdGlvbnMgdG8gdGVzdCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBzdGF0ZVxuICBmdW5jdGlvbiBpc0luWG1sQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwidGFnXCIpOyB9XG4gIGZ1bmN0aW9uIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJhdHRyaWJ1dGVcIik7IH1cbiAgZnVuY3Rpb24gaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInhtbGNvbnN0cnVjdG9yXCIpOyB9XG4gIGZ1bmN0aW9uIGlzSW5TdHJpbmcoc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwic3RyaW5nXCIpOyB9XG5cbiAgZnVuY3Rpb24gaXNFUU5hbWVBaGVhZChzdHJlYW0pIHtcbiAgICAvLyBhc3N1bWUgd2UndmUgYWxyZWFkeSBlYXRlbiBhIHF1b3RlIChcIilcbiAgICBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXCInKVxuICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFxcIlxcOi8sIGZhbHNlKTtcbiAgICBlbHNlIGlmKHN0cmVhbS5jdXJyZW50KCkgPT09ICdcXCcnKVxuICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFwnXFw6LywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW4oc3RhdGUsIHR5cGUpIHtcbiAgICByZXR1cm4gKHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGggLSAxXS50eXBlID09IHR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFN0YXRlU3RhY2soc3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgc3RhdGUuc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BTdGF0ZVN0YWNrKHN0YXRlKSB7XG4gICAgc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHJlaW5zdGF0ZVRva2VuaXplID0gc3RhdGUuc3RhY2subGVuZ3RoICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXS50b2tlbml6ZTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHJlaW5zdGF0ZVRva2VuaXplIHx8IHRva2VuQmFzZTtcbiAgfVxuXG4gIC8vIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBtb2RlIEFQSVxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgY2M6IFtdLFxuICAgICAgICBzdGFjazogW11cbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIig6XCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIjopXCJcblxuICB9O1xuXG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veHF1ZXJ5XCIsIFwieHF1ZXJ5XCIpO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVNb2RlIiwia2V5d29yZHMiLCJrdyIsInR5cGUiLCJzdHlsZSIsIm9wZXJhdG9yIiwiYXRvbSIsInB1bmN0dWF0aW9uIiwicXVhbGlmaWVyIiwia3dPYmoiLCJiYXNpYyIsImkiLCJsIiwibGVuZ3RoIiwidHlwZXMiLCJvcGVyYXRvcnMiLCJheGlzX3NwZWNpZmllcnMiLCJjaGFpbiIsInN0cmVhbSIsInN0YXRlIiwiZiIsInRva2VuaXplIiwidG9rZW5CYXNlIiwiY2giLCJuZXh0IiwibWlnaHRCZUZ1bmN0aW9uIiwiaXNFUU5hbWUiLCJpc0VRTmFtZUFoZWFkIiwibWF0Y2giLCJ0b2tlblhNTENvbW1lbnQiLCJ0b2tlbkNEQVRBIiwidG9rZW5QcmVQcm9jZXNzaW5nIiwiaXNjbG9zZSIsImVhdCIsImVhdFNwYWNlIiwidGFnTmFtZSIsImMiLCJ0b2tlblRhZyIsInB1c2hTdGF0ZVN0YWNrIiwicG9wU3RhdGVTdGFjayIsImlzSW5YbWxCbG9jayIsInRlc3QiLCJ0b2tlbkNvbW1lbnQiLCJ0b2tlblN0cmluZyIsInRva2VuVmFyaWFibGUiLCJrbm93biIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZWF0V2hpbGUiLCJmb3VuZENvbG9uIiwid29yZCIsImN1cnJlbnQiLCJpc0luWG1sQ29uc3RydWN0b3IiLCJtYXliZUVuZCIsIm1heWJlTmVzdGVkIiwibmVzdGVkQ291bnQiLCJxdW90ZSIsImlzSW5TdHJpbmciLCJuYW1lIiwiaXNJblhtbEF0dHJpYnV0ZUJsb2NrIiwiaXNWYXJpYWJsZUNoYXIiLCJ0b2tlbkF0dHJpYnV0ZSIsImlzSW4iLCJzdGFjayIsIm5ld1N0YXRlIiwicHVzaCIsInBvcCIsInJlaW5zdGF0ZVRva2VuaXplIiwic3RhcnRTdGF0ZSIsImNjIiwidG9rZW4iLCJibG9ja0NvbW1lbnRTdGFydCIsImJsb2NrQ29tbWVudEVuZCIsImRlZmluZU1JTUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/xquery/xquery.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/xquery/xquery.js");
/******/ 	
/******/ })()
;