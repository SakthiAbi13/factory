/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/d/d.js":
/*!*************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/d/d.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"d\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n        keywords = parserConfig.keywords || {},\n        builtin = parserConfig.builtin || {},\n        blockKeywords = parserConfig.blockKeywords || {},\n        atoms = parserConfig.atoms || {},\n        hooks = parserConfig.hooks || {},\n        multiLineStrings = parserConfig.multiLineStrings;\n    var isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (hooks[ch]) {\n        var result = hooks[ch](stream, state);\n        if (result !== false) return result;\n      }\n\n      if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w\\.]/);\n        return \"number\";\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"+\")) {\n          state.tokenize = tokenNestedComment;\n          return tokenNestedComment(stream, state);\n        }\n\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n      var cur = stream.current();\n\n      if (keywords.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"keyword\";\n      }\n\n      if (builtin.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n        return \"builtin\";\n      }\n\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return \"variable\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = null;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenNestedComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = null;\n          break;\n        }\n\n        maybeEnd = ch == \"+\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type) {\n      var indent = state.indented;\n      if (state.context && state.context.type == \"statement\") indent = state.context.indented;\n      return state.context = new Context(indent, col, type, null, state.context);\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n      return state.context = state.context.prev;\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n          indented: 0,\n          startOfLine: true\n        };\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") popContext(state);else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n\n          if (ctx.type == \"}\") ctx = popContext(state);\n\n          while (ctx.type == \"statement\") {\n            ctx = popContext(state);\n          }\n        } else if (curPunc == ctx.type) popContext(state);else if ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';' || ctx.type == \"statement\" && curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = firstChar == ctx.type;\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);else if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      blockCommentContinue: \" * \",\n      lineComment: \"//\",\n      fold: \"brace\"\n    };\n  });\n\n  function words(str) {\n    var obj = {},\n        words = str.split(\" \");\n\n    for (var i = 0; i < words.length; ++i) {\n      obj[words[i]] = true;\n    }\n\n    return obj;\n  }\n\n  var blockKeywords = \"body catch class do else enum for foreach foreach_reverse if in interface mixin \" + \"out scope struct switch try union unittest version while with\";\n  CodeMirror.defineMIME(\"text/x-d\", {\n    name: \"d\",\n    keywords: words(\"abstract alias align asm assert auto break case cast cdouble cent cfloat const continue \" + \"debug default delegate delete deprecated export extern final finally function goto immutable \" + \"import inout invariant is lazy macro module new nothrow override package pragma private \" + \"protected public pure ref return shared short static super synchronized template this \" + \"throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters \" + blockKeywords),\n    blockKeywords: words(blockKeywords),\n    builtin: words(\"bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte \" + \"ucent uint ulong ushort wchar wstring void size_t sizediff_t\"),\n    atoms: words(\"exit failure success true false null\"),\n    hooks: {\n      \"@\": function _(stream, _state) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9kL2QuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBLENBQUMsVUFBU0EsR0FBVCxFQUFjO0VBQ2IsSUFBSSxzQkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QixzQkFBT0MsTUFBUCxNQUFpQixRQUFuRCxFQUE2RDtJQUMzREYsR0FBRyxDQUFDRyxtQkFBTyxDQUFDLG1KQUFELENBQVIsQ0FBSCxDQURGLEtBRUssSUFBSSxJQUFKLEVBQStDO0lBQ2xEQyxpQ0FBTyxDQUFDLG1KQUFELENBQUQsb0NBQTJCSixHQUEzQjtBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURHLEtBRUE7SUFDSEEsRUFBQTtBQUNILENBUEQsRUFPRyxVQUFTTSxVQUFULEVBQXFCO0VBQ3hCOztFQUVBQSxVQUFVLENBQUNDLFVBQVgsQ0FBc0IsR0FBdEIsRUFBMkIsVUFBU0MsTUFBVCxFQUFpQkMsWUFBakIsRUFBK0I7SUFDeEQsSUFBSUMsVUFBVSxHQUFHRixNQUFNLENBQUNFLFVBQXhCO0lBQUEsSUFDSUMsbUJBQW1CLEdBQUdGLFlBQVksQ0FBQ0UsbUJBQWIsSUFBb0NELFVBRDlEO0lBQUEsSUFFSUUsUUFBUSxHQUFHSCxZQUFZLENBQUNHLFFBQWIsSUFBeUIsRUFGeEM7SUFBQSxJQUdJQyxPQUFPLEdBQUdKLFlBQVksQ0FBQ0ksT0FBYixJQUF3QixFQUh0QztJQUFBLElBSUlDLGFBQWEsR0FBR0wsWUFBWSxDQUFDSyxhQUFiLElBQThCLEVBSmxEO0lBQUEsSUFLSUMsS0FBSyxHQUFHTixZQUFZLENBQUNNLEtBQWIsSUFBc0IsRUFMbEM7SUFBQSxJQU1JQyxLQUFLLEdBQUdQLFlBQVksQ0FBQ08sS0FBYixJQUFzQixFQU5sQztJQUFBLElBT0lDLGdCQUFnQixHQUFHUixZQUFZLENBQUNRLGdCQVBwQztJQVFBLElBQUlDLGNBQWMsR0FBRyxrQkFBckI7SUFFQSxJQUFJQyxPQUFKOztJQUVB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cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9tb2RlL2QvZC5qcz8xZGE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZFwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgc3RhdGVtZW50SW5kZW50VW5pdCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGluZGVudFVuaXQsXG4gICAgICBrZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5rZXl3b3JkcyB8fCB7fSxcbiAgICAgIGJ1aWx0aW4gPSBwYXJzZXJDb25maWcuYnVpbHRpbiB8fCB7fSxcbiAgICAgIGJsb2NrS2V5d29yZHMgPSBwYXJzZXJDb25maWcuYmxvY2tLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9LFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge30sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3M7XG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fFxcL10vO1xuXG4gIHZhciBjdXJQdW5jO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoaG9va3NbY2hdKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaG9va3NbY2hdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiIHx8IGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbk5lc3RlZENvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBtdWx0aUxpbmVTdHJpbmdzKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbk5lc3RlZENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiK1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldikge1xuICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9XG4gIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwic3RhdGVtZW50XCIpXG4gICAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoaW5kZW50LCBjb2wsIHR5cGUsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiKSByZXR1cm4gc3R5bGU7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgIGlmICgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiIHx8IGN1clB1bmMgPT0gXCIsXCIpICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdHgudHlwZSA9PSBcIn1cIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoKChjdHgudHlwZSA9PSBcIn1cIiB8fCBjdHgudHlwZSA9PSBcInRvcFwiKSAmJiBjdXJQdW5jICE9ICc7JykgfHwgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSlcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSByZXR1cm4gY3R4LmluZGVudGVkICsgKGZpcnN0Q2hhciA9PSBcIntcIiA/IDAgOiBzdGF0ZW1lbnRJbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGN0eC5hbGlnbikgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCIsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBibG9ja0NvbW1lbnRDb250aW51ZTogXCIgKiBcIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiLFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9O1xufSk7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBibG9ja0tleXdvcmRzID0gXCJib2R5IGNhdGNoIGNsYXNzIGRvIGVsc2UgZW51bSBmb3IgZm9yZWFjaCBmb3JlYWNoX3JldmVyc2UgaWYgaW4gaW50ZXJmYWNlIG1peGluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIm91dCBzY29wZSBzdHJ1Y3Qgc3dpdGNoIHRyeSB1bmlvbiB1bml0dGVzdCB2ZXJzaW9uIHdoaWxlIHdpdGhcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZFwiLCB7XG4gICAgbmFtZTogXCJkXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3QgYWxpYXMgYWxpZ24gYXNtIGFzc2VydCBhdXRvIGJyZWFrIGNhc2UgY2FzdCBjZG91YmxlIGNlbnQgY2Zsb2F0IGNvbnN0IGNvbnRpbnVlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkZWJ1ZyBkZWZhdWx0IGRlbGVnYXRlIGRlbGV0ZSBkZXByZWNhdGVkIGV4cG9ydCBleHRlcm4gZmluYWwgZmluYWxseSBmdW5jdGlvbiBnb3RvIGltbXV0YWJsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaW1wb3J0IGlub3V0IGludmFyaWFudCBpcyBsYXp5IG1hY3JvIG1vZHVsZSBuZXcgbm90aHJvdyBvdmVycmlkZSBwYWNrYWdlIHByYWdtYSBwcml2YXRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm90ZWN0ZWQgcHVibGljIHB1cmUgcmVmIHJldHVybiBzaGFyZWQgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0ZW1wbGF0ZSB0aGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0aHJvdyB0eXBlZGVmIHR5cGVpZCB0eXBlb2Ygdm9sYXRpbGUgX19GSUxFX18gX19MSU5FX18gX19nc2hhcmVkIF9fdHJhaXRzIF9fdmVjdG9yIF9fcGFyYW1ldGVycyBcIiArXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrS2V5d29yZHMpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKGJsb2NrS2V5d29yZHMpLFxuICAgIGJ1aWx0aW46IHdvcmRzKFwiYm9vbCBieXRlIGNoYXIgY3JlYWwgZGNoYXIgZG91YmxlIGZsb2F0IGlkb3VibGUgaWZsb2F0IGludCBpcmVhbCBsb25nIHJlYWwgc2hvcnQgdWJ5dGUgXCIgK1xuICAgICAgICAgICAgICAgICAgIFwidWNlbnQgdWludCB1bG9uZyB1c2hvcnQgd2NoYXIgd3N0cmluZyB2b2lkIHNpemVfdCBzaXplZGlmZl90XCIpLFxuICAgIGF0b21zOiB3b3JkcyhcImV4aXQgZmFpbHVyZSBzdWNjZXNzIHRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBob29rczoge1xuICAgICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSwgX3N0YXRlKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkZWZpbmVNb2RlIiwiY29uZmlnIiwicGFyc2VyQ29uZmlnIiwiaW5kZW50VW5pdCIsInN0YXRlbWVudEluZGVudFVuaXQiLCJrZXl3b3JkcyIsImJ1aWx0aW4iLCJibG9ja0tleXdvcmRzIiwiYXRvbXMiLCJob29rcyIsIm11bHRpTGluZVN0cmluZ3MiLCJpc09wZXJhdG9yQ2hhciIsImN1clB1bmMiLCJ0b2tlbkJhc2UiLCJzdHJlYW0iLCJzdGF0ZSIsImNoIiwibmV4dCIsInJlc3VsdCIsInRva2VuaXplIiwidG9rZW5TdHJpbmciLCJ0ZXN0IiwiZWF0V2hpbGUiLCJlYXQiLCJ0b2tlbk5lc3RlZENvbW1lbnQiLCJ0b2tlbkNvbW1lbnQiLCJza2lwVG9FbmQiLCJjdXIiLCJjdXJyZW50IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJxdW90ZSIsImVzY2FwZWQiLCJlbmQiLCJtYXliZUVuZCIsIkNvbnRleHQiLCJpbmRlbnRlZCIsImNvbHVtbiIsInR5cGUiLCJhbGlnbiIsInByZXYiLCJwdXNoQ29udGV4dCIsImNvbCIsImluZGVudCIsImNvbnRleHQiLCJwb3BDb250ZXh0IiwidCIsInN0YXJ0U3RhdGUiLCJiYXNlY29sdW1uIiwic3RhcnRPZkxpbmUiLCJ0b2tlbiIsImN0eCIsInNvbCIsImluZGVudGF0aW9uIiwiZWF0U3BhY2UiLCJzdHlsZSIsInRleHRBZnRlciIsIlBhc3MiLCJmaXJzdENoYXIiLCJjaGFyQXQiLCJjbG9zaW5nIiwiZWxlY3RyaWNDaGFycyIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwiYmxvY2tDb21tZW50Q29udGludWUiLCJsaW5lQ29tbWVudCIsImZvbGQiLCJ3b3JkcyIsInN0ciIsIm9iaiIsInNwbGl0IiwiaSIsImxlbmd0aCIsImRlZmluZU1JTUUiLCJuYW1lIiwiX3N0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/d/d.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/d/d.js");
/******/ 	
/******/ })()
;