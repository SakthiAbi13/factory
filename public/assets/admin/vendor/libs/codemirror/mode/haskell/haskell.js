/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/haskell/haskell.js":
/*!*************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/haskell/haskell.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haskell\", function (_config, modeConfig) {\n    function switchState(source, setState, f) {\n      setState(f);\n      return f(source, setState);\n    } // These should all be Unicode extended, as per the Haskell 2010 report\n\n\n    var smallRE = /[a-z_]/;\n    var largeRE = /[A-Z]/;\n    var digitRE = /\\d/;\n    var hexitRE = /[0-9A-Fa-f]/;\n    var octitRE = /[0-7]/;\n    var idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\n    var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\n    var specialRE = /[(),;[\\]`{}]/;\n    var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n    function normal(source, setState) {\n      if (source.eatWhile(whiteCharRE)) {\n        return null;\n      }\n\n      var ch = source.next();\n\n      if (specialRE.test(ch)) {\n        if (ch == '{' && source.eat('-')) {\n          var t = \"comment\";\n\n          if (source.eat('#')) {\n            t = \"meta\";\n          }\n\n          return switchState(source, setState, ncomment(t, 1));\n        }\n\n        return null;\n      }\n\n      if (ch == '\\'') {\n        if (source.eat('\\\\')) {\n          source.next(); // should handle other escapes here\n        } else {\n          source.next();\n        }\n\n        if (source.eat('\\'')) {\n          return \"string\";\n        }\n\n        return \"string error\";\n      }\n\n      if (ch == '\"') {\n        return switchState(source, setState, stringLiteral);\n      }\n\n      if (largeRE.test(ch)) {\n        source.eatWhile(idRE);\n\n        if (source.eat('.')) {\n          return \"qualifier\";\n        }\n\n        return \"variable-2\";\n      }\n\n      if (smallRE.test(ch)) {\n        source.eatWhile(idRE);\n        return \"variable\";\n      }\n\n      if (digitRE.test(ch)) {\n        if (ch == '0') {\n          if (source.eat(/[xX]/)) {\n            source.eatWhile(hexitRE); // should require at least 1\n\n            return \"integer\";\n          }\n\n          if (source.eat(/[oO]/)) {\n            source.eatWhile(octitRE); // should require at least 1\n\n            return \"number\";\n          }\n        }\n\n        source.eatWhile(digitRE);\n        var t = \"number\";\n\n        if (source.match(/^\\.\\d+/)) {\n          t = \"number\";\n        }\n\n        if (source.eat(/[eE]/)) {\n          t = \"number\";\n          source.eat(/[-+]/);\n          source.eatWhile(digitRE); // should require at least 1\n        }\n\n        return t;\n      }\n\n      if (ch == \".\" && source.eat(\".\")) return \"keyword\";\n\n      if (symbolRE.test(ch)) {\n        if (ch == '-' && source.eat(/-/)) {\n          source.eatWhile(/-/);\n\n          if (!source.eat(symbolRE)) {\n            source.skipToEnd();\n            return \"comment\";\n          }\n        }\n\n        var t = \"variable\";\n\n        if (ch == ':') {\n          t = \"variable-2\";\n        }\n\n        source.eatWhile(symbolRE);\n        return t;\n      }\n\n      return \"error\";\n    }\n\n    function ncomment(type, nest) {\n      if (nest == 0) {\n        return normal;\n      }\n\n      return function (source, setState) {\n        var currNest = nest;\n\n        while (!source.eol()) {\n          var ch = source.next();\n\n          if (ch == '{' && source.eat('-')) {\n            ++currNest;\n          } else if (ch == '-' && source.eat('}')) {\n            --currNest;\n\n            if (currNest == 0) {\n              setState(normal);\n              return type;\n            }\n          }\n        }\n\n        setState(ncomment(type, currNest));\n        return type;\n      };\n    }\n\n    function stringLiteral(source, setState) {\n      while (!source.eol()) {\n        var ch = source.next();\n\n        if (ch == '\"') {\n          setState(normal);\n          return \"string\";\n        }\n\n        if (ch == '\\\\') {\n          if (source.eol() || source.eat(whiteCharRE)) {\n            setState(stringGap);\n            return \"string\";\n          }\n\n          if (source.eat('&')) {} else {\n            source.next(); // should handle other escapes here\n          }\n        }\n      }\n\n      setState(normal);\n      return \"string error\";\n    }\n\n    function stringGap(source, setState) {\n      if (source.eat('\\\\')) {\n        return switchState(source, setState, stringLiteral);\n      }\n\n      source.next();\n      setState(normal);\n      return \"error\";\n    }\n\n    var wellKnownWords = function () {\n      var wkw = {};\n\n      function setType(t) {\n        return function () {\n          for (var i = 0; i < arguments.length; i++) {\n            wkw[arguments[i]] = t;\n          }\n        };\n      }\n\n      setType(\"keyword\")(\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\", \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n      setType(\"keyword\")(\"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n      setType(\"builtin\")(\"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\", \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"*>\", \"**\");\n      setType(\"builtin\")(\"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\", \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\", \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\", \"String\", \"True\");\n      setType(\"builtin\")(\"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\", \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\", \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\", \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\", \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\", \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\", \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\", \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\", \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\", \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\", \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\", \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\", \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\", \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\", \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\", \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\", \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\", \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\", \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\", \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\", \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\", \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\", \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\", \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\", \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\", \"zip3\", \"zipWith\", \"zipWith3\");\n      var override = modeConfig.overrideKeywords;\n      if (override) for (var word in override) {\n        if (override.hasOwnProperty(word)) wkw[word] = override[word];\n      }\n      return wkw;\n    }();\n\n    return {\n      startState: function startState() {\n        return {\n          f: normal\n        };\n      },\n      copyState: function copyState(s) {\n        return {\n          f: s.f\n        };\n      },\n      token: function token(stream, state) {\n        var t = state.f(stream, function (s) {\n          state.f = s;\n        });\n        var w = stream.current();\n        return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n      },\n      blockCommentStart: \"{-\",\n      blockCommentEnd: \"-}\",\n      lineComment: \"--\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haskell\", \"haskell\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9oYXNrZWxsL2hhc2tlbGwuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBLENBQUMsVUFBU0EsR0FBVCxFQUFjO0VBQ2IsSUFBSSxzQkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QixzQkFBT0MsTUFBUCxNQUFpQixRQUFuRCxFQUE2RDtJQUMzREYsR0FBRyxDQUFDRyxtQkFBTyxDQUFDLG1KQUFELENBQVIsQ0FBSCxDQURGLEtBRUssSUFBSSxJQUFKLEVBQStDO0lBQ2xEQyxpQ0FBTyxDQUFDLG1KQUFELENBQUQsb0NBQTJCSixHQUEzQjtBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURHLEtBRUE7SUFDSEEsRUFBQTtBQUNILENBUEQsRUFPRyxVQUFTTSxVQUFULEVBQXFCO0VBQ3hCOztFQUVBQSxVQUFVLENBQUNDLFVBQVgsQ0FBc0IsU0FBdEIsRUFBaUMsVUFBU0MsT0FBVCxFQUFrQkMsVUFBbEIsRUFBOEI7SUFFN0QsU0FBU0MsV0FBVCxDQUFxQkMsTUFBckIsRUFBNkJDLFFBQTdCLEVBQXVDQyxDQUF2QyxFQUEwQztNQUN4Q0QsUUFBUSxDQUFDQyxDQUFELENBQVI7TUFDQSxPQUFPQSxDQUFDLENBQUNGLE1BQUQsRUFBU0MsUUFBVCxDQUFSO0lBQ0QsQ0FMNEQsQ0FPN0Q7OztJQUNBLElBQUlFLE9BQU8sR0FBRyxRQUFkO0lBQ0EsSUFBSUMsT0FBTyxHQUFHLE9BQWQ7SUFDQSxJQUFJQyxPQUFPLEdBQUcsSUFBZDtJQUNBLElBQUlDLE9BQU8sR0FBRyxhQUFkO0lBQ0EsSUFBSUMsT0FBTyxHQUFHLE9BQWQ7SUFDQSxJQUFJQyxJQUFJLEdBQUcsMEJBQVg7SUFDQSxJQUFJQyxRQUFRLEdBQUcsMEJBQWY7SUFDQSxJQUFJQyxTQUFTLEdBQUcsY0FBaEI7SUFDQSxJQUFJQyxXQUFXLEdBQUcsV0FBbEIsQ0FoQjZELENBZ0I5Qjs7SUFFL0IsU0FBU0MsTUFBVCxD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Q0FSSTtNQVVMNEIsaUJBQWlCLEVBQUUsSUFWZDtNQVdMQyxlQUFlLEVBQUUsSUFYWjtNQVlMQyxXQUFXLEVBQUU7SUFaUixDQUFQO0VBZUQsQ0ExUEQ7RUE0UEFyRCxVQUFVLENBQUNzRCxVQUFYLENBQXNCLGdCQUF0QixFQUF3QyxTQUF4QztBQUVDLENBeFFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL21vZGUvaGFza2VsbC9oYXNrZWxsLmpzPzhlY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJoYXNrZWxsXCIsIGZ1bmN0aW9uKF9jb25maWcsIG1vZGVDb25maWcpIHtcblxuICBmdW5jdGlvbiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBmKSB7XG4gICAgc2V0U3RhdGUoZik7XG4gICAgcmV0dXJuIGYoc291cmNlLCBzZXRTdGF0ZSk7XG4gIH1cblxuICAvLyBUaGVzZSBzaG91bGQgYWxsIGJlIFVuaWNvZGUgZXh0ZW5kZWQsIGFzIHBlciB0aGUgSGFza2VsbCAyMDEwIHJlcG9ydFxuICB2YXIgc21hbGxSRSA9IC9bYS16X10vO1xuICB2YXIgbGFyZ2VSRSA9IC9bQS1aXS87XG4gIHZhciBkaWdpdFJFID0gL1xcZC87XG4gIHZhciBoZXhpdFJFID0gL1swLTlBLUZhLWZdLztcbiAgdmFyIG9jdGl0UkUgPSAvWzAtN10vO1xuICB2YXIgaWRSRSA9IC9bYS16X0EtWjAtOSdcXHhhMS1cXHVmZmZmXS87XG4gIHZhciBzeW1ib2xSRSA9IC9bLSEjJCUmKisuXFwvPD0+P0BcXFxcXnx+Ol0vO1xuICB2YXIgc3BlY2lhbFJFID0gL1soKSw7W1xcXWB7fV0vO1xuICB2YXIgd2hpdGVDaGFyUkUgPSAvWyBcXHRcXHZcXGZdLzsgLy8gbmV3bGluZXMgYXJlIGhhbmRsZWQgaW4gdG9rZW5pemVyXG5cbiAgZnVuY3Rpb24gbm9ybWFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICBpZiAoc291cmNlLmVhdFdoaWxlKHdoaXRlQ2hhclJFKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICBpZiAoc3BlY2lhbFJFLnRlc3QoY2gpKSB7XG4gICAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgICB2YXIgdCA9IFwiY29tbWVudFwiO1xuICAgICAgICBpZiAoc291cmNlLmVhdCgnIycpKSB7XG4gICAgICAgICAgdCA9IFwibWV0YVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBuY29tbWVudCh0LCAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICAgICAgc291cmNlLm5leHQoKTsgIC8vIHNob3VsZCBoYW5kbGUgb3RoZXIgZXNjYXBlcyBoZXJlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc291cmNlLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KCdcXCcnKSkge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZyBlcnJvclwiO1xuICAgIH1cblxuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgaWYgKGxhcmdlUkUudGVzdChjaCkpIHtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCcuJykpIHtcbiAgICAgICAgcmV0dXJuIFwicXVhbGlmaWVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfVxuXG4gICAgaWYgKHNtYWxsUkUudGVzdChjaCkpIHtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICAgIGlmIChjaCA9PSAnMCcpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5lYXQoL1t4WF0vKSkge1xuICAgICAgICAgIHNvdXJjZS5lYXRXaGlsZShoZXhpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICAgIHJldHVybiBcImludGVnZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLmVhdCgvW29PXS8pKSB7XG4gICAgICAgICAgc291cmNlLmVhdFdoaWxlKG9jdGl0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICAgIHZhciB0ID0gXCJudW1iZXJcIjtcbiAgICAgIGlmIChzb3VyY2UubWF0Y2goL15cXC5cXGQrLykpIHtcbiAgICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmVhdCgvW2VFXS8pKSB7XG4gICAgICAgIHQgPSBcIm51bWJlclwiO1xuICAgICAgICBzb3VyY2UuZWF0KC9bLStdLyk7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoID09IFwiLlwiICYmIHNvdXJjZS5lYXQoXCIuXCIpKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgaWYgKHN5bWJvbFJFLnRlc3QoY2gpKSB7XG4gICAgICBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoLy0vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUoLy0vKTtcbiAgICAgICAgaWYgKCFzb3VyY2UuZWF0KHN5bWJvbFJFKSkge1xuICAgICAgICAgIHNvdXJjZS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0ID0gXCJ2YXJpYWJsZVwiO1xuICAgICAgaWYgKGNoID09ICc6Jykge1xuICAgICAgICB0ID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoc3ltYm9sUkUpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5jb21tZW50KHR5cGUsIG5lc3QpIHtcbiAgICBpZiAobmVzdCA9PSAwKSB7XG4gICAgICByZXR1cm4gbm9ybWFsO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSkge1xuICAgICAgdmFyIGN1cnJOZXN0ID0gbmVzdDtcbiAgICAgIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICAgIGlmIChjaCA9PSAneycgJiYgc291cmNlLmVhdCgnLScpKSB7XG4gICAgICAgICAgKytjdXJyTmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PSAnLScgJiYgc291cmNlLmVhdCgnfScpKSB7XG4gICAgICAgICAgLS1jdXJyTmVzdDtcbiAgICAgICAgICBpZiAoY3Vyck5lc3QgPT0gMCkge1xuICAgICAgICAgICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0U3RhdGUobmNvbW1lbnQodHlwZSwgY3Vyck5lc3QpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdMaXRlcmFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICB3aGlsZSAoIXNvdXJjZS5lb2woKSkge1xuICAgICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09ICdcXFxcJykge1xuICAgICAgICBpZiAoc291cmNlLmVvbCgpIHx8IHNvdXJjZS5lYXQod2hpdGVDaGFyUkUpKSB7XG4gICAgICAgICAgc2V0U3RhdGUoc3RyaW5nR2FwKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLmVhdCgnJicpKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc291cmNlLm5leHQoKTsgLy8gc2hvdWxkIGhhbmRsZSBvdGhlciBlc2NhcGVzIGhlcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0ZShub3JtYWwpO1xuICAgIHJldHVybiBcInN0cmluZyBlcnJvclwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nR2FwKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gICAgfVxuICAgIHNvdXJjZS5uZXh0KCk7XG4gICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICB9XG5cblxuICB2YXIgd2VsbEtub3duV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdrdyA9IHt9O1xuICAgIGZ1bmN0aW9uIHNldFR5cGUodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgd2t3W2FyZ3VtZW50c1tpXV0gPSB0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICAgIFwiY2FzZVwiLCBcImNsYXNzXCIsIFwiZGF0YVwiLCBcImRlZmF1bHRcIiwgXCJkZXJpdmluZ1wiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZvcmVpZ25cIixcbiAgICAgIFwiaWZcIiwgXCJpbXBvcnRcIiwgXCJpblwiLCBcImluZml4XCIsIFwiaW5maXhsXCIsIFwiaW5maXhyXCIsIFwiaW5zdGFuY2VcIiwgXCJsZXRcIixcbiAgICAgIFwibW9kdWxlXCIsIFwibmV3dHlwZVwiLCBcIm9mXCIsIFwidGhlblwiLCBcInR5cGVcIiwgXCJ3aGVyZVwiLCBcIl9cIik7XG5cbiAgICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICAgIFwiXFwuXFwuXCIsIFwiOlwiLCBcIjo6XCIsIFwiPVwiLCBcIlxcXFxcIiwgXCI8LVwiLCBcIi0+XCIsIFwiQFwiLCBcIn5cIiwgXCI9PlwiKTtcblxuICAgIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgICAgXCIhIVwiLCBcIiQhXCIsIFwiJFwiLCBcIiYmXCIsIFwiK1wiLCBcIisrXCIsIFwiLVwiLCBcIi5cIiwgXCIvXCIsIFwiLz1cIiwgXCI8XCIsIFwiPCpcIiwgXCI8PVwiLFxuICAgICAgXCI8JD5cIiwgXCI8Kj5cIiwgXCI9PDxcIiwgXCI9PVwiLCBcIj5cIiwgXCI+PVwiLCBcIj4+XCIsIFwiPj49XCIsIFwiXlwiLCBcIl5eXCIsIFwifHxcIiwgXCIqXCIsXG4gICAgICBcIio+XCIsIFwiKipcIik7XG5cbiAgICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICAgIFwiQXBwbGljYXRpdmVcIiwgXCJCb29sXCIsIFwiQm91bmRlZFwiLCBcIkNoYXJcIiwgXCJEb3VibGVcIiwgXCJFUVwiLCBcIkVpdGhlclwiLCBcIkVudW1cIixcbiAgICAgIFwiRXFcIiwgXCJGYWxzZVwiLCBcIkZpbGVQYXRoXCIsIFwiRmxvYXRcIiwgXCJGbG9hdGluZ1wiLCBcIkZyYWN0aW9uYWxcIiwgXCJGdW5jdG9yXCIsXG4gICAgICBcIkdUXCIsIFwiSU9cIiwgXCJJT0Vycm9yXCIsIFwiSW50XCIsIFwiSW50ZWdlclwiLCBcIkludGVncmFsXCIsIFwiSnVzdFwiLCBcIkxUXCIsIFwiTGVmdFwiLFxuICAgICAgXCJNYXliZVwiLCBcIk1vbmFkXCIsIFwiTm90aGluZ1wiLCBcIk51bVwiLCBcIk9yZFwiLCBcIk9yZGVyaW5nXCIsIFwiUmF0aW9uYWxcIiwgXCJSZWFkXCIsXG4gICAgICBcIlJlYWRTXCIsIFwiUmVhbFwiLCBcIlJlYWxGbG9hdFwiLCBcIlJlYWxGcmFjXCIsIFwiUmlnaHRcIiwgXCJTaG93XCIsIFwiU2hvd1NcIixcbiAgICAgIFwiU3RyaW5nXCIsIFwiVHJ1ZVwiKTtcblxuICAgIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgICAgXCJhYnNcIiwgXCJhY29zXCIsIFwiYWNvc2hcIiwgXCJhbGxcIiwgXCJhbmRcIiwgXCJhbnlcIiwgXCJhcHBlbmRGaWxlXCIsIFwiYXNUeXBlT2ZcIixcbiAgICAgIFwiYXNpblwiLCBcImFzaW5oXCIsIFwiYXRhblwiLCBcImF0YW4yXCIsIFwiYXRhbmhcIiwgXCJicmVha1wiLCBcImNhdGNoXCIsIFwiY2VpbGluZ1wiLFxuICAgICAgXCJjb21wYXJlXCIsIFwiY29uY2F0XCIsIFwiY29uY2F0TWFwXCIsIFwiY29uc3RcIiwgXCJjb3NcIiwgXCJjb3NoXCIsIFwiY3VycnlcIixcbiAgICAgIFwiY3ljbGVcIiwgXCJkZWNvZGVGbG9hdFwiLCBcImRpdlwiLCBcImRpdk1vZFwiLCBcImRyb3BcIiwgXCJkcm9wV2hpbGVcIiwgXCJlaXRoZXJcIixcbiAgICAgIFwiZWxlbVwiLCBcImVuY29kZUZsb2F0XCIsIFwiZW51bUZyb21cIiwgXCJlbnVtRnJvbVRoZW5cIiwgXCJlbnVtRnJvbVRoZW5Ub1wiLFxuICAgICAgXCJlbnVtRnJvbVRvXCIsIFwiZXJyb3JcIiwgXCJldmVuXCIsIFwiZXhwXCIsIFwiZXhwb25lbnRcIiwgXCJmYWlsXCIsIFwiZmlsdGVyXCIsXG4gICAgICBcImZsaXBcIiwgXCJmbG9hdERpZ2l0c1wiLCBcImZsb2F0UmFkaXhcIiwgXCJmbG9hdFJhbmdlXCIsIFwiZmxvb3JcIiwgXCJmbWFwXCIsXG4gICAgICBcImZvbGRsXCIsIFwiZm9sZGwxXCIsIFwiZm9sZHJcIiwgXCJmb2xkcjFcIiwgXCJmcm9tRW51bVwiLCBcImZyb21JbnRlZ2VyXCIsXG4gICAgICBcImZyb21JbnRlZ3JhbFwiLCBcImZyb21SYXRpb25hbFwiLCBcImZzdFwiLCBcImdjZFwiLCBcImdldENoYXJcIiwgXCJnZXRDb250ZW50c1wiLFxuICAgICAgXCJnZXRMaW5lXCIsIFwiaGVhZFwiLCBcImlkXCIsIFwiaW5pdFwiLCBcImludGVyYWN0XCIsIFwiaW9FcnJvclwiLCBcImlzRGVub3JtYWxpemVkXCIsXG4gICAgICBcImlzSUVFRVwiLCBcImlzSW5maW5pdGVcIiwgXCJpc05hTlwiLCBcImlzTmVnYXRpdmVaZXJvXCIsIFwiaXRlcmF0ZVwiLCBcImxhc3RcIixcbiAgICAgIFwibGNtXCIsIFwibGVuZ3RoXCIsIFwibGV4XCIsIFwibGluZXNcIiwgXCJsb2dcIiwgXCJsb2dCYXNlXCIsIFwibG9va3VwXCIsIFwibWFwXCIsXG4gICAgICBcIm1hcE1cIiwgXCJtYXBNX1wiLCBcIm1heFwiLCBcIm1heEJvdW5kXCIsIFwibWF4aW11bVwiLCBcIm1heWJlXCIsIFwibWluXCIsIFwibWluQm91bmRcIixcbiAgICAgIFwibWluaW11bVwiLCBcIm1vZFwiLCBcIm5lZ2F0ZVwiLCBcIm5vdFwiLCBcIm5vdEVsZW1cIiwgXCJudWxsXCIsIFwib2RkXCIsIFwib3JcIixcbiAgICAgIFwib3RoZXJ3aXNlXCIsIFwicGlcIiwgXCJwcmVkXCIsIFwicHJpbnRcIiwgXCJwcm9kdWN0XCIsIFwicHJvcGVyRnJhY3Rpb25cIiwgXCJwdXJlXCIsXG4gICAgICBcInB1dENoYXJcIiwgXCJwdXRTdHJcIiwgXCJwdXRTdHJMblwiLCBcInF1b3RcIiwgXCJxdW90UmVtXCIsIFwicmVhZFwiLCBcInJlYWRGaWxlXCIsXG4gICAgICBcInJlYWRJT1wiLCBcInJlYWRMaXN0XCIsIFwicmVhZExuXCIsIFwicmVhZFBhcmVuXCIsIFwicmVhZHNcIiwgXCJyZWFkc1ByZWNcIixcbiAgICAgIFwicmVhbFRvRnJhY1wiLCBcInJlY2lwXCIsIFwicmVtXCIsIFwicmVwZWF0XCIsIFwicmVwbGljYXRlXCIsIFwicmV0dXJuXCIsIFwicmV2ZXJzZVwiLFxuICAgICAgXCJyb3VuZFwiLCBcInNjYWxlRmxvYXRcIiwgXCJzY2FubFwiLCBcInNjYW5sMVwiLCBcInNjYW5yXCIsIFwic2NhbnIxXCIsIFwic2VxXCIsXG4gICAgICBcInNlcXVlbmNlXCIsIFwic2VxdWVuY2VfXCIsIFwic2hvd1wiLCBcInNob3dDaGFyXCIsIFwic2hvd0xpc3RcIiwgXCJzaG93UGFyZW5cIixcbiAgICAgIFwic2hvd1N0cmluZ1wiLCBcInNob3dzXCIsIFwic2hvd3NQcmVjXCIsIFwic2lnbmlmaWNhbmRcIiwgXCJzaWdudW1cIiwgXCJzaW5cIixcbiAgICAgIFwic2luaFwiLCBcInNuZFwiLCBcInNwYW5cIiwgXCJzcGxpdEF0XCIsIFwic3FydFwiLCBcInN1YnRyYWN0XCIsIFwic3VjY1wiLCBcInN1bVwiLFxuICAgICAgXCJ0YWlsXCIsIFwidGFrZVwiLCBcInRha2VXaGlsZVwiLCBcInRhblwiLCBcInRhbmhcIiwgXCJ0b0VudW1cIiwgXCJ0b0ludGVnZXJcIixcbiAgICAgIFwidG9SYXRpb25hbFwiLCBcInRydW5jYXRlXCIsIFwidW5jdXJyeVwiLCBcInVuZGVmaW5lZFwiLCBcInVubGluZXNcIiwgXCJ1bnRpbFwiLFxuICAgICAgXCJ1bndvcmRzXCIsIFwidW56aXBcIiwgXCJ1bnppcDNcIiwgXCJ1c2VyRXJyb3JcIiwgXCJ3b3Jkc1wiLCBcIndyaXRlRmlsZVwiLCBcInppcFwiLFxuICAgICAgXCJ6aXAzXCIsIFwiemlwV2l0aFwiLCBcInppcFdpdGgzXCIpO1xuXG4gICAgdmFyIG92ZXJyaWRlID0gbW9kZUNvbmZpZy5vdmVycmlkZUtleXdvcmRzO1xuICAgIGlmIChvdmVycmlkZSkgZm9yICh2YXIgd29yZCBpbiBvdmVycmlkZSkgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgd2t3W3dvcmRdID0gb3ZlcnJpZGVbd29yZF07XG5cbiAgICByZXR1cm4gd2t3O1xuICB9KSgpO1xuXG5cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpICB7IHJldHVybiB7IGY6IG5vcm1hbCB9OyB9LFxuICAgIGNvcHlTdGF0ZTogIGZ1bmN0aW9uIChzKSB7IHJldHVybiB7IGY6IHMuZiB9OyB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciB0ID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgICAgdmFyIHcgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgcmV0dXJuIHdlbGxLbm93bldvcmRzLmhhc093blByb3BlcnR5KHcpID8gd2VsbEtub3duV29yZHNbd10gOiB0O1xuICAgIH0sXG5cbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCJ7LVwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCItfVwiLFxuICAgIGxpbmVDb21tZW50OiBcIi0tXCJcbiAgfTtcblxufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1oYXNrZWxsXCIsIFwiaGFza2VsbFwiKTtcblxufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwiZGVmaW5lTW9kZSIsIl9jb25maWciLCJtb2RlQ29uZmlnIiwic3dpdGNoU3RhdGUiLCJzb3VyY2UiLCJzZXRTdGF0ZSIsImYiLCJzbWFsbFJFIiwibGFyZ2VSRSIsImRpZ2l0UkUiLCJoZXhpdFJFIiwib2N0aXRSRSIsImlkUkUiLCJzeW1ib2xSRSIsInNwZWNpYWxSRSIsIndoaXRlQ2hhclJFIiwibm9ybWFsIiwiZWF0V2hpbGUiLCJjaCIsIm5leHQiLCJ0ZXN0IiwiZWF0IiwidCIsIm5jb21tZW50Iiwic3RyaW5nTGl0ZXJhbCIsIm1hdGNoIiwic2tpcFRvRW5kIiwidHlwZSIsIm5lc3QiLCJjdXJyTmVzdCIsImVvbCIsInN0cmluZ0dhcCIsIndlbGxLbm93bldvcmRzIiwid2t3Iiwic2V0VHlwZSIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJvdmVycmlkZSIsIm92ZXJyaWRlS2V5d29yZHMiLCJ3b3JkIiwiaGFzT3duUHJvcGVydHkiLCJzdGFydFN0YXRlIiwiY29weVN0YXRlIiwicyIsInRva2VuIiwic3RyZWFtIiwic3RhdGUiLCJ3IiwiY3VycmVudCIsImJsb2NrQ29tbWVudFN0YXJ0IiwiYmxvY2tDb21tZW50RW5kIiwibGluZUNvbW1lbnQiLCJkZWZpbmVNSU1FIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/haskell/haskell.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/haskell/haskell.js");
/******/ 	
/******/ })()
;