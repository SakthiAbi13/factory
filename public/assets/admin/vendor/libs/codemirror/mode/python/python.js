/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/mode/python/python.js":
/*!***********************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/mode/python/python.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"lambda\", \"pass\", \"raise\", \"return\", \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\", \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\", \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\", \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\", \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\", \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\", \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function (conf, parserConf) {\n    var ERRORCLASS = \"error\";\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/; //               (Backwards-compatibility with old, cumbersome config system)\n\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters, parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/];\n\n    for (var i = 0; i < operators.length; i++) {\n      if (!operators[i]) operators.splice(i--, 1);\n    }\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n    var myKeywords = commonKeywords,\n        myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined) myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    if (parserConf.extra_builtins != undefined) myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\", \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\", \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins); // tokenizers\n\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\";\n      if (sol) state.indent = stream.indentation(); // Handle scope changes\n\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset) pushPyScope(state);else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\") state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state)) style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state, inFormat) {\n      if (stream.eatSpace()) return null; // Handle Comments\n\n      if (!inFormat && stream.match(/^#.*/)) return \"comment\"; // Handle Number Literals\n\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^[\\d_]+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^\\.\\d+/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true; // Binary\n\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true; // Octal\n\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true; // Decimal\n\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i); // TODO - Can you have imaginary longs?\n\n          intLiteral = true;\n        } // Zero by itself with no other piece of number.\n\n\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++) {\n        if (stream.match(operators[i])) return \"operator\";\n      }\n\n      if (stream.match(delimiters)) return \"punctuation\";\n      if (state.lastToken == \".\" && stream.match(identifiers)) return \"property\";\n      if (stream.match(keywords) || stream.match(wordOperators)) return \"keyword\";\n      if (stream.match(builtins)) return \"builtin\";\n      if (stream.match(/^(self|cls)\\b/)) return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\") return \"def\";\n        return \"variable\";\n      } // Handle non-detected items\n\n\n      stream.next();\n      return inFormat ? null : ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function (stream, state) {\n          var inner = tokenBaseInner(stream, state, true);\n\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1);\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);else state.tokenize = tokenString;\n            }\n          }\n\n          return inner;\n        };\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0);\n            if (stream.current()) return OUTCLASS;else return state.tokenize(stream, state);\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") {\n        state.scopes.pop();\n      }\n\n      state.scopes.push({\n        offset: top(state).offset + conf.indentUnit,\n        type: \"py\",\n        align: null\n      });\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1;\n      state.scopes.push({\n        offset: state.indent + hangingIndent,\n        type: type,\n        align: align\n      });\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) {\n        state.beginningOfLine = true;\n        state.dedent = false;\n      }\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle decorators\n\n      if (state.beginningOfLine && current == \"@\") return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n      if ((style == \"variable\" || style == \"builtin\") && state.lastToken == \"meta\") style = \"meta\"; // Handle scope changes.\n\n      if (current == \"pass\" || current == \"return\") state.dedent = true;\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false)) pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1) pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n        delimiter_index = \"])}\".indexOf(current);\n\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent;else return ERRORCLASS;\n        }\n      }\n\n      if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1) state.scopes.pop();\n      return style;\n    }\n\n    var external = {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{\n            offset: basecolumn || 0,\n            type: \"py\",\n            align: null\n          }],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n      token: function token(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n        if (style && style != \"comment\") state.lastToken = style == \"keyword\" || style == \"punctuation\" ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n        if (stream.eol() && state.lambda) state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase) return state.tokenize.isString ? CodeMirror.Pass : 0;\n        var scope = top(state);\n        var closing = scope.type == textAfter.charAt(0) || scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter);\n        if (scope.align != null) return scope.align - (closing ? 1 : 0);else return scope.offset - (closing ? hangingIndent : 0);\n      },\n      electricInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      closeBrackets: {\n        triples: \"'\\\"\"\n      },\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function words(str) {\n    return str.split(\" \");\n  };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \" + \"extern gil include nogil property public \" + \"readonly struct union DEF IF ELIF ELSE\")\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9weXRob24vcHl0aG9uLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN0Qjs7RUFFQSxTQUFTQyxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtJQUN6QixPQUFPLElBQUlDLE1BQUosQ0FBVyxRQUFRRCxLQUFLLENBQUNFLElBQU4sQ0FBVyxLQUFYLENBQVIsR0FBNEIsT0FBdkMsQ0FBUDtFQUNEOztFQUVELElBQUlDLGFBQWEsR0FBR0osVUFBVSxDQUFDLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxLQUFkLEVBQXFCLElBQXJCLENBQUQsQ0FBOUI7RUFDQSxJQUFJSyxjQUFjLEdBQUcsQ0FBQyxJQUFELEVBQU8sUUFBUCxFQUFpQixPQUFqQixFQUEwQixPQUExQixFQUFtQyxVQUFuQyxFQUNDLEtBREQsRUFDUSxLQURSLEVBQ2UsTUFEZixFQUN1QixNQUR2QixFQUMrQixRQUQvQixFQUN5QyxTQUR6QyxFQUVDLEtBRkQsRUFFUSxNQUZSLEVBRWdCLFFBRmhCLEVBRTBCLElBRjFCLEVBRWdDLFFBRmhDLEVBR0MsUUFIRCxFQUdXLE1BSFgsRUFHbUIsT0FIbkIsRUFHNEIsUUFINUIsRUFJQyxLQUpELEVBSVEsT0FKUixFQUlpQixNQUpqQixFQUl5QixPQUp6QixF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Q0MsT0FBTyxFQUFFO01BQVYsQ0F4Q0Y7TUF5Q2JDLFdBQVcsRUFBRSxHQXpDQTtNQTBDYkMsSUFBSSxFQUFFO0lBMUNPLENBQWY7SUE0Q0EsT0FBT2IsUUFBUDtFQUNELENBNVZEO0VBOFZBakcsVUFBVSxDQUFDK0csVUFBWCxDQUFzQixlQUF0QixFQUF1QyxRQUF2Qzs7RUFFQSxJQUFJN0csS0FBSyxHQUFHLFNBQVJBLEtBQVEsQ0FBUzhHLEdBQVQsRUFBYztJQUFFLE9BQU9BLEdBQUcsQ0FBQ0MsS0FBSixDQUFVLEdBQVYsQ0FBUDtFQUF3QixDQUFwRDs7RUFFQWpILFVBQVUsQ0FBQytHLFVBQVgsQ0FBc0IsZUFBdEIsRUFBdUM7SUFDckNHLElBQUksRUFBRSxRQUQrQjtJQUVyQ25GLGNBQWMsRUFBRTdCLEtBQUssQ0FBQyxnREFDQSwyQ0FEQSxHQUVBLHdDQUZEO0VBRmdCLENBQXZDO0FBT0QsQ0E5WUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvbW9kZS9weXRob24vcHl0aG9uLmpzPzk4MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuICB9XG5cbiAgdmFyIHdvcmRPcGVyYXRvcnMgPSB3b3JkUmVnZXhwKFtcImFuZFwiLCBcIm9yXCIsIFwibm90XCIsIFwiaXNcIl0pO1xuICB2YXIgY29tbW9uS2V5d29yZHMgPSBbXCJhc1wiLCBcImFzc2VydFwiLCBcImJyZWFrXCIsIFwiY2xhc3NcIiwgXCJjb250aW51ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZcIiwgXCJkZWxcIiwgXCJlbGlmXCIsIFwiZWxzZVwiLCBcImV4Y2VwdFwiLCBcImZpbmFsbHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9yXCIsIFwiZnJvbVwiLCBcImdsb2JhbFwiLCBcImlmXCIsIFwiaW1wb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhbWJkYVwiLCBcInBhc3NcIiwgXCJyYWlzZVwiLCBcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJ5aWVsZFwiLCBcImluXCJdO1xuICB2YXIgY29tbW9uQnVpbHRpbnMgPSBbXCJhYnNcIiwgXCJhbGxcIiwgXCJhbnlcIiwgXCJiaW5cIiwgXCJib29sXCIsIFwiYnl0ZWFycmF5XCIsIFwiY2FsbGFibGVcIiwgXCJjaHJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NtZXRob2RcIiwgXCJjb21waWxlXCIsIFwiY29tcGxleFwiLCBcImRlbGF0dHJcIiwgXCJkaWN0XCIsIFwiZGlyXCIsIFwiZGl2bW9kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImVudW1lcmF0ZVwiLCBcImV2YWxcIiwgXCJmaWx0ZXJcIiwgXCJmbG9hdFwiLCBcImZvcm1hdFwiLCBcImZyb3plbnNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRhdHRyXCIsIFwiZ2xvYmFsc1wiLCBcImhhc2F0dHJcIiwgXCJoYXNoXCIsIFwiaGVscFwiLCBcImhleFwiLCBcImlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlucHV0XCIsIFwiaW50XCIsIFwiaXNpbnN0YW5jZVwiLCBcImlzc3ViY2xhc3NcIiwgXCJpdGVyXCIsIFwibGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpc3RcIiwgXCJsb2NhbHNcIiwgXCJtYXBcIiwgXCJtYXhcIiwgXCJtZW1vcnl2aWV3XCIsIFwibWluXCIsIFwibmV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiwgXCJvY3RcIiwgXCJvcGVuXCIsIFwib3JkXCIsIFwicG93XCIsIFwicHJvcGVydHlcIiwgXCJyYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXByXCIsIFwicmV2ZXJzZWRcIiwgXCJyb3VuZFwiLCBcInNldFwiLCBcInNldGF0dHJcIiwgXCJzbGljZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3J0ZWRcIiwgXCJzdGF0aWNtZXRob2RcIiwgXCJzdHJcIiwgXCJzdW1cIiwgXCJzdXBlclwiLCBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIiwgXCJ2YXJzXCIsIFwiemlwXCIsIFwiX19pbXBvcnRfX1wiLCBcIk5vdEltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkVsbGlwc2lzXCIsIFwiX19kZWJ1Z19fXCJdO1xuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwicHl0aG9uXCIsIGNvbW1vbktleXdvcmRzLmNvbmNhdChjb21tb25CdWlsdGlucykpO1xuXG4gIGZ1bmN0aW9uIHRvcChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zY29wZXNbc3RhdGUuc2NvcGVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicHl0aG9uXCIsIGZ1bmN0aW9uKGNvbmYsIHBhcnNlckNvbmYpIHtcbiAgICB2YXIgRVJST1JDTEFTUyA9IFwiZXJyb3JcIjtcblxuICAgIHZhciBkZWxpbWl0ZXJzID0gcGFyc2VyQ29uZi5kZWxpbWl0ZXJzIHx8IHBhcnNlckNvbmYuc2luZ2xlRGVsaW1pdGVycyB8fCAvXltcXChcXClcXFtcXF1cXHtcXH1ALDpgPTtcXC5cXFxcXS87XG4gICAgLy8gICAgICAgICAgICAgICAoQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBvbGQsIGN1bWJlcnNvbWUgY29uZmlnIHN5c3RlbSlcbiAgICB2YXIgb3BlcmF0b3JzID0gW3BhcnNlckNvbmYuc2luZ2xlT3BlcmF0b3JzLCBwYXJzZXJDb25mLmRvdWJsZU9wZXJhdG9ycywgcGFyc2VyQ29uZi5kb3VibGVEZWxpbWl0ZXJzLCBwYXJzZXJDb25mLnRyaXBsZURlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICBwYXJzZXJDb25mLm9wZXJhdG9ycyB8fCAvXihbLSsqLyVcXC8mfF5dPT98Wzw+PV0rfFxcL1xcLz0/fFxcKlxcKj0/fCE9fFt+IUBdfFxcLlxcLlxcLikvXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3JzLmxlbmd0aDsgaSsrKSBpZiAoIW9wZXJhdG9yc1tpXSkgb3BlcmF0b3JzLnNwbGljZShpLS0sIDEpXG5cbiAgICB2YXIgaGFuZ2luZ0luZGVudCA9IHBhcnNlckNvbmYuaGFuZ2luZ0luZGVudCB8fCBjb25mLmluZGVudFVuaXQ7XG5cbiAgICB2YXIgbXlLZXl3b3JkcyA9IGNvbW1vbktleXdvcmRzLCBteUJ1aWx0aW5zID0gY29tbW9uQnVpbHRpbnM7XG4gICAgaWYgKHBhcnNlckNvbmYuZXh0cmFfa2V5d29yZHMgIT0gdW5kZWZpbmVkKVxuICAgICAgbXlLZXl3b3JkcyA9IG15S2V5d29yZHMuY29uY2F0KHBhcnNlckNvbmYuZXh0cmFfa2V5d29yZHMpO1xuXG4gICAgaWYgKHBhcnNlckNvbmYuZXh0cmFfYnVpbHRpbnMgIT0gdW5kZWZpbmVkKVxuICAgICAgbXlCdWlsdGlucyA9IG15QnVpbHRpbnMuY29uY2F0KHBhcnNlckNvbmYuZXh0cmFfYnVpbHRpbnMpO1xuXG4gICAgdmFyIHB5MyA9ICEocGFyc2VyQ29uZi52ZXJzaW9uICYmIE51bWJlcihwYXJzZXJDb25mLnZlcnNpb24pIDwgMylcbiAgICBpZiAocHkzKSB7XG4gICAgICAvLyBzaW5jZSBodHRwOi8vbGVnYWN5LnB5dGhvbi5vcmcvZGV2L3BlcHMvcGVwLTA0NjUvIEAgaXMgYWxzbyBhbiBvcGVyYXRvclxuICAgICAgdmFyIGlkZW50aWZpZXJzID0gcGFyc2VyQ29uZi5pZGVudGlmaWVyc3x8IC9eW19BLVphLXpcXHUwMEExLVxcdUZGRkZdW19BLVphLXowLTlcXHUwMEExLVxcdUZGRkZdKi87XG4gICAgICBteUtleXdvcmRzID0gbXlLZXl3b3Jkcy5jb25jYXQoW1wibm9ubG9jYWxcIiwgXCJGYWxzZVwiLCBcIlRydWVcIiwgXCJOb25lXCIsIFwiYXN5bmNcIiwgXCJhd2FpdFwiXSk7XG4gICAgICBteUJ1aWx0aW5zID0gbXlCdWlsdGlucy5jb25jYXQoW1wiYXNjaWlcIiwgXCJieXRlc1wiLCBcImV4ZWNcIiwgXCJwcmludFwiXSk7XG4gICAgICB2YXIgc3RyaW5nUHJlZml4ZXMgPSBuZXcgUmVnRXhwKFwiXigoW3JidWZdfChicil8KHJiKXwoZnIpfChyZikpPygnezN9fFxcXCJ7M318WydcXFwiXSkpXCIsIFwiaVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkZW50aWZpZXJzID0gcGFyc2VyQ29uZi5pZGVudGlmaWVyc3x8IC9eW19BLVphLXpdW19BLVphLXowLTldKi87XG4gICAgICBteUtleXdvcmRzID0gbXlLZXl3b3Jkcy5jb25jYXQoW1wiZXhlY1wiLCBcInByaW50XCJdKTtcbiAgICAgIG15QnVpbHRpbnMgPSBteUJ1aWx0aW5zLmNvbmNhdChbXCJhcHBseVwiLCBcImJhc2VzdHJpbmdcIiwgXCJidWZmZXJcIiwgXCJjbXBcIiwgXCJjb2VyY2VcIiwgXCJleGVjZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJpbnRlcm5cIiwgXCJsb25nXCIsIFwicmF3X2lucHV0XCIsIFwicmVkdWNlXCIsIFwicmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidW5pY2hyXCIsIFwidW5pY29kZVwiLCBcInhyYW5nZVwiLCBcIkZhbHNlXCIsIFwiVHJ1ZVwiLCBcIk5vbmVcIl0pO1xuICAgICAgdmFyIHN0cmluZ1ByZWZpeGVzID0gbmV3IFJlZ0V4cChcIl4oKFtydWJmXXwodXIpfChicikpPygnezN9fFxcXCJ7M318WydcXFwiXSkpXCIsIFwiaVwiKTtcbiAgICB9XG4gICAgdmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChteUtleXdvcmRzKTtcbiAgICB2YXIgYnVpbHRpbnMgPSB3b3JkUmVnZXhwKG15QnVpbHRpbnMpO1xuXG4gICAgLy8gdG9rZW5pemVyc1xuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgc29sID0gc3RyZWFtLnNvbCgpICYmIHN0YXRlLmxhc3RUb2tlbiAhPSBcIlxcXFxcIlxuICAgICAgaWYgKHNvbCkgc3RhdGUuaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKClcbiAgICAgIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzXG4gICAgICBpZiAoc29sICYmIHRvcChzdGF0ZSkudHlwZSA9PSBcInB5XCIpIHtcbiAgICAgICAgdmFyIHNjb3BlT2Zmc2V0ID0gdG9wKHN0YXRlKS5vZmZzZXQ7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgICAgaWYgKGxpbmVPZmZzZXQgPiBzY29wZU9mZnNldClcbiAgICAgICAgICAgIHB1c2hQeVNjb3BlKHN0YXRlKTtcbiAgICAgICAgICBlbHNlIGlmIChsaW5lT2Zmc2V0IDwgc2NvcGVPZmZzZXQgJiYgZGVkZW50KHN0cmVhbSwgc3RhdGUpICYmIHN0cmVhbS5wZWVrKCkgIT0gXCIjXCIpXG4gICAgICAgICAgICBzdGF0ZS5lcnJvclRva2VuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3R5bGUgPSB0b2tlbkJhc2VJbm5lcihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICBpZiAoc2NvcGVPZmZzZXQgPiAwICYmIGRlZGVudChzdHJlYW0sIHN0YXRlKSlcbiAgICAgICAgICAgIHN0eWxlICs9IFwiIFwiICsgRVJST1JDTEFTUztcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbkJhc2VJbm5lcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkJhc2VJbm5lcihzdHJlYW0sIHN0YXRlLCBpbkZvcm1hdCkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gSGFuZGxlIENvbW1lbnRzXG4gICAgICBpZiAoIWluRm9ybWF0ICYmIHN0cmVhbS5tYXRjaCgvXiMuKi8pKSByZXR1cm4gXCJjb21tZW50XCI7XG5cbiAgICAgIC8vIEhhbmRsZSBOdW1iZXIgTGl0ZXJhbHNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bMC05XFwuXS8sIGZhbHNlKSkge1xuICAgICAgICB2YXIgZmxvYXRMaXRlcmFsID0gZmFsc2U7XG4gICAgICAgIC8vIEZsb2F0c1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcZF9dKlxcLlxcZCsoZVtcXCtcXC1dP1xcZCspPy9pKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bXFxkX10rXFwuXFxkKi8pKSB7IGZsb2F0TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcLlxcZCsvKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgIGlmIChmbG9hdExpdGVyYWwpIHtcbiAgICAgICAgICAvLyBGbG9hdCBsaXRlcmFscyBtYXkgYmUgXCJpbWFnaW5hcnlcIlxuICAgICAgICAgIHN0cmVhbS5lYXQoL0ovaSk7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZWdlcnNcbiAgICAgICAgdmFyIGludExpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgLy8gSGV4XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14weFswLTlhLWZfXSsvaSkpIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgICAvLyBCaW5hcnlcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjBiWzAxX10rL2kpKSBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgLy8gT2N0YWxcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjBvWzAtN19dKy9pKSkgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIC8vIERlY2ltYWxcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlsxLTldW1xcZF9dKihlW1xcK1xcLV0/W1xcZF9dKyk/LykpIHtcbiAgICAgICAgICAvLyBEZWNpbWFsIGxpdGVyYWxzIG1heSBiZSBcImltYWdpbmFyeVwiXG4gICAgICAgICAgc3RyZWFtLmVhdCgvSi9pKTtcbiAgICAgICAgICAvLyBUT0RPIC0gQ2FuIHlvdSBoYXZlIGltYWdpbmFyeSBsb25ncz9cbiAgICAgICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBaZXJvIGJ5IGl0c2VsZiB3aXRoIG5vIG90aGVyIHBpZWNlIG9mIG51bWJlci5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjAoPyFbXFxkeF0pL2kpKSBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGludExpdGVyYWwpIHtcbiAgICAgICAgICAvLyBJbnRlZ2VyIGxpdGVyYWxzIG1heSBiZSBcImxvbmdcIlxuICAgICAgICAgIHN0cmVhbS5lYXQoL0wvaSk7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIFN0cmluZ3NcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goc3RyaW5nUHJlZml4ZXMpKSB7XG4gICAgICAgIHZhciBpc0ZtdFN0cmluZyA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmJykgIT09IC0xO1xuICAgICAgICBpZiAoIWlzRm10U3RyaW5nKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0ZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSwgc3RhdGUudG9rZW5pemUpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGZvcm1hdFN0cmluZ0ZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSwgc3RhdGUudG9rZW5pemUpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdG9ycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChvcGVyYXRvcnNbaV0pKSByZXR1cm4gXCJvcGVyYXRvclwiXG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goZGVsaW1pdGVycykpIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG5cbiAgICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSlcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykgfHwgc3RyZWFtLm1hdGNoKHdvcmRPcGVyYXRvcnMpKVxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goYnVpbHRpbnMpKVxuICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oc2VsZnxjbHMpXFxiLykpXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICAgICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PSBcImRlZlwiIHx8IHN0YXRlLmxhc3RUb2tlbiA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBub24tZGV0ZWN0ZWQgaXRlbXNcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gaW5Gb3JtYXQgPyBudWxsIDpFUlJPUkNMQVNTO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFN0cmluZ0ZhY3RvcnkoZGVsaW1pdGVyLCB0b2tlbk91dGVyKSB7XG4gICAgICB3aGlsZSAoXCJydWJmXCIuaW5kZXhPZihkZWxpbWl0ZXIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkpID49IDApXG4gICAgICAgIGRlbGltaXRlciA9IGRlbGltaXRlci5zdWJzdHIoMSk7XG5cbiAgICAgIHZhciBzaW5nbGVsaW5lID0gZGVsaW1pdGVyLmxlbmd0aCA9PSAxO1xuICAgICAgdmFyIE9VVENMQVNTID0gXCJzdHJpbmdcIjtcblxuICAgICAgZnVuY3Rpb24gdG9rZW5OZXN0ZWRFeHByKGRlcHRoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGlubmVyID0gdG9rZW5CYXNlSW5uZXIoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSlcbiAgICAgICAgICBpZiAoaW5uZXIgPT0gXCJwdW5jdHVhdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSA9PSBcIntcIikge1xuICAgICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkRXhwcihkZXB0aCArIDEpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5jdXJyZW50KCkgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMSkgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZEV4cHIoZGVwdGggLSAxKVxuICAgICAgICAgICAgICBlbHNlIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlubmVyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14nXCJcXHtcXH1cXFxcXS8pO1xuICAgICAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcXFwiKSkge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVsaW5lICYmIHN0cmVhbS5lb2woKSlcbiAgICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcikpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5PdXRlcjtcbiAgICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgne3snKSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIHt7IGluIGYtc3RyXG4gICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ3snLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIC8vIHN3aXRjaCB0byBuZXN0ZWQgbW9kZVxuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZEV4cHIoMClcbiAgICAgICAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpKSByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCd9fScpKSB7XG4gICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgLy8gc2luZ2xlIH0gaW4gZi1zdHJpbmcgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KC9bJ1wiXS8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICAgIGlmIChwYXJzZXJDb25mLnNpbmdsZUxpbmVTdHJpbmdFcnJvcnMpXG4gICAgICAgICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuT3V0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgfVxuICAgICAgdG9rZW5TdHJpbmcuaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRva2VuU3RyaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIsIHRva2VuT3V0ZXIpIHtcbiAgICAgIHdoaWxlIChcInJ1YmZcIi5pbmRleE9mKGRlbGltaXRlci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSkgPj0gMClcbiAgICAgICAgZGVsaW1pdGVyID0gZGVsaW1pdGVyLnN1YnN0cigxKTtcblxuICAgICAgdmFyIHNpbmdsZWxpbmUgPSBkZWxpbWl0ZXIubGVuZ3RoID09IDE7XG4gICAgICB2YXIgT1VUQ0xBU1MgPSBcInN0cmluZ1wiO1xuXG4gICAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXidcIlxcXFxdLyk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJcXFxcXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZWxpbmUgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goZGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KC9bJ1wiXS8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICAgIGlmIChwYXJzZXJDb25mLnNpbmdsZUxpbmVTdHJpbmdFcnJvcnMpXG4gICAgICAgICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuT3V0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgfVxuICAgICAgdG9rZW5TdHJpbmcuaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRva2VuU3RyaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hQeVNjb3BlKHN0YXRlKSB7XG4gICAgICB3aGlsZSAodG9wKHN0YXRlKS50eXBlICE9IFwicHlcIikgc3RhdGUuc2NvcGVzLnBvcCgpXG4gICAgICBzdGF0ZS5zY29wZXMucHVzaCh7b2Zmc2V0OiB0b3Aoc3RhdGUpLm9mZnNldCArIGNvbmYuaW5kZW50VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IG51bGx9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hCcmFja2V0U2NvcGUoc3RyZWFtLCBzdGF0ZSwgdHlwZSkge1xuICAgICAgdmFyIGFsaWduID0gc3RyZWFtLm1hdGNoKC9eW1xcc1xcW1xce1xcKF0qKD86I3wkKS8sIGZhbHNlKSA/IG51bGwgOiBzdHJlYW0uY29sdW1uKCkgKyAxXG4gICAgICBzdGF0ZS5zY29wZXMucHVzaCh7b2Zmc2V0OiBzdGF0ZS5pbmRlbnQgKyBoYW5naW5nSW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IGFsaWdufSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWRlbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICB3aGlsZSAoc3RhdGUuc2NvcGVzLmxlbmd0aCA+IDEgJiYgdG9wKHN0YXRlKS5vZmZzZXQgPiBpbmRlbnRlZCkge1xuICAgICAgICBpZiAodG9wKHN0YXRlKS50eXBlICE9IFwicHlcIikgcmV0dXJuIHRydWU7XG4gICAgICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b3Aoc3RhdGUpLm9mZnNldCAhPSBpbmRlbnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgc3RhdGUuYmVnaW5uaW5nT2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZGVkZW50ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gICAgICAvLyBIYW5kbGUgZGVjb3JhdG9yc1xuICAgICAgaWYgKHN0YXRlLmJlZ2lubmluZ09mTGluZSAmJiBjdXJyZW50ID09IFwiQFwiKVxuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzLCBmYWxzZSkgPyBcIm1ldGFcIiA6IHB5MyA/IFwib3BlcmF0b3JcIiA6IEVSUk9SQ0xBU1M7XG5cbiAgICAgIGlmICgvXFxTLy50ZXN0KGN1cnJlbnQpKSBzdGF0ZS5iZWdpbm5pbmdPZkxpbmUgPSBmYWxzZTtcblxuICAgICAgaWYgKChzdHlsZSA9PSBcInZhcmlhYmxlXCIgfHwgc3R5bGUgPT0gXCJidWlsdGluXCIpXG4gICAgICAgICAgJiYgc3RhdGUubGFzdFRva2VuID09IFwibWV0YVwiKVxuICAgICAgICBzdHlsZSA9IFwibWV0YVwiO1xuXG4gICAgICAvLyBIYW5kbGUgc2NvcGUgY2hhbmdlcy5cbiAgICAgIGlmIChjdXJyZW50ID09IFwicGFzc1wiIHx8IGN1cnJlbnQgPT0gXCJyZXR1cm5cIilcbiAgICAgICAgc3RhdGUuZGVkZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT0gXCJsYW1iZGFcIikgc3RhdGUubGFtYmRhID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50ID09IFwiOlwiICYmICFzdGF0ZS5sYW1iZGEgJiYgdG9wKHN0YXRlKS50eXBlID09IFwicHlcIiAmJiBzdHJlYW0ubWF0Y2goL15cXHMqKD86I3wkKS8sIGZhbHNlKSlcbiAgICAgICAgcHVzaFB5U2NvcGUoc3RhdGUpO1xuXG4gICAgICBpZiAoY3VycmVudC5sZW5ndGggPT0gMSAmJiAhL3N0cmluZ3xjb21tZW50Ly50ZXN0KHN0eWxlKSkge1xuICAgICAgICB2YXIgZGVsaW1pdGVyX2luZGV4ID0gXCJbKHtcIi5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgICBpZiAoZGVsaW1pdGVyX2luZGV4ICE9IC0xKVxuICAgICAgICAgIHB1c2hCcmFja2V0U2NvcGUoc3RyZWFtLCBzdGF0ZSwgXCJdKX1cIi5zbGljZShkZWxpbWl0ZXJfaW5kZXgsIGRlbGltaXRlcl9pbmRleCsxKSk7XG5cbiAgICAgICAgZGVsaW1pdGVyX2luZGV4ID0gXCJdKX1cIi5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgICBpZiAoZGVsaW1pdGVyX2luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgaWYgKHRvcChzdGF0ZSkudHlwZSA9PSBjdXJyZW50KSBzdGF0ZS5pbmRlbnQgPSBzdGF0ZS5zY29wZXMucG9wKCkub2Zmc2V0IC0gaGFuZ2luZ0luZGVudFxuICAgICAgICAgIGVsc2UgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5kZWRlbnQgJiYgc3RyZWFtLmVvbCgpICYmIHRvcChzdGF0ZSkudHlwZSA9PSBcInB5XCIgJiYgc3RhdGUuc2NvcGVzLmxlbmd0aCA+IDEpXG4gICAgICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHZhciBleHRlcm5hbCA9IHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgIHNjb3BlczogW3tvZmZzZXQ6IGJhc2Vjb2x1bW4gfHwgMCwgdHlwZTogXCJweVwiLCBhbGlnbjogbnVsbH1dLFxuICAgICAgICAgIGluZGVudDogYmFzZWNvbHVtbiB8fCAwLFxuICAgICAgICAgIGxhc3RUb2tlbjogbnVsbCxcbiAgICAgICAgICBsYW1iZGE6IGZhbHNlLFxuICAgICAgICAgIGRlZGVudDogMFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGFkZEVyciA9IHN0YXRlLmVycm9yVG9rZW47XG4gICAgICAgIGlmIChhZGRFcnIpIHN0YXRlLmVycm9yVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0eWxlID0gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgICBpZiAoc3R5bGUgJiYgc3R5bGUgIT0gXCJjb21tZW50XCIpXG4gICAgICAgICAgc3RhdGUubGFzdFRva2VuID0gKHN0eWxlID09IFwia2V5d29yZFwiIHx8IHN0eWxlID09IFwicHVuY3R1YXRpb25cIikgPyBzdHJlYW0uY3VycmVudCgpIDogc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcInB1bmN0dWF0aW9uXCIpIHN0eWxlID0gbnVsbDtcblxuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpICYmIHN0YXRlLmxhbWJkYSlcbiAgICAgICAgICBzdGF0ZS5sYW1iZGEgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGFkZEVyciA/IHN0eWxlICsgXCIgXCIgKyBFUlJPUkNMQVNTIDogc3R5bGU7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSlcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUuaXNTdHJpbmcgPyBDb2RlTWlycm9yLlBhc3MgOiAwO1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRvcChzdGF0ZSlcbiAgICAgICAgdmFyIGNsb3NpbmcgPSBzY29wZS50eXBlID09IHRleHRBZnRlci5jaGFyQXQoMCkgfHxcbiAgICAgICAgICAgIHNjb3BlLnR5cGUgPT0gXCJweVwiICYmICFzdGF0ZS5kZWRlbnQgJiYgL14oZWxzZTp8ZWxpZiB8ZXhjZXB0IHxmaW5hbGx5OikvLnRlc3QodGV4dEFmdGVyKVxuICAgICAgICBpZiAoc2NvcGUuYWxpZ24gIT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gc2NvcGUuYWxpZ24gLSAoY2xvc2luZyA/IDEgOiAwKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm9mZnNldCAtIChjbG9zaW5nID8gaGFuZ2luZ0luZGVudCA6IDApXG4gICAgICB9LFxuXG4gICAgICBlbGVjdHJpY0lucHV0OiAvXlxccyooW1xcfVxcXVxcKV18ZWxzZTp8ZWxpZiB8ZXhjZXB0IHxmaW5hbGx5OikkLyxcbiAgICAgIGNsb3NlQnJhY2tldHM6IHt0cmlwbGVzOiBcIidcXFwiXCJ9LFxuICAgICAgbGluZUNvbW1lbnQ6IFwiI1wiLFxuICAgICAgZm9sZDogXCJpbmRlbnRcIlxuICAgIH07XG4gICAgcmV0dXJuIGV4dGVybmFsO1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcHl0aG9uXCIsIFwicHl0aG9uXCIpO1xuXG4gIHZhciB3b3JkcyA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLnNwbGl0KFwiIFwiKTsgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtY3l0aG9uXCIsIHtcbiAgICBuYW1lOiBcInB5dGhvblwiLFxuICAgIGV4dHJhX2tleXdvcmRzOiB3b3JkcyhcImJ5IGNkZWYgY2ltcG9ydCBjcGRlZiBjdHlwZWRlZiBlbnVtIGV4Y2VwdCBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHRlcm4gZ2lsIGluY2x1ZGUgbm9naWwgcHJvcGVydHkgcHVibGljIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlYWRvbmx5IHN0cnVjdCB1bmlvbiBERUYgSUYgRUxJRiBFTFNFXCIpXG4gIH0pO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJ3b3JkUmVnZXhwIiwid29yZHMiLCJSZWdFeHAiLCJqb2luIiwid29yZE9wZXJhdG9ycyIsImNvbW1vbktleXdvcmRzIiwiY29tbW9uQnVpbHRpbnMiLCJyZWdpc3RlckhlbHBlciIsImNvbmNhdCIsInRvcCIsInN0YXRlIiwic2NvcGVzIiwibGVuZ3RoIiwiZGVmaW5lTW9kZSIsImNvbmYiLCJwYXJzZXJDb25mIiwiRVJST1JDTEFTUyIsImRlbGltaXRlcnMiLCJzaW5nbGVEZWxpbWl0ZXJzIiwib3BlcmF0b3JzIiwic2luZ2xlT3BlcmF0b3JzIiwiZG91YmxlT3BlcmF0b3JzIiwiZG91YmxlRGVsaW1pdGVycyIsInRyaXBsZURlbGltaXRlcnMiLCJpIiwic3BsaWNlIiwiaGFuZ2luZ0luZGVudCIsImluZGVudFVuaXQiLCJteUtleXdvcmRzIiwibXlCdWlsdGlucyIsImV4dHJhX2tleXdvcmRzIiwidW5kZWZpbmVkIiwiZXh0cmFfYnVpbHRpbnMiLCJweTMiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwiaWRlbnRpZmllcnMiLCJzdHJpbmdQcmVmaXhlcyIsImtleXdvcmRzIiwiYnVpbHRpbnMiLCJ0b2tlbkJhc2UiLCJzdHJlYW0iLCJzb2wiLCJsYXN0VG9rZW4iLCJpbmRlbnQiLCJpbmRlbnRhdGlvbiIsInR5cGUiLCJzY29wZU9mZnNldCIsIm9mZnNldCIsImVhdFNwYWNlIiwibGluZU9mZnNldCIsInB1c2hQeVNjb3BlIiwiZGVkZW50IiwicGVlayIsImVycm9yVG9rZW4iLCJzdHlsZSIsInRva2VuQmFzZUlubmVyIiwiaW5Gb3JtYXQiLCJtYXRjaCIsImZsb2F0TGl0ZXJhbCIsImVhdCIsImludExpdGVyYWwiLCJpc0ZtdFN0cmluZyIsImN1cnJlbnQiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJ0b2tlbml6ZSIsInRva2VuU3RyaW5nRmFjdG9yeSIsImZvcm1hdFN0cmluZ0ZhY3RvcnkiLCJuZXh0IiwiZGVsaW1pdGVyIiwidG9rZW5PdXRlciIsImNoYXJBdCIsInN1YnN0ciIsInNpbmdsZWxpbmUiLCJPVVRDTEFTUyIsInRva2VuTmVzdGVkRXhwciIsImRlcHRoIiwiaW5uZXIiLCJ0b2tlblN0cmluZyIsImVvbCIsImVhdFdoaWxlIiwic2luZ2xlTGluZVN0cmluZ0Vycm9ycyIsImlzU3RyaW5nIiwicG9wIiwicHVzaCIsImFsaWduIiwicHVzaEJyYWNrZXRTY29wZSIsImNvbHVtbiIsImluZGVudGVkIiwidG9rZW5MZXhlciIsImJlZ2lubmluZ09mTGluZSIsInRlc3QiLCJsYW1iZGEiLCJkZWxpbWl0ZXJfaW5kZXgiLCJzbGljZSIsImV4dGVybmFsIiwic3RhcnRTdGF0ZSIsImJhc2Vjb2x1bW4iLCJ0b2tlbiIsImFkZEVyciIsInRleHRBZnRlciIsIlBhc3MiLCJzY29wZSIsImNsb3NpbmciLCJlbGVjdHJpY0lucHV0IiwiY2xvc2VCcmFja2V0cyIsInRyaXBsZXMiLCJsaW5lQ29tbWVudCIsImZvbGQiLCJkZWZpbmVNSU1FIiwic3RyIiwic3BsaXQiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/mode/python/python.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/mode/python/python.js");
/******/ 	
/******/ })()
;