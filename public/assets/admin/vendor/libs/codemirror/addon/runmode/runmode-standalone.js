/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/addon/runmode/runmode-standalone.js":
/*!*************************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/runmode/runmode-standalone.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n(function () {\n  'use strict';\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) {\n      target = {};\n    }\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n        target[prop] = obj[prop];\n      }\n    }\n\n    return target;\n  } // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n\n\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n\n      if (end == -1) {\n        end = string.length;\n      }\n    }\n\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n\n      if (nextTab < 0 || nextTab >= end) {\n        return n + (end - i);\n      }\n\n      n += nextTab - i;\n      n += tabSize - n % tabSize;\n      i = nextTab + 1;\n    }\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n\n    if (props) {\n      copyObj(props, inst);\n    }\n\n    return inst;\n  } // STRING STREAM\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n\n  var StringStream = function StringStream(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {\n    return this.pos >= this.string.length;\n  };\n\n  StringStream.prototype.sol = function () {\n    return this.pos == this.lineStart;\n  };\n\n  StringStream.prototype.peek = function () {\n    return this.string.charAt(this.pos) || undefined;\n  };\n\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length) {\n      return this.string.charAt(this.pos++);\n    }\n  };\n\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n\n    if (typeof match == \"string\") {\n      ok = ch == match;\n    } else {\n      ok = ch && (match.test ? match.test(ch) : match(ch));\n    }\n\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  };\n\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n\n    while (this.eat(match)) {}\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n      ++this.pos;\n    }\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.skipToEnd = function () {\n    this.pos = this.string.length;\n  };\n\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  };\n\n  StringStream.prototype.backUp = function (n) {\n    this.pos -= n;\n  };\n\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function cased(str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n\n      var substr = this.string.substr(this.pos, pattern.length);\n\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) {\n          this.pos += pattern.length;\n        }\n\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n\n      if (match && match.index > 0) {\n        return null;\n      }\n\n      if (match && consume !== false) {\n        this.pos += match[0].length;\n      }\n\n      return match;\n    }\n  };\n\n  StringStream.prototype.current = function () {\n    return this.string.slice(this.start, this.pos);\n  };\n\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  };\n\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n);\n  };\n\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos);\n  }; // Known modes, by name and by MIME\n\n\n  var modes = {},\n      mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  function defineMode(name, mode) {\n    if (arguments.length > 2) {\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    }\n\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  } // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n\n\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n\n      if (typeof found == \"string\") {\n        found = {\n          name: found\n        };\n      }\n\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\");\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\");\n    }\n\n    if (typeof spec == \"string\") {\n      return {\n        name: spec\n      };\n    } else {\n      return spec || {\n        name: \"null\"\n      };\n    }\n  } // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n\n\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n\n    if (!mfactory) {\n      return getMode(options, \"text/plain\");\n    }\n\n    var modeObj = mfactory(options, spec);\n\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (modeObj.hasOwnProperty(prop)) {\n          modeObj[\"_\" + prop] = modeObj[prop];\n        }\n\n        modeObj[prop] = exts[prop];\n      }\n    }\n\n    modeObj.name = spec.name;\n\n    if (spec.helperType) {\n      modeObj.helperType = spec.helperType;\n    }\n\n    if (spec.modeProps) {\n      for (var prop$1 in spec.modeProps) {\n        modeObj[prop$1] = spec.modeProps[prop$1];\n      }\n    }\n\n    return modeObj;\n  } // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n\n\n  var modeExtensions = {};\n\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) {\n      return state;\n    }\n\n    if (mode.copyState) {\n      return mode.copyState(state);\n    }\n\n    var nstate = {};\n\n    for (var n in state) {\n      var val = state[n];\n\n      if (val instanceof Array) {\n        val = val.concat([]);\n      }\n\n      nstate[n] = val;\n    }\n\n    return nstate;\n  } // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n\n\n  function innerMode(mode, state) {\n    var info;\n\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n\n      if (!info || info.mode == mode) {\n        break;\n      }\n\n      state = info.state;\n      mode = info.mode;\n    }\n\n    return info || {\n      mode: mode,\n      state: state\n    };\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n\n  var modeMethods = {\n    __proto__: null,\n    modes: modes,\n    mimeModes: mimeModes,\n    defineMode: defineMode,\n    defineMIME: defineMIME,\n    resolveMode: resolveMode,\n    getMode: getMode,\n    modeExtensions: modeExtensions,\n    extendMode: extendMode,\n    copyState: copyState,\n    innerMode: innerMode,\n    startState: startState\n  }; // declare global: globalThis, CodeMirror\n  // Create a minimal CodeMirror needed to use runMode, and assign to root.\n\n  var root = typeof globalThis !== 'undefined' ? globalThis : window;\n  root.CodeMirror = {}; // Copy StringStream and mode methods into CodeMirror object.\n\n  CodeMirror.StringStream = StringStream;\n\n  for (var exported in modeMethods) {\n    CodeMirror[exported] = modeMethods[exported];\n  } // Minimal default mode.\n\n\n  CodeMirror.defineMode(\"null\", function () {\n    return {\n      token: function token(stream) {\n        return stream.skipToEnd();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n  CodeMirror.registerHelper = CodeMirror.registerGlobalHelper = Math.min;\n\n  CodeMirror.splitLines = function (string) {\n    return string.split(/\\r?\\n|\\r/);\n  };\n\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.defaults = {\n    indentUnit: 2\n  }; // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  // Distributed under an MIT license: https://codemirror.net/LICENSE\n\n  (function (mod) {\n    if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n      {\n        mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n      } else if (true) // AMD\n      {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else // Plain browser env\n      {}\n  })(function (CodeMirror) {\n    CodeMirror.runMode = function (string, modespec, callback, options) {\n      var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);\n      var tabSize = options && options.tabSize || CodeMirror.defaults.tabSize; // Create a tokenizing callback function if passed-in callback is a DOM element.\n\n      if (callback.appendChild) {\n        var ie = /MSIE \\d/.test(navigator.userAgent);\n        var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);\n        var node = callback,\n            col = 0;\n        node.innerHTML = \"\";\n\n        callback = function callback(text, style) {\n          if (text == \"\\n\") {\n            // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.\n            // Emitting a carriage return makes everything ok.\n            node.appendChild(document.createTextNode(ie_lt9 ? '\\r' : text));\n            col = 0;\n            return;\n          }\n\n          var content = \"\"; // replace tabs\n\n          for (var pos = 0;;) {\n            var idx = text.indexOf(\"\\t\", pos);\n\n            if (idx == -1) {\n              content += text.slice(pos);\n              col += text.length - pos;\n              break;\n            } else {\n              col += idx - pos;\n              content += text.slice(pos, idx);\n              var size = tabSize - col % tabSize;\n              col += size;\n\n              for (var i = 0; i < size; ++i) {\n                content += \" \";\n              }\n\n              pos = idx + 1;\n            }\n          } // Create a node with token style and append it to the callback DOM element.\n\n\n          if (style) {\n            var sp = node.appendChild(document.createElement(\"span\"));\n            sp.className = \"cm-\" + style.replace(/ +/g, \" cm-\");\n            sp.appendChild(document.createTextNode(content));\n          } else {\n            node.appendChild(document.createTextNode(content));\n          }\n        };\n      }\n\n      var lines = CodeMirror.splitLines(string),\n          state = options && options.state || CodeMirror.startState(mode);\n\n      for (var i = 0, e = lines.length; i < e; ++i) {\n        if (i) {\n          callback(\"\\n\");\n        }\n\n        var stream = new CodeMirror.StringStream(lines[i], null, {\n          lookAhead: function lookAhead(n) {\n            return lines[i + n];\n          },\n          baseToken: function baseToken() {}\n        });\n\n        if (!stream.string && mode.blankLine) {\n          mode.blankLine(state);\n        }\n\n        while (!stream.eol()) {\n          var style = mode.token(stream, state);\n          callback(stream.current(), style, i, stream.start, state, mode);\n          stream.start = stream.pos;\n        }\n      }\n    };\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vcnVubW9kZS9ydW5tb2RlLXN0YW5kYWxvbmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUMsYUFBWTtFQUNYOztFQUVBLFNBQVNBLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCQyxNQUF0QixFQUE4QkMsU0FBOUIsRUFBeUM7SUFDdkMsSUFBSSxDQUFDRCxNQUFMLEVBQWE7TUFBRUEsTUFBTSxHQUFHLEVBQVQ7SUFBYzs7SUFDN0IsS0FBSyxJQUFJRSxJQUFULElBQWlCSCxHQUFqQixFQUNFO01BQUUsSUFBSUEsR0FBRyxDQUFDSSxjQUFKLENBQW1CRCxJQUFuQixNQUE2QkQsU0FBUyxLQUFLLEtBQWQsSUFBdUIsQ0FBQ0QsTUFBTSxDQUFDRyxjQUFQLENBQXNCRCxJQUF0QixDQUFyRCxDQUFKLEVBQ0E7UUFBRUYsTUFBTSxDQUFDRSxJQUFELENBQU4sR0FBZUgsR0FBRyxDQUFDRyxJQUFELENBQWxCO01BQTJCO0lBQUU7O0lBQ25DLE9BQU9GLE1BQVA7RUFDRCxDQVRVLENBV1g7RUFDQTs7O0VBQ0EsU0FBU0ksV0FBVCxDQUFxQkMsTUFBckIsRUFBNkJDLEdBQTdCLEVBQWtDQyxPQUFsQyxFQUEyQ0MsVUFBM0MsRUFBdURDLFVBQXZELEVBQW1FO0lBQ2pFLElBQUlILEdBQUcsSUFBSSxJQUFYLEVBQWlCO01BQ2ZBLEdBQUcsR0FBR0QsTUFBTSxDQUFDSyxNQUFQLENBQWMsYUFBZCxDQUFOOztNQUNBLElBQUlKLEdBQUcsSUFBSSxDQUFDLENBQVosRUFBZTtRQUFFQSxHQUFHLEdBQUdELE1BQU0sQ0FBQ00sTUFBYjtNQUFzQjtJQUN4Qzs7SUFDRCxLQUFLLElBQUlDLENBQUMsR0FBR0osVUFBVSxJQUFJLENBQXRCLEVBQXlCSyxDQUFDLEdBQUdKLFVBQVUsSUFBSSxDQUFoRCxJQUFxRDtNQUNuRCxJQUFJSyxPQUFPLEdBQUdULE1BQU0sQ0FBQ1UsT0FBUCxDQUFlLElBQWYsRUFB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RUFBRCxFQUFtQjZFLEtBQW5CLEVBQTBCNUgsQ0FBMUIsRUFBNkIrRixNQUFNLENBQUNoRixLQUFwQyxFQUEyQytELEtBQTNDLEVBQWtEckIsSUFBbEQsQ0FBUjtVQUNBc0MsTUFBTSxDQUFDaEYsS0FBUCxHQUFlZ0YsTUFBTSxDQUFDakYsR0FBdEI7UUFDRDtNQUNGO0lBQ0YsQ0E1REQ7RUE4REMsQ0F2RUQ7QUF5RUQsQ0E3VUEsR0FBRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9hZGRvbi9ydW5tb2RlL3J1bm1vZGUtc3RhbmRhbG9uZS5qcz8xNDE2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgeyB0YXJnZXQgPSB7fTsgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgeyBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICBpZiAoZW5kID09IC0xKSB7IGVuZCA9IHN0cmluZy5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xuICAgIHZhciBpbnN0O1xuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KTsgfVxuICAgIHJldHVybiBpbnN0XG4gIH1cblxuICAvLyBTVFJJTkcgU1RSRUFNXG5cbiAgLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxuICAvLyBwYXJzZXJzIG1vcmUgc3VjY2luY3QuXG5cbiAgdmFyIFN0cmluZ1N0cmVhbSA9IGZ1bmN0aW9uKHN0cmluZywgdGFiU2l6ZSwgbGluZU9yYWNsZSkge1xuICAgIHRoaXMucG9zID0gdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZSB8fCA4O1xuICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgdGhpcy5saW5lT3JhY2xlID0gbGluZU9yYWNsZTtcbiAgfTtcblxuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RofTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5zb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID09IHRoaXMubGluZVN0YXJ0fTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKykgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgdmFyIG9rO1xuICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIikgeyBvayA9IGNoID09IG1hdGNoOyB9XG4gICAgZWxzZSB7IG9rID0gY2ggJiYgKG1hdGNoLnRlc3QgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSk7IH1cbiAgICBpZiAob2spIHsrK3RoaXMucG9zOyByZXR1cm4gY2h9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0V2hpbGUgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKXt9XG4gICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnRcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSkgeyArK3RoaXMucG9zOyB9XG4gICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnRcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5za2lwVG9FbmQgPSBmdW5jdGlvbiAoKSB7dGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7fTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5za2lwVG8gPSBmdW5jdGlvbiAoY2gpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG4gICAgaWYgKGZvdW5kID4gLTEpIHt0aGlzLnBvcyA9IGZvdW5kOyByZXR1cm4gdHJ1ZX1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5iYWNrVXAgPSBmdW5jdGlvbiAobikge3RoaXMucG9zIC09IG47fTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5jb2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmluZGVudGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtXG4gICAgICAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgY2FzZWQgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjsgfTtcbiAgICAgIHZhciBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkgeyB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDsgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSkgeyB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7IH1cbiAgICAgIHJldHVybiBtYXRjaFxuICAgIH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCl7cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKX07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaGlkZUZpcnN0Q2hhcnMgPSBmdW5jdGlvbiAobiwgaW5uZXIpIHtcbiAgICB0aGlzLmxpbmVTdGFydCArPSBuO1xuICAgIHRyeSB7IHJldHVybiBpbm5lcigpIH1cbiAgICBmaW5hbGx5IHsgdGhpcy5saW5lU3RhcnQgLT0gbjsgfVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmxvb2tBaGVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIG9yYWNsZSA9IHRoaXMubGluZU9yYWNsZTtcbiAgICByZXR1cm4gb3JhY2xlICYmIG9yYWNsZS5sb29rQWhlYWQobilcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5iYXNlVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yYWNsZSA9IHRoaXMubGluZU9yYWNsZTtcbiAgICByZXR1cm4gb3JhY2xlICYmIG9yYWNsZS5iYXNlVG9rZW4odGhpcy5wb3MpXG4gIH07XG5cbiAgLy8gS25vd24gbW9kZXMsIGJ5IG5hbWUgYW5kIGJ5IE1JTUVcbiAgdmFyIG1vZGVzID0ge30sIG1pbWVNb2RlcyA9IHt9O1xuXG4gIC8vIEV4dHJhIGFyZ3VtZW50cyBhcmUgc3RvcmVkIGFzIHRoZSBtb2RlJ3MgZGVwZW5kZW5jaWVzLCB3aGljaCBpc1xuICAvLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XG4gIC8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxuICBmdW5jdGlvbiBkZWZpbmVNb2RlKG5hbWUsIG1vZGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXG4gICAgICB7IG1vZGUuZGVwZW5kZW5jaWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTsgfVxuICAgIG1vZGVzW25hbWVdID0gbW9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZU1JTUUobWltZSwgc3BlYykge1xuICAgIG1pbWVNb2Rlc1ttaW1lXSA9IHNwZWM7XG4gIH1cblxuICAvLyBHaXZlbiBhIE1JTUUgdHlwZSwgYSB7bmFtZSwgLi4ub3B0aW9uc30gY29uZmlnIG9iamVjdCwgb3IgYSBuYW1lXG4gIC8vIHN0cmluZywgcmV0dXJuIGEgbW9kZSBjb25maWcgb2JqZWN0LlxuICBmdW5jdGlvbiByZXNvbHZlTW9kZShzcGVjKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMpKSB7XG4gICAgICBzcGVjID0gbWltZU1vZGVzW3NwZWNdO1xuICAgIH0gZWxzZSBpZiAoc3BlYyAmJiB0eXBlb2Ygc3BlYy5uYW1lID09IFwic3RyaW5nXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1pbWVNb2Rlc1tzcGVjLm5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBmb3VuZCA9PSBcInN0cmluZ1wiKSB7IGZvdW5kID0ge25hbWU6IGZvdW5kfTsgfVxuICAgICAgc3BlYyA9IGNyZWF0ZU9iaihmb3VuZCwgc3BlYyk7XG4gICAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiAvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3Qoc3BlYykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL3htbFwiKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiAvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK2pzb24kLy50ZXN0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiKSB7IHJldHVybiB7bmFtZTogc3BlY30gfVxuICAgIGVsc2UgeyByZXR1cm4gc3BlYyB8fCB7bmFtZTogXCJudWxsXCJ9IH1cbiAgfVxuXG4gIC8vIEdpdmVuIGEgbW9kZSBzcGVjIChhbnl0aGluZyB0aGF0IHJlc29sdmVNb2RlIGFjY2VwdHMpLCBmaW5kIGFuZFxuICAvLyBpbml0aWFsaXplIGFuIGFjdHVhbCBtb2RlIG9iamVjdC5cbiAgZnVuY3Rpb24gZ2V0TW9kZShvcHRpb25zLCBzcGVjKSB7XG4gICAgc3BlYyA9IHJlc29sdmVNb2RlKHNwZWMpO1xuICAgIHZhciBtZmFjdG9yeSA9IG1vZGVzW3NwZWMubmFtZV07XG4gICAgaWYgKCFtZmFjdG9yeSkgeyByZXR1cm4gZ2V0TW9kZShvcHRpb25zLCBcInRleHQvcGxhaW5cIikgfVxuICAgIHZhciBtb2RlT2JqID0gbWZhY3Rvcnkob3B0aW9ucywgc3BlYyk7XG4gICAgaWYgKG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcbiAgICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnNbc3BlYy5uYW1lXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXh0cykge1xuICAgICAgICBpZiAoIWV4dHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHsgY29udGludWUgfVxuICAgICAgICBpZiAobW9kZU9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBtb2RlT2JqW1wiX1wiICsgcHJvcF0gPSBtb2RlT2JqW3Byb3BdOyB9XG4gICAgICAgIG1vZGVPYmpbcHJvcF0gPSBleHRzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2RlT2JqLm5hbWUgPSBzcGVjLm5hbWU7XG4gICAgaWYgKHNwZWMuaGVscGVyVHlwZSkgeyBtb2RlT2JqLmhlbHBlclR5cGUgPSBzcGVjLmhlbHBlclR5cGU7IH1cbiAgICBpZiAoc3BlYy5tb2RlUHJvcHMpIHsgZm9yICh2YXIgcHJvcCQxIGluIHNwZWMubW9kZVByb3BzKVxuICAgICAgeyBtb2RlT2JqW3Byb3AkMV0gPSBzcGVjLm1vZGVQcm9wc1twcm9wJDFdOyB9IH1cblxuICAgIHJldHVybiBtb2RlT2JqXG4gIH1cblxuICAvLyBUaGlzIGNhbiBiZSB1c2VkIHRvIGF0dGFjaCBwcm9wZXJ0aWVzIHRvIG1vZGUgb2JqZWN0cyBmcm9tXG4gIC8vIG91dHNpZGUgdGhlIGFjdHVhbCBtb2RlIGRlZmluaXRpb24uXG4gIHZhciBtb2RlRXh0ZW5zaW9ucyA9IHt9O1xuICBmdW5jdGlvbiBleHRlbmRNb2RlKG1vZGUsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KG1vZGUpID8gbW9kZUV4dGVuc2lvbnNbbW9kZV0gOiAobW9kZUV4dGVuc2lvbnNbbW9kZV0gPSB7fSk7XG4gICAgY29weU9iaihwcm9wZXJ0aWVzLCBleHRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlTdGF0ZShtb2RlLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdHJ1ZSkgeyByZXR1cm4gc3RhdGUgfVxuICAgIGlmIChtb2RlLmNvcHlTdGF0ZSkgeyByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpIH1cbiAgICB2YXIgbnN0YXRlID0ge307XG4gICAgZm9yICh2YXIgbiBpbiBzdGF0ZSkge1xuICAgICAgdmFyIHZhbCA9IHN0YXRlW25dO1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7IHZhbCA9IHZhbC5jb25jYXQoW10pOyB9XG4gICAgICBuc3RhdGVbbl0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBuc3RhdGVcbiAgfVxuXG4gIC8vIEdpdmVuIGEgbW9kZSBhbmQgYSBzdGF0ZSAoZm9yIHRoYXQgbW9kZSksIGZpbmQgdGhlIGlubmVyIG1vZGUgYW5kXG4gIC8vIHN0YXRlIGF0IHRoZSBwb3NpdGlvbiB0aGF0IHRoZSBzdGF0ZSByZWZlcnMgdG8uXG4gIGZ1bmN0aW9uIGlubmVyTW9kZShtb2RlLCBzdGF0ZSkge1xuICAgIHZhciBpbmZvO1xuICAgIHdoaWxlIChtb2RlLmlubmVyTW9kZSkge1xuICAgICAgaW5mbyA9IG1vZGUuaW5uZXJNb2RlKHN0YXRlKTtcbiAgICAgIGlmICghaW5mbyB8fCBpbmZvLm1vZGUgPT0gbW9kZSkgeyBicmVhayB9XG4gICAgICBzdGF0ZSA9IGluZm8uc3RhdGU7XG4gICAgICBtb2RlID0gaW5mby5tb2RlO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRTdGF0ZShtb2RlLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gbW9kZS5zdGFydFN0YXRlID8gbW9kZS5zdGFydFN0YXRlKGExLCBhMikgOiB0cnVlXG4gIH1cblxuICB2YXIgbW9kZU1ldGhvZHMgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG1vZGVzOiBtb2RlcyxcbiAgICBtaW1lTW9kZXM6IG1pbWVNb2RlcyxcbiAgICBkZWZpbmVNb2RlOiBkZWZpbmVNb2RlLFxuICAgIGRlZmluZU1JTUU6IGRlZmluZU1JTUUsXG4gICAgcmVzb2x2ZU1vZGU6IHJlc29sdmVNb2RlLFxuICAgIGdldE1vZGU6IGdldE1vZGUsXG4gICAgbW9kZUV4dGVuc2lvbnM6IG1vZGVFeHRlbnNpb25zLFxuICAgIGV4dGVuZE1vZGU6IGV4dGVuZE1vZGUsXG4gICAgY29weVN0YXRlOiBjb3B5U3RhdGUsXG4gICAgaW5uZXJNb2RlOiBpbm5lck1vZGUsXG4gICAgc3RhcnRTdGF0ZTogc3RhcnRTdGF0ZVxuICB9O1xuXG4gIC8vIGRlY2xhcmUgZ2xvYmFsOiBnbG9iYWxUaGlzLCBDb2RlTWlycm9yXG5cbiAgLy8gQ3JlYXRlIGEgbWluaW1hbCBDb2RlTWlycm9yIG5lZWRlZCB0byB1c2UgcnVuTW9kZSwgYW5kIGFzc2lnbiB0byByb290LlxuICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG4gIHJvb3QuQ29kZU1pcnJvciA9IHt9O1xuXG4gIC8vIENvcHkgU3RyaW5nU3RyZWFtIGFuZCBtb2RlIG1ldGhvZHMgaW50byBDb2RlTWlycm9yIG9iamVjdC5cbiAgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW07XG4gIGZvciAodmFyIGV4cG9ydGVkIGluIG1vZGVNZXRob2RzKSB7IENvZGVNaXJyb3JbZXhwb3J0ZWRdID0gbW9kZU1ldGhvZHNbZXhwb3J0ZWRdOyB9XG5cbiAgLy8gTWluaW1hbCBkZWZhdWx0IG1vZGUuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm51bGxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHt0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSkgeyByZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpOyB9fSk7IH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3BsYWluXCIsIFwibnVsbFwiKTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IE1hdGgubWluO1xuICBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBmdW5jdGlvbihzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyP1xcbnxcXHIvKSB9O1xuICBDb2RlTWlycm9yLmNvdW50Q29sdW1uID0gY291bnRDb2x1bW47XG5cbiAgQ29kZU1pcnJvci5kZWZhdWx0cyA9IHsgaW5kZW50VW5pdDogMiB9O1xuXG4gIC8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4gIC8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuICAoZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgICAgeyBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTsgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgICAgeyBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7IH1cbiAgICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgICB7IG1vZChDb2RlTWlycm9yKTsgfVxuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cbiAgQ29kZU1pcnJvci5ydW5Nb2RlID0gZnVuY3Rpb24oc3RyaW5nLCBtb2Rlc3BlYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgbW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShDb2RlTWlycm9yLmRlZmF1bHRzLCBtb2Rlc3BlYyk7XG4gICAgdmFyIHRhYlNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnRhYlNpemUpIHx8IENvZGVNaXJyb3IuZGVmYXVsdHMudGFiU2l6ZTtcblxuICAgIC8vIENyZWF0ZSBhIHRva2VuaXppbmcgY2FsbGJhY2sgZnVuY3Rpb24gaWYgcGFzc2VkLWluIGNhbGxiYWNrIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgaWYgKGNhbGxiYWNrLmFwcGVuZENoaWxkKSB7XG4gICAgICB2YXIgaWUgPSAvTVNJRSBcXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgaWVfbHQ5ID0gaWUgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PSBudWxsIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDkpO1xuICAgICAgdmFyIG5vZGUgPSBjYWxsYmFjaywgY29sID0gMDtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24odGV4dCwgc3R5bGUpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gXCJcXG5cIikge1xuICAgICAgICAgIC8vIEVtaXR0aW5nIExGIG9yIENSTEYgb24gSUU4IG9yIGVhcmxpZXIgcmVzdWx0cyBpbiBhbiBpbmNvcnJlY3QgZGlzcGxheS5cbiAgICAgICAgICAvLyBFbWl0dGluZyBhIGNhcnJpYWdlIHJldHVybiBtYWtlcyBldmVyeXRoaW5nIG9rLlxuICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaWVfbHQ5ID8gJ1xccicgOiB0ZXh0KSk7XG4gICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAvLyByZXBsYWNlIHRhYnNcbiAgICAgICAgZm9yICh2YXIgcG9zID0gMDs7KSB7XG4gICAgICAgICAgdmFyIGlkeCA9IHRleHQuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgICAgIGlmIChpZHggPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdGV4dC5zbGljZShwb3MpO1xuICAgICAgICAgICAgY29sICs9IHRleHQubGVuZ3RoIC0gcG9zO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbCArPSBpZHggLSBwb3M7XG4gICAgICAgICAgICBjb250ZW50ICs9IHRleHQuc2xpY2UocG9zLCBpZHgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0YWJTaXplIC0gY29sICUgdGFiU2l6ZTtcbiAgICAgICAgICAgIGNvbCArPSBzaXplO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHsgY29udGVudCArPSBcIiBcIjsgfVxuICAgICAgICAgICAgcG9zID0gaWR4ICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbm9kZSB3aXRoIHRva2VuIHN0eWxlIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGNhbGxiYWNrIERPTSBlbGVtZW50LlxuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICB2YXIgc3AgPSBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICBzcC5jbGFzc05hbWUgPSBcImNtLVwiICsgc3R5bGUucmVwbGFjZSgvICsvZywgXCIgY20tXCIpO1xuICAgICAgICAgIHNwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSBDb2RlTWlycm9yLnNwbGl0TGluZXMoc3RyaW5nKSwgc3RhdGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXRlKSB8fCBDb2RlTWlycm9yLnN0YXJ0U3RhdGUobW9kZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsaW5lcy5sZW5ndGg7IGkgPCBlOyArK2kpIHtcbiAgICAgIGlmIChpKSB7IGNhbGxiYWNrKFwiXFxuXCIpOyB9XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKGxpbmVzW2ldLCBudWxsLCB7XG4gICAgICAgIGxvb2tBaGVhZDogZnVuY3Rpb24obikgeyByZXR1cm4gbGluZXNbaSArIG5dIH0sXG4gICAgICAgIGJhc2VUb2tlbjogZnVuY3Rpb24oKSB7fVxuICAgICAgfSk7XG4gICAgICBpZiAoIXN0cmVhbS5zdHJpbmcgJiYgbW9kZS5ibGFua0xpbmUpIHsgbW9kZS5ibGFua0xpbmUoc3RhdGUpOyB9XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBjYWxsYmFjayhzdHJlYW0uY3VycmVudCgpLCBzdHlsZSwgaSwgc3RyZWFtLnN0YXJ0LCBzdGF0ZSwgbW9kZSk7XG4gICAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIH0pO1xuXG59KCkpO1xuIl0sIm5hbWVzIjpbImNvcHlPYmoiLCJvYmoiLCJ0YXJnZXQiLCJvdmVyd3JpdGUiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJjb3VudENvbHVtbiIsInN0cmluZyIsImVuZCIsInRhYlNpemUiLCJzdGFydEluZGV4Iiwic3RhcnRWYWx1ZSIsInNlYXJjaCIsImxlbmd0aCIsImkiLCJuIiwibmV4dFRhYiIsImluZGV4T2YiLCJub3RoaW5nIiwiY3JlYXRlT2JqIiwiYmFzZSIsInByb3BzIiwiaW5zdCIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvdHlwZSIsIlN0cmluZ1N0cmVhbSIsImxpbmVPcmFjbGUiLCJwb3MiLCJzdGFydCIsImxhc3RDb2x1bW5Qb3MiLCJsYXN0Q29sdW1uVmFsdWUiLCJsaW5lU3RhcnQiLCJlb2wiLCJzb2wiLCJwZWVrIiwiY2hhckF0IiwidW5kZWZpbmVkIiwibmV4dCIsImVhdCIsIm1hdGNoIiwiY2giLCJvayIsInRlc3QiLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiZm91bmQiLCJiYWNrVXAiLCJjb2x1bW4iLCJpbmRlbnRhdGlvbiIsInBhdHRlcm4iLCJjb25zdW1lIiwiY2FzZUluc2Vuc2l0aXZlIiwiY2FzZWQiLCJzdHIiLCJ0b0xvd2VyQ2FzZSIsInN1YnN0ciIsInNsaWNlIiwiaW5kZXgiLCJjdXJyZW50IiwiaGlkZUZpcnN0Q2hhcnMiLCJpbm5lciIsImxvb2tBaGVhZCIsIm9yYWNsZSIsImJhc2VUb2tlbiIsIm1vZGVzIiwibWltZU1vZGVzIiwiZGVmaW5lTW9kZSIsIm5hbWUiLCJtb2RlIiwiYXJndW1lbnRzIiwiZGVwZW5kZW5jaWVzIiwiQXJyYXkiLCJjYWxsIiwiZGVmaW5lTUlNRSIsIm1pbWUiLCJzcGVjIiwicmVzb2x2ZU1vZGUiLCJnZXRNb2RlIiwib3B0aW9ucyIsIm1mYWN0b3J5IiwibW9kZU9iaiIsIm1vZGVFeHRlbnNpb25zIiwiZXh0cyIsImhlbHBlclR5cGUiLCJtb2RlUHJvcHMiLCJwcm9wJDEiLCJleHRlbmRNb2RlIiwicHJvcGVydGllcyIsImNvcHlTdGF0ZSIsInN0YXRlIiwibnN0YXRlIiwidmFsIiwiY29uY2F0IiwiaW5uZXJNb2RlIiwiaW5mbyIsInN0YXJ0U3RhdGUiLCJhMSIsImEyIiwibW9kZU1ldGhvZHMiLCJfX3Byb3RvX18iLCJyb290IiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsIkNvZGVNaXJyb3IiLCJleHBvcnRlZCIsInRva2VuIiwic3RyZWFtIiwicmVnaXN0ZXJIZWxwZXIiLCJyZWdpc3Rlckdsb2JhbEhlbHBlciIsIk1hdGgiLCJtaW4iLCJzcGxpdExpbmVzIiwic3BsaXQiLCJkZWZhdWx0cyIsImluZGVudFVuaXQiLCJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsInJ1bk1vZGUiLCJtb2Rlc3BlYyIsImNhbGxiYWNrIiwiYXBwZW5kQ2hpbGQiLCJpZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImllX2x0OSIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwibm9kZSIsImNvbCIsImlubmVySFRNTCIsInRleHQiLCJzdHlsZSIsImNyZWF0ZVRleHROb2RlIiwiY29udGVudCIsImlkeCIsInNpemUiLCJzcCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJyZXBsYWNlIiwibGluZXMiLCJlIiwiYmxhbmtMaW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/runmode/runmode-standalone.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/addon/runmode/runmode-standalone.js");
/******/ 	
/******/ })()
;