/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js":
/*!************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n  }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"-:.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line;\n    this.ch = ch;\n    this.cm = cm;\n    this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n\n      if (gt == -1) {\n        if (nextLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, gt + 1)) {\n        iter.ch = gt + 1;\n        continue;\n      }\n\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n\n      if (lt == -1) {\n        if (prevLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, lt + 1)) {\n        iter.ch = lt;\n        continue;\n      }\n\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n\n      if (!found) {\n        if (nextLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, found.index + 1)) {\n        iter.ch = found.index + 1;\n        continue;\n      }\n\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n\n      if (gt == -1) {\n        if (prevLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, gt + 1)) {\n        iter.ch = gt;\n        continue;\n      }\n\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n\n    for (;;) {\n      var next = toNextTag(iter),\n          end,\n          startLine = iter.line,\n          startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n\n      if (next[1]) {\n        // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) {\n          if (stack[i] == next[2]) {\n            stack.length = i;\n            break;\n          }\n        }\n\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else {\n        // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n\n      if (prev == \"selfClose\") {\n        toTagStart(iter);\n        continue;\n      }\n\n      var endLine = iter.line,\n          endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n\n      if (start[1]) {\n        // closing tag\n        stack.push(start[2]);\n      } else {\n        // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) {\n          if (stack[i] == start[2]) {\n            stack.length = i;\n            break;\n          }\n        }\n\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function (cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n\n    for (;;) {\n      var openTag = toNextTag(iter);\n      if (!openTag || iter.line != start.line) return;\n      var end = toTagEnd(iter);\n      if (!end) return;\n\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && cmp(endPos.from, startPos) > 0 ? {\n          from: startPos,\n          to: endPos.from\n        } : null;\n      }\n    }\n  });\n\n  CodeMirror.findMatchingTag = function (cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter),\n        to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {\n      from: Pos(iter.line, iter.ch),\n      to: to,\n      tag: start[2]\n    };\n    if (end == \"selfClose\") return {\n      open: here,\n      close: null,\n      at: \"open\"\n    };\n\n    if (start[1]) {\n      // closing tag\n      return {\n        open: findMatchingOpen(iter, start[2]),\n        close: here,\n        at: \"close\"\n      };\n    } else {\n      // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {\n        open: here,\n        close: findMatchingClose(iter, start[2]),\n        at: \"open\"\n      };\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function (cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {\n        open: open,\n        close: close\n      };\n    }\n  }; // Used by addon/edit/closetag.js\n\n\n  CodeMirror.scanForClosingTag = function (cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {\n      from: 0,\n      to: end\n    } : null);\n    return findMatchingClose(iter, name);\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC94bWwtZm9sZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsQ0FBRCxvQ0FBMkJKLEdBQTNCO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREcsS0FFQTtJQUNIQSxFQUFBO0FBQ0gsQ0FQRCxFQU9HLFVBQVNNLFVBQVQsRUFBcUI7RUFDdEI7O0VBRUEsSUFBSUMsR0FBRyxHQUFHRCxVQUFVLENBQUNDLEdBQXJCOztFQUNBLFNBQVNDLEdBQVQsQ0FBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI7SUFBRSxPQUFPRCxDQUFDLENBQUNFLElBQUYsR0FBU0QsQ0FBQyxDQUFDQyxJQUFYLElBQW1CRixDQUFDLENBQUNHLEVBQUYsR0FBT0YsQ0FBQyxDQUFDRSxFQUFuQztFQUF3Qzs7RUFFN0QsSUFBSUMsYUFBYSxHQUFHLDhLQUFwQjtFQUNBLElBQUlDLFFBQVEsR0FBR0QsYUFBYSxHQUFHLDZDQUEvQjtFQUNBLElBQUlFLFdBQVcsR0FBRyxJQUFJQyxNQUFKLENBQVcsWUFBWUgsYUFBWixHQUE0QixJQUE1QixHQUFtQ0MsUUFBbkMsR0FBOEMsS0FBekQsRUFBZ0UsR0FBaEUsQ0FBbEI7O0VBRUEsU0FBU0csSUFBVCxDQUFjQyxFQUFkLEVBQWtCUCxJQUFsQixFQUF3QkMsRUFBeEIsRUFBNEJPLEtBQTVCLEVBQW1DO0lBQ2pDLEtBQUtSLElBQUwsR0FBWUEsSUFBWjtJQUFrQixLQUFLQyxFQUFMLEdBQVVBLEVBQVY7SUFDbEIs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QUFPLEdBQUcsSUFBSTdELElBQUosQ0FBU0MsRUFBVCxFQUFhc0QsR0FBRyxDQUFDN0QsSUFBakIsRUFBdUI2RCxHQUFHLENBQUM1RCxFQUEzQixFQUErQk8sS0FBL0IsQ0FBZDtNQUNBLElBQUl3RCxLQUFLLEdBQUd0QixpQkFBaUIsQ0FBQ3lCLE9BQUQsRUFBVUosSUFBSSxDQUFDcEIsR0FBZixDQUE3QjtNQUNBLElBQUlxQixLQUFKLEVBQVcsT0FBTztRQUFDRCxJQUFJLEVBQUVBLElBQVA7UUFBYUMsS0FBSyxFQUFFQTtNQUFwQixDQUFQO0lBQ1o7RUFDRixDQVRELENBN0pzQixDQXdLdEI7OztFQUNBckUsVUFBVSxDQUFDeUUsaUJBQVgsR0FBK0IsVUFBUzdELEVBQVQsRUFBYXNELEdBQWIsRUFBa0JRLElBQWxCLEVBQXdCdkIsR0FBeEIsRUFBNkI7SUFDMUQsSUFBSTNCLElBQUksR0FBRyxJQUFJYixJQUFKLENBQVNDLEVBQVQsRUFBYXNELEdBQUcsQ0FBQzdELElBQWpCLEVBQXVCNkQsR0FBRyxDQUFDNUQsRUFBM0IsRUFBK0I2QyxHQUFHLEdBQUc7TUFBQ2hDLElBQUksRUFBRSxDQUFQO01BQVVFLEVBQUUsRUFBRThCO0lBQWQsQ0FBSCxHQUF3QixJQUExRCxDQUFYO0lBQ0EsT0FBT0osaUJBQWlCLENBQUN2QixJQUFELEVBQU9rRCxJQUFQLENBQXhCO0VBQ0QsQ0FIRDtBQUlELENBcExEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL2FkZG9uL2ZvbGQveG1sLWZvbGQuanM/YTY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG4gIGZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2g7IH1cblxuICB2YXIgbmFtZVN0YXJ0Q2hhciA9IFwiQS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4gIHZhciBuYW1lQ2hhciA9IG5hbWVTdGFydENoYXIgKyBcIlxcLVxcOlxcLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG4gIHZhciB4bWxUYWdTdGFydCA9IG5ldyBSZWdFeHAoXCI8KC8/KShbXCIgKyBuYW1lU3RhcnRDaGFyICsgXCJdW1wiICsgbmFtZUNoYXIgKyBcIl0qKVwiLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gSXRlcihjbSwgbGluZSwgY2gsIHJhbmdlKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoO1xuICAgIHRoaXMuY20gPSBjbTsgdGhpcy50ZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICB0aGlzLm1pbiA9IHJhbmdlID8gTWF0aC5tYXgocmFuZ2UuZnJvbSwgY20uZmlyc3RMaW5lKCkpIDogY20uZmlyc3RMaW5lKCk7XG4gICAgdGhpcy5tYXggPSByYW5nZSA/IE1hdGgubWluKHJhbmdlLnRvIC0gMSwgY20ubGFzdExpbmUoKSkgOiBjbS5sYXN0TGluZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnQXQoaXRlciwgY2gpIHtcbiAgICB2YXIgdHlwZSA9IGl0ZXIuY20uZ2V0VG9rZW5UeXBlQXQoUG9zKGl0ZXIubGluZSwgY2gpKTtcbiAgICByZXR1cm4gdHlwZSAmJiAvXFxidGFnXFxiLy50ZXN0KHR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dExpbmUoaXRlcikge1xuICAgIGlmIChpdGVyLmxpbmUgPj0gaXRlci5tYXgpIHJldHVybjtcbiAgICBpdGVyLmNoID0gMDtcbiAgICBpdGVyLnRleHQgPSBpdGVyLmNtLmdldExpbmUoKytpdGVyLmxpbmUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZMaW5lKGl0ZXIpIHtcbiAgICBpZiAoaXRlci5saW5lIDw9IGl0ZXIubWluKSByZXR1cm47XG4gICAgaXRlci50ZXh0ID0gaXRlci5jbS5nZXRMaW5lKC0taXRlci5saW5lKTtcbiAgICBpdGVyLmNoID0gaXRlci50ZXh0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvVGFnRW5kKGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZ3QgPSBpdGVyLnRleHQuaW5kZXhPZihcIj5cIiwgaXRlci5jaCk7XG4gICAgICBpZiAoZ3QgPT0gLTEpIHsgaWYgKG5leHRMaW5lKGl0ZXIpKSBjb250aW51ZTsgZWxzZSByZXR1cm47IH1cbiAgICAgIGlmICghdGFnQXQoaXRlciwgZ3QgKyAxKSkgeyBpdGVyLmNoID0gZ3QgKyAxOyBjb250aW51ZTsgfVxuICAgICAgdmFyIGxhc3RTbGFzaCA9IGl0ZXIudGV4dC5sYXN0SW5kZXhPZihcIi9cIiwgZ3QpO1xuICAgICAgdmFyIHNlbGZDbG9zZSA9IGxhc3RTbGFzaCA+IC0xICYmICEvXFxTLy50ZXN0KGl0ZXIudGV4dC5zbGljZShsYXN0U2xhc2ggKyAxLCBndCkpO1xuICAgICAgaXRlci5jaCA9IGd0ICsgMTtcbiAgICAgIHJldHVybiBzZWxmQ2xvc2UgPyBcInNlbGZDbG9zZVwiIDogXCJyZWd1bGFyXCI7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvVGFnU3RhcnQoaXRlcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBsdCA9IGl0ZXIuY2ggPyBpdGVyLnRleHQubGFzdEluZGV4T2YoXCI8XCIsIGl0ZXIuY2ggLSAxKSA6IC0xO1xuICAgICAgaWYgKGx0ID09IC0xKSB7IGlmIChwcmV2TGluZShpdGVyKSkgY29udGludWU7IGVsc2UgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRhZ0F0KGl0ZXIsIGx0ICsgMSkpIHsgaXRlci5jaCA9IGx0OyBjb250aW51ZTsgfVxuICAgICAgeG1sVGFnU3RhcnQubGFzdEluZGV4ID0gbHQ7XG4gICAgICBpdGVyLmNoID0gbHQ7XG4gICAgICB2YXIgbWF0Y2ggPSB4bWxUYWdTdGFydC5leGVjKGl0ZXIudGV4dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT0gbHQpIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b05leHRUYWcoaXRlcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHhtbFRhZ1N0YXJ0Lmxhc3RJbmRleCA9IGl0ZXIuY2g7XG4gICAgICB2YXIgZm91bmQgPSB4bWxUYWdTdGFydC5leGVjKGl0ZXIudGV4dCk7XG4gICAgICBpZiAoIWZvdW5kKSB7IGlmIChuZXh0TGluZShpdGVyKSkgY29udGludWU7IGVsc2UgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRhZ0F0KGl0ZXIsIGZvdW5kLmluZGV4ICsgMSkpIHsgaXRlci5jaCA9IGZvdW5kLmluZGV4ICsgMTsgY29udGludWU7IH1cbiAgICAgIGl0ZXIuY2ggPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9QcmV2VGFnKGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZ3QgPSBpdGVyLmNoID8gaXRlci50ZXh0Lmxhc3RJbmRleE9mKFwiPlwiLCBpdGVyLmNoIC0gMSkgOiAtMTtcbiAgICAgIGlmIChndCA9PSAtMSkgeyBpZiAocHJldkxpbmUoaXRlcikpIGNvbnRpbnVlOyBlbHNlIHJldHVybjsgfVxuICAgICAgaWYgKCF0YWdBdChpdGVyLCBndCArIDEpKSB7IGl0ZXIuY2ggPSBndDsgY29udGludWU7IH1cbiAgICAgIHZhciBsYXN0U2xhc2ggPSBpdGVyLnRleHQubGFzdEluZGV4T2YoXCIvXCIsIGd0KTtcbiAgICAgIHZhciBzZWxmQ2xvc2UgPSBsYXN0U2xhc2ggPiAtMSAmJiAhL1xcUy8udGVzdChpdGVyLnRleHQuc2xpY2UobGFzdFNsYXNoICsgMSwgZ3QpKTtcbiAgICAgIGl0ZXIuY2ggPSBndCArIDE7XG4gICAgICByZXR1cm4gc2VsZkNsb3NlID8gXCJzZWxmQ2xvc2VcIiA6IFwicmVndWxhclwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0Nsb3NlKGl0ZXIsIHRhZykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXh0ID0gdG9OZXh0VGFnKGl0ZXIpLCBlbmQsIHN0YXJ0TGluZSA9IGl0ZXIubGluZSwgc3RhcnRDaCA9IGl0ZXIuY2ggLSAobmV4dCA/IG5leHRbMF0ubGVuZ3RoIDogMCk7XG4gICAgICBpZiAoIW5leHQgfHwgIShlbmQgPSB0b1RhZ0VuZChpdGVyKSkpIHJldHVybjtcbiAgICAgIGlmIChlbmQgPT0gXCJzZWxmQ2xvc2VcIikgY29udGludWU7XG4gICAgICBpZiAobmV4dFsxXSkgeyAvLyBjbG9zaW5nIHRhZ1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGlmIChzdGFja1tpXSA9PSBuZXh0WzJdKSB7XG4gICAgICAgICAgc3RhY2subGVuZ3RoID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgJiYgKCF0YWcgfHwgdGFnID09IG5leHRbMl0pKSByZXR1cm4ge1xuICAgICAgICAgIHRhZzogbmV4dFsyXSxcbiAgICAgICAgICBmcm9tOiBQb3Moc3RhcnRMaW5lLCBzdGFydENoKSxcbiAgICAgICAgICB0bzogUG9zKGl0ZXIubGluZSwgaXRlci5jaClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7IC8vIG9wZW5pbmcgdGFnXG4gICAgICAgIHN0YWNrLnB1c2gobmV4dFsyXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ09wZW4oaXRlciwgdGFnKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIHByZXYgPSB0b1ByZXZUYWcoaXRlcik7XG4gICAgICBpZiAoIXByZXYpIHJldHVybjtcbiAgICAgIGlmIChwcmV2ID09IFwic2VsZkNsb3NlXCIpIHsgdG9UYWdTdGFydChpdGVyKTsgY29udGludWU7IH1cbiAgICAgIHZhciBlbmRMaW5lID0gaXRlci5saW5lLCBlbmRDaCA9IGl0ZXIuY2g7XG4gICAgICB2YXIgc3RhcnQgPSB0b1RhZ1N0YXJ0KGl0ZXIpO1xuICAgICAgaWYgKCFzdGFydCkgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0WzFdKSB7IC8vIGNsb3NpbmcgdGFnXG4gICAgICAgIHN0YWNrLnB1c2goc3RhcnRbMl0pO1xuICAgICAgfSBlbHNlIHsgLy8gb3BlbmluZyB0YWdcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBpZiAoc3RhY2tbaV0gPT0gc3RhcnRbMl0pIHtcbiAgICAgICAgICBzdGFjay5sZW5ndGggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgMCAmJiAoIXRhZyB8fCB0YWcgPT0gc3RhcnRbMl0pKSByZXR1cm4ge1xuICAgICAgICAgIHRhZzogc3RhcnRbMl0sXG4gICAgICAgICAgZnJvbTogUG9zKGl0ZXIubGluZSwgaXRlci5jaCksXG4gICAgICAgICAgdG86IFBvcyhlbmRMaW5lLCBlbmRDaClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiZm9sZFwiLCBcInhtbFwiLCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBJdGVyKGNtLCBzdGFydC5saW5lLCAwKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgb3BlblRhZyA9IHRvTmV4dFRhZyhpdGVyKVxuICAgICAgaWYgKCFvcGVuVGFnIHx8IGl0ZXIubGluZSAhPSBzdGFydC5saW5lKSByZXR1cm5cbiAgICAgIHZhciBlbmQgPSB0b1RhZ0VuZChpdGVyKVxuICAgICAgaWYgKCFlbmQpIHJldHVyblxuICAgICAgaWYgKCFvcGVuVGFnWzFdICYmIGVuZCAhPSBcInNlbGZDbG9zZVwiKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpO1xuICAgICAgICB2YXIgZW5kUG9zID0gZmluZE1hdGNoaW5nQ2xvc2UoaXRlciwgb3BlblRhZ1syXSk7XG4gICAgICAgIHJldHVybiBlbmRQb3MgJiYgY21wKGVuZFBvcy5mcm9tLCBzdGFydFBvcykgPiAwID8ge2Zyb206IHN0YXJ0UG9zLCB0bzogZW5kUG9zLmZyb219IDogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIENvZGVNaXJyb3IuZmluZE1hdGNoaW5nVGFnID0gZnVuY3Rpb24oY20sIHBvcywgcmFuZ2UpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBJdGVyKGNtLCBwb3MubGluZSwgcG9zLmNoLCByYW5nZSk7XG4gICAgaWYgKGl0ZXIudGV4dC5pbmRleE9mKFwiPlwiKSA9PSAtMSAmJiBpdGVyLnRleHQuaW5kZXhPZihcIjxcIikgPT0gLTEpIHJldHVybjtcbiAgICB2YXIgZW5kID0gdG9UYWdFbmQoaXRlciksIHRvID0gZW5kICYmIFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpO1xuICAgIHZhciBzdGFydCA9IGVuZCAmJiB0b1RhZ1N0YXJ0KGl0ZXIpO1xuICAgIGlmICghZW5kIHx8ICFzdGFydCB8fCBjbXAoaXRlciwgcG9zKSA+IDApIHJldHVybjtcbiAgICB2YXIgaGVyZSA9IHtmcm9tOiBQb3MoaXRlci5saW5lLCBpdGVyLmNoKSwgdG86IHRvLCB0YWc6IHN0YXJ0WzJdfTtcbiAgICBpZiAoZW5kID09IFwic2VsZkNsb3NlXCIpIHJldHVybiB7b3BlbjogaGVyZSwgY2xvc2U6IG51bGwsIGF0OiBcIm9wZW5cIn07XG5cbiAgICBpZiAoc3RhcnRbMV0pIHsgLy8gY2xvc2luZyB0YWdcbiAgICAgIHJldHVybiB7b3BlbjogZmluZE1hdGNoaW5nT3BlbihpdGVyLCBzdGFydFsyXSksIGNsb3NlOiBoZXJlLCBhdDogXCJjbG9zZVwifTtcbiAgICB9IGVsc2UgeyAvLyBvcGVuaW5nIHRhZ1xuICAgICAgaXRlciA9IG5ldyBJdGVyKGNtLCB0by5saW5lLCB0by5jaCwgcmFuZ2UpO1xuICAgICAgcmV0dXJuIHtvcGVuOiBoZXJlLCBjbG9zZTogZmluZE1hdGNoaW5nQ2xvc2UoaXRlciwgc3RhcnRbMl0pLCBhdDogXCJvcGVuXCJ9O1xuICAgIH1cbiAgfTtcblxuICBDb2RlTWlycm9yLmZpbmRFbmNsb3NpbmdUYWcgPSBmdW5jdGlvbihjbSwgcG9zLCByYW5nZSwgdGFnKSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgSXRlcihjbSwgcG9zLmxpbmUsIHBvcy5jaCwgcmFuZ2UpO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBvcGVuID0gZmluZE1hdGNoaW5nT3BlbihpdGVyLCB0YWcpO1xuICAgICAgaWYgKCFvcGVuKSBicmVhaztcbiAgICAgIHZhciBmb3J3YXJkID0gbmV3IEl0ZXIoY20sIHBvcy5saW5lLCBwb3MuY2gsIHJhbmdlKTtcbiAgICAgIHZhciBjbG9zZSA9IGZpbmRNYXRjaGluZ0Nsb3NlKGZvcndhcmQsIG9wZW4udGFnKTtcbiAgICAgIGlmIChjbG9zZSkgcmV0dXJuIHtvcGVuOiBvcGVuLCBjbG9zZTogY2xvc2V9O1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGJ5IGFkZG9uL2VkaXQvY2xvc2V0YWcuanNcbiAgQ29kZU1pcnJvci5zY2FuRm9yQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uKGNtLCBwb3MsIG5hbWUsIGVuZCkge1xuICAgIHZhciBpdGVyID0gbmV3IEl0ZXIoY20sIHBvcy5saW5lLCBwb3MuY2gsIGVuZCA/IHtmcm9tOiAwLCB0bzogZW5kfSA6IG51bGwpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdDbG9zZShpdGVyLCBuYW1lKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsIlBvcyIsImNtcCIsImEiLCJiIiwibGluZSIsImNoIiwibmFtZVN0YXJ0Q2hhciIsIm5hbWVDaGFyIiwieG1sVGFnU3RhcnQiLCJSZWdFeHAiLCJJdGVyIiwiY20iLCJyYW5nZSIsInRleHQiLCJnZXRMaW5lIiwibWluIiwiTWF0aCIsIm1heCIsImZyb20iLCJmaXJzdExpbmUiLCJ0byIsImxhc3RMaW5lIiwidGFnQXQiLCJpdGVyIiwidHlwZSIsImdldFRva2VuVHlwZUF0IiwidGVzdCIsIm5leHRMaW5lIiwicHJldkxpbmUiLCJsZW5ndGgiLCJ0b1RhZ0VuZCIsImd0IiwiaW5kZXhPZiIsImxhc3RTbGFzaCIsImxhc3RJbmRleE9mIiwic2VsZkNsb3NlIiwic2xpY2UiLCJ0b1RhZ1N0YXJ0IiwibHQiLCJsYXN0SW5kZXgiLCJtYXRjaCIsImV4ZWMiLCJpbmRleCIsInRvTmV4dFRhZyIsImZvdW5kIiwidG9QcmV2VGFnIiwiZmluZE1hdGNoaW5nQ2xvc2UiLCJ0YWciLCJzdGFjayIsIm5leHQiLCJlbmQiLCJzdGFydExpbmUiLCJzdGFydENoIiwiaSIsInB1c2giLCJmaW5kTWF0Y2hpbmdPcGVuIiwicHJldiIsImVuZExpbmUiLCJlbmRDaCIsInN0YXJ0IiwicmVnaXN0ZXJIZWxwZXIiLCJvcGVuVGFnIiwic3RhcnRQb3MiLCJlbmRQb3MiLCJmaW5kTWF0Y2hpbmdUYWciLCJwb3MiLCJoZXJlIiwib3BlbiIsImNsb3NlIiwiYXQiLCJmaW5kRW5jbG9zaW5nVGFnIiwiZm9yd2FyZCIsInNjYW5Gb3JDbG9zaW5nVGFnIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js");
/******/ 	
/******/ })()
;