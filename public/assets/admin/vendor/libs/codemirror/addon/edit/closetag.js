/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/addon/edit/closetag.js":
/*!************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/edit/closetag.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n * `emptyTags` (default is none)\n *   An array of XML tag names that should be autoclosed with '/>'.\n *\n * See demos/closetag.html for a usage example.\n */\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), __webpack_require__(/*! ../fold/xml-fold */ \"./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js\"));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__(/*! ../fold/xml-fold */ \"./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function (cm, val, old) {\n    if (old != CodeMirror.Init && old) cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {\n      name: \"autoCloseTags\"\n    };\n    if (_typeof(val) != \"object\" || val.whenClosing !== false) map[\"'/'\"] = function (cm) {\n      return autoCloseSlash(cm);\n    };\n    if (_typeof(val) != \"object\" || val.whenOpening !== false) map[\"'>'\"] = function (cm) {\n      return autoCloseGT(cm);\n    };\n    cm.addKeyMap(map);\n  });\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(),\n        replacements = [];\n    var opt = cm.getOption(\"autoCloseTags\");\n\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head,\n          tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state),\n          state = inner.state;\n      var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state);\n      var tagName = tagInfo && tagInfo.name;\n      if (!tagName) return CodeMirror.Pass;\n      var html = inner.mode.configuration == \"html\";\n      var dontCloseTags = _typeof(opt) == \"object\" && opt.dontCloseTags || html && htmlDontClose;\n      var indentTags = _typeof(opt) == \"object\" && opt.indentTags || html && htmlIndent;\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase(); // Don't process the '>' at the end of an end-tag or self-closing tag\n\n      if (!tagName || tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) || tok.type == \"tag\" && tagInfo.close || tok.string.indexOf(\"/\") == pos.ch - tok.start - 1 || // match something like <someTagName />\n      dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 || closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true)) return CodeMirror.Pass;\n      var emptyTags = _typeof(opt) == \"object\" && opt.emptyTags;\n\n      if (emptyTags && indexOf(emptyTags, tagName) > -1) {\n        replacements[i] = {\n          text: \"/>\",\n          newPos: CodeMirror.Pos(pos.line, pos.ch + 2)\n        };\n        continue;\n      }\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {\n        indent: indent,\n        text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n        newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)\n      };\n    }\n\n    var dontIndentOnAutoClose = _typeof(opt) == \"object\" && opt.dontIndentOnAutoClose;\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {\n        head: info.newPos,\n        anchor: info.newPos\n      };\n      cm.setSelections(sel);\n\n      if (!dontIndentOnAutoClose && info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(),\n        replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    var opt = cm.getOption(\"autoCloseTags\");\n    var dontIndentOnAutoClose = _typeof(opt) == \"object\" && opt.dontIndentOnSlash;\n\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head,\n          tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state),\n          state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" || tok.start != pos.ch - 1)) return CodeMirror.Pass; // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n\n      var replacement,\n          mixed = inner.mode.name != \"xml\" && cm.getMode().name == \"htmlmixed\";\n\n      if (mixed && inner.mode.name == \"javascript\") {\n        replacement = head + \"script\";\n      } else if (mixed && inner.mode.name == \"css\") {\n        replacement = head + \"style\";\n      } else {\n        var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state);\n        var top = context.length ? context[context.length - 1] : \"\";\n        if (!context || context.length && closingTagExists(cm, context, top, pos)) return CodeMirror.Pass;\n        replacement = head + top;\n      }\n\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n\n    if (!dontIndentOnAutoClose) {\n      for (var i = 0; i < ranges.length; i++) {\n        if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line) cm.indentLine(ranges[i].head.line);\n      }\n    }\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function (cm) {\n    return autoCloseCurrent(cm);\n  };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n\n    for (var i = 0, e = collection.length; i < e; ++i) {\n      if (collection[i] == elt) return i;\n    }\n\n    return -1;\n  } // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n\n\n  function closingTagExists(cm, context, tagName, pos, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false; // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n\n    var onCx = newTag ? 1 : 0;\n\n    for (var i = context.length - 1; i >= 0; i--) {\n      if (context[i] == tagName) ++onCx;else break;\n    }\n\n    pos = nextClose.to;\n\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n\n    return true;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZWRpdC9jbG9zZXRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixFQUFrQ0EsbUJBQU8sQ0FBQywwRkFBRCxDQUF6QyxDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsRUFBeUIsK0dBQXpCLENBQUQsb0NBQStDSixHQUEvQztBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURHLEtBRUE7SUFDSEEsRUFBQTtBQUNILENBUEQsRUFPRyxVQUFTTSxVQUFULEVBQXFCO0VBQ3RCQSxVQUFVLENBQUNDLFlBQVgsQ0FBd0IsZUFBeEIsRUFBeUMsS0FBekMsRUFBZ0QsVUFBU0MsRUFBVCxFQUFhQyxHQUFiLEVBQWtCQyxHQUFsQixFQUF1QjtJQUNyRSxJQUFJQSxHQUFHLElBQUlKLFVBQVUsQ0FBQ0ssSUFBbEIsSUFBMEJELEdBQTlCLEVBQ0VGLEVBQUUsQ0FBQ0ksWUFBSCxDQUFnQixlQUFoQjtJQUNGLElBQUksQ0FBQ0gsR0FBTCxFQUFVO0lBQ1YsSUFBSUksR0FBRyxHQUFHO01BQUNDLElBQUksRUFBRTtJQUFQLENBQVY7SUFDQSxJQUFJLFFBQU9MLEdBQVAsS0FBYyxRQUFkLElBQTBCQSxHQUFHLENBQUNNLFdBQUosS0FBb0IsS0FBbEQsRUFDRUYsR0FBRyxD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QUFPLENBQUNuRCxDQUFELENBQVAsSUFBY2MsT0FBbEIsRUFBMkIsRUFBRXFELElBQUYsQ0FBM0IsS0FDSztJQUNOOztJQUNEaEUsR0FBRyxHQUFHOEQsU0FBUyxDQUFDRyxFQUFoQjs7SUFDQSxLQUFLLElBQUlwRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbUUsSUFBcEIsRUFBMEJuRSxDQUFDLEVBQTNCLEVBQStCO01BQzdCLElBQUlxRSxJQUFJLEdBQUczRixVQUFVLENBQUNtRixpQkFBWCxDQUE2QmpGLEVBQTdCLEVBQWlDdUIsR0FBakMsRUFBc0MsSUFBdEMsRUFBNENnQixHQUE1QyxDQUFYO01BQ0EsSUFBSSxDQUFDa0QsSUFBRCxJQUFTQSxJQUFJLENBQUNILEdBQUwsSUFBWXBELE9BQXpCLEVBQWtDLE9BQU8sS0FBUDtNQUNsQ1gsR0FBRyxHQUFHa0UsSUFBSSxDQUFDRCxFQUFYO0lBQ0Q7O0lBQ0QsT0FBTyxJQUFQO0VBQ0Q7QUFDRixDQTNKRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9hZGRvbi9lZGl0L2Nsb3NldGFnLmpzPzEzMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBUYWctY2xvc2VyIGV4dGVuc2lvbiBmb3IgQ29kZU1pcnJvci5cbiAqXG4gKiBUaGlzIGV4dGVuc2lvbiBhZGRzIGFuIFwiYXV0b0Nsb3NlVGFnc1wiIG9wdGlvbiB0aGF0IGNhbiBiZSBzZXQgdG9cbiAqIGVpdGhlciB0cnVlIHRvIGdldCB0aGUgZGVmYXVsdCBiZWhhdmlvciwgb3IgYW4gb2JqZWN0IHRvIGZ1cnRoZXJcbiAqIGNvbmZpZ3VyZSBpdHMgYmVoYXZpb3IuXG4gKlxuICogVGhlc2UgYXJlIHN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIGB3aGVuQ2xvc2luZ2AgKGRlZmF1bHQgdHJ1ZSlcbiAqICAgV2hldGhlciB0byBhdXRvY2xvc2Ugd2hlbiB0aGUgJy8nIG9mIGEgY2xvc2luZyB0YWcgaXMgdHlwZWQuXG4gKiBgd2hlbk9wZW5pbmdgIChkZWZhdWx0IHRydWUpXG4gKiAgIFdoZXRoZXIgdG8gYXV0b2Nsb3NlIHRoZSB0YWcgd2hlbiB0aGUgZmluYWwgJz4nIG9mIGFuIG9wZW5pbmdcbiAqICAgdGFnIGlzIHR5cGVkLlxuICogYGRvbnRDbG9zZVRhZ3NgIChkZWZhdWx0IGlzIGVtcHR5IHRhZ3MgZm9yIEhUTUwsIG5vbmUgZm9yIFhNTClcbiAqICAgQW4gYXJyYXkgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvY2xvc2VkLlxuICogYGluZGVudFRhZ3NgIChkZWZhdWx0IGlzIGJsb2NrIHRhZ3MgZm9yIEhUTUwsIG5vbmUgZm9yIFhNTClcbiAqICAgQW4gYXJyYXkgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkLCB3aGVuIG9wZW5lZCwgY2F1c2UgYVxuICogICBibGFuayBsaW5lIHRvIGJlIGFkZGVkIGluc2lkZSB0aGUgdGFnLCBhbmQgdGhlIGJsYW5rIGxpbmUgYW5kXG4gKiAgIGNsb3NpbmcgbGluZSB0byBiZSBpbmRlbnRlZC5cbiAqIGBlbXB0eVRhZ3NgIChkZWZhdWx0IGlzIG5vbmUpXG4gKiAgIEFuIGFycmF5IG9mIFhNTCB0YWcgbmFtZXMgdGhhdCBzaG91bGQgYmUgYXV0b2Nsb3NlZCB3aXRoICcvPicuXG4gKlxuICogU2VlIGRlbW9zL2Nsb3NldGFnLmh0bWwgZm9yIGEgdXNhZ2UgZXhhbXBsZS5cbiAqL1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vZm9sZC94bWwtZm9sZFwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2ZvbGQveG1sLWZvbGRcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiYXV0b0Nsb3NlVGFnc1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgaWYgKG9sZCAhPSBDb2RlTWlycm9yLkluaXQgJiYgb2xkKVxuICAgICAgY20ucmVtb3ZlS2V5TWFwKFwiYXV0b0Nsb3NlVGFnc1wiKTtcbiAgICBpZiAoIXZhbCkgcmV0dXJuO1xuICAgIHZhciBtYXAgPSB7bmFtZTogXCJhdXRvQ2xvc2VUYWdzXCJ9O1xuICAgIGlmICh0eXBlb2YgdmFsICE9IFwib2JqZWN0XCIgfHwgdmFsLndoZW5DbG9zaW5nICE9PSBmYWxzZSlcbiAgICAgIG1hcFtcIicvJ1wiXSA9IGZ1bmN0aW9uKGNtKSB7IHJldHVybiBhdXRvQ2xvc2VTbGFzaChjbSk7IH07XG4gICAgaWYgKHR5cGVvZiB2YWwgIT0gXCJvYmplY3RcIiB8fCB2YWwud2hlbk9wZW5pbmcgIT09IGZhbHNlKVxuICAgICAgbWFwW1wiJz4nXCJdID0gZnVuY3Rpb24oY20pIHsgcmV0dXJuIGF1dG9DbG9zZUdUKGNtKTsgfTtcbiAgICBjbS5hZGRLZXlNYXAobWFwKTtcbiAgfSk7XG5cbiAgdmFyIGh0bWxEb250Q2xvc2UgPSBbXCJhcmVhXCIsIFwiYmFzZVwiLCBcImJyXCIsIFwiY29sXCIsIFwiY29tbWFuZFwiLCBcImVtYmVkXCIsIFwiaHJcIiwgXCJpbWdcIiwgXCJpbnB1dFwiLCBcImtleWdlblwiLCBcImxpbmtcIiwgXCJtZXRhXCIsIFwicGFyYW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiwgXCJ0cmFja1wiLCBcIndiclwiXTtcbiAgdmFyIGh0bWxJbmRlbnQgPSBbXCJhcHBsZXRcIiwgXCJibG9ja3F1b3RlXCIsIFwiYm9keVwiLCBcImJ1dHRvblwiLCBcImRpdlwiLCBcImRsXCIsIFwiZmllbGRzZXRcIiwgXCJmb3JtXCIsIFwiZnJhbWVzZXRcIiwgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLFxuICAgICAgICAgICAgICAgICAgICBcImg1XCIsIFwiaDZcIiwgXCJoZWFkXCIsIFwiaHRtbFwiLCBcImlmcmFtZVwiLCBcImxheWVyXCIsIFwibGVnZW5kXCIsIFwib2JqZWN0XCIsIFwib2xcIiwgXCJwXCIsIFwic2VsZWN0XCIsIFwidGFibGVcIiwgXCJ1bFwiXTtcblxuICBmdW5jdGlvbiBhdXRvQ2xvc2VHVChjbSkge1xuICAgIGlmIChjbS5nZXRPcHRpb24oXCJkaXNhYmxlSW5wdXRcIikpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHJlcGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBvcHQgPSBjbS5nZXRPcHRpb24oXCJhdXRvQ2xvc2VUYWdzXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXJhbmdlc1tpXS5lbXB0eSgpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5oZWFkLCB0b2sgPSBjbS5nZXRUb2tlbkF0KHBvcyk7XG4gICAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShjbS5nZXRNb2RlKCksIHRvay5zdGF0ZSksIHN0YXRlID0gaW5uZXIuc3RhdGU7XG4gICAgICB2YXIgdGFnSW5mbyA9IGlubmVyLm1vZGUueG1sQ3VycmVudFRhZyAmJiBpbm5lci5tb2RlLnhtbEN1cnJlbnRUYWcoc3RhdGUpXG4gICAgICB2YXIgdGFnTmFtZSA9IHRhZ0luZm8gJiYgdGFnSW5mby5uYW1lXG4gICAgICBpZiAoIXRhZ05hbWUpIHJldHVybiBDb2RlTWlycm9yLlBhc3NcblxuICAgICAgdmFyIGh0bWwgPSBpbm5lci5tb2RlLmNvbmZpZ3VyYXRpb24gPT0gXCJodG1sXCI7XG4gICAgICB2YXIgZG9udENsb3NlVGFncyA9ICh0eXBlb2Ygb3B0ID09IFwib2JqZWN0XCIgJiYgb3B0LmRvbnRDbG9zZVRhZ3MpIHx8IChodG1sICYmIGh0bWxEb250Q2xvc2UpO1xuICAgICAgdmFyIGluZGVudFRhZ3MgPSAodHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5pbmRlbnRUYWdzKSB8fCAoaHRtbCAmJiBodG1sSW5kZW50KTtcblxuICAgICAgaWYgKHRvay5lbmQgPiBwb3MuY2gpIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKDAsIHRhZ05hbWUubGVuZ3RoIC0gdG9rLmVuZCArIHBvcy5jaCk7XG4gICAgICB2YXIgbG93ZXJUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyB0aGUgJz4nIGF0IHRoZSBlbmQgb2YgYW4gZW5kLXRhZyBvciBzZWxmLWNsb3NpbmcgdGFnXG4gICAgICBpZiAoIXRhZ05hbWUgfHxcbiAgICAgICAgICB0b2sudHlwZSA9PSBcInN0cmluZ1wiICYmICh0b2suZW5kICE9IHBvcy5jaCB8fCAhL1tcXFwiXFwnXS8udGVzdCh0b2suc3RyaW5nLmNoYXJBdCh0b2suc3RyaW5nLmxlbmd0aCAtIDEpKSB8fCB0b2suc3RyaW5nLmxlbmd0aCA9PSAxKSB8fFxuICAgICAgICAgIHRvay50eXBlID09IFwidGFnXCIgJiYgdGFnSW5mby5jbG9zZSB8fFxuICAgICAgICAgIHRvay5zdHJpbmcuaW5kZXhPZihcIi9cIikgPT0gKHBvcy5jaCAtIHRvay5zdGFydCAtIDEpIHx8IC8vIG1hdGNoIHNvbWV0aGluZyBsaWtlIDxzb21lVGFnTmFtZSAvPlxuICAgICAgICAgIGRvbnRDbG9zZVRhZ3MgJiYgaW5kZXhPZihkb250Q2xvc2VUYWdzLCBsb3dlclRhZ05hbWUpID4gLTEgfHxcbiAgICAgICAgICBjbG9zaW5nVGFnRXhpc3RzKGNtLCBpbm5lci5tb2RlLnhtbEN1cnJlbnRDb250ZXh0ICYmIGlubmVyLm1vZGUueG1sQ3VycmVudENvbnRleHQoc3RhdGUpIHx8IFtdLCB0YWdOYW1lLCBwb3MsIHRydWUpKVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuXG4gICAgICB2YXIgZW1wdHlUYWdzID0gdHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5lbXB0eVRhZ3M7XG4gICAgICBpZiAoZW1wdHlUYWdzICYmIGluZGV4T2YoZW1wdHlUYWdzLCB0YWdOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlcGxhY2VtZW50c1tpXSA9IHsgdGV4dDogXCIvPlwiLCBuZXdQb3M6IENvZGVNaXJyb3IuUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAyKSB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudCA9IGluZGVudFRhZ3MgJiYgaW5kZXhPZihpbmRlbnRUYWdzLCBsb3dlclRhZ05hbWUpID4gLTE7XG4gICAgICByZXBsYWNlbWVudHNbaV0gPSB7aW5kZW50OiBpbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCI+XCIgKyAoaW5kZW50ID8gXCJcXG5cXG5cIiA6IFwiXCIpICsgXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvczogaW5kZW50ID8gQ29kZU1pcnJvci5Qb3MocG9zLmxpbmUgKyAxLCAwKSA6IENvZGVNaXJyb3IuUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxKX07XG4gICAgfVxuXG4gICAgdmFyIGRvbnRJbmRlbnRPbkF1dG9DbG9zZSA9ICh0eXBlb2Ygb3B0ID09IFwib2JqZWN0XCIgJiYgb3B0LmRvbnRJbmRlbnRPbkF1dG9DbG9zZSk7XG4gICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGluZm8gPSByZXBsYWNlbWVudHNbaV07XG4gICAgICBjbS5yZXBsYWNlUmFuZ2UoaW5mby50ZXh0LCByYW5nZXNbaV0uaGVhZCwgcmFuZ2VzW2ldLmFuY2hvciwgXCIraW5zZXJ0XCIpO1xuICAgICAgdmFyIHNlbCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkuc2xpY2UoMCk7XG4gICAgICBzZWxbaV0gPSB7aGVhZDogaW5mby5uZXdQb3MsIGFuY2hvcjogaW5mby5uZXdQb3N9O1xuICAgICAgY20uc2V0U2VsZWN0aW9ucyhzZWwpO1xuICAgICAgaWYgKCFkb250SW5kZW50T25BdXRvQ2xvc2UgJiYgaW5mby5pbmRlbnQpIHtcbiAgICAgICAgY20uaW5kZW50TGluZShpbmZvLm5ld1Bvcy5saW5lLCBudWxsLCB0cnVlKTtcbiAgICAgICAgY20uaW5kZW50TGluZShpbmZvLm5ld1Bvcy5saW5lICsgMSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXV0b0Nsb3NlQ3VycmVudChjbSwgdHlwaW5nU2xhc2gpIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgcmVwbGFjZW1lbnRzID0gW107XG4gICAgdmFyIGhlYWQgPSB0eXBpbmdTbGFzaCA/IFwiL1wiIDogXCI8L1wiO1xuICAgIHZhciBvcHQgPSBjbS5nZXRPcHRpb24oXCJhdXRvQ2xvc2VUYWdzXCIpO1xuICAgIHZhciBkb250SW5kZW50T25BdXRvQ2xvc2UgPSAodHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5kb250SW5kZW50T25TbGFzaCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmhlYWQsIHRvayA9IGNtLmdldFRva2VuQXQocG9zKTtcbiAgICAgIHZhciBpbm5lciA9IENvZGVNaXJyb3IuaW5uZXJNb2RlKGNtLmdldE1vZGUoKSwgdG9rLnN0YXRlKSwgc3RhdGUgPSBpbm5lci5zdGF0ZTtcbiAgICAgIGlmICh0eXBpbmdTbGFzaCAmJiAodG9rLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0b2suc3RyaW5nLmNoYXJBdCgwKSAhPSBcIjxcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2suc3RhcnQgIT0gcG9zLmNoIC0gMSkpXG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAvLyBLbHVkZ2UgdG8gZ2V0IGFyb3VuZCB0aGUgZmFjdCB0aGF0IHdlIGFyZSBub3QgaW4gWE1MIG1vZGVcbiAgICAgIC8vIHdoZW4gY29tcGxldGluZyBpbiBKUy9DU1Mgc25pcHBldCBpbiBodG1sbWl4ZWQgbW9kZS4gRG9lcyBub3RcbiAgICAgIC8vIHdvcmsgZm9yIG90aGVyIFhNTCBlbWJlZGRlZCBsYW5ndWFnZXMgKHRoZXJlIGlzIG5vIGdlbmVyYWxcbiAgICAgIC8vIHdheSB0byBnbyBmcm9tIGEgbWl4ZWQgbW9kZSB0byBpdHMgY3VycmVudCBYTUwgc3RhdGUpLlxuICAgICAgdmFyIHJlcGxhY2VtZW50LCBtaXhlZCA9IGlubmVyLm1vZGUubmFtZSAhPSBcInhtbFwiICYmIGNtLmdldE1vZGUoKS5uYW1lID09IFwiaHRtbG1peGVkXCJcbiAgICAgIGlmIChtaXhlZCAmJiBpbm5lci5tb2RlLm5hbWUgPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBoZWFkICsgXCJzY3JpcHRcIjtcbiAgICAgIH0gZWxzZSBpZiAobWl4ZWQgJiYgaW5uZXIubW9kZS5uYW1lID09IFwiY3NzXCIpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBoZWFkICsgXCJzdHlsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBpbm5lci5tb2RlLnhtbEN1cnJlbnRDb250ZXh0ICYmIGlubmVyLm1vZGUueG1sQ3VycmVudENvbnRleHQoc3RhdGUpXG4gICAgICAgIHZhciB0b3AgPSBjb250ZXh0Lmxlbmd0aCA/IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA6IFwiXCJcbiAgICAgICAgaWYgKCFjb250ZXh0IHx8IChjb250ZXh0Lmxlbmd0aCAmJiBjbG9zaW5nVGFnRXhpc3RzKGNtLCBjb250ZXh0LCB0b3AsIHBvcykpKVxuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaGVhZCArIHRvcFxuICAgICAgfVxuICAgICAgaWYgKGNtLmdldExpbmUocG9zLmxpbmUpLmNoYXJBdCh0b2suZW5kKSAhPSBcIj5cIikgcmVwbGFjZW1lbnQgKz0gXCI+XCI7XG4gICAgICByZXBsYWNlbWVudHNbaV0gPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMocmVwbGFjZW1lbnRzKTtcbiAgICByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIGlmICghZG9udEluZGVudE9uQXV0b0Nsb3NlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGkgPT0gcmFuZ2VzLmxlbmd0aCAtIDEgfHwgcmFuZ2VzW2ldLmhlYWQubGluZSA8IHJhbmdlc1tpICsgMV0uaGVhZC5saW5lKVxuICAgICAgICAgICAgICAgIGNtLmluZGVudExpbmUocmFuZ2VzW2ldLmhlYWQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXV0b0Nsb3NlU2xhc2goY20pIHtcbiAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZGlzYWJsZUlucHV0XCIpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgIHJldHVybiBhdXRvQ2xvc2VDdXJyZW50KGNtLCB0cnVlKTtcbiAgfVxuXG4gIENvZGVNaXJyb3IuY29tbWFuZHMuY2xvc2VUYWcgPSBmdW5jdGlvbihjbSkgeyByZXR1cm4gYXV0b0Nsb3NlQ3VycmVudChjbSk7IH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihjb2xsZWN0aW9uLCBlbHQpIHtcbiAgICBpZiAoY29sbGVjdGlvbi5pbmRleE9mKSByZXR1cm4gY29sbGVjdGlvbi5pbmRleE9mKGVsdCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGU7ICsraSlcbiAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09IGVsdCkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gSWYgeG1sLWZvbGQgaXMgbG9hZGVkLCB3ZSB1c2UgaXRzIGZ1bmN0aW9uYWxpdHkgdG8gdHJ5IGFuZCB2ZXJpZnlcbiAgLy8gd2hldGhlciBhIGdpdmVuIHRhZyBpcyBhY3R1YWxseSB1bmNsb3NlZC5cbiAgZnVuY3Rpb24gY2xvc2luZ1RhZ0V4aXN0cyhjbSwgY29udGV4dCwgdGFnTmFtZSwgcG9zLCBuZXdUYWcpIHtcbiAgICBpZiAoIUNvZGVNaXJyb3Iuc2NhbkZvckNsb3NpbmdUYWcpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSArIDEsIHBvcy5saW5lICsgNTAwKTtcbiAgICB2YXIgbmV4dENsb3NlID0gQ29kZU1pcnJvci5zY2FuRm9yQ2xvc2luZ1RhZyhjbSwgcG9zLCBudWxsLCBlbmQpO1xuICAgIGlmICghbmV4dENsb3NlIHx8IG5leHRDbG9zZS50YWcgIT0gdGFnTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIHRoZSBpbW1lZGlhdGUgd3JhcHBpbmcgY29udGV4dCBjb250YWlucyBvbkN4IGluc3RhbmNlcyBvZlxuICAgIC8vIHRoZSBzYW1lIHRhZywgYSBjbG9zaW5nIHRhZyBvbmx5IGV4aXN0cyBpZiB0aGVyZSBhcmUgYXQgbGVhc3RcbiAgICAvLyB0aGF0IG1hbnkgY2xvc2luZyB0YWdzIG9mIHRoYXQgdHlwZSBmb2xsb3dpbmcuXG4gICAgdmFyIG9uQ3ggPSBuZXdUYWcgPyAxIDogMFxuICAgIGZvciAodmFyIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoY29udGV4dFtpXSA9PSB0YWdOYW1lKSArK29uQ3hcbiAgICAgIGVsc2UgYnJlYWtcbiAgICB9XG4gICAgcG9zID0gbmV4dENsb3NlLnRvO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb25DeDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IENvZGVNaXJyb3Iuc2NhbkZvckNsb3NpbmdUYWcoY20sIHBvcywgbnVsbCwgZW5kKTtcbiAgICAgIGlmICghbmV4dCB8fCBuZXh0LnRhZyAhPSB0YWdOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICBwb3MgPSBuZXh0LnRvO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwiZGVmaW5lT3B0aW9uIiwiY20iLCJ2YWwiLCJvbGQiLCJJbml0IiwicmVtb3ZlS2V5TWFwIiwibWFwIiwibmFtZSIsIndoZW5DbG9zaW5nIiwiYXV0b0Nsb3NlU2xhc2giLCJ3aGVuT3BlbmluZyIsImF1dG9DbG9zZUdUIiwiYWRkS2V5TWFwIiwiaHRtbERvbnRDbG9zZSIsImh0bWxJbmRlbnQiLCJnZXRPcHRpb24iLCJQYXNzIiwicmFuZ2VzIiwibGlzdFNlbGVjdGlvbnMiLCJyZXBsYWNlbWVudHMiLCJvcHQiLCJpIiwibGVuZ3RoIiwiZW1wdHkiLCJwb3MiLCJoZWFkIiwidG9rIiwiZ2V0VG9rZW5BdCIsImlubmVyIiwiaW5uZXJNb2RlIiwiZ2V0TW9kZSIsInN0YXRlIiwidGFnSW5mbyIsIm1vZGUiLCJ4bWxDdXJyZW50VGFnIiwidGFnTmFtZSIsImh0bWwiLCJjb25maWd1cmF0aW9uIiwiZG9udENsb3NlVGFncyIsImluZGVudFRhZ3MiLCJlbmQiLCJjaCIsInNsaWNlIiwibG93ZXJUYWdOYW1lIiwidG9Mb3dlckNhc2UiLCJ0eXBlIiwidGVzdCIsInN0cmluZyIsImNoYXJBdCIsImNsb3NlIiwiaW5kZXhPZiIsInN0YXJ0IiwiY2xvc2luZ1RhZ0V4aXN0cyIsInhtbEN1cnJlbnRDb250ZXh0IiwiZW1wdHlUYWdzIiwidGV4dCIsIm5ld1BvcyIsIlBvcyIsImxpbmUiLCJpbmRlbnQiLCJkb250SW5kZW50T25BdXRvQ2xvc2UiLCJpbmZvIiwicmVwbGFjZVJhbmdlIiwiYW5jaG9yIiwic2VsIiwic2V0U2VsZWN0aW9ucyIsImluZGVudExpbmUiLCJhdXRvQ2xvc2VDdXJyZW50IiwidHlwaW5nU2xhc2giLCJkb250SW5kZW50T25TbGFzaCIsInJlcGxhY2VtZW50IiwibWl4ZWQiLCJjb250ZXh0IiwidG9wIiwiZ2V0TGluZSIsInJlcGxhY2VTZWxlY3Rpb25zIiwiY29tbWFuZHMiLCJjbG9zZVRhZyIsImNvbGxlY3Rpb24iLCJlbHQiLCJlIiwibmV3VGFnIiwic2NhbkZvckNsb3NpbmdUYWciLCJNYXRoIiwibWluIiwibGFzdExpbmUiLCJuZXh0Q2xvc2UiLCJ0YWciLCJvbkN4IiwidG8iLCJuZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/edit/closetag.js\n");

/***/ }),

/***/ "./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js":
/*!************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n  }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"-:.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line;\n    this.ch = ch;\n    this.cm = cm;\n    this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n\n      if (gt == -1) {\n        if (nextLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, gt + 1)) {\n        iter.ch = gt + 1;\n        continue;\n      }\n\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n\n      if (lt == -1) {\n        if (prevLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, lt + 1)) {\n        iter.ch = lt;\n        continue;\n      }\n\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n\n      if (!found) {\n        if (nextLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, found.index + 1)) {\n        iter.ch = found.index + 1;\n        continue;\n      }\n\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n\n      if (gt == -1) {\n        if (prevLine(iter)) continue;else return;\n      }\n\n      if (!tagAt(iter, gt + 1)) {\n        iter.ch = gt;\n        continue;\n      }\n\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n\n    for (;;) {\n      var next = toNextTag(iter),\n          end,\n          startLine = iter.line,\n          startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n\n      if (next[1]) {\n        // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) {\n          if (stack[i] == next[2]) {\n            stack.length = i;\n            break;\n          }\n        }\n\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else {\n        // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n\n      if (prev == \"selfClose\") {\n        toTagStart(iter);\n        continue;\n      }\n\n      var endLine = iter.line,\n          endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n\n      if (start[1]) {\n        // closing tag\n        stack.push(start[2]);\n      } else {\n        // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) {\n          if (stack[i] == start[2]) {\n            stack.length = i;\n            break;\n          }\n        }\n\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function (cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n\n    for (;;) {\n      var openTag = toNextTag(iter);\n      if (!openTag || iter.line != start.line) return;\n      var end = toTagEnd(iter);\n      if (!end) return;\n\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && cmp(endPos.from, startPos) > 0 ? {\n          from: startPos,\n          to: endPos.from\n        } : null;\n      }\n    }\n  });\n\n  CodeMirror.findMatchingTag = function (cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter),\n        to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {\n      from: Pos(iter.line, iter.ch),\n      to: to,\n      tag: start[2]\n    };\n    if (end == \"selfClose\") return {\n      open: here,\n      close: null,\n      at: \"open\"\n    };\n\n    if (start[1]) {\n      // closing tag\n      return {\n        open: findMatchingOpen(iter, start[2]),\n        close: here,\n        at: \"close\"\n      };\n    } else {\n      // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {\n        open: here,\n        close: findMatchingClose(iter, start[2]),\n        at: \"open\"\n      };\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function (cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {\n        open: open,\n        close: close\n      };\n    }\n  }; // Used by addon/edit/closetag.js\n\n\n  CodeMirror.scanForClosingTag = function (cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {\n      from: 0,\n      to: end\n    } : null);\n    return findMatchingClose(iter, name);\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC94bWwtZm9sZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsQ0FBRCxvQ0FBMkJKLEdBQTNCO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREcsS0FFQTtJQUNIQSxFQUFBO0FBQ0gsQ0FQRCxFQU9HLFVBQVNNLFVBQVQsRUFBcUI7RUFDdEI7O0VBRUEsSUFBSUMsR0FBRyxHQUFHRCxVQUFVLENBQUNDLEdBQXJCOztFQUNBLFNBQVNDLEdBQVQsQ0FBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI7SUFBRSxPQUFPRCxDQUFDLENBQUNFLElBQUYsR0FBU0QsQ0FBQyxDQUFDQyxJQUFYLElBQW1CRixDQUFDLENBQUNHLEVBQUYsR0FBT0YsQ0FBQyxDQUFDRSxFQUFuQztFQUF3Qzs7RUFFN0QsSUFBSUMsYUFBYSxHQUFHLDhLQUFwQjtFQUNBLElBQUlDLFFBQVEsR0FBR0QsYUFBYSxHQUFHLDZDQUEvQjtFQUNBLElBQUlFLFdBQVcsR0FBRyxJQUFJQyxNQUFKLENBQVcsWUFBWUgsYUFBWixHQUE0QixJQUE1QixHQUFtQ0MsUUFBbkMsR0FBOEMsS0FBekQsRUFBZ0UsR0FBaEUsQ0FBbEI7O0VBRUEsU0FBU0csSUFBVCxDQUFjQyxFQUFkLEVBQWtCUCxJQUFsQixFQUF3QkMsRUFBeEIsRUFBNEJPLEtBQTVCLEVBQW1DO0lBQ2pDLEtBQUtSLElBQUwsR0FBWUEsSUFBWjtJQUFrQixLQUFLQyxFQUFMLEdBQVVBLEVBQVY7SUFDbEIs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QUFPLEdBQUcsSUFBSTdELElBQUosQ0FBU0MsRUFBVCxFQUFhc0QsR0FBRyxDQUFDN0QsSUFBakIsRUFBdUI2RCxHQUFHLENBQUM1RCxFQUEzQixFQUErQk8sS0FBL0IsQ0FBZDtNQUNBLElBQUl3RCxLQUFLLEdBQUd0QixpQkFBaUIsQ0FBQ3lCLE9BQUQsRUFBVUosSUFBSSxDQUFDcEIsR0FBZixDQUE3QjtNQUNBLElBQUlxQixLQUFKLEVBQVcsT0FBTztRQUFDRCxJQUFJLEVBQUVBLElBQVA7UUFBYUMsS0FBSyxFQUFFQTtNQUFwQixDQUFQO0lBQ1o7RUFDRixDQVRELENBN0pzQixDQXdLdEI7OztFQUNBckUsVUFBVSxDQUFDeUUsaUJBQVgsR0FBK0IsVUFBUzdELEVBQVQsRUFBYXNELEdBQWIsRUFBa0JRLElBQWxCLEVBQXdCdkIsR0FBeEIsRUFBNkI7SUFDMUQsSUFBSTNCLElBQUksR0FBRyxJQUFJYixJQUFKLENBQVNDLEVBQVQsRUFBYXNELEdBQUcsQ0FBQzdELElBQWpCLEVBQXVCNkQsR0FBRyxDQUFDNUQsRUFBM0IsRUFBK0I2QyxHQUFHLEdBQUc7TUFBQ2hDLElBQUksRUFBRSxDQUFQO01BQVVFLEVBQUUsRUFBRThCO0lBQWQsQ0FBSCxHQUF3QixJQUExRCxDQUFYO0lBQ0EsT0FBT0osaUJBQWlCLENBQUN2QixJQUFELEVBQU9rRCxJQUFQLENBQXhCO0VBQ0QsQ0FIRDtBQUlELENBcExEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL2FkZG9uL2ZvbGQveG1sLWZvbGQuanM/YTY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG4gIGZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2g7IH1cblxuICB2YXIgbmFtZVN0YXJ0Q2hhciA9IFwiQS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4gIHZhciBuYW1lQ2hhciA9IG5hbWVTdGFydENoYXIgKyBcIlxcLVxcOlxcLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG4gIHZhciB4bWxUYWdTdGFydCA9IG5ldyBSZWdFeHAoXCI8KC8/KShbXCIgKyBuYW1lU3RhcnRDaGFyICsgXCJdW1wiICsgbmFtZUNoYXIgKyBcIl0qKVwiLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gSXRlcihjbSwgbGluZSwgY2gsIHJhbmdlKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoO1xuICAgIHRoaXMuY20gPSBjbTsgdGhpcy50ZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICB0aGlzLm1pbiA9IHJhbmdlID8gTWF0aC5tYXgocmFuZ2UuZnJvbSwgY20uZmlyc3RMaW5lKCkpIDogY20uZmlyc3RMaW5lKCk7XG4gICAgdGhpcy5tYXggPSByYW5nZSA/IE1hdGgubWluKHJhbmdlLnRvIC0gMSwgY20ubGFzdExpbmUoKSkgOiBjbS5sYXN0TGluZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnQXQoaXRlciwgY2gpIHtcbiAgICB2YXIgdHlwZSA9IGl0ZXIuY20uZ2V0VG9rZW5UeXBlQXQoUG9zKGl0ZXIubGluZSwgY2gpKTtcbiAgICByZXR1cm4gdHlwZSAmJiAvXFxidGFnXFxiLy50ZXN0KHR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dExpbmUoaXRlcikge1xuICAgIGlmIChpdGVyLmxpbmUgPj0gaXRlci5tYXgpIHJldHVybjtcbiAgICBpdGVyLmNoID0gMDtcbiAgICBpdGVyLnRleHQgPSBpdGVyLmNtLmdldExpbmUoKytpdGVyLmxpbmUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZMaW5lKGl0ZXIpIHtcbiAgICBpZiAoaXRlci5saW5lIDw9IGl0ZXIubWluKSByZXR1cm47XG4gICAgaXRlci50ZXh0ID0gaXRlci5jbS5nZXRMaW5lKC0taXRlci5saW5lKTtcbiAgICBpdGVyLmNoID0gaXRlci50ZXh0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvVGFnRW5kKGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZ3QgPSBpdGVyLnRleHQuaW5kZXhPZihcIj5cIiwgaXRlci5jaCk7XG4gICAgICBpZiAoZ3QgPT0gLTEpIHsgaWYgKG5leHRMaW5lKGl0ZXIpKSBjb250aW51ZTsgZWxzZSByZXR1cm47IH1cbiAgICAgIGlmICghdGFnQXQoaXRlciwgZ3QgKyAxKSkgeyBpdGVyLmNoID0gZ3QgKyAxOyBjb250aW51ZTsgfVxuICAgICAgdmFyIGxhc3RTbGFzaCA9IGl0ZXIudGV4dC5sYXN0SW5kZXhPZihcIi9cIiwgZ3QpO1xuICAgICAgdmFyIHNlbGZDbG9zZSA9IGxhc3RTbGFzaCA+IC0xICYmICEvXFxTLy50ZXN0KGl0ZXIudGV4dC5zbGljZShsYXN0U2xhc2ggKyAxLCBndCkpO1xuICAgICAgaXRlci5jaCA9IGd0ICsgMTtcbiAgICAgIHJldHVybiBzZWxmQ2xvc2UgPyBcInNlbGZDbG9zZVwiIDogXCJyZWd1bGFyXCI7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvVGFnU3RhcnQoaXRlcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBsdCA9IGl0ZXIuY2ggPyBpdGVyLnRleHQubGFzdEluZGV4T2YoXCI8XCIsIGl0ZXIuY2ggLSAxKSA6IC0xO1xuICAgICAgaWYgKGx0ID09IC0xKSB7IGlmIChwcmV2TGluZShpdGVyKSkgY29udGludWU7IGVsc2UgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRhZ0F0KGl0ZXIsIGx0ICsgMSkpIHsgaXRlci5jaCA9IGx0OyBjb250aW51ZTsgfVxuICAgICAgeG1sVGFnU3RhcnQubGFzdEluZGV4ID0gbHQ7XG4gICAgICBpdGVyLmNoID0gbHQ7XG4gICAgICB2YXIgbWF0Y2ggPSB4bWxUYWdTdGFydC5leGVjKGl0ZXIudGV4dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT0gbHQpIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b05leHRUYWcoaXRlcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHhtbFRhZ1N0YXJ0Lmxhc3RJbmRleCA9IGl0ZXIuY2g7XG4gICAgICB2YXIgZm91bmQgPSB4bWxUYWdTdGFydC5leGVjKGl0ZXIudGV4dCk7XG4gICAgICBpZiAoIWZvdW5kKSB7IGlmIChuZXh0TGluZShpdGVyKSkgY29udGludWU7IGVsc2UgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRhZ0F0KGl0ZXIsIGZvdW5kLmluZGV4ICsgMSkpIHsgaXRlci5jaCA9IGZvdW5kLmluZGV4ICsgMTsgY29udGludWU7IH1cbiAgICAgIGl0ZXIuY2ggPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9QcmV2VGFnKGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZ3QgPSBpdGVyLmNoID8gaXRlci50ZXh0Lmxhc3RJbmRleE9mKFwiPlwiLCBpdGVyLmNoIC0gMSkgOiAtMTtcbiAgICAgIGlmIChndCA9PSAtMSkgeyBpZiAocHJldkxpbmUoaXRlcikpIGNvbnRpbnVlOyBlbHNlIHJldHVybjsgfVxuICAgICAgaWYgKCF0YWdBdChpdGVyLCBndCArIDEpKSB7IGl0ZXIuY2ggPSBndDsgY29udGludWU7IH1cbiAgICAgIHZhciBsYXN0U2xhc2ggPSBpdGVyLnRleHQubGFzdEluZGV4T2YoXCIvXCIsIGd0KTtcbiAgICAgIHZhciBzZWxmQ2xvc2UgPSBsYXN0U2xhc2ggPiAtMSAmJiAhL1xcUy8udGVzdChpdGVyLnRleHQuc2xpY2UobGFzdFNsYXNoICsgMSwgZ3QpKTtcbiAgICAgIGl0ZXIuY2ggPSBndCArIDE7XG4gICAgICByZXR1cm4gc2VsZkNsb3NlID8gXCJzZWxmQ2xvc2VcIiA6IFwicmVndWxhclwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0Nsb3NlKGl0ZXIsIHRhZykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXh0ID0gdG9OZXh0VGFnKGl0ZXIpLCBlbmQsIHN0YXJ0TGluZSA9IGl0ZXIubGluZSwgc3RhcnRDaCA9IGl0ZXIuY2ggLSAobmV4dCA/IG5leHRbMF0ubGVuZ3RoIDogMCk7XG4gICAgICBpZiAoIW5leHQgfHwgIShlbmQgPSB0b1RhZ0VuZChpdGVyKSkpIHJldHVybjtcbiAgICAgIGlmIChlbmQgPT0gXCJzZWxmQ2xvc2VcIikgY29udGludWU7XG4gICAgICBpZiAobmV4dFsxXSkgeyAvLyBjbG9zaW5nIHRhZ1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGlmIChzdGFja1tpXSA9PSBuZXh0WzJdKSB7XG4gICAgICAgICAgc3RhY2subGVuZ3RoID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgJiYgKCF0YWcgfHwgdGFnID09IG5leHRbMl0pKSByZXR1cm4ge1xuICAgICAgICAgIHRhZzogbmV4dFsyXSxcbiAgICAgICAgICBmcm9tOiBQb3Moc3RhcnRMaW5lLCBzdGFydENoKSxcbiAgICAgICAgICB0bzogUG9zKGl0ZXIubGluZSwgaXRlci5jaClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7IC8vIG9wZW5pbmcgdGFnXG4gICAgICAgIHN0YWNrLnB1c2gobmV4dFsyXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ09wZW4oaXRlciwgdGFnKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIHByZXYgPSB0b1ByZXZUYWcoaXRlcik7XG4gICAgICBpZiAoIXByZXYpIHJldHVybjtcbiAgICAgIGlmIChwcmV2ID09IFwic2VsZkNsb3NlXCIpIHsgdG9UYWdTdGFydChpdGVyKTsgY29udGludWU7IH1cbiAgICAgIHZhciBlbmRMaW5lID0gaXRlci5saW5lLCBlbmRDaCA9IGl0ZXIuY2g7XG4gICAgICB2YXIgc3RhcnQgPSB0b1RhZ1N0YXJ0KGl0ZXIpO1xuICAgICAgaWYgKCFzdGFydCkgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0WzFdKSB7IC8vIGNsb3NpbmcgdGFnXG4gICAgICAgIHN0YWNrLnB1c2goc3RhcnRbMl0pO1xuICAgICAgfSBlbHNlIHsgLy8gb3BlbmluZyB0YWdcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBpZiAoc3RhY2tbaV0gPT0gc3RhcnRbMl0pIHtcbiAgICAgICAgICBzdGFjay5sZW5ndGggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgMCAmJiAoIXRhZyB8fCB0YWcgPT0gc3RhcnRbMl0pKSByZXR1cm4ge1xuICAgICAgICAgIHRhZzogc3RhcnRbMl0sXG4gICAgICAgICAgZnJvbTogUG9zKGl0ZXIubGluZSwgaXRlci5jaCksXG4gICAgICAgICAgdG86IFBvcyhlbmRMaW5lLCBlbmRDaClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiZm9sZFwiLCBcInhtbFwiLCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBJdGVyKGNtLCBzdGFydC5saW5lLCAwKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgb3BlblRhZyA9IHRvTmV4dFRhZyhpdGVyKVxuICAgICAgaWYgKCFvcGVuVGFnIHx8IGl0ZXIubGluZSAhPSBzdGFydC5saW5lKSByZXR1cm5cbiAgICAgIHZhciBlbmQgPSB0b1RhZ0VuZChpdGVyKVxuICAgICAgaWYgKCFlbmQpIHJldHVyblxuICAgICAgaWYgKCFvcGVuVGFnWzFdICYmIGVuZCAhPSBcInNlbGZDbG9zZVwiKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpO1xuICAgICAgICB2YXIgZW5kUG9zID0gZmluZE1hdGNoaW5nQ2xvc2UoaXRlciwgb3BlblRhZ1syXSk7XG4gICAgICAgIHJldHVybiBlbmRQb3MgJiYgY21wKGVuZFBvcy5mcm9tLCBzdGFydFBvcykgPiAwID8ge2Zyb206IHN0YXJ0UG9zLCB0bzogZW5kUG9zLmZyb219IDogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIENvZGVNaXJyb3IuZmluZE1hdGNoaW5nVGFnID0gZnVuY3Rpb24oY20sIHBvcywgcmFuZ2UpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBJdGVyKGNtLCBwb3MubGluZSwgcG9zLmNoLCByYW5nZSk7XG4gICAgaWYgKGl0ZXIudGV4dC5pbmRleE9mKFwiPlwiKSA9PSAtMSAmJiBpdGVyLnRleHQuaW5kZXhPZihcIjxcIikgPT0gLTEpIHJldHVybjtcbiAgICB2YXIgZW5kID0gdG9UYWdFbmQoaXRlciksIHRvID0gZW5kICYmIFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpO1xuICAgIHZhciBzdGFydCA9IGVuZCAmJiB0b1RhZ1N0YXJ0KGl0ZXIpO1xuICAgIGlmICghZW5kIHx8ICFzdGFydCB8fCBjbXAoaXRlciwgcG9zKSA+IDApIHJldHVybjtcbiAgICB2YXIgaGVyZSA9IHtmcm9tOiBQb3MoaXRlci5saW5lLCBpdGVyLmNoKSwgdG86IHRvLCB0YWc6IHN0YXJ0WzJdfTtcbiAgICBpZiAoZW5kID09IFwic2VsZkNsb3NlXCIpIHJldHVybiB7b3BlbjogaGVyZSwgY2xvc2U6IG51bGwsIGF0OiBcIm9wZW5cIn07XG5cbiAgICBpZiAoc3RhcnRbMV0pIHsgLy8gY2xvc2luZyB0YWdcbiAgICAgIHJldHVybiB7b3BlbjogZmluZE1hdGNoaW5nT3BlbihpdGVyLCBzdGFydFsyXSksIGNsb3NlOiBoZXJlLCBhdDogXCJjbG9zZVwifTtcbiAgICB9IGVsc2UgeyAvLyBvcGVuaW5nIHRhZ1xuICAgICAgaXRlciA9IG5ldyBJdGVyKGNtLCB0by5saW5lLCB0by5jaCwgcmFuZ2UpO1xuICAgICAgcmV0dXJuIHtvcGVuOiBoZXJlLCBjbG9zZTogZmluZE1hdGNoaW5nQ2xvc2UoaXRlciwgc3RhcnRbMl0pLCBhdDogXCJvcGVuXCJ9O1xuICAgIH1cbiAgfTtcblxuICBDb2RlTWlycm9yLmZpbmRFbmNsb3NpbmdUYWcgPSBmdW5jdGlvbihjbSwgcG9zLCByYW5nZSwgdGFnKSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgSXRlcihjbSwgcG9zLmxpbmUsIHBvcy5jaCwgcmFuZ2UpO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBvcGVuID0gZmluZE1hdGNoaW5nT3BlbihpdGVyLCB0YWcpO1xuICAgICAgaWYgKCFvcGVuKSBicmVhaztcbiAgICAgIHZhciBmb3J3YXJkID0gbmV3IEl0ZXIoY20sIHBvcy5saW5lLCBwb3MuY2gsIHJhbmdlKTtcbiAgICAgIHZhciBjbG9zZSA9IGZpbmRNYXRjaGluZ0Nsb3NlKGZvcndhcmQsIG9wZW4udGFnKTtcbiAgICAgIGlmIChjbG9zZSkgcmV0dXJuIHtvcGVuOiBvcGVuLCBjbG9zZTogY2xvc2V9O1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGJ5IGFkZG9uL2VkaXQvY2xvc2V0YWcuanNcbiAgQ29kZU1pcnJvci5zY2FuRm9yQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uKGNtLCBwb3MsIG5hbWUsIGVuZCkge1xuICAgIHZhciBpdGVyID0gbmV3IEl0ZXIoY20sIHBvcy5saW5lLCBwb3MuY2gsIGVuZCA/IHtmcm9tOiAwLCB0bzogZW5kfSA6IG51bGwpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdDbG9zZShpdGVyLCBuYW1lKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsIlBvcyIsImNtcCIsImEiLCJiIiwibGluZSIsImNoIiwibmFtZVN0YXJ0Q2hhciIsIm5hbWVDaGFyIiwieG1sVGFnU3RhcnQiLCJSZWdFeHAiLCJJdGVyIiwiY20iLCJyYW5nZSIsInRleHQiLCJnZXRMaW5lIiwibWluIiwiTWF0aCIsIm1heCIsImZyb20iLCJmaXJzdExpbmUiLCJ0byIsImxhc3RMaW5lIiwidGFnQXQiLCJpdGVyIiwidHlwZSIsImdldFRva2VuVHlwZUF0IiwidGVzdCIsIm5leHRMaW5lIiwicHJldkxpbmUiLCJsZW5ndGgiLCJ0b1RhZ0VuZCIsImd0IiwiaW5kZXhPZiIsImxhc3RTbGFzaCIsImxhc3RJbmRleE9mIiwic2VsZkNsb3NlIiwic2xpY2UiLCJ0b1RhZ1N0YXJ0IiwibHQiLCJsYXN0SW5kZXgiLCJtYXRjaCIsImV4ZWMiLCJpbmRleCIsInRvTmV4dFRhZyIsImZvdW5kIiwidG9QcmV2VGFnIiwiZmluZE1hdGNoaW5nQ2xvc2UiLCJ0YWciLCJzdGFjayIsIm5leHQiLCJlbmQiLCJzdGFydExpbmUiLCJzdGFydENoIiwiaSIsInB1c2giLCJmaW5kTWF0Y2hpbmdPcGVuIiwicHJldiIsImVuZExpbmUiLCJlbmRDaCIsInN0YXJ0IiwicmVnaXN0ZXJIZWxwZXIiLCJvcGVuVGFnIiwic3RhcnRQb3MiLCJlbmRQb3MiLCJmaW5kTWF0Y2hpbmdUYWciLCJwb3MiLCJoZXJlIiwib3BlbiIsImNsb3NlIiwiYXQiLCJmaW5kRW5jbG9zaW5nVGFnIiwiZm9yd2FyZCIsInNjYW5Gb3JDbG9zaW5nVGFnIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/fold/xml-fold.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/addon/edit/closetag.js");
/******/ 	
/******/ })()
;