/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/addon/wrap/hardwrap.js":
/*!************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/wrap/hardwrap.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function findParagraph(cm, pos, options) {\n    var startRE = options.paragraphStart || cm.getHelper(pos, \"paragraphStart\");\n\n    for (var start = pos.line, first = cm.firstLine(); start > first; --start) {\n      var line = cm.getLine(start);\n      if (startRE && startRE.test(line)) break;\n\n      if (!/\\S/.test(line)) {\n        ++start;\n        break;\n      }\n    }\n\n    var endRE = options.paragraphEnd || cm.getHelper(pos, \"paragraphEnd\");\n\n    for (var end = pos.line + 1, last = cm.lastLine(); end <= last; ++end) {\n      var line = cm.getLine(end);\n\n      if (endRE && endRE.test(line)) {\n        ++end;\n        break;\n      }\n\n      if (!/\\S/.test(line)) break;\n    }\n\n    return {\n      from: start,\n      to: end\n    };\n  }\n\n  function findBreakPoint(text, column, wrapOn, killTrailingSpace, forceBreak) {\n    var at = column;\n\n    while (at < text.length && text.charAt(at) == \" \") {\n      at++;\n    }\n\n    for (; at > 0; --at) {\n      if (wrapOn.test(text.slice(at - 1, at + 1))) break;\n    }\n\n    if (!forceBreak && at <= text.match(/^[ \\t]*/)[0].length) {\n      // didn't find a break point before column, in non-forceBreak mode try to\n      // find one after 'column'.\n      for (at = column + 1; at < text.length - 1; ++at) {\n        if (wrapOn.test(text.slice(at - 1, at + 1))) break;\n      }\n    }\n\n    for (var first = true;; first = false) {\n      var endOfText = at;\n      if (killTrailingSpace) while (text.charAt(endOfText - 1) == \" \") {\n        --endOfText;\n      }\n      if (endOfText == 0 && first) at = column;else return {\n        from: endOfText,\n        to: at\n      };\n    }\n  }\n\n  function wrapRange(cm, from, to, options) {\n    from = cm.clipPos(from);\n    to = cm.clipPos(to);\n    var column = options.column || 80;\n    var wrapOn = options.wrapOn || /\\s\\S|-[^\\.\\d]/;\n    var forceBreak = options.forceBreak !== false;\n    var killTrailing = options.killTrailingSpace !== false;\n    var changes = [],\n        curLine = \"\",\n        curNo = from.line;\n    var lines = cm.getRange(from, to, false);\n    if (!lines.length) return null;\n    var leadingSpace = lines[0].match(/^[ \\t]*/)[0];\n    if (leadingSpace.length >= column) column = leadingSpace.length + 1;\n\n    for (var i = 0; i < lines.length; ++i) {\n      var text = lines[i],\n          oldLen = curLine.length,\n          spaceInserted = 0;\n\n      if (curLine && text && !wrapOn.test(curLine.charAt(curLine.length - 1) + text.charAt(0))) {\n        curLine += \" \";\n        spaceInserted = 1;\n      }\n\n      var spaceTrimmed = \"\";\n\n      if (i) {\n        spaceTrimmed = text.match(/^\\s*/)[0];\n        text = text.slice(spaceTrimmed.length);\n      }\n\n      curLine += text;\n\n      if (i) {\n        var firstBreak = curLine.length > column && leadingSpace == spaceTrimmed && findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak); // If this isn't broken, or is broken at a different point, remove old break\n\n        if (!firstBreak || firstBreak.from != oldLen || firstBreak.to != oldLen + spaceInserted) {\n          changes.push({\n            text: [spaceInserted ? \" \" : \"\"],\n            from: Pos(curNo, oldLen),\n            to: Pos(curNo + 1, spaceTrimmed.length)\n          });\n        } else {\n          curLine = leadingSpace + text;\n          ++curNo;\n        }\n      }\n\n      while (curLine.length > column) {\n        var bp = findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak);\n\n        if (bp.from != bp.to || forceBreak && leadingSpace !== curLine.slice(0, bp.to)) {\n          changes.push({\n            text: [\"\", leadingSpace],\n            from: Pos(curNo, bp.from),\n            to: Pos(curNo, bp.to)\n          });\n          curLine = leadingSpace + curLine.slice(bp.to);\n          ++curNo;\n        } else {\n          break;\n        }\n      }\n    }\n\n    if (changes.length) cm.operation(function () {\n      for (var i = 0; i < changes.length; ++i) {\n        var change = changes[i];\n        if (change.text || CodeMirror.cmpPos(change.from, change.to)) cm.replaceRange(change.text, change.from, change.to);\n      }\n    });\n    return changes.length ? {\n      from: changes[0].from,\n      to: CodeMirror.changeEnd(changes[changes.length - 1])\n    } : null;\n  }\n\n  CodeMirror.defineExtension(\"wrapParagraph\", function (pos, options) {\n    options = options || {};\n    if (!pos) pos = this.getCursor();\n    var para = findParagraph(this, pos, options);\n    return wrapRange(this, Pos(para.from, 0), Pos(para.to - 1), options);\n  });\n\n  CodeMirror.commands.wrapLines = function (cm) {\n    cm.operation(function () {\n      var ranges = cm.listSelections(),\n          at = cm.lastLine() + 1;\n\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var range = ranges[i],\n            span;\n\n        if (range.empty()) {\n          var para = findParagraph(cm, range.head, {});\n          span = {\n            from: Pos(para.from, 0),\n            to: Pos(para.to - 1)\n          };\n        } else {\n          span = {\n            from: range.from(),\n            to: range.to()\n          };\n        }\n\n        if (span.to.line >= at) continue;\n        at = span.from.line;\n        wrapRange(cm, span.from, span.to, {});\n      }\n    });\n  };\n\n  CodeMirror.defineExtension(\"wrapRange\", function (from, to, options) {\n    return wrapRange(this, from, to, options || {});\n  });\n  CodeMirror.defineExtension(\"wrapParagraphsInRange\", function (from, to, options) {\n    options = options || {};\n    var cm = this,\n        paras = [];\n\n    for (var line = from.line; line <= to.line;) {\n      var para = findParagraph(cm, Pos(line, 0), options);\n      paras.push(para);\n      line = para.to;\n    }\n\n    var madeChange = false;\n    if (paras.length) cm.operation(function () {\n      for (var i = paras.length - 1; i >= 0; --i) {\n        madeChange = madeChange || wrapRange(cm, Pos(paras[i].from, 0), Pos(paras[i].to - 1), options);\n      }\n    });\n    return madeChange;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vd3JhcC9oYXJkd3JhcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsQ0FBRCxvQ0FBMkJKLEdBQTNCO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREcsS0FFQTtJQUNIQSxFQUFBO0FBQ0gsQ0FQRCxFQU9HLFVBQVNNLFVBQVQsRUFBcUI7RUFDdEI7O0VBRUEsSUFBSUMsR0FBRyxHQUFHRCxVQUFVLENBQUNDLEdBQXJCOztFQUVBLFNBQVNDLGFBQVQsQ0FBdUJDLEVBQXZCLEVBQTJCQyxHQUEzQixFQUFnQ0MsT0FBaEMsRUFBeUM7SUFDdkMsSUFBSUMsT0FBTyxHQUFHRCxPQUFPLENBQUNFLGNBQVIsSUFBMEJKLEVBQUUsQ0FBQ0ssU0FBSCxDQUFhSixHQUFiLEVBQWtCLGdCQUFsQixDQUF4Qzs7SUFDQSxLQUFLLElBQUlLLEtBQUssR0FBR0wsR0FBRyxDQUFDTSxJQUFoQixFQUFzQkMsS0FBSyxHQUFHUixFQUFFLENBQUNTLFNBQUgsRUFBbkMsRUFBbURILEtBQUssR0FBR0UsS0FBM0QsRUFBa0UsRUFBRUYsS0FBcEUsRUFBMkU7TUFDekUsSUFBSUMsSUFBSSxHQUFHUCxFQUFFLENBQUNVLE9BQUgsQ0FBV0osS0FBWCxDQUFYO01BQ0EsSUFBSUgsT0FBTyxJQUFJQSxPQUFPLENBQUNRLElBQVIsQ0FBYUosSUFBYixDQUFmLEVBQW1DOztNQUNuQyxJQUFJLENBQUMsS0FBS0ksSUFBTCxDQUFVSixJQUFWLENBQUwsRUFBc0I7UUFB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aEIsT0FBbEQsQ0FBcEM7TUFERjtJQUVELENBSGlCO0lBSWxCLE9BQU84RCxVQUFQO0VBQ0QsQ0FkRDtBQWVELENBNUpEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL2FkZG9uL3dyYXAvaGFyZHdyYXAuanM/MTI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG5cbiAgZnVuY3Rpb24gZmluZFBhcmFncmFwaChjbSwgcG9zLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0UkUgPSBvcHRpb25zLnBhcmFncmFwaFN0YXJ0IHx8IGNtLmdldEhlbHBlcihwb3MsIFwicGFyYWdyYXBoU3RhcnRcIik7XG4gICAgZm9yICh2YXIgc3RhcnQgPSBwb3MubGluZSwgZmlyc3QgPSBjbS5maXJzdExpbmUoKTsgc3RhcnQgPiBmaXJzdDsgLS1zdGFydCkge1xuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydFJFICYmIHN0YXJ0UkUudGVzdChsaW5lKSkgYnJlYWs7XG4gICAgICBpZiAoIS9cXFMvLnRlc3QobGluZSkpIHsgKytzdGFydDsgYnJlYWs7IH1cbiAgICB9XG4gICAgdmFyIGVuZFJFID0gb3B0aW9ucy5wYXJhZ3JhcGhFbmQgfHwgY20uZ2V0SGVscGVyKHBvcywgXCJwYXJhZ3JhcGhFbmRcIik7XG4gICAgZm9yICh2YXIgZW5kID0gcG9zLmxpbmUgKyAxLCBsYXN0ID0gY20ubGFzdExpbmUoKTsgZW5kIDw9IGxhc3Q7ICsrZW5kKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUoZW5kKTtcbiAgICAgIGlmIChlbmRSRSAmJiBlbmRSRS50ZXN0KGxpbmUpKSB7ICsrZW5kOyBicmVhazsgfVxuICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUpKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBzdGFydCwgdG86IGVuZH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQnJlYWtQb2ludCh0ZXh0LCBjb2x1bW4sIHdyYXBPbiwga2lsbFRyYWlsaW5nU3BhY2UsIGZvcmNlQnJlYWspIHtcbiAgICB2YXIgYXQgPSBjb2x1bW5cbiAgICB3aGlsZSAoYXQgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChhdCkgPT0gXCIgXCIpIGF0KytcbiAgICBmb3IgKDsgYXQgPiAwOyAtLWF0KVxuICAgICAgaWYgKHdyYXBPbi50ZXN0KHRleHQuc2xpY2UoYXQgLSAxLCBhdCArIDEpKSkgYnJlYWs7XG5cbiAgICBpZiAoIWZvcmNlQnJlYWsgJiYgYXQgPD0gdGV4dC5tYXRjaCgvXlsgXFx0XSovKVswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGRpZG4ndCBmaW5kIGEgYnJlYWsgcG9pbnQgYmVmb3JlIGNvbHVtbiwgaW4gbm9uLWZvcmNlQnJlYWsgbW9kZSB0cnkgdG9cbiAgICAgIC8vIGZpbmQgb25lIGFmdGVyICdjb2x1bW4nLlxuICAgICAgZm9yIChhdCA9IGNvbHVtbiArIDE7IGF0IDwgdGV4dC5sZW5ndGggLSAxOyArK2F0KSB7XG4gICAgICAgIGlmICh3cmFwT24udGVzdCh0ZXh0LnNsaWNlKGF0IC0gMSwgYXQgKyAxKSkpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgIHZhciBlbmRPZlRleHQgPSBhdDtcbiAgICAgIGlmIChraWxsVHJhaWxpbmdTcGFjZSlcbiAgICAgICAgd2hpbGUgKHRleHQuY2hhckF0KGVuZE9mVGV4dCAtIDEpID09IFwiIFwiKSAtLWVuZE9mVGV4dDtcbiAgICAgIGlmIChlbmRPZlRleHQgPT0gMCAmJiBmaXJzdCkgYXQgPSBjb2x1bW47XG4gICAgICBlbHNlIHJldHVybiB7ZnJvbTogZW5kT2ZUZXh0LCB0bzogYXR9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBSYW5nZShjbSwgZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBmcm9tID0gY20uY2xpcFBvcyhmcm9tKTsgdG8gPSBjbS5jbGlwUG9zKHRvKTtcbiAgICB2YXIgY29sdW1uID0gb3B0aW9ucy5jb2x1bW4gfHwgODA7XG4gICAgdmFyIHdyYXBPbiA9IG9wdGlvbnMud3JhcE9uIHx8IC9cXHNcXFN8LVteXFwuXFxkXS87XG4gICAgdmFyIGZvcmNlQnJlYWsgPSBvcHRpb25zLmZvcmNlQnJlYWsgIT09IGZhbHNlO1xuICAgIHZhciBraWxsVHJhaWxpbmcgPSBvcHRpb25zLmtpbGxUcmFpbGluZ1NwYWNlICE9PSBmYWxzZTtcbiAgICB2YXIgY2hhbmdlcyA9IFtdLCBjdXJMaW5lID0gXCJcIiwgY3VyTm8gPSBmcm9tLmxpbmU7XG4gICAgdmFyIGxpbmVzID0gY20uZ2V0UmFuZ2UoZnJvbSwgdG8sIGZhbHNlKTtcbiAgICBpZiAoIWxpbmVzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGxlYWRpbmdTcGFjZSA9IGxpbmVzWzBdLm1hdGNoKC9eWyBcXHRdKi8pWzBdO1xuICAgIGlmIChsZWFkaW5nU3BhY2UubGVuZ3RoID49IGNvbHVtbikgY29sdW1uID0gbGVhZGluZ1NwYWNlLmxlbmd0aCArIDFcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0ZXh0ID0gbGluZXNbaV0sIG9sZExlbiA9IGN1ckxpbmUubGVuZ3RoLCBzcGFjZUluc2VydGVkID0gMDtcbiAgICAgIGlmIChjdXJMaW5lICYmIHRleHQgJiYgIXdyYXBPbi50ZXN0KGN1ckxpbmUuY2hhckF0KGN1ckxpbmUubGVuZ3RoIC0gMSkgKyB0ZXh0LmNoYXJBdCgwKSkpIHtcbiAgICAgICAgY3VyTGluZSArPSBcIiBcIjtcbiAgICAgICAgc3BhY2VJbnNlcnRlZCA9IDE7XG4gICAgICB9XG4gICAgICB2YXIgc3BhY2VUcmltbWVkID0gXCJcIjtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIHNwYWNlVHJpbW1lZCA9IHRleHQubWF0Y2goL15cXHMqLylbMF07XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHNwYWNlVHJpbW1lZC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY3VyTGluZSArPSB0ZXh0O1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgdmFyIGZpcnN0QnJlYWsgPSBjdXJMaW5lLmxlbmd0aCA+IGNvbHVtbiAmJiBsZWFkaW5nU3BhY2UgPT0gc3BhY2VUcmltbWVkICYmXG4gICAgICAgICAgZmluZEJyZWFrUG9pbnQoY3VyTGluZSwgY29sdW1uLCB3cmFwT24sIGtpbGxUcmFpbGluZywgZm9yY2VCcmVhayk7XG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYnJva2VuLCBvciBpcyBicm9rZW4gYXQgYSBkaWZmZXJlbnQgcG9pbnQsIHJlbW92ZSBvbGQgYnJlYWtcbiAgICAgICAgaWYgKCFmaXJzdEJyZWFrIHx8IGZpcnN0QnJlYWsuZnJvbSAhPSBvbGRMZW4gfHwgZmlyc3RCcmVhay50byAhPSBvbGRMZW4gKyBzcGFjZUluc2VydGVkKSB7XG4gICAgICAgICAgY2hhbmdlcy5wdXNoKHt0ZXh0OiBbc3BhY2VJbnNlcnRlZCA/IFwiIFwiIDogXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBQb3MoY3VyTm8sIG9sZExlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogUG9zKGN1ck5vICsgMSwgc3BhY2VUcmltbWVkLmxlbmd0aCl9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJMaW5lID0gbGVhZGluZ1NwYWNlICsgdGV4dDtcbiAgICAgICAgICArK2N1ck5vO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3VyTGluZS5sZW5ndGggPiBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGJwID0gZmluZEJyZWFrUG9pbnQoY3VyTGluZSwgY29sdW1uLCB3cmFwT24sIGtpbGxUcmFpbGluZywgZm9yY2VCcmVhayk7XG4gICAgICAgIGlmIChicC5mcm9tICE9IGJwLnRvIHx8XG4gICAgICAgICAgICBmb3JjZUJyZWFrICYmIGxlYWRpbmdTcGFjZSAhPT0gY3VyTGluZS5zbGljZSgwLCBicC50bykpIHtcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goe3RleHQ6IFtcIlwiLCBsZWFkaW5nU3BhY2VdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogUG9zKGN1ck5vLCBicC5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBQb3MoY3VyTm8sIGJwLnRvKX0pO1xuICAgICAgICAgIGN1ckxpbmUgPSBsZWFkaW5nU3BhY2UgKyBjdXJMaW5lLnNsaWNlKGJwLnRvKTtcbiAgICAgICAgICArK2N1ck5vO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICBpZiAoY2hhbmdlLnRleHQgfHwgQ29kZU1pcnJvci5jbXBQb3MoY2hhbmdlLmZyb20sIGNoYW5nZS50bykpXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGNoYW5nZS50ZXh0LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlcy5sZW5ndGggPyB7ZnJvbTogY2hhbmdlc1swXS5mcm9tLCB0bzogQ29kZU1pcnJvci5jaGFuZ2VFbmQoY2hhbmdlc1tjaGFuZ2VzLmxlbmd0aCAtIDFdKX0gOiBudWxsO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJ3cmFwUGFyYWdyYXBoXCIsIGZ1bmN0aW9uKHBvcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghcG9zKSBwb3MgPSB0aGlzLmdldEN1cnNvcigpO1xuICAgIHZhciBwYXJhID0gZmluZFBhcmFncmFwaCh0aGlzLCBwb3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiB3cmFwUmFuZ2UodGhpcywgUG9zKHBhcmEuZnJvbSwgMCksIFBvcyhwYXJhLnRvIC0gMSksIG9wdGlvbnMpO1xuICB9KTtcblxuICBDb2RlTWlycm9yLmNvbW1hbmRzLndyYXBMaW5lcyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIGF0ID0gY20ubGFzdExpbmUoKSArIDE7XG4gICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXSwgc3BhbjtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgcGFyYSA9IGZpbmRQYXJhZ3JhcGgoY20sIHJhbmdlLmhlYWQsIHt9KTtcbiAgICAgICAgICBzcGFuID0ge2Zyb206IFBvcyhwYXJhLmZyb20sIDApLCB0bzogUG9zKHBhcmEudG8gLSAxKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhbiA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Bhbi50by5saW5lID49IGF0KSBjb250aW51ZTtcbiAgICAgICAgYXQgPSBzcGFuLmZyb20ubGluZTtcbiAgICAgICAgd3JhcFJhbmdlKGNtLCBzcGFuLmZyb20sIHNwYW4udG8sIHt9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcIndyYXBSYW5nZVwiLCBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiB3cmFwUmFuZ2UodGhpcywgZnJvbSwgdG8sIG9wdGlvbnMgfHwge30pO1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcIndyYXBQYXJhZ3JhcGhzSW5SYW5nZVwiLCBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBjbSA9IHRoaXMsIHBhcmFzID0gW107XG4gICAgZm9yICh2YXIgbGluZSA9IGZyb20ubGluZTsgbGluZSA8PSB0by5saW5lOykge1xuICAgICAgdmFyIHBhcmEgPSBmaW5kUGFyYWdyYXBoKGNtLCBQb3MobGluZSwgMCksIG9wdGlvbnMpO1xuICAgICAgcGFyYXMucHVzaChwYXJhKTtcbiAgICAgIGxpbmUgPSBwYXJhLnRvO1xuICAgIH1cbiAgICB2YXIgbWFkZUNoYW5nZSA9IGZhbHNlO1xuICAgIGlmIChwYXJhcy5sZW5ndGgpIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSBwYXJhcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgbWFkZUNoYW5nZSA9IG1hZGVDaGFuZ2UgfHwgd3JhcFJhbmdlKGNtLCBQb3MocGFyYXNbaV0uZnJvbSwgMCksIFBvcyhwYXJhc1tpXS50byAtIDEpLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFkZUNoYW5nZTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJQb3MiLCJmaW5kUGFyYWdyYXBoIiwiY20iLCJwb3MiLCJvcHRpb25zIiwic3RhcnRSRSIsInBhcmFncmFwaFN0YXJ0IiwiZ2V0SGVscGVyIiwic3RhcnQiLCJsaW5lIiwiZmlyc3QiLCJmaXJzdExpbmUiLCJnZXRMaW5lIiwidGVzdCIsImVuZFJFIiwicGFyYWdyYXBoRW5kIiwiZW5kIiwibGFzdCIsImxhc3RMaW5lIiwiZnJvbSIsInRvIiwiZmluZEJyZWFrUG9pbnQiLCJ0ZXh0IiwiY29sdW1uIiwid3JhcE9uIiwia2lsbFRyYWlsaW5nU3BhY2UiLCJmb3JjZUJyZWFrIiwiYXQiLCJsZW5ndGgiLCJjaGFyQXQiLCJzbGljZSIsIm1hdGNoIiwiZW5kT2ZUZXh0Iiwid3JhcFJhbmdlIiwiY2xpcFBvcyIsImtpbGxUcmFpbGluZyIsImNoYW5nZXMiLCJjdXJMaW5lIiwiY3VyTm8iLCJsaW5lcyIsImdldFJhbmdlIiwibGVhZGluZ1NwYWNlIiwiaSIsIm9sZExlbiIsInNwYWNlSW5zZXJ0ZWQiLCJzcGFjZVRyaW1tZWQiLCJmaXJzdEJyZWFrIiwicHVzaCIsImJwIiwib3BlcmF0aW9uIiwiY2hhbmdlIiwiY21wUG9zIiwicmVwbGFjZVJhbmdlIiwiY2hhbmdlRW5kIiwiZGVmaW5lRXh0ZW5zaW9uIiwiZ2V0Q3Vyc29yIiwicGFyYSIsImNvbW1hbmRzIiwid3JhcExpbmVzIiwicmFuZ2VzIiwibGlzdFNlbGVjdGlvbnMiLCJyYW5nZSIsInNwYW4iLCJlbXB0eSIsImhlYWQiLCJwYXJhcyIsIm1hZGVDaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/wrap/hardwrap.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/addon/wrap/hardwrap.js");
/******/ 	
/******/ })()
;