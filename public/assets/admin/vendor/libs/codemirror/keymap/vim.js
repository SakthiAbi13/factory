/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/codemirror/addon/dialog/dialog.js":
/*!************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/dialog/dialog.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom) dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";else dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else {\n      // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n    if (!options) options = {};\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false,\n        me = this;\n\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0],\n        button;\n\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n        options.onInput(e, inp.value, close);\n      });\n      if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n        options.onKeyUp(e, inp.value, close);\n      });\n      CodeMirror.on(inp, \"keydown\", function (e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n          return;\n        }\n\n        if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function () {\n        close();\n        me.focus();\n      });\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n      button.focus();\n    }\n\n    return close;\n  });\n  CodeMirror.defineExtension(\"openConfirm\", function (template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false,\n        me = this,\n        blurring = 1;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n\n    buttons[0].focus();\n\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n\n      (function (callback) {\n        CodeMirror.on(b, \"click\", function (e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n\n      CodeMirror.on(b, \"blur\", function () {\n        --blurring;\n        setTimeout(function () {\n          if (blurring <= 0) close();\n        }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function () {\n        ++blurring;\n      });\n    }\n  });\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n\n  CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false,\n        doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function (e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n    if (duration) doneTimer = setTimeout(close, duration);\n    return close;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZGlhbG9nL2RpYWxvZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUE7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN0QixTQUFTQyxTQUFULENBQW1CQyxFQUFuQixFQUF1QkMsUUFBdkIsRUFBaUNDLE1BQWpDLEVBQXlDO0lBQ3ZDLElBQUlDLElBQUksR0FBR0gsRUFBRSxDQUFDSSxpQkFBSCxFQUFYO0lBQ0EsSUFBSUMsTUFBSjtJQUNBQSxNQUFNLEdBQUdGLElBQUksQ0FBQ0csV0FBTCxDQUFpQkMsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWpCLENBQVQ7SUFDQSxJQUFJTixNQUFKLEVBQ0VHLE1BQU0sQ0FBQ0ksU0FBUCxHQUFtQiw0Q0FBbkIsQ0FERixLQUdFSixNQUFNLENBQUNJLFNBQVAsR0FBbUIseUNBQW5COztJQUVGLElBQUksT0FBT1IsUUFBUCxJQUFtQixRQUF2QixFQUFpQztNQUMvQkksTUFBTSxDQUFDSyxTQUFQLEdBQW1CVCxRQUFuQjtJQUNELENBRkQsTUFFTztNQUFFO01BQ1BJLE1BQU0sQ0FBQ0MsV0FBUCxDQUFtQkwsUUFBbkI7SUFDRDs7SUFDREgsVUFBVSxDQUFDYSxRQUFYLENBQW9CUixJQUFwQixFQUEwQixlQUExQjtJQUNBLE9BQU9FLE1BQVA7RUFD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VUFBVSxDQUFDcUQsZ0JBQVgsQ0FBNEJoQixDQUE1QjtNQUNBZCxLQUFLO0lBQ04sQ0FIRDtJQUtBLElBQUlpQyxRQUFKLEVBQ0VELFNBQVMsR0FBR0QsVUFBVSxDQUFDL0IsS0FBRCxFQUFRaUMsUUFBUixDQUF0QjtJQUVGLE9BQU9qQyxLQUFQO0VBQ0QsQ0F2QkQ7QUF3QkQsQ0E3SkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZGlhbG9nL2RpYWxvZy5qcz9jOTU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIE9wZW4gc2ltcGxlIGRpYWxvZ3Mgb24gdG9wIG9mIGFuIGVkaXRvci4gUmVsaWVzIG9uIGRpYWxvZy5jc3MuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIGZ1bmN0aW9uIGRpYWxvZ0RpdihjbSwgdGVtcGxhdGUsIGJvdHRvbSkge1xuICAgIHZhciB3cmFwID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgZGlhbG9nO1xuICAgIGRpYWxvZyA9IHdyYXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgaWYgKGJvdHRvbSlcbiAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItZGlhbG9nIENvZGVNaXJyb3ItZGlhbG9nLWJvdHRvbVwiO1xuICAgIGVsc2VcbiAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItZGlhbG9nIENvZGVNaXJyb3ItZGlhbG9nLXRvcFwiO1xuXG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkaWFsb2cuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgfSBlbHNlIHsgLy8gQXNzdW1pbmcgaXQncyBhIGRldGFjaGVkIERPTSBlbGVtZW50LlxuICAgICAgZGlhbG9nLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgQ29kZU1pcnJvci5hZGRDbGFzcyh3cmFwLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgIHJldHVybiBkaWFsb2c7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZU5vdGlmaWNhdGlvbihjbSwgbmV3VmFsKSB7XG4gICAgaWYgKGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSlcbiAgICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSgpO1xuICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSA9IG5ld1ZhbDtcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwib3BlbkRpYWxvZ1wiLCBmdW5jdGlvbih0ZW1wbGF0ZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIGNsb3NlTm90aWZpY2F0aW9uKHRoaXMsIG51bGwpO1xuXG4gICAgdmFyIGRpYWxvZyA9IGRpYWxvZ0Rpdih0aGlzLCB0ZW1wbGF0ZSwgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgbWUgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGNsb3NlKG5ld1ZhbCkge1xuICAgICAgaWYgKHR5cGVvZiBuZXdWYWwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5wLnZhbHVlID0gbmV3VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBDb2RlTWlycm9yLnJtQ2xhc3MoZGlhbG9nLnBhcmVudE5vZGUsICdkaWFsb2ctb3BlbmVkJyk7XG4gICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgIG1lLmZvY3VzKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub25DbG9zZSkgb3B0aW9ucy5vbkNsb3NlKGRpYWxvZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlucCA9IGRpYWxvZy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLCBidXR0b247XG4gICAgaWYgKGlucCkge1xuICAgICAgaW5wLmZvY3VzKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlucC52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbGVjdFZhbHVlT25PcGVuICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlucC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vbklucHV0KVxuICAgICAgICBDb2RlTWlycm9yLm9uKGlucCwgXCJpbnB1dFwiLCBmdW5jdGlvbihlKSB7IG9wdGlvbnMub25JbnB1dChlLCBpbnAudmFsdWUsIGNsb3NlKTt9KTtcbiAgICAgIGlmIChvcHRpb25zLm9uS2V5VXApXG4gICAgICAgIENvZGVNaXJyb3Iub24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uKGUpIHtvcHRpb25zLm9uS2V5VXAoZSwgaW5wLnZhbHVlLCBjbG9zZSk7fSk7XG5cbiAgICAgIENvZGVNaXJyb3Iub24oaW5wLCBcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9uS2V5RG93biAmJiBvcHRpb25zLm9uS2V5RG93bihlLCBpbnAudmFsdWUsIGNsb3NlKSkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNyB8fCAob3B0aW9ucy5jbG9zZU9uRW50ZXIgIT09IGZhbHNlICYmIGUua2V5Q29kZSA9PSAxMykpIHtcbiAgICAgICAgICBpbnAuYmx1cigpO1xuICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgY2FsbGJhY2soaW5wLnZhbHVlLCBlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5jbG9zZU9uQmx1ciAhPT0gZmFsc2UpIENvZGVNaXJyb3Iub24oZGlhbG9nLCBcImZvY3Vzb3V0XCIsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5yZWxhdGVkVGFyZ2V0ICE9PSBudWxsKSBjbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPSBkaWFsb2cuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJidXR0b25cIilbMF0pIHtcbiAgICAgIENvZGVNaXJyb3Iub24oYnV0dG9uLCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICBtZS5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25CbHVyICE9PSBmYWxzZSkgQ29kZU1pcnJvci5vbihidXR0b24sIFwiYmx1clwiLCBjbG9zZSk7XG5cbiAgICAgIGJ1dHRvbi5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2U7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwib3BlbkNvbmZpcm1cIiwgZnVuY3Rpb24odGVtcGxhdGUsIGNhbGxiYWNrcywgb3B0aW9ucykge1xuICAgIGNsb3NlTm90aWZpY2F0aW9uKHRoaXMsIG51bGwpO1xuICAgIHZhciBkaWFsb2cgPSBkaWFsb2dEaXYodGhpcywgdGVtcGxhdGUsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBidXR0b25zID0gZGlhbG9nLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYnV0dG9uXCIpO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgbWUgPSB0aGlzLCBibHVycmluZyA9IDE7XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgQ29kZU1pcnJvci5ybUNsYXNzKGRpYWxvZy5wYXJlbnROb2RlLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgIG1lLmZvY3VzKCk7XG4gICAgfVxuICAgIGJ1dHRvbnNbMF0uZm9jdXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBiID0gYnV0dG9uc1tpXTtcbiAgICAgIChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBDb2RlTWlycm9yLm9uKGIsIFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKGNhbGxiYWNrc1tpXSk7XG4gICAgICBDb2RlTWlycm9yLm9uKGIsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLS1ibHVycmluZztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgaWYgKGJsdXJyaW5nIDw9IDApIGNsb3NlKCk7IH0sIDIwMCk7XG4gICAgICB9KTtcbiAgICAgIENvZGVNaXJyb3Iub24oYiwgXCJmb2N1c1wiLCBmdW5jdGlvbigpIHsgKytibHVycmluZzsgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKlxuICAgKiBvcGVuTm90aWZpY2F0aW9uXG4gICAqIE9wZW5zIGEgbm90aWZpY2F0aW9uLCB0aGF0IGNhbiBiZSBjbG9zZWQgd2l0aCBhbiBvcHRpb25hbCB0aW1lclxuICAgKiAoZGVmYXVsdCA1MDAwbXMgdGltZXIpIGFuZCBhbHdheXMgY2xvc2VzIG9uIGNsaWNrLlxuICAgKlxuICAgKiBJZiBhIG5vdGlmaWNhdGlvbiBpcyBvcGVuZWQgd2hpbGUgYW5vdGhlciBpcyBvcGVuZWQsIGl0IHdpbGwgY2xvc2UgdGhlXG4gICAqIGN1cnJlbnRseSBvcGVuZWQgb25lIGFuZCBvcGVuIHRoZSBuZXcgb25lIGltbWVkaWF0ZWx5LlxuICAgKi9cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJvcGVuTm90aWZpY2F0aW9uXCIsIGZ1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgY2xvc2VOb3RpZmljYXRpb24odGhpcywgY2xvc2UpO1xuICAgIHZhciBkaWFsb2cgPSBkaWFsb2dEaXYodGhpcywgdGVtcGxhdGUsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3R0b20pO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgZG9uZVRpbWVyO1xuICAgIHZhciBkdXJhdGlvbiA9IG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZHVyYXRpb24gIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmR1cmF0aW9uIDogNTAwMDtcblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChkb25lVGltZXIpO1xuICAgICAgQ29kZU1pcnJvci5ybUNsYXNzKGRpYWxvZy5wYXJlbnROb2RlLCAnZGlhbG9nLW9wZW5lZCcpO1xuICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICB9XG5cbiAgICBDb2RlTWlycm9yLm9uKGRpYWxvZywgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmIChkdXJhdGlvbilcbiAgICAgIGRvbmVUaW1lciA9IHNldFRpbWVvdXQoY2xvc2UsIGR1cmF0aW9uKTtcblxuICAgIHJldHVybiBjbG9zZTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJkaWFsb2dEaXYiLCJjbSIsInRlbXBsYXRlIiwiYm90dG9tIiwid3JhcCIsImdldFdyYXBwZXJFbGVtZW50IiwiZGlhbG9nIiwiYXBwZW5kQ2hpbGQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJhZGRDbGFzcyIsImNsb3NlTm90aWZpY2F0aW9uIiwibmV3VmFsIiwic3RhdGUiLCJjdXJyZW50Tm90aWZpY2F0aW9uQ2xvc2UiLCJkZWZpbmVFeHRlbnNpb24iLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjbG9zZWQiLCJtZSIsImNsb3NlIiwiaW5wIiwidmFsdWUiLCJybUNsYXNzIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9jdXMiLCJvbkNsb3NlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJidXR0b24iLCJzZWxlY3RWYWx1ZU9uT3BlbiIsInNlbGVjdCIsIm9uSW5wdXQiLCJvbiIsImUiLCJvbktleVVwIiwib25LZXlEb3duIiwia2V5Q29kZSIsImNsb3NlT25FbnRlciIsImJsdXIiLCJlX3N0b3AiLCJjbG9zZU9uQmx1ciIsImV2dCIsInJlbGF0ZWRUYXJnZXQiLCJjYWxsYmFja3MiLCJidXR0b25zIiwiYmx1cnJpbmciLCJpIiwibGVuZ3RoIiwiYiIsImVfcHJldmVudERlZmF1bHQiLCJzZXRUaW1lb3V0IiwiZG9uZVRpbWVyIiwiZHVyYXRpb24iLCJjbGVhclRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/dialog/dialog.js\n");

/***/ }),

/***/ "./resources/assets/vendor/libs/codemirror/addon/edit/matchbrackets.js":
/*!*****************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/edit/matchbrackets.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n  var Pos = CodeMirror.Pos;\n  var matching = {\n    \"(\": \")>\",\n    \")\": \"(<\",\n    \"[\": \"]>\",\n    \"]\": \"[<\",\n    \"{\": \"}>\",\n    \"}\": \"{<\",\n    \"<\": \">>\",\n    \">\": \"<<\"\n  };\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line),\n        pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor;\n    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n    var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n\n    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {\n      from: Pos(where.line, pos),\n      to: found && found.pos,\n      match: found && found.ch == match.charAt(0),\n      forward: dir > 0\n    };\n  } // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n\n\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = config && config.maxScanLineLength || 10000;\n    var maxScanLines = config && config.maxScanLines || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1,\n          end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n\n        if (re.test(ch) && (style === undefined || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && match.charAt(1) == \">\" == dir > 0) stack.push(ch);else if (!stack.length) return {\n            pos: Pos(lineNo, pos),\n            ch: ch\n          };else stack.pop();\n        }\n      }\n    }\n\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n        highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [],\n        ranges = cm.listSelections();\n\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {\n          className: style\n        }));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {\n          className: style\n        }));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function clear() {\n        cm.operation(function () {\n          for (var i = 0; i < marks.length; i++) {\n            marks[i].clear();\n          }\n        });\n      };\n\n      if (autoclear) setTimeout(clear, 800);else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function () {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function (cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets);\n      cm.off(\"blur\", clearHighlighted);\n      clearHighlighted(cm);\n    }\n\n    if (val) {\n      cm.state.matchBrackets = _typeof(val) == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets);\n      cm.on(\"blur\", clearHighlighted);\n    }\n  });\n  CodeMirror.defineExtension(\"matchBrackets\", function () {\n    matchBrackets(this, true);\n  });\n  CodeMirror.defineExtension(\"findMatchingBracket\", function (pos, config, oldConfig) {\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {\n          strict: true\n        } : null;\n      } else {\n        oldConfig.strict = config;\n        config = oldConfig;\n      }\n    }\n\n    return findMatchingBracket(this, pos, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function (pos, dir, style, config) {\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxtSkFBRCxDQUFSLENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxtSkFBRCxDQUFELG9DQUEyQkosR0FBM0I7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN0QixJQUFJQyxNQUFNLEdBQUcsVUFBVUMsSUFBVixDQUFlQyxTQUFTLENBQUNDLFNBQXpCLE1BQ1ZDLFFBQVEsQ0FBQ0MsWUFBVCxJQUF5QixJQUF6QixJQUFpQ0QsUUFBUSxDQUFDQyxZQUFULEdBQXdCLENBRC9DLENBQWI7RUFHQSxJQUFJQyxHQUFHLEdBQUdQLFVBQVUsQ0FBQ08sR0FBckI7RUFFQSxJQUFJQyxRQUFRLEdBQUc7SUFBQyxLQUFLLElBQU47SUFBWSxLQUFLLElBQWpCO0lBQXVCLEtBQUssSUFBNUI7SUFBa0MsS0FBSyxJQUF2QztJQUE2QyxLQUFLLElBQWxEO0lBQXdELEtBQUssSUFBN0Q7SUFBbUUsS0FBSyxJQUF4RTtJQUE4RSxLQUFLO0VBQW5GLENBQWY7O0VBRUEsU0FBU0MsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEI7SUFDNUIsT0FBT0EsTUFBTSxJQUFJQSxNQUFNLENBQUNELFlBQWpCLElBQWlDLFdBQXhDO0VBQ0Q7O0VBRUQsU0FBU0UsbUJBQVQsQ0FBNkJDLEVBQTdCLEVBQWlDQyxLQUFqQyxFQUF3Q0gsTUFBeEMsRUFBZ0Q7SUFDOUMsSUFBSUks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LEVBQUUsQ0FBQ2lFLEVBQUgsQ0FBTSxNQUFOLEVBQWNOLGdCQUFkO0lBQ0Q7RUFDRixDQWJEO0VBZUF2RSxVQUFVLENBQUM4RSxlQUFYLENBQTJCLGVBQTNCLEVBQTRDLFlBQVc7SUFBQzNCLGFBQWEsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFiO0VBQTJCLENBQW5GO0VBQ0FuRCxVQUFVLENBQUM4RSxlQUFYLENBQTJCLHFCQUEzQixFQUFrRCxVQUFTOUQsR0FBVCxFQUFjTixNQUFkLEVBQXNCcUUsU0FBdEIsRUFBZ0M7SUFDaEY7SUFDQSxJQUFJQSxTQUFTLElBQUksT0FBT3JFLE1BQVAsSUFBaUIsU0FBbEMsRUFBNkM7TUFDM0MsSUFBSSxDQUFDcUUsU0FBTCxFQUFnQjtRQUNkckUsTUFBTSxHQUFHQSxNQUFNLEdBQUc7VUFBQ2dCLE1BQU0sRUFBRTtRQUFULENBQUgsR0FBb0IsSUFBbkM7TUFDRCxDQUZELE1BRU87UUFDTHFELFNBQVMsQ0FBQ3JELE1BQVYsR0FBbUJoQixNQUFuQjtRQUNBQSxNQUFNLEdBQUdxRSxTQUFUO01BQ0Q7SUFDRjs7SUFDRCxPQUFPcEUsbUJBQW1CLENBQUMsSUFBRCxFQUFPSyxHQUFQLEVBQVlOLE1BQVosQ0FBMUI7RUFDRCxDQVhEO0VBWUFWLFVBQVUsQ0FBQzhFLGVBQVgsQ0FBMkIsZ0JBQTNCLEVBQTZDLFVBQVM5RCxHQUFULEVBQWNTLEdBQWQsRUFBbUJFLEtBQW5CLEVBQTBCakIsTUFBMUIsRUFBaUM7SUFDNUUsT0FBT29CLGNBQWMsQ0FBQyxJQUFELEVBQU9kLEdBQVAsRUFBWVMsR0FBWixFQUFpQkUsS0FBakIsRUFBd0JqQixNQUF4QixDQUFyQjtFQUNELENBRkQ7QUFHRCxDQTVKRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvdmVuZG9yL2xpYnMvY29kZW1pcnJvci9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanM/MDE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICB2YXIgaWVfbHQ4ID0gL01TSUUgXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PSBudWxsIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDgpO1xuXG4gIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcblxuICB2YXIgbWF0Y2hpbmcgPSB7XCIoXCI6IFwiKT5cIiwgXCIpXCI6IFwiKDxcIiwgXCJbXCI6IFwiXT5cIiwgXCJdXCI6IFwiWzxcIiwgXCJ7XCI6IFwifT5cIiwgXCJ9XCI6IFwiezxcIiwgXCI8XCI6IFwiPj5cIiwgXCI+XCI6IFwiPDxcIn07XG5cbiAgZnVuY3Rpb24gYnJhY2tldFJlZ2V4KGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgJiYgY29uZmlnLmJyYWNrZXRSZWdleCB8fCAvWygpe31bXFxdXS9cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0JyYWNrZXQoY20sIHdoZXJlLCBjb25maWcpIHtcbiAgICB2YXIgbGluZSA9IGNtLmdldExpbmVIYW5kbGUod2hlcmUubGluZSksIHBvcyA9IHdoZXJlLmNoIC0gMTtcbiAgICB2YXIgYWZ0ZXJDdXJzb3IgPSBjb25maWcgJiYgY29uZmlnLmFmdGVyQ3Vyc29yXG4gICAgaWYgKGFmdGVyQ3Vyc29yID09IG51bGwpXG4gICAgICBhZnRlckN1cnNvciA9IC8oXnwgKWNtLWZhdC1jdXJzb3IoJHwgKS8udGVzdChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmNsYXNzTmFtZSlcbiAgICB2YXIgcmUgPSBicmFja2V0UmVnZXgoY29uZmlnKVxuXG4gICAgLy8gQSBjdXJzb3IgaXMgZGVmaW5lZCBhcyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzLCBidXQgaW4gaW4gdmltIGNvbW1hbmQgbW9kZVxuICAgIC8vIChpLmUuIG5vdCBpbnNlcnQgbW9kZSksIHRoZSBjdXJzb3IgaXMgdmlzdWFsbHkgcmVwcmVzZW50ZWQgYXMgYVxuICAgIC8vIGhpZ2hsaWdodGVkIGJveCBvbiB0b3Agb2YgdGhlIDJuZCBjaGFyYWN0ZXIuIE90aGVyd2lzZSwgd2UgYWxsb3cgbWF0Y2hlc1xuICAgIC8vIGZyb20gYmVmb3JlIG9yIGFmdGVyIHRoZSBjdXJzb3IuXG4gICAgdmFyIG1hdGNoID0gKCFhZnRlckN1cnNvciAmJiBwb3MgPj0gMCAmJiByZS50ZXN0KGxpbmUudGV4dC5jaGFyQXQocG9zKSkgJiYgbWF0Y2hpbmdbbGluZS50ZXh0LmNoYXJBdChwb3MpXSkgfHxcbiAgICAgICAgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcyArIDEpKSAmJiBtYXRjaGluZ1tsaW5lLnRleHQuY2hhckF0KCsrcG9zKV07XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGRpciA9IG1hdGNoLmNoYXJBdCgxKSA9PSBcIj5cIiA/IDEgOiAtMTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5zdHJpY3QgJiYgKGRpciA+IDApICE9IChwb3MgPT0gd2hlcmUuY2gpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBjbS5nZXRUb2tlblR5cGVBdChQb3Mod2hlcmUubGluZSwgcG9zICsgMSkpO1xuXG4gICAgdmFyIGZvdW5kID0gc2NhbkZvckJyYWNrZXQoY20sIFBvcyh3aGVyZS5saW5lLCBwb3MgKyAoZGlyID4gMCA/IDEgOiAwKSksIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gICAgaWYgKGZvdW5kID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7ZnJvbTogUG9zKHdoZXJlLmxpbmUsIHBvcyksIHRvOiBmb3VuZCAmJiBmb3VuZC5wb3MsXG4gICAgICAgICAgICBtYXRjaDogZm91bmQgJiYgZm91bmQuY2ggPT0gbWF0Y2guY2hhckF0KDApLCBmb3J3YXJkOiBkaXIgPiAwfTtcbiAgfVxuXG4gIC8vIGJyYWNrZXRSZWdleCBpcyB1c2VkIHRvIHNwZWNpZnkgd2hpY2ggdHlwZSBvZiBicmFja2V0IHRvIHNjYW5cbiAgLy8gc2hvdWxkIGJlIGEgcmVnZXhwLCBlLmcuIC9bW1xcXV0vXG4gIC8vXG4gIC8vIE5vdGU6IElmIFwid2hlcmVcIiBpcyBvbiBhbiBvcGVuIGJyYWNrZXQsIHRoZW4gdGhpcyBicmFja2V0IGlzIGlnbm9yZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgZmFsc2Ugd2hlbiBubyBicmFja2V0IHdhcyBmb3VuZCwgbnVsbCB3aGVuIGl0IHJlYWNoZWRcbiAgLy8gbWF4U2NhbkxpbmVzIGFuZCBnYXZlIHVwXG4gIGZ1bmN0aW9uIHNjYW5Gb3JCcmFja2V0KGNtLCB3aGVyZSwgZGlyLCBzdHlsZSwgY29uZmlnKSB7XG4gICAgdmFyIG1heFNjYW5MZW4gPSAoY29uZmlnICYmIGNvbmZpZy5tYXhTY2FuTGluZUxlbmd0aCkgfHwgMTAwMDA7XG4gICAgdmFyIG1heFNjYW5MaW5lcyA9IChjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lcykgfHwgMTAwMDtcblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciByZSA9IGJyYWNrZXRSZWdleChjb25maWcpXG4gICAgdmFyIGxpbmVFbmQgPSBkaXIgPiAwID8gTWF0aC5taW4od2hlcmUubGluZSArIG1heFNjYW5MaW5lcywgY20ubGFzdExpbmUoKSArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoY20uZmlyc3RMaW5lKCkgLSAxLCB3aGVyZS5saW5lIC0gbWF4U2NhbkxpbmVzKTtcbiAgICBmb3IgKHZhciBsaW5lTm8gPSB3aGVyZS5saW5lOyBsaW5lTm8gIT0gbGluZUVuZDsgbGluZU5vICs9IGRpcikge1xuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVObyk7XG4gICAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xuICAgICAgdmFyIHBvcyA9IGRpciA+IDAgPyAwIDogbGluZS5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gbGluZS5sZW5ndGggOiAtMTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA+IG1heFNjYW5MZW4pIGNvbnRpbnVlO1xuICAgICAgaWYgKGxpbmVObyA9PSB3aGVyZS5saW5lKSBwb3MgPSB3aGVyZS5jaCAtIChkaXIgPCAwID8gMSA6IDApO1xuICAgICAgZm9yICg7IHBvcyAhPSBlbmQ7IHBvcyArPSBkaXIpIHtcbiAgICAgICAgdmFyIGNoID0gbGluZS5jaGFyQXQocG9zKTtcbiAgICAgICAgaWYgKHJlLnRlc3QoY2gpICYmIChzdHlsZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNtLmdldFRva2VuVHlwZUF0KFBvcyhsaW5lTm8sIHBvcyArIDEpKSB8fCBcIlwiKSA9PSAoc3R5bGUgfHwgXCJcIikpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hpbmdbY2hdO1xuICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2guY2hhckF0KDEpID09IFwiPlwiKSA9PSAoZGlyID4gMCkpIHN0YWNrLnB1c2goY2gpO1xuICAgICAgICAgIGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHJldHVybiB7cG9zOiBQb3MobGluZU5vLCBwb3MpLCBjaDogY2h9O1xuICAgICAgICAgIGVsc2Ugc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVObyAtIGRpciA9PSAoZGlyID4gMCA/IGNtLmxhc3RMaW5lKCkgOiBjbS5maXJzdExpbmUoKSkgPyBmYWxzZSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaEJyYWNrZXRzKGNtLCBhdXRvY2xlYXIsIGNvbmZpZykge1xuICAgIC8vIERpc2FibGUgYnJhY2UgbWF0Y2hpbmcgaW4gbG9uZyBsaW5lcywgc2luY2UgaXQnbGwgY2F1c2UgaHVnZWx5IHNsb3cgdXBkYXRlc1xuICAgIHZhciBtYXhIaWdobGlnaHRMZW4gPSBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLm1heEhpZ2hsaWdodExpbmVMZW5ndGggfHwgMTAwMCxcbiAgICAgIGhpZ2hsaWdodE5vbk1hdGNoaW5nID0gY29uZmlnICYmIGNvbmZpZy5oaWdobGlnaHROb25NYXRjaGluZztcbiAgICB2YXIgbWFya3MgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hdGNoID0gcmFuZ2VzW2ldLmVtcHR5KCkgJiYgZmluZE1hdGNoaW5nQnJhY2tldChjbSwgcmFuZ2VzW2ldLmhlYWQsIGNvbmZpZyk7XG4gICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoLm1hdGNoIHx8IGhpZ2hsaWdodE5vbk1hdGNoaW5nICE9PSBmYWxzZSkgJiYgY20uZ2V0TGluZShtYXRjaC5mcm9tLmxpbmUpLmxlbmd0aCA8PSBtYXhIaWdobGlnaHRMZW4pIHtcbiAgICAgICAgdmFyIHN0eWxlID0gbWF0Y2gubWF0Y2ggPyBcIkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0XCIgOiBcIkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0XCI7XG4gICAgICAgIG1hcmtzLnB1c2goY20ubWFya1RleHQobWF0Y2guZnJvbSwgUG9zKG1hdGNoLmZyb20ubGluZSwgbWF0Y2guZnJvbS5jaCArIDEpLCB7Y2xhc3NOYW1lOiBzdHlsZX0pKTtcbiAgICAgICAgaWYgKG1hdGNoLnRvICYmIGNtLmdldExpbmUobWF0Y2gudG8ubGluZSkubGVuZ3RoIDw9IG1heEhpZ2hsaWdodExlbilcbiAgICAgICAgICBtYXJrcy5wdXNoKGNtLm1hcmtUZXh0KG1hdGNoLnRvLCBQb3MobWF0Y2gudG8ubGluZSwgbWF0Y2gudG8uY2ggKyAxKSwge2NsYXNzTmFtZTogc3R5bGV9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgICAgLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIHRoZSBJRSBidWcgZnJvbSBpc3N1ZSAjMTE5Mywgd2hlcmUgdGV4dFxuICAgICAgLy8gaW5wdXQgc3RvcHMgZ29pbmcgdG8gdGhlIHRleHRhcmVhIHdoZW5ldmVyIHRoaXMgZmlyZXMuXG4gICAgICBpZiAoaWVfbHQ4ICYmIGNtLnN0YXRlLmZvY3VzZWQpIGNtLmZvY3VzKCk7XG5cbiAgICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykgbWFya3NbaV0uY2xlYXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGF1dG9jbGVhcikgc2V0VGltZW91dChjbGVhciwgODAwKTtcbiAgICAgIGVsc2UgcmV0dXJuIGNsZWFyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvTWF0Y2hCcmFja2V0cyhjbSkge1xuICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKSB7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQoKTtcbiAgICAgICAgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkID0gbWF0Y2hCcmFja2V0cyhjbSwgZmFsc2UsIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRlZChjbSkge1xuICAgIGlmIChjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzICYmIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQpIHtcbiAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQoKTtcbiAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwibWF0Y2hCcmFja2V0c1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgaWYgKG9sZCAmJiBvbGQgIT0gQ29kZU1pcnJvci5Jbml0KSB7XG4gICAgICBjbS5vZmYoXCJjdXJzb3JBY3Rpdml0eVwiLCBkb01hdGNoQnJhY2tldHMpO1xuICAgICAgY20ub2ZmKFwiZm9jdXNcIiwgZG9NYXRjaEJyYWNrZXRzKVxuICAgICAgY20ub2ZmKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKVxuICAgICAgY2xlYXJIaWdobGlnaHRlZChjbSk7XG4gICAgfVxuICAgIGlmICh2YWwpIHtcbiAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMgPSB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgPyB2YWwgOiB7fTtcbiAgICAgIGNtLm9uKFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgIGNtLm9uKFwiZm9jdXNcIiwgZG9NYXRjaEJyYWNrZXRzKVxuICAgICAgY20ub24oXCJibHVyXCIsIGNsZWFySGlnaGxpZ2h0ZWQpXG4gICAgfVxuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcIm1hdGNoQnJhY2tldHNcIiwgZnVuY3Rpb24oKSB7bWF0Y2hCcmFja2V0cyh0aGlzLCB0cnVlKTt9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJmaW5kTWF0Y2hpbmdCcmFja2V0XCIsIGZ1bmN0aW9uKHBvcywgY29uZmlnLCBvbGRDb25maWcpe1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGtsdWRnZVxuICAgIGlmIChvbGRDb25maWcgfHwgdHlwZW9mIGNvbmZpZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKCFvbGRDb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnID8ge3N0cmljdDogdHJ1ZX0gOiBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRDb25maWcuc3RyaWN0ID0gY29uZmlnXG4gICAgICAgIGNvbmZpZyA9IG9sZENvbmZpZ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluZE1hdGNoaW5nQnJhY2tldCh0aGlzLCBwb3MsIGNvbmZpZylcbiAgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2NhbkZvckJyYWNrZXRcIiwgZnVuY3Rpb24ocG9zLCBkaXIsIHN0eWxlLCBjb25maWcpe1xuICAgIHJldHVybiBzY2FuRm9yQnJhY2tldCh0aGlzLCBwb3MsIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsibW9kIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJDb2RlTWlycm9yIiwiaWVfbHQ4IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwiUG9zIiwibWF0Y2hpbmciLCJicmFja2V0UmVnZXgiLCJjb25maWciLCJmaW5kTWF0Y2hpbmdCcmFja2V0IiwiY20iLCJ3aGVyZSIsImxpbmUiLCJnZXRMaW5lSGFuZGxlIiwicG9zIiwiY2giLCJhZnRlckN1cnNvciIsImdldFdyYXBwZXJFbGVtZW50IiwiY2xhc3NOYW1lIiwicmUiLCJtYXRjaCIsInRleHQiLCJjaGFyQXQiLCJkaXIiLCJzdHJpY3QiLCJzdHlsZSIsImdldFRva2VuVHlwZUF0IiwiZm91bmQiLCJzY2FuRm9yQnJhY2tldCIsImZyb20iLCJ0byIsImZvcndhcmQiLCJtYXhTY2FuTGVuIiwibWF4U2NhbkxpbmVMZW5ndGgiLCJtYXhTY2FuTGluZXMiLCJzdGFjayIsImxpbmVFbmQiLCJNYXRoIiwibWluIiwibGFzdExpbmUiLCJtYXgiLCJmaXJzdExpbmUiLCJsaW5lTm8iLCJnZXRMaW5lIiwibGVuZ3RoIiwiZW5kIiwidW5kZWZpbmVkIiwicHVzaCIsInBvcCIsIm1hdGNoQnJhY2tldHMiLCJhdXRvY2xlYXIiLCJtYXhIaWdobGlnaHRMZW4iLCJzdGF0ZSIsIm1heEhpZ2hsaWdodExpbmVMZW5ndGgiLCJoaWdobGlnaHROb25NYXRjaGluZyIsIm1hcmtzIiwicmFuZ2VzIiwibGlzdFNlbGVjdGlvbnMiLCJpIiwiZW1wdHkiLCJoZWFkIiwibWFya1RleHQiLCJmb2N1c2VkIiwiZm9jdXMiLCJjbGVhciIsIm9wZXJhdGlvbiIsInNldFRpbWVvdXQiLCJkb01hdGNoQnJhY2tldHMiLCJjdXJyZW50bHlIaWdobGlnaHRlZCIsImNsZWFySGlnaGxpZ2h0ZWQiLCJkZWZpbmVPcHRpb24iLCJ2YWwiLCJvbGQiLCJJbml0Iiwib2ZmIiwib24iLCJkZWZpbmVFeHRlbnNpb24iLCJvbGRDb25maWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/edit/matchbrackets.js\n");

/***/ }),

/***/ "./resources/assets/vendor/libs/codemirror/addon/search/searchcursor.js":
/*!******************************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/addon/search/searchcursor.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags;\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\") + (regexp.global ? \"g\" : \"\") + (regexp.multiline ? \"m\" : \"\");\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp),\n        target = current;\n\n    for (var i = 0; i < flags.length; i++) {\n      if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);\n    }\n\n    return current == target ? regexp : new RegExp(regexp.source, target);\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\");\n\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch;\n      var string = doc.getLine(line),\n          match = regexp.exec(string);\n      if (match) return {\n        from: Pos(line, match.index),\n        to: Pos(line, match.index + match[0].length),\n        match: match\n      };\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);\n    regexp = ensureFlags(regexp, \"gm\");\n    var string,\n        chunk = 1;\n\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break;\n        var curLine = doc.getLine(line++);\n        string = string == null ? curLine : string + \"\\n\" + curLine;\n      }\n\n      chunk = chunk * 2;\n      regexp.lastIndex = start.ch;\n      var match = regexp.exec(string);\n\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"),\n            inside = match[0].split(\"\\n\");\n        var startLine = start.line + before.length - 1,\n            startCh = before[before.length - 1].length;\n        return {\n          from: Pos(startLine, startCh),\n          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n          match: match\n        };\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match,\n        from = 0;\n\n    while (from <= string.length) {\n      regexp.lastIndex = from;\n      var newMatch = regexp.exec(string);\n      if (!newMatch) break;\n      var end = newMatch.index + newMatch[0].length;\n      if (end > string.length - endMargin) break;\n      if (!match || end > match.index + match[0].length) match = newMatch;\n      from = newMatch.index + 1;\n    }\n\n    return match;\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\");\n\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line);\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);\n      if (match) return {\n        from: Pos(line, match.index),\n        to: Pos(line, match.index + match[0].length),\n        match: match\n      };\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start);\n    regexp = ensureFlags(regexp, \"gm\");\n    var string,\n        chunkSize = 1,\n        endMargin = doc.getLine(start.line).length - start.ch;\n\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--);\n        string = string == null ? curLine : curLine + \"\\n\" + string;\n      }\n\n      chunkSize *= 2;\n      var match = lastMatchIn(string, regexp, endMargin);\n\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"),\n            inside = match[0].split(\"\\n\");\n        var startLine = line + before.length,\n            startCh = before[before.length - 1].length;\n        return {\n          from: Pos(startLine, startCh),\n          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n          match: match\n        };\n      }\n    }\n  }\n\n  var doFold, noFold;\n\n  if (String.prototype.normalize) {\n    doFold = function doFold(str) {\n      return str.normalize(\"NFD\").toLowerCase();\n    };\n\n    noFold = function noFold(str) {\n      return str.normalize(\"NFD\");\n    };\n  } else {\n    doFold = function doFold(str) {\n      return str.toLowerCase();\n    };\n\n    noFold = function noFold(str) {\n      return str;\n    };\n  } // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n\n\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos;\n\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min;\n      var mid = min + max >> 1;\n      var len = foldFunc(orig.slice(0, mid)).length;\n      if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null;\n    var fold = caseFold ? doFold : noFold;\n    var lines = fold(query).split(/\\r|\\n\\r?/);\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch),\n          string = fold(orig);\n\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0]);\n        if (found == -1) continue search;\n        var start = adjustPos(orig, string, found, fold) + ch;\n        return {\n          from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)\n        };\n      } else {\n        var cutFrom = string.length - lines[0].length;\n        if (string.slice(cutFrom) != lines[0]) continue search;\n\n        for (var i = 1; i < lines.length - 1; i++) {\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search;\n        }\n\n        var end = doc.getLine(line + lines.length - 1),\n            endString = fold(end),\n            lastLine = lines[lines.length - 1];\n        if (endString.slice(0, lastLine.length) != lastLine) continue search;\n        return {\n          from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n          to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))\n        };\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null;\n    var fold = caseFold ? doFold : noFold;\n    var lines = fold(query).split(/\\r|\\n\\r?/);\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line);\n      if (ch > -1) orig = orig.slice(0, ch);\n      var string = fold(orig);\n\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0]);\n        if (found == -1) continue search;\n        return {\n          from: Pos(line, adjustPos(orig, string, found, fold)),\n          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))\n        };\n      } else {\n        var lastLine = lines[lines.length - 1];\n        if (string.slice(0, lastLine.length) != lastLine) continue search;\n\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) {\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search;\n        }\n\n        var top = doc.getLine(line + 1 - lines.length),\n            topString = fold(top);\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;\n        return {\n          from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n          to: Pos(line, adjustPos(orig, string, lastLine.length, fold))\n        };\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false;\n    this.afterEmptyMatch = false;\n    this.doc = doc;\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {\n      from: pos,\n      to: pos\n    };\n    var caseFold;\n\n    if (_typeof(options) == \"object\") {\n      caseFold = options.caseFold;\n    } else {\n      // Backwards compat for when caseFold was the 4th argument\n      caseFold = options;\n      options = null;\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false;\n\n      this.matches = function (reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);\n      };\n    } else {\n      query = ensureFlags(query, \"gm\");\n      if (!options || options.multiline !== false) this.matches = function (reverse, pos) {\n        return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);\n      };else this.matches = function (reverse, pos) {\n        return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);\n      };\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function findNext() {\n      return this.find(false);\n    },\n    findPrevious: function findPrevious() {\n      return this.find(true);\n    },\n    find: function find(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch);\n\n        if (reverse) {\n          head.ch--;\n\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n          return this.atOccurrence = false;\n        }\n      }\n\n      var result = this.matches(reverse, head);\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0;\n\n      if (result) {\n        this.pos = result;\n        this.atOccurrence = true;\n        return this.pos.match || true;\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n        this.pos = {\n          from: end,\n          to: end\n        };\n        return this.atOccurrence = false;\n      }\n    },\n    from: function from() {\n      if (this.atOccurrence) return this.pos.from;\n    },\n    to: function to() {\n      if (this.atOccurrence) return this.pos.to;\n    },\n    replace: function replace(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n  CodeMirror.defineExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function (query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n  CodeMirror.defineExtension(\"selectMatches\", function (query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({\n        anchor: cur.from(),\n        head: cur.to()\n      });\n    }\n\n    if (ranges.length) this.setSelections(ranges, 0);\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3IvYWRkb24vc2VhcmNoL3NlYXJjaGN1cnNvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxHQUFULEVBQWM7RUFDYixJQUFJLHNCQUFPQyxPQUFQLE1BQWtCLFFBQWxCLElBQThCLHNCQUFPQyxNQUFQLE1BQWlCLFFBQW5ELEVBQTZEO0lBQzNERixHQUFHLENBQUNHLG1CQUFPLENBQUMsbUpBQUQsQ0FBUixDQUFILENBREYsS0FFSyxJQUFJLElBQUosRUFBK0M7SUFDbERDLGlDQUFPLENBQUMsbUpBQUQsQ0FBRCxvQ0FBMkJKLEdBQTNCO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREcsS0FFQTtJQUNIQSxFQUFBO0FBQ0gsQ0FQRCxFQU9HLFVBQVNNLFVBQVQsRUFBcUI7RUFDdEI7O0VBQ0EsSUFBSUMsR0FBRyxHQUFHRCxVQUFVLENBQUNDLEdBQXJCOztFQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0lBQzNCLElBQUlDLEtBQUssR0FBR0QsTUFBTSxDQUFDQyxLQUFuQjtJQUNBLE9BQU9BLEtBQUssSUFBSSxJQUFULEdBQWdCQSxLQUFoQixHQUF3QixDQUFDRCxNQUFNLENBQUNFLFVBQVAsR0FBb0IsR0FBcEIsR0FBMEIsRUFBM0IsS0FDMUJGLE1BQU0sQ0FBQ0csTUFBUCxHQUFnQixHQUFoQixHQUFzQixFQURJLEtBRTFCSCxNQUFNLENBQUNJLFNBQVAsR0FBbUIsR0FBbkIsR0FBeUIsRUFGQyxDQUEvQjtFQUdEOztFQUVELFNBQVNDLFdBQVQsQ0FBcUJMLE1BQXJCLEVBQTZCQyxLQUE3QixFQUFvQztJQUNsQyxJQUFJSyxPQUFPLEdBQUdQLFdBQVcsQ0FBQ0MsTUFBRCxDQUF6QjtJQUFBLElBQW1DTyxNQUFNLEdBQUdELE9BQTVDOztJQUNBLEtBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1AsS0FBSyxD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QUNELElBQUlxRSxNQUFNLENBQUMxRixNQUFYLEVBQ0UsS0FBS2dHLGFBQUwsQ0FBbUJOLE1BQW5CLEVBQTJCLENBQTNCO0VBQ0gsQ0FURDtBQVVELENBN1NEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy92ZW5kb3IvbGlicy9jb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanM/OWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZClcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIlxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3NcblxuICBmdW5jdGlvbiByZWdleHBGbGFncyhyZWdleHApIHtcbiAgICB2YXIgZmxhZ3MgPSByZWdleHAuZmxhZ3NcbiAgICByZXR1cm4gZmxhZ3MgIT0gbnVsbCA/IGZsYWdzIDogKHJlZ2V4cC5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKVxuICAgICAgKyAocmVnZXhwLmdsb2JhbCA/IFwiZ1wiIDogXCJcIilcbiAgICAgICsgKHJlZ2V4cC5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpXG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVGbGFncyhyZWdleHAsIGZsYWdzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWdleHBGbGFncyhyZWdleHApLCB0YXJnZXQgPSBjdXJyZW50XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykgaWYgKHRhcmdldC5pbmRleE9mKGZsYWdzLmNoYXJBdChpKSkgPT0gLTEpXG4gICAgICB0YXJnZXQgKz0gZmxhZ3MuY2hhckF0KGkpXG4gICAgcmV0dXJuIGN1cnJlbnQgPT0gdGFyZ2V0ID8gcmVnZXhwIDogbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB0YXJnZXQpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZU11bHRpbGluZShyZWdleHApIHtcbiAgICByZXR1cm4gL1xcXFxzfFxcXFxufFxcbnxcXFxcV3xcXFxcRHxcXFtcXF4vLnRlc3QocmVnZXhwLnNvdXJjZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEZvcndhcmQoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdcIilcbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7IGxpbmUrKywgY2ggPSAwKSB7XG4gICAgICByZWdleHAubGFzdEluZGV4ID0gY2hcbiAgICAgIHZhciBzdHJpbmcgPSBkb2MuZ2V0TGluZShsaW5lKSwgbWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpXG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2h9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZShkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpIHJldHVybiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydClcblxuICAgIHJlZ2V4cCA9IGVuc3VyZUZsYWdzKHJlZ2V4cCwgXCJnbVwiKVxuICAgIHZhciBzdHJpbmcsIGNodW5rID0gMVxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7IGxpbmUgPD0gbGFzdDspIHtcbiAgICAgIC8vIFRoaXMgZ3Jvd3MgdGhlIHNlYXJjaCBidWZmZXIgaW4gZXhwb25lbnRpYWxseS1zaXplZCBjaHVua3NcbiAgICAgIC8vIGJldHdlZW4gbWF0Y2hlcywgc28gdGhhdCBuZWFyYnkgbWF0Y2hlcyBhcmUgZmFzdCBhbmQgZG9uJ3RcbiAgICAgIC8vIHJlcXVpcmUgY29uY2F0ZW5hdGluZyB0aGUgd2hvbGUgZG9jdW1lbnQgKGluIGNhc2Ugd2UncmVcbiAgICAgIC8vIHNlYXJjaGluZyBmb3Igc29tZXRoaW5nIHRoYXQgaGFzIHRvbnMgb2YgbWF0Y2hlcyksIGJ1dCBhdCB0aGVcbiAgICAgIC8vIHNhbWUgdGltZSwgdGhlIGFtb3VudCBvZiByZXRyaWVzIGlzIGxpbWl0ZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmUgPiBsYXN0KSBicmVha1xuICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUrKylcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogc3RyaW5nICsgXCJcXG5cIiArIGN1ckxpbmVcbiAgICAgIH1cbiAgICAgIGNodW5rID0gY2h1bmsgKiAyXG4gICAgICByZWdleHAubGFzdEluZGV4ID0gc3RhcnQuY2hcbiAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cmluZylcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gc3RyaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KS5zcGxpdChcIlxcblwiKSwgaW5zaWRlID0gbWF0Y2hbMF0uc3BsaXQoXCJcXG5cIilcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmUgKyBiZWZvcmUubGVuZ3RoIC0gMSwgc3RhcnRDaCA9IGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZS5sZW5ndGggPT0gMSA/IHN0YXJ0Q2ggKyBpbnNpZGVbMF0ubGVuZ3RoIDogaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgZW5kTWFyZ2luKSB7XG4gICAgdmFyIG1hdGNoLCBmcm9tID0gMFxuICAgIHdoaWxlIChmcm9tIDw9IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBmcm9tXG4gICAgICB2YXIgbmV3TWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpXG4gICAgICBpZiAoIW5ld01hdGNoKSBicmVha1xuICAgICAgdmFyIGVuZCA9IG5ld01hdGNoLmluZGV4ICsgbmV3TWF0Y2hbMF0ubGVuZ3RoXG4gICAgICBpZiAoZW5kID4gc3RyaW5nLmxlbmd0aCAtIGVuZE1hcmdpbikgYnJlYWtcbiAgICAgIGlmICghbWF0Y2ggfHwgZW5kID4gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpXG4gICAgICAgIG1hdGNoID0gbmV3TWF0Y2hcbiAgICAgIGZyb20gPSBuZXdNYXRjaC5pbmRleCArIDFcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoXG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ1wiKVxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBjaCA9IHN0YXJ0LmNoLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKTsgbGluZSA+PSBmaXJzdDsgbGluZS0tLCBjaCA9IC0xKSB7XG4gICAgICB2YXIgc3RyaW5nID0gZG9jLmdldExpbmUobGluZSlcbiAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBjaCA8IDAgPyAwIDogc3RyaW5nLmxlbmd0aCAtIGNoKVxuICAgICAgaWYgKG1hdGNoKVxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNofVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lKGRvYywgcmVnZXhwLCBzdGFydCkge1xuICAgIGlmICghbWF5YmVNdWx0aWxpbmUocmVnZXhwKSkgcmV0dXJuIHNlYXJjaFJlZ2V4cEJhY2t3YXJkKGRvYywgcmVnZXhwLCBzdGFydClcbiAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ21cIilcbiAgICB2YXIgc3RyaW5nLCBjaHVua1NpemUgPSAxLCBlbmRNYXJnaW4gPSBkb2MuZ2V0TGluZShzdGFydC5saW5lKS5sZW5ndGggLSBzdGFydC5jaFxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKTsgbGluZSA+PSBmaXJzdDspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtTaXplICYmIGxpbmUgPj0gZmlyc3Q7IGkrKykge1xuICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUtLSlcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogY3VyTGluZSArIFwiXFxuXCIgKyBzdHJpbmdcbiAgICAgIH1cbiAgICAgIGNodW5rU2l6ZSAqPSAyXG5cbiAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIiksIGluc2lkZSA9IG1hdGNoWzBdLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgIHZhciBzdGFydExpbmUgPSBsaW5lICsgYmVmb3JlLmxlbmd0aCwgc3RhcnRDaCA9IGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZS5sZW5ndGggPT0gMSA/IHN0YXJ0Q2ggKyBpbnNpZGVbMF0ubGVuZ3RoIDogaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZG9Gb2xkLCBub0ZvbGRcbiAgaWYgKFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplKSB7XG4gICAgZG9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpLnRvTG93ZXJDYXNlKCkgfVxuICAgIG5vRm9sZCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKSB9XG4gIH0gZWxzZSB7XG4gICAgZG9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIudG9Mb3dlckNhc2UoKSB9XG4gICAgbm9Gb2xkID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIgfVxuICB9XG5cbiAgLy8gTWFwcyBhIHBvc2l0aW9uIGluIGEgY2FzZS1mb2xkZWQgbGluZSBiYWNrIHRvIGEgcG9zaXRpb24gaW4gdGhlIG9yaWdpbmFsIGxpbmVcbiAgLy8gKGNvbXBlbnNhdGluZyBmb3IgY29kZXBvaW50cyBpbmNyZWFzaW5nIGluIG51bWJlciBkdXJpbmcgZm9sZGluZylcbiAgZnVuY3Rpb24gYWRqdXN0UG9zKG9yaWcsIGZvbGRlZCwgcG9zLCBmb2xkRnVuYykge1xuICAgIGlmIChvcmlnLmxlbmd0aCA9PSBmb2xkZWQubGVuZ3RoKSByZXR1cm4gcG9zXG4gICAgZm9yICh2YXIgbWluID0gMCwgbWF4ID0gcG9zICsgTWF0aC5tYXgoMCwgb3JpZy5sZW5ndGggLSBmb2xkZWQubGVuZ3RoKTs7KSB7XG4gICAgICBpZiAobWluID09IG1heCkgcmV0dXJuIG1pblxuICAgICAgdmFyIG1pZCA9IChtaW4gKyBtYXgpID4+IDFcbiAgICAgIHZhciBsZW4gPSBmb2xkRnVuYyhvcmlnLnNsaWNlKDAsIG1pZCkpLmxlbmd0aFxuICAgICAgaWYgKGxlbiA9PSBwb3MpIHJldHVybiBtaWRcbiAgICAgIGVsc2UgaWYgKGxlbiA+IHBvcykgbWF4ID0gbWlkXG4gICAgICBlbHNlIG1pbiA9IG1pZCArIDFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hTdHJpbmdGb3J3YXJkKGRvYywgcXVlcnksIHN0YXJ0LCBjYXNlRm9sZCkge1xuICAgIC8vIEVtcHR5IHN0cmluZyB3b3VsZCBtYXRjaCBhbnl0aGluZyBhbmQgbmV2ZXIgcHJvZ3Jlc3MsIHNvIHdlXG4gICAgLy8gZGVmaW5lIGl0IHRvIG1hdGNoIG5vdGhpbmcgaW5zdGVhZC5cbiAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICB2YXIgZm9sZCA9IGNhc2VGb2xkID8gZG9Gb2xkIDogbm9Gb2xkXG4gICAgdmFyIGxpbmVzID0gZm9sZChxdWVyeSkuc3BsaXQoL1xccnxcXG5cXHI/LylcblxuICAgIHNlYXJjaDogZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGxhc3QgPSBkb2MubGFzdExpbmUoKSArIDEgLSBsaW5lcy5sZW5ndGg7IGxpbmUgPD0gbGFzdDsgbGluZSsrLCBjaCA9IDApIHtcbiAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSkuc2xpY2UoY2gpLCBzdHJpbmcgPSBmb2xkKG9yaWcpXG4gICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gc3RyaW5nLmluZGV4T2YobGluZXNbMF0pXG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhciBzdGFydCA9IGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kLCBmb2xkKSArIGNoXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kLCBmb2xkKSArIGNoKSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kICsgbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSArIGNoKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXRGcm9tID0gc3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aFxuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGN1dEZyb20pICE9IGxpbmVzWzBdKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgaWYgKGZvbGQoZG9jLmdldExpbmUobGluZSArIGkpKSAhPSBsaW5lc1tpXSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhciBlbmQgPSBkb2MuZ2V0TGluZShsaW5lICsgbGluZXMubGVuZ3RoIC0gMSksIGVuZFN0cmluZyA9IGZvbGQoZW5kKSwgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXVxuICAgICAgICBpZiAoZW5kU3RyaW5nLnNsaWNlKDAsIGxhc3RMaW5lLmxlbmd0aCkgIT0gbGFzdExpbmUpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBjdXRGcm9tLCBmb2xkKSArIGNoKSxcbiAgICAgICAgICAgICAgICB0bzogUG9zKGxpbmUgKyBsaW5lcy5sZW5ndGggLSAxLCBhZGp1c3RQb3MoZW5kLCBlbmRTdHJpbmcsIGxhc3RMaW5lLmxlbmd0aCwgZm9sZCkpfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFN0cmluZ0JhY2t3YXJkKGRvYywgcXVlcnksIHN0YXJ0LCBjYXNlRm9sZCkge1xuICAgIGlmICghcXVlcnkubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgIHZhciBmb2xkID0gY2FzZUZvbGQgPyBkb0ZvbGQgOiBub0ZvbGRcbiAgICB2YXIgbGluZXMgPSBmb2xkKHF1ZXJ5KS5zcGxpdCgvXFxyfFxcblxccj8vKVxuXG4gICAgc2VhcmNoOiBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCkgLSAxICsgbGluZXMubGVuZ3RoOyBsaW5lID49IGZpcnN0OyBsaW5lLS0sIGNoID0gLTEpIHtcbiAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSlcbiAgICAgIGlmIChjaCA+IC0xKSBvcmlnID0gb3JpZy5zbGljZSgwLCBjaClcbiAgICAgIHZhciBzdHJpbmcgPSBmb2xkKG9yaWcpXG4gICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gc3RyaW5nLmxhc3RJbmRleE9mKGxpbmVzWzBdKVxuICAgICAgICBpZiAoZm91bmQgPT0gLTEpIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCwgZm9sZCkpLFxuICAgICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQgKyBsaW5lc1swXS5sZW5ndGgsIGZvbGQpKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXN0TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdXG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoMCwgbGFzdExpbmUubGVuZ3RoKSAhPSBsYXN0TGluZSkgY29udGludWUgc2VhcmNoXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBzdGFydCA9IGxpbmUgLSBsaW5lcy5sZW5ndGggKyAxOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKHN0YXJ0ICsgaSkpICE9IGxpbmVzW2ldKSBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgdmFyIHRvcCA9IGRvYy5nZXRMaW5lKGxpbmUgKyAxIC0gbGluZXMubGVuZ3RoKSwgdG9wU3RyaW5nID0gZm9sZCh0b3ApXG4gICAgICAgIGlmICh0b3BTdHJpbmcuc2xpY2UodG9wU3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCkgIT0gbGluZXNbMF0pIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCwgYWRqdXN0UG9zKHRvcCwgdG9wU3RyaW5nLCB0b3AubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSksXG4gICAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBsYXN0TGluZS5sZW5ndGgsIGZvbGQpKX1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBTZWFyY2hDdXJzb3IoZG9jLCBxdWVyeSwgcG9zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hdE9jY3VycmVuY2UgPSBmYWxzZVxuICAgIHRoaXMuYWZ0ZXJFbXB0eU1hdGNoID0gZmFsc2VcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHBvcyA9IHBvcyA/IGRvYy5jbGlwUG9zKHBvcykgOiBQb3MoMCwgMClcbiAgICB0aGlzLnBvcyA9IHtmcm9tOiBwb3MsIHRvOiBwb3N9XG5cbiAgICB2YXIgY2FzZUZvbGRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIikge1xuICAgICAgY2FzZUZvbGQgPSBvcHRpb25zLmNhc2VGb2xkXG4gICAgfSBlbHNlIHsgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3Igd2hlbiBjYXNlRm9sZCB3YXMgdGhlIDR0aCBhcmd1bWVudFxuICAgICAgY2FzZUZvbGQgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGNhc2VGb2xkID09IG51bGwpIGNhc2VGb2xkID0gZmFsc2VcbiAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hTdHJpbmdCYWNrd2FyZCA6IHNlYXJjaFN0cmluZ0ZvcndhcmQpKGRvYywgcXVlcnksIHBvcywgY2FzZUZvbGQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gZW5zdXJlRmxhZ3MocXVlcnksIFwiZ21cIilcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLm11bHRpbGluZSAhPT0gZmFsc2UpXG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lIDogc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZSkoZG9jLCBxdWVyeSwgcG9zKVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHJldmVyc2UsIHBvcykge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFJlZ2V4cEJhY2t3YXJkIDogc2VhcmNoUmVnZXhwRm9yd2FyZCkoZG9jLCBxdWVyeSwgcG9zKVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZSA9IHtcbiAgICBmaW5kTmV4dDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmluZChmYWxzZSl9LFxuICAgIGZpbmRQcmV2aW91czogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmluZCh0cnVlKX0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbihyZXZlcnNlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuZG9jLmNsaXBQb3MocmV2ZXJzZSA/IHRoaXMucG9zLmZyb20gOiB0aGlzLnBvcy50byk7XG4gICAgICBpZiAodGhpcy5hZnRlckVtcHR5TWF0Y2ggJiYgdGhpcy5hdE9jY3VycmVuY2UpIHtcbiAgICAgICAgLy8gZG8gbm90IHJldHVybiB0aGUgc2FtZSAwIHdpZHRoIG1hdGNoIHR3aWNlXG4gICAgICAgIGhlYWQgPSBQb3MoaGVhZC5saW5lLCBoZWFkLmNoKVxuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgIGhlYWQuY2gtLTtcbiAgICAgICAgICBpZiAoaGVhZC5jaCA8IDApIHtcbiAgICAgICAgICAgIGhlYWQubGluZS0tO1xuICAgICAgICAgICAgaGVhZC5jaCA9ICh0aGlzLmRvYy5nZXRMaW5lKGhlYWQubGluZSkgfHwgXCJcIikubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkLmNoKys7XG4gICAgICAgICAgaWYgKGhlYWQuY2ggPiAodGhpcy5kb2MuZ2V0TGluZShoZWFkLmxpbmUpIHx8IFwiXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgaGVhZC5jaCA9IDA7XG4gICAgICAgICAgICBoZWFkLmxpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGhlYWQsIHRoaXMuZG9jLmNsaXBQb3MoaGVhZCkpICE9IDApIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWF0Y2hlcyhyZXZlcnNlLCBoZWFkKVxuICAgICAgdGhpcy5hZnRlckVtcHR5TWF0Y2ggPSByZXN1bHQgJiYgQ29kZU1pcnJvci5jbXBQb3MocmVzdWx0LmZyb20sIHJlc3VsdC50bykgPT0gMFxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcmVzdWx0XG4gICAgICAgIHRoaXMuYXRPY2N1cnJlbmNlID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MubWF0Y2ggfHwgdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVuZCA9IFBvcyhyZXZlcnNlID8gdGhpcy5kb2MuZmlyc3RMaW5lKCkgOiB0aGlzLmRvYy5sYXN0TGluZSgpICsgMSwgMClcbiAgICAgICAgdGhpcy5wb3MgPSB7ZnJvbTogZW5kLCB0bzogZW5kfVxuICAgICAgICByZXR1cm4gdGhpcy5hdE9jY3VycmVuY2UgPSBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmcm9tOiBmdW5jdGlvbigpIHtpZiAodGhpcy5hdE9jY3VycmVuY2UpIHJldHVybiB0aGlzLnBvcy5mcm9tfSxcbiAgICB0bzogZnVuY3Rpb24oKSB7aWYgKHRoaXMuYXRPY2N1cnJlbmNlKSByZXR1cm4gdGhpcy5wb3MudG99LFxuXG4gICAgcmVwbGFjZTogZnVuY3Rpb24obmV3VGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoIXRoaXMuYXRPY2N1cnJlbmNlKSByZXR1cm5cbiAgICAgIHZhciBsaW5lcyA9IENvZGVNaXJyb3Iuc3BsaXRMaW5lcyhuZXdUZXh0KVxuICAgICAgdGhpcy5kb2MucmVwbGFjZVJhbmdlKGxpbmVzLCB0aGlzLnBvcy5mcm9tLCB0aGlzLnBvcy50bywgb3JpZ2luKVxuICAgICAgdGhpcy5wb3MudG8gPSBQb3ModGhpcy5wb3MuZnJvbS5saW5lICsgbGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIChsaW5lcy5sZW5ndGggPT0gMSA/IHRoaXMucG9zLmZyb20uY2ggOiAwKSlcbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHRoaXMuZG9jLCBxdWVyeSwgcG9zLCBjYXNlRm9sZClcbiAgfSlcbiAgQ29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb24oXCJnZXRTZWFyY2hDdXJzb3JcIiwgZnVuY3Rpb24ocXVlcnksIHBvcywgY2FzZUZvbGQpIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcih0aGlzLCBxdWVyeSwgcG9zLCBjYXNlRm9sZClcbiAgfSlcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcInNlbGVjdE1hdGNoZXNcIiwgZnVuY3Rpb24ocXVlcnksIGNhc2VGb2xkKSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdXG4gICAgdmFyIGN1ciA9IHRoaXMuZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCB0aGlzLmdldEN1cnNvcihcImZyb21cIiksIGNhc2VGb2xkKVxuICAgIHdoaWxlIChjdXIuZmluZE5leHQoKSkge1xuICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGN1ci50bygpLCB0aGlzLmdldEN1cnNvcihcInRvXCIpKSA+IDApIGJyZWFrXG4gICAgICByYW5nZXMucHVzaCh7YW5jaG9yOiBjdXIuZnJvbSgpLCBoZWFkOiBjdXIudG8oKX0pXG4gICAgfVxuICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25zKHJhbmdlcywgMClcbiAgfSlcbn0pO1xuIl0sIm5hbWVzIjpbIm1vZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiQ29kZU1pcnJvciIsIlBvcyIsInJlZ2V4cEZsYWdzIiwicmVnZXhwIiwiZmxhZ3MiLCJpZ25vcmVDYXNlIiwiZ2xvYmFsIiwibXVsdGlsaW5lIiwiZW5zdXJlRmxhZ3MiLCJjdXJyZW50IiwidGFyZ2V0IiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJjaGFyQXQiLCJSZWdFeHAiLCJzb3VyY2UiLCJtYXliZU11bHRpbGluZSIsInRlc3QiLCJzZWFyY2hSZWdleHBGb3J3YXJkIiwiZG9jIiwic3RhcnQiLCJsaW5lIiwiY2giLCJsYXN0IiwibGFzdExpbmUiLCJsYXN0SW5kZXgiLCJzdHJpbmciLCJnZXRMaW5lIiwibWF0Y2giLCJleGVjIiwiZnJvbSIsImluZGV4IiwidG8iLCJzZWFyY2hSZWdleHBGb3J3YXJkTXVsdGlsaW5lIiwiY2h1bmsiLCJjdXJMaW5lIiwiYmVmb3JlIiwic2xpY2UiLCJzcGxpdCIsImluc2lkZSIsInN0YXJ0TGluZSIsInN0YXJ0Q2giLCJsYXN0TWF0Y2hJbiIsImVuZE1hcmdpbiIsIm5ld01hdGNoIiwiZW5kIiwic2VhcmNoUmVnZXhwQmFja3dhcmQiLCJmaXJzdCIsImZpcnN0TGluZSIsInNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lIiwiY2h1bmtTaXplIiwiZG9Gb2xkIiwibm9Gb2xkIiwiU3RyaW5nIiwicHJvdG90eXBlIiwibm9ybWFsaXplIiwic3RyIiwidG9Mb3dlckNhc2UiLCJhZGp1c3RQb3MiLCJvcmlnIiwiZm9sZGVkIiwicG9zIiwiZm9sZEZ1bmMiLCJtaW4iLCJtYXgiLCJNYXRoIiwibWlkIiwibGVuIiwic2VhcmNoU3RyaW5nRm9yd2FyZCIsInF1ZXJ5IiwiY2FzZUZvbGQiLCJmb2xkIiwibGluZXMiLCJzZWFyY2giLCJmb3VuZCIsImN1dEZyb20iLCJlbmRTdHJpbmciLCJzZWFyY2hTdHJpbmdCYWNrd2FyZCIsImxhc3RJbmRleE9mIiwidG9wIiwidG9wU3RyaW5nIiwiU2VhcmNoQ3Vyc29yIiwib3B0aW9ucyIsImF0T2NjdXJyZW5jZSIsImFmdGVyRW1wdHlNYXRjaCIsImNsaXBQb3MiLCJtYXRjaGVzIiwicmV2ZXJzZSIsImZpbmROZXh0IiwiZmluZCIsImZpbmRQcmV2aW91cyIsImhlYWQiLCJjbXBQb3MiLCJyZXN1bHQiLCJyZXBsYWNlIiwibmV3VGV4dCIsIm9yaWdpbiIsInNwbGl0TGluZXMiLCJyZXBsYWNlUmFuZ2UiLCJkZWZpbmVFeHRlbnNpb24iLCJkZWZpbmVEb2NFeHRlbnNpb24iLCJyYW5nZXMiLCJjdXIiLCJnZXRTZWFyY2hDdXJzb3IiLCJnZXRDdXJzb3IiLCJwdXNoIiwiYW5jaG9yIiwic2V0U2VsZWN0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/addon/search/searchcursor.js\n");

/***/ }),

/***/ "./resources/assets/vendor/libs/codemirror/keymap/vim.js":
/*!***************************************************************!*\
  !*** ./resources/assets/vendor/libs/codemirror/keymap/vim.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n(function (mod) {\n  if (( false ? 0 : _typeof(exports)) == \"object\" && ( false ? 0 : _typeof(module)) == \"object\") // CommonJS\n    mod(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), __webpack_require__(/*! ../addon/search/searchcursor */ \"./resources/assets/vendor/libs/codemirror/addon/search/searchcursor.js\"), __webpack_require__(/*! ../addon/dialog/dialog */ \"./resources/assets/vendor/libs/codemirror/addon/dialog/dialog.js\"), __webpack_require__(/*! ../addon/edit/matchbrackets.js */ \"./resources/assets/vendor/libs/codemirror/addon/edit/matchbrackets.js\"));else if (true) // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__(/*! ../addon/search/searchcursor */ \"./resources/assets/vendor/libs/codemirror/addon/search/searchcursor.js\"), __webpack_require__(/*! ../addon/dialog/dialog */ \"./resources/assets/vendor/libs/codemirror/addon/dialog/dialog.js\"), __webpack_require__(/*! ../addon/edit/matchbrackets */ \"./resources/assets/vendor/libs/codemirror/addon/edit/matchbrackets.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env\n    {}\n})(function (CodeMirror) {\n  'use strict';\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head) return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [// Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  {\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, // Motions\n  {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, // Operators\n  {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, // Operator-Motion dual commands\n  {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, //ignore C-w in normal mode\n  {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, // Actions\n  {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, // Text object motions\n  {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, // Search\n  {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, // Ex command\n  {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n\n  var Vim = function Vim() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n    }\n\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n    } // Deprecated, simply setting the keymap works again.\n\n\n    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) {\n        return undefined;\n      }\n\n      if (this[key]) {\n        return this[key];\n      }\n\n      var vimKey = cmKeyToVimKey(key);\n\n      if (!vimKey) {\n        return false;\n      }\n\n      var cmd = vimApi.findKey(cm, vimKey);\n\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n\n      return cmd;\n    }\n\n    var modifiers = {\n      Shift: 'S',\n      Ctrl: 'C',\n      Alt: 'A',\n      Cmd: 'D',\n      Mod: 'A',\n      CapsLock: ''\n    };\n    var specialKeys = {\n      Enter: 'CR',\n      Backspace: 'BS',\n      Delete: 'Del',\n      Insert: 'Ins'\n    };\n\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n\n      var hasCharacter = false;\n\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n\n        if (piece in modifiers) {\n          pieces[i] = modifiers[piece];\n        } else {\n          hasCharacter = true;\n        }\n\n        if (piece in specialKeys) {\n          pieces[i] = specialKeys[piece];\n        }\n      }\n\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      } // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n\n\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n        bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n\n    function makeKeyRange(start, size) {\n      var keys = [];\n\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n\n      return keys;\n    }\n\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n\n    try {\n      upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n    } catch (_) {\n      upperCaseChars = /^[A-Z]$/;\n    }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n\n    function isLowerCase(k) {\n      return /^[a-z]$/.test(k);\n    }\n\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n\n    function isWhiteSpaceString(k) {\n      return /^\\s*$/.test(k);\n    }\n\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    var options = {};\n\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n\n      if (!type) {\n        type = 'string';\n      }\n\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {\n            value: value\n          };\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n\n        if (scope !== 'local') {\n          return option.callback();\n        }\n\n        return;\n      } else {\n        var local = scope !== 'global' && cm && cm.state.vim.options[name];\n        return (local || scope !== 'local' && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      } // The 'filetype' option proxies to the CodeMirror 'mode' option.\n\n\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function createCircularJumpList() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n\n          if (trashMark) {\n            trashMark.clear();\n          }\n\n          buffer[next] = cm.setBookmark(cursor);\n        }\n\n        if (curMark) {\n          var markPos = curMark.find(); // avoid recording redundant cursor position\n\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n\n      function move(cm, offset) {\n        pointer += offset;\n\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n\n        var mark = buffer[(size + pointer) % size]; // skip marks that are temporarily removed from text buffer\n\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size]; // skip marks that are the same as current position\n\n            if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n\n        return mark;\n      }\n\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n\n      return {\n        cachedCursor: undefined,\n        //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    }; // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n\n\n    var createInsertModeChanges = function createInsertModeChanges(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function exitMacroRecordMode() {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(document.createTextNode('(recording)[' + registerName + ']'), null, {\n              bottom: true\n            });\n          }\n\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n\n      return cm.state.vim;\n    }\n\n    var vimGlobalState;\n\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState(),\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {\n          increment: 0,\n          forward: true,\n          selectedCharacter: ''\n        },\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController: new HistoryController()\n      };\n\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      buildKeyMap: function buildKeyMap() {// TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function getRegisterController() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n      // Testing hook.\n      getVimGlobalState_: function getVimGlobalState_() {\n        return vimGlobalState;\n      },\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n      suppressErrorLogging: false,\n      InsertModeKey: InsertModeKey,\n      map: function map(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function unmap(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function noremap(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n\n        var ctxsToMap = toCtxArray(ctx); // Look through all actual defaults to find a map candidate.\n\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n\n        for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n          var mapping = defaultKeymap[i]; // Omit mappings that operate in the wrong context(s) and those of invalid type.\n\n          if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            } // Modify it point to the new mapping with the proper context.\n\n\n            newMapping.keys = lhs;\n\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            } // Add it to the keymap with a higher priority than the original.\n\n\n            this._mapCommand(newMapping); // Record the mapped contexts as complete.\n\n\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function (el) {\n              return mappedCtxs.indexOf(el) === -1;\n            });\n          }\n        } // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function mapclear(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n\n                    newMapping.context = contexts[j];\n\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function defineEx(name, prefix, func) {\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = {\n          name: name,\n          shortName: prefix,\n          type: 'api'\n        };\n      },\n      handleKey: function handleKey(cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function findKey(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n\n            return true;\n          }\n        }\n\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert'); // Need to check all key substrings in insert mode.\n\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n            if (thisMatch.type != 'none') {\n              match = thisMatch;\n            }\n          }\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) {\n              window.clearTimeout(lastInsertModeKeyTimer);\n            }\n\n            lastInsertModeKeyTimer = window.setTimeout(function () {\n              if (vim.insertMode && vim.inputState.keyBuffer) {\n                clearInputState(cm);\n              }\n            }, getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n          if (/^[1-9]\\d*$/.test(keys)) {\n            return true;\n          }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (!keysMatcher) {\n            clearInputState(cm);\n            return false;\n          }\n\n          var context = vim.visualMode ? 'visual' : 'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            return true;\n          }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n\n          return match.command;\n        }\n\n        var command;\n\n        if (vim.insertMode) {\n          command = handleKeyInsertMode();\n        } else {\n          command = handleKeyNonInsertMode();\n        }\n\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function () {\n            return true;\n          } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function () {\n            return true;\n          };\n        } else {\n          return function () {\n            return cm.operation(function () {\n              cm.curOp.isVimOp = true;\n\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n\n                throw e;\n              }\n\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function handleEx(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n      defineRegister: defineRegister,\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    }; // Represents the current input state.\n\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n\n    InputState.prototype.pushRepeatDigit = function (n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n\n    InputState.prototype.getRepeat = function () {\n      var repeat = 0;\n\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n\n\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n\n    Register.prototype = {\n      setText: function setText(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function pushText(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n\n          this.linewise = true;\n        }\n\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function pushInsertModeChanges(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function pushSearchQuery(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function clear() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function toString() {\n        return this.keyBuffer.join('');\n      }\n    };\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n\n\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n\n    RegisterController.prototype = {\n      pushText: function pushText(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n          text += '\\n';\n        } // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n\n\n        var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null; // if no register/an invalid register was specified, things go to the\n        // default registers\n\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n\n              break;\n          } // Make sure the unnamed register is set to what just happened\n\n\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        } // If we've gotten to this point, we've actually specified a register\n\n\n        var append = isUpperCase(registerName);\n\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        } // The unnamed register always has the same value as the last used\n        // register.\n\n\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function getRegister(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n\n        name = name.toLowerCase();\n\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n\n        return this.registers[name];\n      },\n      isValidRegister: function isValidRegister(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function shiftNumericRegisters_() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n\n    function HistoryController() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function nextMatch(input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n          var element = historyBuffer[i];\n\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        } // should return the user input in case we reach the end of buffer.\n\n\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        } // return the last autocompleted query or exCommand as it is.\n\n\n        if (i < 0) return input;\n      },\n      pushInput: function pushInput(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function reset() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function matchCommand(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n\n        if (!matches.full && !matches.partial) {\n          return {\n            type: 'none'\n          };\n        } else if (!matches.full && matches.partial) {\n          return {\n            type: 'partial'\n          };\n        }\n\n        var bestMatch;\n\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {\n            type: 'none'\n          };\n          inputState.selectedCharacter = character;\n        }\n\n        return {\n          type: 'full',\n          command: bestMatch\n        };\n      },\n      processCommand: function processCommand(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n\n          default:\n            break;\n        }\n      },\n      processMotion: function processMotion(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function processOperator(cm, vim, command) {\n        var inputState = vim.inputState;\n\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = {\n              linewise: true\n            };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n\n        if (command.exitVisualBlock) {\n          vim.visualBlock = false;\n          updateCmSelection(cm);\n        }\n\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function processOperatorMotion(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n\n        this.processOperator(cm, vim, command);\n\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function processAction(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        } // Actions may or may not have motions and operators. Do these first.\n\n\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function processSearch(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = forward ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: {\n              forward: true,\n              toJumplist: command.searchArgs.toJumplist\n            }\n          });\n        }\n\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n          }\n\n          var parsedQuery;\n\n          try {\n            parsedQuery = updateSearchQuery(cm, query, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {// Swallow bad regexes for incremental search.\n          }\n\n          if (parsedQuery) {\n            cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true\n              /** ignoreCase */\n              , false\n              /** smartCase */\n              );\n            } else {\n              showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: '(JavaScript regexp)',\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n              });\n            }\n\n            break;\n\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , true\n            /** noSymbol */\n            );\n            var isKeyword = true;\n\n            if (!word) {\n              word = expandWordUnderCursor(cm, false\n              /** inclusive */\n              , true\n              /** forward */\n              , false\n              /** bigWord */\n              , false\n              /** noSymbol */\n              );\n              isKeyword = false;\n            }\n\n            if (!word) {\n              return;\n            }\n\n            var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n            if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            } // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n\n\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n            break;\n        }\n      },\n      processEx: function processEx(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown,\n              selectValueOnOpen: false\n            });\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              onKeyDown: onPromptKeyDown\n            });\n          }\n        }\n      },\n      evalInput: function evalInput(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel; // TODO: Make sure cm and vim selections are identical outside visual mode.\n\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n\n          if (!motionResult) {\n            return;\n          }\n\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList; // if the current motion is # or *, use cachedCursor\n\n            var cachedCursor = jumpList.cachedCursor;\n\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          } // TODO: Handle null returns from motion commands better.\n\n\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n            updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n\n            if (linewise) {\n              var ranges = cmSel.ranges;\n\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n\n          operatorArgs.registerName = registerName; // Keep track of linewise as it affects how paste and change behave.\n\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n\n    var motions = {\n      moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function moveToMiddleLine(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function expandToLine(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function findNext(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward; // If search is initiated with ? instead of /, negate direction.\n\n        prev = state.isReversed() ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return _findNext(cm, prev\n        /** prev */\n        , query, motionArgs.repeat);\n      },\n\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function findAndSelectNextInclusive(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = state.isReversed() ? !prev : prev; // next: [from, to] | null\n\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim); // No matches.\n\n        if (!next) {\n          return;\n        } // If there's an operator that will be executed, return the selection.\n\n\n        if (prevInputState.operator) {\n          return next;\n        } // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n\n        var from = next[0]; // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {\n              mode: \"visual\",\n              subMode: \"\"\n            });\n          } // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n\n\n          var anchor = vim.sel.anchor;\n\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function goToMark(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n        if (pos) {\n          return motionArgs.linewise ? {\n            line: pos.line,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n          } : pos;\n        }\n\n        return null;\n      },\n      moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n        } else {\n          return [vim.sel.head, vim.sel.anchor];\n        }\n      },\n      jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {\n        var best = head;\n\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n\n            var mark = vim.marks[key].find();\n            var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n\n            if (motionArgs.linewise && mark.line == cursor.line) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n\n        return best;\n      },\n      moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function moveByLines(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch; // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n\n          default:\n            vim.lastHPos = endCh;\n        }\n\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        } // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n\n\n        if (line < first && cur.line == first) {\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last) {\n          return _moveToEol(cm, head, motionArgs, vim, true);\n        }\n\n        if (motionArgs.toFirstChar) {\n          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {\n        var cur = head;\n\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n\n          default:\n            vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = {\n              top: lastCharCoords.top + 8,\n              left: vim.lastHSPos\n            };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function moveByPage(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n      },\n      moveByParagraph: function moveByParagraph(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function moveBySentence(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n        if (!curEnd) {\n          return null;\n        }\n\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function moveByWords(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n\n        var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function moveToCharacter(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function moveToSymbol(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat; // repeat is equivalent to which column we want to move to!\n\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return _moveToColumn(cm, repeat);\n      },\n      moveToEol: function moveToEol(cm, head, motionArgs, vim) {\n        return _moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = ch === '<' || ch === '>' ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {\n            bracketRegex: re\n          });\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function moveToStartOfLine(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n\n        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function moveToStartOfDisplayLine(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function moveToEndOfDisplayLine(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {\n          '(': ')',\n          ')': '(',\n          '{': '}',\n          '}': '{',\n          '[': ']',\n          ']': '[',\n          '<': '>',\n          '>': '<'\n        };\n        var selfPaired = {\n          '\\'': true,\n          '\"': true,\n          '`': true\n        };\n        var character = motionArgs.selectedCharacter; // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        } // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n\n\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , true\n          /** bigWord */\n          );\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , false\n          /** bigWord */\n          );\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n\n          if (vim.visualMode) {\n            if (!vim.visualLine) {\n              vim.visualLine = true;\n            }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n\n            if (operatorArgs) {\n              operatorArgs.linewise = true;\n            }\n\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n      repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n\n        var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n\n\n    var operators = {\n      change: function change(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = /\\s+$/.exec(text);\n\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, -match[0].length);\n              text = text.slice(0, -match[0].length);\n            }\n          }\n\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            } // make sure cursor ends up at the end of the line.\n\n\n            anchor.ch = Number.MAX_VALUE;\n          }\n\n          finalHead = anchor;\n        } else if (args.fullLine) {\n          head.ch = Number.MAX_VALUE;\n          head.line--;\n          cm.setSelection(anchor, head);\n          text = cm.getSelection();\n          cm.replaceSelection(\"\");\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {\n          head: finalHead\n        }, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function _delete(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n\n          if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function indent(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line; // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n\n        var repeat = vim.visualMode ? args.repeat : 1;\n\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function indentAuto(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n            }\n          }\n\n          swapped.push(text);\n        }\n\n        cm.replaceSelections(swapped);\n\n        if (args.shouldMoveCursor) {\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise) {\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function yank(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function scroll(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n          if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function scrollToCursor(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n\n        switch (actionArgs.position) {\n          case 'center':\n            y = y - height / 2 + lineHeight;\n            break;\n\n          case 'bottom':\n            y = y - height + lineHeight;\n            break;\n        }\n\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function replayMacro(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n\n        while (repeat--) {\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function toggleOverwrite(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n      },\n      enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n          return;\n        }\n\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = actionArgs ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode) return;\n\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualMode) return;\n\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode) {\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n\n        cm.setOption('disableInput', false);\n\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head; // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n          });\n        }\n      },\n      joinLines: function joinLines(cm, actionArgs, vim) {\n        var curStart, curEnd;\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n        }\n\n        var finalCh = 0;\n\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces ? text.replace(/\\n\\r?/g, '') : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n\n        var curFinalPos = new Pos(curStart.line, finalCh);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n\n        this.enterInsertMode(cm, {\n          repeat: actionArgs.repeat\n        }, vim);\n      },\n      paste: function paste(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var text = register.toString();\n\n        if (!text) {\n          return;\n        }\n\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\"); // length that considers tabs and tabSize\n\n          var whitespaceLength = function whitespaceLength(str) {\n            var tabs = str.split(\"\\t\").length - 1;\n            var spaces = str.split(\" \").length - 1;\n            return tabs * tabSize + spaces * 1;\n          };\n\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]); // chomp last newline b/c don't want it to match /^\\s*/gm\n\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n            if (newIndent < 0) {\n              return \"\";\n            } else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            } else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n\n        if (blockwise) {\n          text = text.split('\\n');\n\n          if (linewise) {\n            text.pop();\n          }\n\n          for (var i = 0; i < text.length; i++) {\n            text[i] = text[i] == '' ? ' ' : text[i];\n          }\n\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if (vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n\n        var curPosFinal;\n        var idx;\n\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1'); // save the curEnd marker before it get cleared due to cm.replaceRange.\n\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          } // push the previously selected text to unnamed register\n\n\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings); // Set new selections as per the block length of the yanked text\n\n            selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          } // restore the the curEnd marker\n\n\n          if (lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n\n          if (linewise) {\n            curPosFinal.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line + i;\n\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n', new Pos(line, 0));\n              }\n\n              var lastCh = lineLength(cm, line);\n\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur); // Now fine tune the cursor to where we want it.\n\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curPosFinal);\n      },\n      undo: function undo(cm, actionArgs) {\n        cm.operation(function () {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function redo(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function setRegister(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function setMark(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function replace(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n\n          if (replaceTo > line.length) {\n            replaceTo = line.length;\n          }\n\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n\n        if (replaceWith == '\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd); // special case, where vim help says to replace by just one line-break\n\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd); //replace all characters in range by selected, but keep linebreaks\n\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function incrementNumberToken(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end) break;\n        }\n\n        if (!actionArgs.backtrack && end <= cur.ch) return;\n\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {\n            '0b': 2,\n            '0': 8,\n            '': 10,\n            '0x': 16\n          }[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n\n        if (!lastEditInputState) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n\n        _repeatLastEdit(cm, vim, repeat, false\n        /** repeatForInsert */\n        );\n      },\n      indent: function indent(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n\n\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n\n    function copyArgs(args) {\n      var ret = {};\n\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n\n      return ret;\n    }\n\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (_typeof(offsetLine) === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match,\n          partial = [],\n          full = [];\n\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n\n        if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n          continue;\n        }\n\n        if (match == 'partial') {\n          partial.push(command);\n        }\n\n        if (match == 'full') {\n          full.push(command);\n        }\n      }\n\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n      if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n          case '<CR>':\n            selectedCharacter = '\\n';\n            break;\n\n          case '<Space>':\n            selectedCharacter = ' ';\n            break;\n\n          default:\n            selectedCharacter = '';\n            break;\n        }\n      }\n\n      return selectedCharacter;\n    }\n\n    function repeatFn(cm, fn, repeat) {\n      return function () {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column - endCh + 1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    } // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n\n\n    function selectBlock(cm, selectionEnd) {\n      var selections = [],\n          ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch,\n          headCh = head.ch;\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n\n        if (!isClipped) {\n          headCh--;\n        }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n\n        if (!wasClipped) {\n          headCh++;\n        }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {\n          anchor: new Pos(line, baseCh),\n          head: new Pos(line, headCh)\n        };\n        selections.push(range);\n      }\n\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({\n          anchor: lineHead,\n          head: lineHead\n        });\n      }\n\n      cm.setSelections(sel, 0);\n    } // getIndex returns the index of the cursor in the selections.\n\n\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n\n      var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange() {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n\n      var getLastSelectedAreaRange = function getLastSelectedAreaRange() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = []; // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {\n              anchor: anchor,\n              head: head\n            };\n            selections.push(range);\n          }\n\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {\n            line: selectionEnd.line + line,\n            ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n          };\n\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n\n        return [selectionStart, selectionEnd];\n      };\n\n      if (!vim.visualMode) {\n        // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    } // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n\n\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head; // To accommodate the effect of lastPastedText in the last selection\n\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n\n      vim.lastSelection = {\n        'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock\n      };\n    }\n\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n\n\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n          var lastLine = cm.lastLine();\n\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n\n        if (fromCh < toCh) {\n          toCh += 1;\n        } else {\n          fromCh += 1;\n        }\n\n        ;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n\n      return cur;\n    }\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n\n\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n    } // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n\n\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd); // Only clip if the selection ends with trailing newline + whitespace\n\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n'); // We know this is all whitespace.\n\n        lines.pop(); // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n\n        var line; // Find the line containing the last word, and clip all whitespace up\n        // to it.\n\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        } // If the last word is not an empty line, clip an additional newline\n\n\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    } // Expand the selection to line ends.\n\n\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch; // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n      while (!test(line.charAt(idx))) {\n        idx++;\n\n        if (idx >= line.length) {\n          return null;\n        }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx,\n          start = idx;\n\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      while (test(line.charAt(start)) && start >= 0) {\n        start--;\n      }\n\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n          end++;\n        }\n\n        if (wordEnd == end) {\n          var wordStart = start;\n\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n            start--;\n          }\n\n          if (!start) {\n            start = wordStart;\n          }\n        }\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n\n\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n\n      if (!tags || !tags.open || !tags.close) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      if (inclusive) {\n        return {\n          start: tags.open.from,\n          end: tags.close.to\n        };\n      }\n\n      return {\n        start: tags.open.to,\n        end: tags.close.from\n      };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n      '(': 'bracket',\n      ')': 'bracket',\n      '{': 'bracket',\n      '}': 'bracket',\n      '[': 'section',\n      ']': 'section',\n      '*': 'comment',\n      '/': 'comment',\n      'm': 'method',\n      'M': 'method',\n      '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function isComplete(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1) return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n\n          return false;\n        }\n      },\n      section: {\n        init: function init(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function isComplete(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function isComplete(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function init(state) {\n          state.symb = state.symb === 'm' ? '{' : '}';\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function isComplete(state) {\n          if (state.nextCh === state.symb) return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function init(state) {\n          state.index = 0;\n        },\n        isComplete: function isComplete(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth--;\n            }\n\n            if (token === 'else' && state.depth === 0) return true;\n          }\n\n          return false;\n        }\n      }\n    };\n\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? {\n          ')': '(',\n          '}': '{'\n        } : {\n          '(': ')',\n          '{': '}'\n        })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode) return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n\n      if (init) {\n        init(state);\n      }\n\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = lineLen > 0 ? lineLen - 1 : 0;\n          }\n\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n\n      return cur;\n    }\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n\n\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        pos = forward ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return {\n            from: 0,\n            to: 0,\n            line: lineNum\n          };\n        }\n\n        var stop = dir > 0 ? line.length : -1;\n        var wordStart = stop,\n            wordEnd = stop; // Find bounds of next word.\n\n        while (pos != stop) {\n          var foundWord = false;\n\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos; // Advance to end of word.\n\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n\n              if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum\n                };\n              }\n            }\n          }\n\n          if (!foundWord) {\n            pos += dir;\n          }\n        } // Advance to next/prev line.\n\n\n        lineNum += dir;\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        line = cm.getLine(lineNum);\n        pos = dir > 0 ? 0 : line.length;\n      }\n    }\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n\n\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      } // For 'e', empty lines are not considered words, go figure.\n\n\n      var emptyLineIsWord = !(forward && wordEnd);\n\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward ? {\n            line: cm.lastLine(),\n            from: eodCh,\n            to: eodCh\n          } : {\n            line: 0,\n            from: 0,\n            to: 0\n          });\n          break;\n        }\n\n        words.push(word);\n        cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n      }\n\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function _moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end = cm.clipPos(retval);\n      end.ch--;\n\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n      }\n\n      return retval;\n    }\n\n    function _moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n\n      for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n\n        if (idx == -1) {\n          return null;\n        }\n\n        start = idx;\n      }\n\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function _moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start,\n          end,\n          i = line;\n\n      function isEmpty(i) {\n        return !cm.getLine(i);\n      }\n\n      function isBoundary(i, dir, any) {\n        if (any) {\n          return isEmpty(i) != isEmpty(i + dir);\n        }\n\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) {\n            repeat--;\n          }\n\n          i += dir;\n        }\n\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n\n      var startState = isEmpty(line);\n\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n\n      end = new Pos(i, 0); // select boundary before paragraph for the last one\n\n      if (i > max && !startState) {\n        startState = true;\n      } else {\n        inclusive = false;\n      }\n\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) {\n            break;\n          }\n        }\n      }\n\n      start = new Pos(i, 0);\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n        } else {\n          idx.pos += idx.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n\n\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = line === \"\";\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n\n\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: null\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            } else {\n              return {\n                ln: curr.ln,\n                pos: curr.pos\n              };\n            }\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        } else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    } // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n\n\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head,\n          start,\n          end;\n      var bracketRegexp = {\n        '(': /[()]/,\n        ')': /[()]/,\n        '[': /[[\\]]/,\n        ']': /[[\\]]/,\n        '{': /[{}]/,\n        '}': /[{}]/,\n        '<': /[<>]/,\n        '>': /[<>]/\n      }[symb];\n      var openSym = {\n        '(': '(',\n        ')': '(',\n        '[': '[',\n        ']': '[',\n        '{': '{',\n        '}': '{',\n        '<': '<',\n        '>': '<'\n      }[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch); // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n\n      var offset = curChar === openSym ? 1 : 0;\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return {\n        start: start,\n        end: end\n      };\n    } // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n\n\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb); // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex; // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      } // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n\n        --cur.ch; // make sure to look backwards\n      } // if we're currently on the symbol, we've got a start\n\n\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      } // look forwards for the end symbol\n\n\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      } // nothing found\n\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      } // include the symbols\n\n\n      if (inclusive) {\n        --start;\n        ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    } // Search functions\n\n\n    defineOption('pcre', true, 'boolean');\n\n    function SearchState() {}\n\n    SearchState.prototype = {\n      getQuery: function getQuery() {\n        return vimGlobalState.query;\n      },\n      setQuery: function setQuery(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function getOverlay() {\n        return this.searchOverlay;\n      },\n      setOverlay: function setOverlay(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function isReversed() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function setReversed(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function getScrollbarAnnotate() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {\n        this.annotate = annotate;\n      }\n    };\n\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = []; // in case of strings like foo/bar\n\n      if (slashes[0] !== 0) return;\n\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n      }\n\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator) separator = '/';\n      var escapeNextChar = false;\n      var slashes = [];\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n\n        escapeNextChar = !escapeNextChar && c == '\\\\';\n      }\n\n      return slashes;\n    } // Translates a search string from ex (vim) syntax into javascript form.\n\n\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){'; // Remove, but never add, a '\\' for these.\n\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = n && specials.indexOf(n) != -1;\n\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true; // Treat the unescape list as special for removing, but not adding '\\'.\n\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            } // Not passing this test means removing a '\\'.\n\n\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n\n\n    var charUnescapes = {\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c + n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n\n            if (isNumber(n) || n === '$') {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n\n            out.push(c);\n\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Unescape \\ and / in the replace part, for PCRE mode.\n\n\n    var unescapes = {\n      '\\\\/': '/',\n      '\\\\\\\\': '\\\\',\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t',\n      '\\\\&': '&'\n    };\n\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n\n        var matched = false;\n\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n\n      return output.join('');\n    }\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n\n\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query); // Check if the query is already a regex.\n\n      if (query instanceof RegExp) {\n        return query;\n      } // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n\n\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = flagsPart.indexOf('i') != -1;\n      }\n\n      if (!regexPart) {\n        return null;\n      }\n\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n\n      if (smartCase) {\n        ignoreCase = /^[^A-Z]*$/.test(regexPart);\n      }\n\n      var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n      return regexp;\n    }\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n\n\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (_typeof(a) !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n        }\n      }\n\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('pre', {\n        $color: 'red',\n        \"class\": 'cm-vim-message'\n      }, template);\n\n      if (cm.openNotification) {\n        cm.openNotification(pre, {\n          bottom: true,\n          duration: 5000\n        });\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(), dom('span', {\n        $fontFamily: 'monospace',\n        $whiteSpace: 'pre'\n      }, prefix, dom('input', {\n        type: 'text',\n        autocorrect: 'off',\n        autocapitalize: 'off',\n        spellcheck: 'false'\n      })), desc && dom('span', {\n        $color: '#888'\n      }, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown,\n          onKeyUp: options.onKeyUp,\n          bottom: true,\n          selectValueOnOpen: false,\n          value: options.value\n        });\n      } else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n\n          if (r1[prop] !== r2[prop]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    } // Returns true if the query is valid.\n\n\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n      if (!query) {\n        return;\n      }\n\n      highlightSearchMatches(cm, query);\n\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n\n      state.setQuery(query);\n      return query;\n    }\n\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n\n      return {\n        token: function token(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n\n          var match = stream.match(query, false);\n\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n\n            stream.match(query);\n            return 'searching';\n          }\n\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n\n    var highlightTimeout = 0;\n\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function () {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n\n    function _findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n            }\n          }\n\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n\n\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos); // Go back one result to ensure that if the cursor is currently a match, we keep it.\n\n        var found = cursor.find(!prev); // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n\n        return [cursor.from(), cursor.to()];\n      });\n    }\n\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n\n\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return pos >= start && pos <= end;\n        } else {\n          return pos == start;\n        }\n      }\n    }\n\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({\n        left: 0,\n        top: occludeToleranceTop + scrollInfo.top\n      }, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({\n        left: 0,\n        top: bottomY\n      }, 'local');\n      return {\n        top: from.line,\n        bottom: to.line\n      };\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function ExCommandDispatcher() {\n      this.buildCommandMap_();\n    };\n\n    ExCommandDispatcher.prototype = {\n      processCommand: function processCommand(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function _processCommand(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        var inputStream = new CodeMirror.StringStream(input); // update \": with the latest command whether valid or invalid\n\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch (e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n\n        var command;\n        var commandName;\n\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n\n          if (command) {\n            commandName = command.name;\n\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n\n            this.parseCommandArgs_(inputStream, params, command);\n\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n\n        try {\n          exCommands[commandName](cm, params); // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch (e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function parseInput_(cm, inputStream, result) {\n        inputStream.eatWhile(':'); // Parse range.\n\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        } // Parse command name.\n\n\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function parseLineSpec_(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n          case '-':\n          case '+':\n            inputStream.backUp(1); // Offset is relative to current line if not otherwise specified.\n\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n\n        return line;\n      },\n      parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n\n        params.argString = inputStream.match(/.*/)[0]; // Parse command-line arguments\n\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function matchCommand_(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n\n        return null;\n      },\n      buildCommandMap_: function buildCommandMap_() {\n        this.commandMap_ = {};\n\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function map(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: {\n                input: rhs.substring(1)\n              }\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function unmap(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n    var exCommands = {\n      colorscheme: function colorscheme(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function map(cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function imap(cm, params) {\n        this.map(cm, params, 'insert');\n      },\n      nmap: function nmap(cm, params) {\n        this.map(cm, params, 'normal');\n      },\n      vmap: function vmap(cm, params) {\n        this.map(cm, params, 'visual');\n      },\n      unmap: function unmap(cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function move(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n          type: 'motion',\n          motion: 'moveToLineOrEdgeOfDocument',\n          motionArgs: {\n            forward: false,\n            explicitRepeat: true,\n            linewise: true\n          },\n          repeatOverride: params.line + 1\n        });\n      },\n      set: function set(cm, params) {\n        var setArgs = params.args; // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n\n        var setCfg = params.setCfg || {};\n\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) {\n            throw Error('Trailing characters: ' + params.argString);\n          }\n\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        } // If no value is provided, then we assume this is a get.\n\n\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function setlocal(cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'local'\n        };\n        this.set(cm, params);\n      },\n      setglobal: function setglobal(cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'global'\n        };\n        this.set(cm, params);\n      },\n      registers: function registers(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n\n        showConfirm(cm, regInfo);\n      },\n      sort: function sort(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n\n            if (args.eat('!')) {\n              reverse = true;\n            }\n\n            if (args.eol()) {\n              return;\n            }\n\n            if (!args.eatSpace()) {\n              return 'Invalid arguments';\n            }\n\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n            if (!opts && !args.eol()) {\n              return 'Invalid arguments';\n            }\n\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n\n              if (decimal + hex + octal > 1) {\n                return 'Invalid arguments';\n              }\n\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n\n        var err = parseArgs();\n\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n        if (lineStart == lineEnd) {\n          return;\n        }\n\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n        var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n        var numPart = [],\n            textPart = [];\n\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n\n        function compareFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a = a.toLowerCase();\n            b = b.toLowerCase();\n          }\n\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n\n          if (!anum) {\n            return a < b ? -1 : 1;\n          }\n\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n\n        function comparePatternFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a[0] = a[0].toLowerCase();\n            b[0] = b[0].toLowerCase();\n          }\n\n          return a[0] < b[0] ? -1 : 1;\n        }\n\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) {\n          textPart.sort(compareFn);\n        }\n\n        text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n        if (unique) {\n          // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n\n            lastLine = textOld[i];\n          }\n        }\n\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function vglobal(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function global(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n\n        var inverted = params.commandName[0] === 'v'; // range is specified here\n\n        var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine(); // get the tokens from argString\n\n        var tokens = splitBySlash(argString);\n        var regexPart = argString,\n            cmd;\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        } // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n\n\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        } // if there is no [cmd], just display the list of matched lines\n\n\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n\n        var index = 0;\n\n        var nextCommand = function nextCommand() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n\n            var command = lineNum + 1 + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n\n        nextCommand();\n      },\n      substitute: function substitute(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n        }\n\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart,\n            replacePart = '',\n            trailing,\n            flagsPart,\n            count;\n        var confirm = false; // Whether to confirm each replace.\n\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n\n          if (getOption('pcre') && regexPart !== '') {\n            regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n\n          replacePart = tokens[1];\n\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n            return;\n          }\n        } // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n\n\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n\n            if (getOption('pcre')) {\n              regexPart = regexPart + '/' + flagsPart;\n            } else {\n              regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function write(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function nohlsearch(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function yank(cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n      },\n      delmarks: function delmarks(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n\n        while (!stream.eol()) {\n          stream.eatSpace(); // Record the streams position at the beginning of the loop for use\n          // in error messages.\n\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next(); // Check if this symbol is part of a range\n\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next(); // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n\n            if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              } // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n\n\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n    var exCommandDispatcher = new ExCommandDispatcher();\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n\n      function replaceAll() {\n        cm.operation(function () {\n          while (!done) {\n            replace();\n            next();\n          }\n\n          stop();\n        });\n      }\n\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n\n        return match;\n      }\n\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n\n        done = true;\n      }\n\n      function stop(close) {\n        if (close) {\n          close();\n        }\n\n        cm.focus();\n\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n\n        if (callback) {\n          callback();\n        }\n      }\n\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n\n        switch (keyName) {\n          case 'Y':\n            replace();\n            next();\n            break;\n\n          case 'N':\n            next();\n            break;\n\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n\n          case 'L':\n            replace();\n          // fall through and exit.\n\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n\n        if (done) {\n          stop(close);\n        }\n\n        return true;\n      } // Actually do replace.\n\n\n      next();\n\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n\n      if (!confirm) {\n        replaceAll();\n\n        if (callback) {\n          callback();\n        }\n\n        return;\n      }\n\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        _repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n        /** repeatForInsert */\n        );\n\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {\n        keys: keys,\n        type: type\n      };\n      command[type] = name;\n      command[type + \"Args\"] = args;\n\n      for (var key in extra) {\n        command[key] = extra[key];\n      }\n\n      _mapCommand(command);\n    } // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n\n\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n\n        macroModeState.isPlaying = false;\n        return;\n      }\n\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n\n\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (!macroModeState.isPlaying) {\n        while (changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined\n          /* only in testing */\n          ) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          } // Change objects may be chained with next.\n\n\n          changeObj = changeObj.next;\n        }\n      }\n    }\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n\n\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        var lastChange = macroModeState.lastInsertModeChanges;\n\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head'); // Enter or exit visual mode to match mouse selection.\n\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\"\n        });\n      }\n\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n    /** Wrapper for special keys pressed in insert mode */\n\n\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n\n\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n\n      if (!keyName) {\n        return;\n      }\n\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n\n\n    function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n\n      vim.inputState = vim.lastEditInputState;\n\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n\n        repeatInsert(repeat);\n      }\n\n      vim.inputState = cachedInputState;\n\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n\n        return true;\n      }\n\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  }; // Initialize Vim and make it available as an API.\n\n\n  CodeMirror.Vim = Vim();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3Iva2V5bWFwL3ZpbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLEdBQVQsRUFBYztFQUNiLElBQUksc0JBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEIsc0JBQU9DLE1BQVAsTUFBaUIsUUFBbkQsRUFBNkQ7SUFDM0RGLEdBQUcsQ0FBQ0csbUJBQU8sQ0FBQyxnSkFBRCxDQUFSLEVBQStCQSxtQkFBTyxDQUFDLDRHQUFELENBQXRDLEVBQXdFQSxtQkFBTyxDQUFDLGdHQUFELENBQS9FLEVBQTJHQSxtQkFBTyxDQUFDLDZHQUFELENBQWxILENBQUgsQ0FERixLQUVLLElBQUksSUFBSixFQUErQztJQUNsREMsaUNBQU8sQ0FBQyxnSkFBRCxFQUFzQixpSUFBdEIsRUFBc0QscUhBQXRELEVBQWdGLCtIQUFoRixDQUFELG9DQUFpSEosR0FBakg7QUFBQTtBQUFBO0FBQUEsa0dBQU4sQ0FERyxLQUVBO0lBQ0hBLEVBQUE7QUFDSCxDQVBELEVBT0csVUFBU00sVUFBVCxFQUFxQjtFQUN0Qjs7RUFFQSxJQUFJQyxHQUFHLEdBQUdELFVBQVUsQ0FBQ0MsR0FBckI7O0VBRUEsU0FBU0MsZUFBVCxDQUF5QkMsRUFBekIsRUFBNkJDLEtBQTdCLEVBQW9DO0lBQ2xDLElBQUlDLEdBQUcsR0FBR0YsRUFBRSxDQUFDRyxLQUFILENBQVNELEdBQW5CO0lBQ0EsSUFBSSxDQUFDQSxHQUFELElBQVFBLEdBQUcsQ0FBQ0UsVUFBaEIsRUFBNEIsT0FBT0gsS0FBSyxDQUFDSSxJQUFiO0lB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Q0QsQ0FGRCxNQUVPLElBQUksT0FBT3ZhLE1BQVAsSUFBaUIsUUFBckIsRUFBK0I7WUFDcEN2aUIsRUFBRSxDQUFDb2pCLGdCQUFILENBQW9CYixNQUFwQjtVQUNELENBRk0sTUFFQTtZQUNMLElBQUkvWixLQUFLLEdBQUd4SSxFQUFFLENBQUNnSSxTQUFILEVBQVo7WUFDQSxJQUFJa1MsR0FBRyxHQUFHblMsWUFBWSxDQUFDUyxLQUFELEVBQVEsQ0FBUixFQUFXK1osTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVOWUsTUFBckIsQ0FBdEI7WUFDQXpELEVBQUUsQ0FBQ2lULFlBQUgsQ0FBZ0JzUCxNQUFNLENBQUMsQ0FBRCxDQUF0QixFQUEyQi9aLEtBQTNCLEVBQWtDMFIsR0FBbEM7WUFDQWxhLEVBQUUsQ0FBQzhILFNBQUgsQ0FBYW9TLEdBQWI7VUFDRDtRQUNGO01BQ0Y7O01BQ0QsSUFBSTNaLFdBQUosRUFBaUI7UUFDZlAsRUFBRSxDQUFDOEgsU0FBSCxDQUFhQyxZQUFZLENBQUMxSCxJQUFELEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBekI7TUFDRDtJQUNGOztJQUVEa08sbUJBQW1CO0lBQ25CLE9BQU9sSSxNQUFQO0VBQ0QsQ0E1MEtELENBM09zQixDQXdqTHRCOzs7RUFDQXhHLFVBQVUsQ0FBQ2tFLEdBQVgsR0FBaUJBLEdBQUcsRUFBcEI7QUFDRCxDQWprTEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL2NvZGVtaXJyb3Iva2V5bWFwL3ZpbS5qcz85OGVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8qKlxuICogU3VwcG9ydGVkIGtleWJpbmRpbmdzOlxuICogICBUb28gbWFueSB0byBsaXN0LiBSZWZlciB0byBkZWZhdWx0S2V5bWFwIGJlbG93LlxuICpcbiAqIFN1cHBvcnRlZCBFeCBjb21tYW5kczpcbiAqICAgUmVmZXIgdG8gZGVmYXVsdEV4Q29tbWFuZE1hcCBiZWxvdy5cbiAqXG4gKiBSZWdpc3RlcnM6IHVubmFtZWQsIC0sIC4sIDosIC8sIF8sIGEteiwgQS1aLCAwLTlcbiAqICAgKERvZXMgbm90IHJlc3BlY3QgdGhlIHNwZWNpYWwgY2FzZSBmb3IgbnVtYmVyIHJlZ2lzdGVycyB3aGVuIGRlbGV0ZVxuICogICAgb3BlcmF0b3IgaXMgbWFkZSB3aXRoIHRoZXNlIGNvbW1hbmRzOiAlLCAoLCApLCAgLCAvLCA/LCBuLCBOLCB7LCB9IClcbiAqICAgVE9ETzogSW1wbGVtZW50IHRoZSByZW1haW5pbmcgcmVnaXN0ZXJzLlxuICpcbiAqIE1hcmtzOiBhLXosIEEtWiwgYW5kIDAtOVxuICogICBUT0RPOiBJbXBsZW1lbnQgdGhlIHJlbWFpbmluZyBzcGVjaWFsIG1hcmtzLiBUaGV5IGhhdmUgbW9yZSBjb21wbGV4XG4gKiAgICAgICBiZWhhdmlvci5cbiAqXG4gKiBFdmVudHM6XG4gKiAgJ3ZpbS1tb2RlLWNoYW5nZScgLSByYWlzZWQgb24gdGhlIGVkaXRvciBhbnl0aW1lIHRoZSBjdXJyZW50IG1vZGUgY2hhbmdlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgIEV2ZW50IG9iamVjdDoge21vZGU6IFwidmlzdWFsXCIsIHN1Yk1vZGU6IFwibGluZXdpc2VcIn1cbiAqXG4gKiBDb2RlIHN0cnVjdHVyZTpcbiAqICAxLiBEZWZhdWx0IGtleW1hcFxuICogIDIuIFZhcmlhYmxlIGRlY2xhcmF0aW9ucyBhbmQgc2hvcnQgYmFzaWMgaGVscGVyc1xuICogIDMuIEluc3RhbmNlIChFeHRlcm5hbCBBUEkpIGltcGxlbWVudGF0aW9uXG4gKiAgNC4gSW50ZXJuYWwgc3RhdGUgdHJhY2tpbmcgb2JqZWN0cyAoaW5wdXQgc3RhdGUsIGNvdW50ZXIpIGltcGxlbWVudGF0aW9uXG4gKiAgICAgYW5kIGluc3RhbnRpYXRpb25cbiAqICA1LiBLZXkgaGFuZGxlciAodGhlIG1haW4gY29tbWFuZCBkaXNwYXRjaGVyKSBpbXBsZW1lbnRhdGlvblxuICogIDYuIE1vdGlvbiwgb3BlcmF0b3IsIGFuZCBhY3Rpb24gaW1wbGVtZW50YXRpb25zXG4gKiAgNy4gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIGtleSBoYW5kbGVyLCBtb3Rpb25zLCBvcGVyYXRvcnMsIGFuZCBhY3Rpb25zXG4gKiAgOC4gU2V0IHVwIFZpbSB0byB3b3JrIGFzIGEga2V5bWFwIGZvciBDb2RlTWlycm9yLlxuICogIDkuIEV4IGNvbW1hbmQgaW1wbGVtZW50YXRpb25zLlxuICovXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9hZGRvbi9zZWFyY2gvc2VhcmNoY3Vyc29yXCIpLCByZXF1aXJlKFwiLi4vYWRkb24vZGlhbG9nL2RpYWxvZ1wiKSwgcmVxdWlyZShcIi4uL2FkZG9uL2VkaXQvbWF0Y2hicmFja2V0cy5qc1wiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3JcIiwgXCIuLi9hZGRvbi9kaWFsb2cvZGlhbG9nXCIsIFwiLi4vYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUN1cnNvcihjbSwgcmFuZ2UpIHtcbiAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgIGlmICghdmltIHx8IHZpbS5pbnNlcnRNb2RlKSByZXR1cm4gcmFuZ2UuaGVhZDtcbiAgICB2YXIgaGVhZCA9IHZpbS5zZWwuaGVhZDtcbiAgICBpZiAoIWhlYWQpICByZXR1cm4gcmFuZ2UuaGVhZDtcblxuICAgIGlmICh2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgIGlmIChyYW5nZS5oZWFkLmxpbmUgIT0gaGVhZC5saW5lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlLmZyb20oKSA9PSByYW5nZS5hbmNob3IgJiYgIXJhbmdlLmVtcHR5KCkpIHtcbiAgICAgIGlmIChyYW5nZS5oZWFkLmxpbmUgPT0gaGVhZC5saW5lICYmIHJhbmdlLmhlYWQuY2ggIT0gaGVhZC5jaClcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MocmFuZ2UuaGVhZC5saW5lLCByYW5nZS5oZWFkLmNoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlLmhlYWQ7XG4gIH1cblxuICB2YXIgZGVmYXVsdEtleW1hcCA9IFtcbiAgICAvLyBLZXkgdG8ga2V5IG1hcHBpbmcuIFRoaXMgZ29lcyBmaXJzdCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIG92ZXJyaWRlXG4gICAgLy8gZXhpc3RpbmcgbWFwcGluZ3MuXG4gICAgeyBrZXlzOiAnPExlZnQ+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaCcgfSxcbiAgICB7IGtleXM6ICc8UmlnaHQ+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnbCcgfSxcbiAgICB7IGtleXM6ICc8VXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaycgfSxcbiAgICB7IGtleXM6ICc8RG93bj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqJyB9LFxuICAgIHsga2V5czogJ2c8VXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnZ2snIH0sXG4gICAgeyBrZXlzOiAnZzxEb3duPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2dqJyB9LFxuICAgIHsga2V5czogJzxTcGFjZT4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdsJyB9LFxuICAgIHsga2V5czogJzxCUz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdoJywgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJzxEZWw+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAneCcsIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICc8Qy1TcGFjZT4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdXJyB9LFxuICAgIHsga2V5czogJzxDLUJTPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ0InLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJzxTLVNwYWNlPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ3cnIH0sXG4gICAgeyBrZXlzOiAnPFMtQlM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnYicsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAnPEMtbj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqJyB9LFxuICAgIHsga2V5czogJzxDLXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaycgfSxcbiAgICB7IGtleXM6ICc8Qy1bPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxFc2M+JyB9LFxuICAgIHsga2V5czogJzxDLWM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEVzYz4nIH0sXG4gICAgeyBrZXlzOiAnPEMtWz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAnPEMtYz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAncycsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2NsJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdzJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnYycsIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICdTJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnY2MnLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ1MnLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdWZE8nLCBjb250ZXh0OiAndmlzdWFsJyB9LFxuICAgIHsga2V5czogJzxIb21lPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzAnIH0sXG4gICAgeyBrZXlzOiAnPEVuZD4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICckJyB9LFxuICAgIHsga2V5czogJzxQYWdlVXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEMtYj4nIH0sXG4gICAgeyBrZXlzOiAnPFBhZ2VEb3duPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxDLWY+JyB9LFxuICAgIHsga2V5czogJzxDUj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqXicsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAnPElucz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdpJywgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJzxJbnM+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZU92ZXJ3cml0ZScsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgLy8gTW90aW9uc1xuICAgIHsga2V5czogJ0gnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvVG9wTGluZScsIG1vdGlvbkFyZ3M6IHsgbGluZXdpc2U6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnTScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9NaWRkbGVMaW5lJywgbW90aW9uQXJnczogeyBsaW5ld2lzZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdMJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0JvdHRvbUxpbmUnLCBtb3Rpb25BcmdzOiB7IGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2gnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnbCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlDaGFyYWN0ZXJzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2onLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2snLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnaicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlEaXNwbGF5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ2snLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5RGlzcGxheUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICd3JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdXJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiBmYWxzZSwgYmlnV29yZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdlJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlXb3JkcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgd29yZEVuZDogdHJ1ZSwgYmlnV29yZDogdHJ1ZSwgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2InLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdCJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgd29yZEVuZDogZmFsc2UsIGJpZ1dvcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ2UnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ0UnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiB0cnVlLCBiaWdXb3JkOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAneycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYXJhZ3JhcGgnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ30nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5UGFyYWdyYXBoJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJygnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5U2VudGVuY2UnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJyknLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5U2VudGVuY2UnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtZj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5UGFnZScsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1iPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYWdlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1kPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlTY3JvbGwnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGV4cGxpY2l0UmVwZWF0OiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLXU+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVNjcm9sbCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGV4cGxpY2l0UmVwZWF0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2dnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50JywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgZXhwbGljaXRSZXBlYXQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ0cnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvTGluZU9yRWRnZU9mRG9jdW1lbnQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGV4cGxpY2l0UmVwZWF0OiB0cnVlLCBsaW5ld2lzZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7a2V5czogXCJnJFwiLCB0eXBlOiBcIm1vdGlvblwiLCBtb3Rpb246IFwibW92ZVRvRW5kT2ZEaXNwbGF5TGluZVwifSxcbiAgICB7a2V5czogXCJnXlwiLCB0eXBlOiBcIm1vdGlvblwiLCBtb3Rpb246IFwibW92ZVRvU3RhcnRPZkRpc3BsYXlMaW5lXCJ9LFxuICAgIHtrZXlzOiBcImcwXCIsIHR5cGU6IFwibW90aW9uXCIsIG1vdGlvbjogXCJtb3ZlVG9TdGFydE9mRGlzcGxheUxpbmVcIn0sXG4gICAgeyBrZXlzOiAnMCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9TdGFydE9mTGluZScgfSxcbiAgICB7IGtleXM6ICdeJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcicgfSxcbiAgICB7IGtleXM6ICcrJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0ZpcnN0Q2hhcjp0cnVlIH19LFxuICAgIHsga2V5czogJy0nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0ZpcnN0Q2hhcjp0cnVlIH19LFxuICAgIHsga2V5czogJ18nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHRvRmlyc3RDaGFyOnRydWUsIHJlcGVhdE9mZnNldDotMSB9fSxcbiAgICB7IGtleXM6ICckJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0VvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJyUnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvTWF0Y2hlZFN5bWJvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2Y8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9DaGFyYWN0ZXInLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRjxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0NoYXJhY3RlcicsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAndDxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUaWxsQ2hhcmFjdGVyJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnVDxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUaWxsQ2hhcmFjdGVyJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICc7JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ3JlcGVhdExhc3RDaGFyYWN0ZXJTZWFyY2gnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnLCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdyZXBlYXRMYXN0Q2hhcmFjdGVyU2VhcmNoJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdcXCc8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdnb1RvTWFyaycsIG1vdGlvbkFyZ3M6IHt0b0p1bXBsaXN0OiB0cnVlLCBsaW5ld2lzZTogdHJ1ZX19LFxuICAgIHsga2V5czogJ2A8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdnb1RvTWFyaycsIG1vdGlvbkFyZ3M6IHt0b0p1bXBsaXN0OiB0cnVlfX0sXG4gICAgeyBrZXlzOiAnXWAnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnanVtcFRvTWFyaycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9IH0sXG4gICAgeyBrZXlzOiAnW2AnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnanVtcFRvTWFyaycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfSB9LFxuICAgIHsga2V5czogJ11cXCcnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnanVtcFRvTWFyaycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgbGluZXdpc2U6IHRydWUgfSB9LFxuICAgIHsga2V5czogJ1tcXCcnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnanVtcFRvTWFyaycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGxpbmV3aXNlOiB0cnVlIH0gfSxcbiAgICAvLyB0aGUgbmV4dCB0d28gYXJlbid0IG1vdGlvbnMgYnV0IG11c3QgY29tZSBiZWZvcmUgbW9yZSBnZW5lcmFsIG1vdGlvbiBkZWNsYXJhdGlvbnNcbiAgICB7IGtleXM6ICddcCcsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdwYXN0ZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogdHJ1ZSwgaXNFZGl0OiB0cnVlLCBtYXRjaEluZGVudDogdHJ1ZX19LFxuICAgIHsga2V5czogJ1twJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Bhc3RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGFmdGVyOiBmYWxzZSwgaXNFZGl0OiB0cnVlLCBtYXRjaEluZGVudDogdHJ1ZX19LFxuICAgIHsga2V5czogJ108Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9TeW1ib2wnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWV9fSxcbiAgICB7IGtleXM6ICdbPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvU3ltYm9sJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgdG9KdW1wbGlzdDogdHJ1ZX19LFxuICAgIHsga2V5czogJ3wnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvQ29sdW1uJ30sXG4gICAgeyBrZXlzOiAnbycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9PdGhlckhpZ2hsaWdodGVkRW5kJywgY29udGV4dDondmlzdWFsJ30sXG4gICAgeyBrZXlzOiAnTycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9PdGhlckhpZ2hsaWdodGVkRW5kJywgbW90aW9uQXJnczoge3NhbWVMaW5lOiB0cnVlfSwgY29udGV4dDondmlzdWFsJ30sXG4gICAgLy8gT3BlcmF0b3JzXG4gICAgeyBrZXlzOiAnZCcsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnZGVsZXRlJyB9LFxuICAgIHsga2V5czogJ3knLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ3lhbmsnIH0sXG4gICAgeyBrZXlzOiAnYycsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlJyB9LFxuICAgIHsga2V5czogJz0nLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2luZGVudEF1dG8nIH0sXG4gICAgeyBrZXlzOiAnPicsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnaW5kZW50Jywgb3BlcmF0b3JBcmdzOiB7IGluZGVudFJpZ2h0OiB0cnVlIH19LFxuICAgIHsga2V5czogJzwnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2luZGVudCcsIG9wZXJhdG9yQXJnczogeyBpbmRlbnRSaWdodDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnZ34nLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnIH0sXG4gICAgeyBrZXlzOiAnZ3UnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBvcGVyYXRvckFyZ3M6IHt0b0xvd2VyOiB0cnVlfSwgaXNFZGl0OiB0cnVlIH0sXG4gICAgeyBrZXlzOiAnZ1UnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBvcGVyYXRvckFyZ3M6IHt0b0xvd2VyOiBmYWxzZX0sIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ24nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZmluZE5leHQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnTicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdmaW5kTmV4dCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ24nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZmluZEFuZFNlbGVjdE5leHRJbmNsdXNpdmUnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ04nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZmluZEFuZFNlbGVjdE5leHRJbmNsdXNpdmUnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIC8vIE9wZXJhdG9yLU1vdGlvbiBkdWFsIGNvbW1hbmRzXG4gICAgeyBrZXlzOiAneCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9LCBvcGVyYXRvck1vdGlvbkFyZ3M6IHsgdmlzdWFsTGluZTogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnWCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfSwgb3BlcmF0b3JNb3Rpb25BcmdzOiB7IHZpc3VhbExpbmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZVRvRW9sJywgbW90aW9uQXJnczogeyBpbmNsdXNpdmU6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJ0QnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG9wZXJhdG9yQXJnczogeyBsaW5ld2lzZTogdHJ1ZSB9LCBjb250ZXh0OiAndmlzdWFsJ30sXG4gICAgeyBrZXlzOiAnWScsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAneWFuaycsIG1vdGlvbjogJ2V4cGFuZFRvTGluZScsIG1vdGlvbkFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJ1knLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ3lhbmsnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ0MnLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2NoYW5nZScsIG1vdGlvbjogJ21vdmVUb0VvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICdDJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2UnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ34nLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBtb3Rpb246ICdtb3ZlQnlDaGFyYWN0ZXJzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH0sIG9wZXJhdG9yQXJnczogeyBzaG91bGRNb3ZlQ3Vyc29yOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICd+JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJzxDLXU+JywgdHlwZTogJ29wZXJhdG9yTW90aW9uJywgb3BlcmF0b3I6ICdkZWxldGUnLCBtb3Rpb246ICdtb3ZlVG9TdGFydE9mTGluZScsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAnPEMtdz4nLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgd29yZEVuZDogZmFsc2UgfSwgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICAvL2lnbm9yZSBDLXcgaW4gbm9ybWFsIG1vZGVcbiAgICB7IGtleXM6ICc8Qy13PicsIHR5cGU6ICdpZGxlJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICAvLyBBY3Rpb25zXG4gICAgeyBrZXlzOiAnPEMtaT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnanVtcExpc3RXYWxrJywgYWN0aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLW8+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2p1bXBMaXN0V2FsaycsIGFjdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnPEMtZT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsJywgYWN0aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy15PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGwnLCBhY3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdhJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2NoYXJBZnRlcicgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdBJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2VvbCcgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdBJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2VuZE9mU2VsZWN0ZWRBcmVhJyB9LCBjb250ZXh0OiAndmlzdWFsJyB9LFxuICAgIHsga2V5czogJ2knLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnaW5wbGFjZScgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdnaScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgaW5zZXJ0QXQ6ICdsYXN0RWRpdCcgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdJJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2ZpcnN0Tm9uQmxhbmsnfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdnSScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgaW5zZXJ0QXQ6ICdib2wnfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdJJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ3N0YXJ0T2ZTZWxlY3RlZEFyZWEnIH0sIGNvbnRleHQ6ICd2aXN1YWwnIH0sXG4gICAgeyBrZXlzOiAnbycsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICduZXdMaW5lQW5kRW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBpbnRlcmxhY2VJbnNlcnRSZXBlYXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgYWZ0ZXI6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdPJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ25ld0xpbmVBbmRFbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGludGVybGFjZUluc2VydFJlcGVhdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICd2JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZVZpc3VhbE1vZGUnIH0sXG4gICAgeyBrZXlzOiAnVicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd0b2dnbGVWaXN1YWxNb2RlJywgYWN0aW9uQXJnczogeyBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy12PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd0b2dnbGVWaXN1YWxNb2RlJywgYWN0aW9uQXJnczogeyBibG9ja3dpc2U6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtcT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAndG9nZ2xlVmlzdWFsTW9kZScsIGFjdGlvbkFyZ3M6IHsgYmxvY2t3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2d2JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Jlc2VsZWN0TGFzdFNlbGVjdGlvbicgfSxcbiAgICB7IGtleXM6ICdKJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2pvaW5MaW5lcycsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ2dKJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2pvaW5MaW5lcycsIGFjdGlvbkFyZ3M6IHsga2VlcFNwYWNlczogdHJ1ZSB9LCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICdwJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Bhc3RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGFmdGVyOiB0cnVlLCBpc0VkaXQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnUCcsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdwYXN0ZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UsIGlzRWRpdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdyPGNoYXJhY3Rlcj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncmVwbGFjZScsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ0A8Y2hhcmFjdGVyPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdyZXBsYXlNYWNybycgfSxcbiAgICB7IGtleXM6ICdxPGNoYXJhY3Rlcj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJNYWNyb1JlY29yZE1vZGUnIH0sXG4gICAgLy8gSGFuZGxlIFJlcGxhY2UtbW9kZSBhcyBhIHNwZWNpYWwgY2FzZSBvZiBpbnNlcnQgbW9kZS5cbiAgICB7IGtleXM6ICdSJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyByZXBsYWNlOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICdSJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2UnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUsIGZ1bGxMaW5lOiB0cnVlIH0sIGNvbnRleHQ6ICd2aXN1YWwnLCBleGl0VmlzdWFsQmxvY2s6IHRydWV9LFxuICAgIHsga2V5czogJ3UnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAndW5kbycsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAndScsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlQ2FzZScsIG9wZXJhdG9yQXJnczoge3RvTG93ZXI6IHRydWV9LCBjb250ZXh0OiAndmlzdWFsJywgaXNFZGl0OiB0cnVlIH0sXG4gICAgeyBrZXlzOiAnVScsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlQ2FzZScsIG9wZXJhdG9yQXJnczoge3RvTG93ZXI6IGZhbHNlfSwgY29udGV4dDogJ3Zpc3VhbCcsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJzxDLXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3JlZG8nIH0sXG4gICAgeyBrZXlzOiAnbTxjaGFyYWN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3NldE1hcmsnIH0sXG4gICAgeyBrZXlzOiAnXCI8Y2hhcmFjdGVyPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzZXRSZWdpc3RlcicgfSxcbiAgICB7IGtleXM6ICd6eicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICdjZW50ZXInIH19LFxuICAgIHsga2V5czogJ3ouJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ2NlbnRlcicgfSwgbW90aW9uOiAnbW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyJyB9LFxuICAgIHsga2V5czogJ3p0JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ3RvcCcgfX0sXG4gICAgeyBrZXlzOiAnejxDUj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAndG9wJyB9LCBtb3Rpb246ICdtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXInIH0sXG4gICAgeyBrZXlzOiAnei0nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAnYm90dG9tJyB9fSxcbiAgICB7IGtleXM6ICd6YicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICdib3R0b20nIH0sIG1vdGlvbjogJ21vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcicgfSxcbiAgICB7IGtleXM6ICcuJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3JlcGVhdExhc3RFZGl0JyB9LFxuICAgIHsga2V5czogJzxDLWE+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luY3JlbWVudE51bWJlclRva2VuJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7aW5jcmVhc2U6IHRydWUsIGJhY2t0cmFjazogZmFsc2V9fSxcbiAgICB7IGtleXM6ICc8Qy14PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdpbmNyZW1lbnROdW1iZXJUb2tlbicsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczoge2luY3JlYXNlOiBmYWxzZSwgYmFja3RyYWNrOiBmYWxzZX19LFxuICAgIHsga2V5czogJzxDLXQ+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luZGVudCcsIGFjdGlvbkFyZ3M6IHsgaW5kZW50UmlnaHQ6IHRydWUgfSwgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICB7IGtleXM6ICc8Qy1kPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdpbmRlbnQnLCBhY3Rpb25BcmdzOiB7IGluZGVudFJpZ2h0OiBmYWxzZSB9LCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIC8vIFRleHQgb2JqZWN0IG1vdGlvbnNcbiAgICB7IGtleXM6ICdhPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAndGV4dE9iamVjdE1hbmlwdWxhdGlvbicgfSxcbiAgICB7IGtleXM6ICdpPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAndGV4dE9iamVjdE1hbmlwdWxhdGlvbicsIG1vdGlvbkFyZ3M6IHsgdGV4dE9iamVjdElubmVyOiB0cnVlIH19LFxuICAgIC8vIFNlYXJjaFxuICAgIHsga2V5czogJy8nLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiB0cnVlLCBxdWVyeVNyYzogJ3Byb21wdCcsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPycsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBxdWVyeVNyYzogJ3Byb21wdCcsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnKicsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IHRydWUsIHF1ZXJ5U3JjOiAnd29yZFVuZGVyQ3Vyc29yJywgd2hvbGVXb3JkT25seTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICcjJywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHF1ZXJ5U3JjOiAnd29yZFVuZGVyQ3Vyc29yJywgd2hvbGVXb3JkT25seTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnKicsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IHRydWUsIHF1ZXJ5U3JjOiAnd29yZFVuZGVyQ3Vyc29yJywgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnIycsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBxdWVyeVNyYzogJ3dvcmRVbmRlckN1cnNvcicsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgLy8gRXggY29tbWFuZFxuICAgIHsga2V5czogJzonLCB0eXBlOiAnZXgnIH1cbiAgXTtcbiAgdmFyIGRlZmF1bHRLZXltYXBMZW5ndGggPSBkZWZhdWx0S2V5bWFwLmxlbmd0aDtcblxuICAvKipcbiAgICogRXggY29tbWFuZHNcbiAgICogQ2FyZSBtdXN0IGJlIHRha2VuIHdoZW4gYWRkaW5nIHRvIHRoZSBkZWZhdWx0IEV4IGNvbW1hbmQgbWFwLiBGb3IgYW55XG4gICAqIHBhaXIgb2YgY29tbWFuZHMgdGhhdCBoYXZlIGEgc2hhcmVkIHByZWZpeCwgYXQgbGVhc3Qgb25lIG9mIHRoZWlyXG4gICAqIHNob3J0TmFtZXMgbXVzdCBub3QgbWF0Y2ggdGhlIHByZWZpeCBvZiB0aGUgb3RoZXIgY29tbWFuZC5cbiAgICovXG4gIHZhciBkZWZhdWx0RXhDb21tYW5kTWFwID0gW1xuICAgIHsgbmFtZTogJ2NvbG9yc2NoZW1lJywgc2hvcnROYW1lOiAnY29sbycgfSxcbiAgICB7IG5hbWU6ICdtYXAnIH0sXG4gICAgeyBuYW1lOiAnaW1hcCcsIHNob3J0TmFtZTogJ2ltJyB9LFxuICAgIHsgbmFtZTogJ25tYXAnLCBzaG9ydE5hbWU6ICdubScgfSxcbiAgICB7IG5hbWU6ICd2bWFwJywgc2hvcnROYW1lOiAndm0nIH0sXG4gICAgeyBuYW1lOiAndW5tYXAnIH0sXG4gICAgeyBuYW1lOiAnd3JpdGUnLCBzaG9ydE5hbWU6ICd3JyB9LFxuICAgIHsgbmFtZTogJ3VuZG8nLCBzaG9ydE5hbWU6ICd1JyB9LFxuICAgIHsgbmFtZTogJ3JlZG8nLCBzaG9ydE5hbWU6ICdyZWQnIH0sXG4gICAgeyBuYW1lOiAnc2V0Jywgc2hvcnROYW1lOiAnc2UnIH0sXG4gICAgeyBuYW1lOiAnc2V0bG9jYWwnLCBzaG9ydE5hbWU6ICdzZXRsJyB9LFxuICAgIHsgbmFtZTogJ3NldGdsb2JhbCcsIHNob3J0TmFtZTogJ3NldGcnIH0sXG4gICAgeyBuYW1lOiAnc29ydCcsIHNob3J0TmFtZTogJ3NvcicgfSxcbiAgICB7IG5hbWU6ICdzdWJzdGl0dXRlJywgc2hvcnROYW1lOiAncycsIHBvc3NpYmx5QXN5bmM6IHRydWUgfSxcbiAgICB7IG5hbWU6ICdub2hsc2VhcmNoJywgc2hvcnROYW1lOiAnbm9oJyB9LFxuICAgIHsgbmFtZTogJ3lhbmsnLCBzaG9ydE5hbWU6ICd5JyB9LFxuICAgIHsgbmFtZTogJ2RlbG1hcmtzJywgc2hvcnROYW1lOiAnZGVsbScgfSxcbiAgICB7IG5hbWU6ICdyZWdpc3RlcnMnLCBzaG9ydE5hbWU6ICdyZWcnLCBleGNsdWRlRnJvbUNvbW1hbmRIaXN0b3J5OiB0cnVlIH0sXG4gICAgeyBuYW1lOiAndmdsb2JhbCcsIHNob3J0TmFtZTogJ3YnIH0sXG4gICAgeyBuYW1lOiAnZ2xvYmFsJywgc2hvcnROYW1lOiAnZycgfVxuICBdO1xuXG4gIHZhciBWaW0gPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlbnRlclZpbU1vZGUoY20pIHtcbiAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgdHJ1ZSk7XG4gICAgICBjbS5zZXRPcHRpb24oJ3Nob3dDdXJzb3JXaGVuU2VsZWN0aW5nJywgZmFsc2UpO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gICAgICBjbS5vbignY3Vyc29yQWN0aXZpdHknLCBvbkN1cnNvckFjdGl2aXR5KTtcbiAgICAgIG1heWJlSW5pdFZpbVN0YXRlKGNtKTtcbiAgICAgIENvZGVNaXJyb3Iub24oY20uZ2V0SW5wdXRGaWVsZCgpLCAncGFzdGUnLCBnZXRPblBhc3RlRm4oY20pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWF2ZVZpbU1vZGUoY20pIHtcbiAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgZmFsc2UpO1xuICAgICAgY20ub2ZmKCdjdXJzb3JBY3Rpdml0eScsIG9uQ3Vyc29yQWN0aXZpdHkpO1xuICAgICAgQ29kZU1pcnJvci5vZmYoY20uZ2V0SW5wdXRGaWVsZCgpLCAncGFzdGUnLCBnZXRPblBhc3RlRm4oY20pKTtcbiAgICAgIGNtLnN0YXRlLnZpbSA9IG51bGw7XG4gICAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCkgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGFjaFZpbU1hcChjbSwgbmV4dCkge1xuICAgICAgaWYgKHRoaXMgPT0gQ29kZU1pcnJvci5rZXlNYXAudmltKSB7XG4gICAgICAgIGNtLm9wdGlvbnMuJGN1c3RvbUN1cnNvciA9IG51bGw7XG4gICAgICAgIENvZGVNaXJyb3Iucm1DbGFzcyhjbS5nZXRXcmFwcGVyRWxlbWVudCgpLCBcImNtLWZhdC1jdXJzb3JcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmV4dCB8fCBuZXh0LmF0dGFjaCAhPSBhdHRhY2hWaW1NYXApXG4gICAgICAgIGxlYXZlVmltTW9kZShjbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFZpbU1hcChjbSwgcHJldikge1xuICAgICAgaWYgKHRoaXMgPT0gQ29kZU1pcnJvci5rZXlNYXAudmltKSB7XG4gICAgICAgIGlmIChjbS5jdXJPcCkgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGNtLm9wdGlvbnMuJGN1c3RvbUN1cnNvciA9IHRyYW5zZm9ybUN1cnNvcjtcbiAgICAgICAgQ29kZU1pcnJvci5hZGRDbGFzcyhjbS5nZXRXcmFwcGVyRWxlbWVudCgpLCBcImNtLWZhdC1jdXJzb3JcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldiB8fCBwcmV2LmF0dGFjaCAhPSBhdHRhY2hWaW1NYXApXG4gICAgICAgIGVudGVyVmltTW9kZShjbSk7XG4gICAgfVxuXG4gICAgLy8gRGVwcmVjYXRlZCwgc2ltcGx5IHNldHRpbmcgdGhlIGtleW1hcCB3b3JrcyBhZ2Fpbi5cbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbigndmltTW9kZScsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsLCBwcmV2KSB7XG4gICAgICBpZiAodmFsICYmIGNtLmdldE9wdGlvbihcImtleU1hcFwiKSAhPSBcInZpbVwiKVxuICAgICAgICBjbS5zZXRPcHRpb24oXCJrZXlNYXBcIiwgXCJ2aW1cIik7XG4gICAgICBlbHNlIGlmICghdmFsICYmIHByZXYgIT0gQ29kZU1pcnJvci5Jbml0ICYmIC9edmltLy50ZXN0KGNtLmdldE9wdGlvbihcImtleU1hcFwiKSkpXG4gICAgICAgIGNtLnNldE9wdGlvbihcImtleU1hcFwiLCBcImRlZmF1bHRcIik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjbUtleShrZXksIGNtKSB7XG4gICAgICBpZiAoIWNtKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICh0aGlzW2tleV0pIHsgcmV0dXJuIHRoaXNba2V5XTsgfVxuICAgICAgdmFyIHZpbUtleSA9IGNtS2V5VG9WaW1LZXkoa2V5KTtcbiAgICAgIGlmICghdmltS2V5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjbWQgPSB2aW1BcGkuZmluZEtleShjbSwgdmltS2V5KTtcbiAgICAgIGlmICh0eXBlb2YgY21kID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sICd2aW0ta2V5cHJlc3MnLCB2aW1LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNtZDtcbiAgICB9XG5cbiAgICB2YXIgbW9kaWZpZXJzID0ge1NoaWZ0OidTJyxDdHJsOidDJyxBbHQ6J0EnLENtZDonRCcsTW9kOidBJyxDYXBzTG9jazonJ307XG4gICAgdmFyIHNwZWNpYWxLZXlzID0ge0VudGVyOidDUicsQmFja3NwYWNlOidCUycsRGVsZXRlOidEZWwnLEluc2VydDonSW5zJ307XG4gICAgZnVuY3Rpb24gY21LZXlUb1ZpbUtleShrZXkpIHtcbiAgICAgIGlmIChrZXkuY2hhckF0KDApID09ICdcXCcnKSB7XG4gICAgICAgIC8vIEtleXByZXNzIGNoYXJhY3RlciBiaW5kaW5nIG9mIGZvcm1hdCBcIidhJ1wiXG4gICAgICAgIHJldHVybiBrZXkuY2hhckF0KDEpO1xuICAgICAgfVxuICAgICAgdmFyIHBpZWNlcyA9IGtleS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgICB2YXIgbGFzdFBpZWNlID0gcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwaWVjZXMubGVuZ3RoID09IDEgJiYgcGllY2VzWzBdLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIE5vLW1vZGlmaWVyIGJpbmRpbmdzIHVzZSBsaXRlcmFsIGNoYXJhY3RlciBiaW5kaW5ncyBhYm92ZS4gU2tpcC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwaWVjZXMubGVuZ3RoID09IDIgJiYgcGllY2VzWzBdID09ICdTaGlmdCcgJiYgbGFzdFBpZWNlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIElnbm9yZSBTaGlmdCtjaGFyIGJpbmRpbmdzIGFzIHRoZXkgc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGl0ZXJhbCBjaGFyYWN0ZXIuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IHBpZWNlc1tpXTtcbiAgICAgICAgaWYgKHBpZWNlIGluIG1vZGlmaWVycykgeyBwaWVjZXNbaV0gPSBtb2RpZmllcnNbcGllY2VdOyB9XG4gICAgICAgIGVsc2UgeyBoYXNDaGFyYWN0ZXIgPSB0cnVlOyB9XG4gICAgICAgIGlmIChwaWVjZSBpbiBzcGVjaWFsS2V5cykgeyBwaWVjZXNbaV0gPSBzcGVjaWFsS2V5c1twaWVjZV07IH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIFZpbSBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVyIG9ubHkga2V5cy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogQ3VycmVudCBiaW5kaW5ncyBleHBlY3QgdGhlIGNoYXJhY3RlciB0byBiZSBsb3dlciBjYXNlLCBidXRcbiAgICAgIC8vIGl0IGxvb2tzIGxpa2UgdmltIGtleSBub3RhdGlvbiB1c2VzIHVwcGVyIGNhc2UuXG4gICAgICBpZiAoaXNVcHBlckNhc2UobGFzdFBpZWNlKSkge1xuICAgICAgICBwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdID0gbGFzdFBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwnICsgcGllY2VzLmpvaW4oJy0nKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPblBhc3RlRm4oY20pIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICBpZiAoIXZpbS5vblBhc3RlRm4pIHtcbiAgICAgICAgdmltLm9uUGFzdGVGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdmltLmluc2VydE1vZGUpIHtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihvZmZzZXRDdXJzb3IoY20uZ2V0Q3Vyc29yKCksIDAsIDEpKTtcbiAgICAgICAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7fSwgdmltKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmltLm9uUGFzdGVGbjtcbiAgICB9XG5cbiAgICB2YXIgbnVtYmVyUmVnZXggPSAvW1xcZF0vO1xuICAgIHZhciB3b3JkQ2hhclRlc3QgPSBbQ29kZU1pcnJvci5pc1dvcmRDaGFyLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIGNoICYmICFDb2RlTWlycm9yLmlzV29yZENoYXIoY2gpICYmICEvXFxzLy50ZXN0KGNoKTtcbiAgICB9XSwgYmlnV29yZENoYXJUZXN0ID0gW2Z1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gL1xcUy8udGVzdChjaCk7XG4gICAgfV07XG4gICAgZnVuY3Rpb24gbWFrZUtleVJhbmdlKHN0YXJ0LCBzaXplKSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBzaXplOyBpKyspIHtcbiAgICAgICAga2V5cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHZhciB1cHBlckNhc2VBbHBoYWJldCA9IG1ha2VLZXlSYW5nZSg2NSwgMjYpO1xuICAgIHZhciBsb3dlckNhc2VBbHBoYWJldCA9IG1ha2VLZXlSYW5nZSg5NywgMjYpO1xuICAgIHZhciBudW1iZXJzID0gbWFrZUtleVJhbmdlKDQ4LCAxMCk7XG4gICAgdmFyIHZhbGlkTWFya3MgPSBbXS5jb25jYXQodXBwZXJDYXNlQWxwaGFiZXQsIGxvd2VyQ2FzZUFscGhhYmV0LCBudW1iZXJzLCBbJzwnLCAnPiddKTtcbiAgICB2YXIgdmFsaWRSZWdpc3RlcnMgPSBbXS5jb25jYXQodXBwZXJDYXNlQWxwaGFiZXQsIGxvd2VyQ2FzZUFscGhhYmV0LCBudW1iZXJzLCBbJy0nLCAnXCInLCAnLicsICc6JywgJ18nLCAnLyddKTtcbiAgICB2YXIgdXBwZXJDYXNlQ2hhcnM7XG4gICAgdHJ5IHsgdXBwZXJDYXNlQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxccHtMdX1dJFwiLCBcInVcIik7IH1cbiAgICBjYXRjaCAoXykgeyB1cHBlckNhc2VDaGFycyA9IC9eW0EtWl0kLzsgfVxuXG4gICAgZnVuY3Rpb24gaXNMaW5lKGNtLCBsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZSA+PSBjbS5maXJzdExpbmUoKSAmJiBsaW5lIDw9IGNtLmxhc3RMaW5lKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTG93ZXJDYXNlKGspIHtcbiAgICAgIHJldHVybiAoL15bYS16XSQvKS50ZXN0KGspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc01hdGNoYWJsZVN5bWJvbChrKSB7XG4gICAgICByZXR1cm4gJygpW117fScuaW5kZXhPZihrKSAhPSAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaykge1xuICAgICAgcmV0dXJuIG51bWJlclJlZ2V4LnRlc3Qoayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVXBwZXJDYXNlKGspIHtcbiAgICAgIHJldHVybiB1cHBlckNhc2VDaGFycy50ZXN0KGspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2VTdHJpbmcoaykge1xuICAgICAgcmV0dXJuICgvXlxccyokLykudGVzdChrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbmRPZlNlbnRlbmNlU3ltYm9sKGspIHtcbiAgICAgIHJldHVybiAnLj8hJy5pbmRleE9mKGspICE9IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbkFycmF5KHZhbCwgYXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09IHZhbCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZpbmVPcHRpb24obmFtZSwgZGVmYXVsdFZhbHVlLCB0eXBlLCBhbGlhc2VzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFjYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBFcnJvcignZGVmYXVsdFZhbHVlIGlzIHJlcXVpcmVkIHVubGVzcyBjYWxsYmFjayBpcyBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7IHR5cGUgPSAnc3RyaW5nJzsgfVxuICAgICAgb3B0aW9uc1tuYW1lXSA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfTtcbiAgICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxpYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9wdGlvbnNbYWxpYXNlc1tpXV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHNldE9wdGlvbihuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgY20sIGNmZykge1xuICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICBjZmcgPSBjZmcgfHwge307XG4gICAgICB2YXIgc2NvcGUgPSBjZmcuc2NvcGU7XG4gICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIG9wdGlvbjogJyArIG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi50eXBlID09ICdib29sZWFuJykge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiAnICsgbmFtZSArICc9JyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBCb29sZWFuIG9wdGlvbnMgYXJlIHNldCB0byB0cnVlIGlmIHZhbHVlIGlzIG5vdCBkZWZpbmVkLlxuICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5jYWxsYmFjaykge1xuICAgICAgICBpZiAoc2NvcGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgICBvcHRpb24uY2FsbGJhY2sodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlICE9PSAnZ2xvYmFsJyAmJiBjbSkge1xuICAgICAgICAgIG9wdGlvbi5jYWxsYmFjayh2YWx1ZSwgY20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2NvcGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgICBvcHRpb24udmFsdWUgPSBvcHRpb24udHlwZSA9PSAnYm9vbGVhbicgPyAhIXZhbHVlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlICE9PSAnZ2xvYmFsJyAmJiBjbSkge1xuICAgICAgICAgIGNtLnN0YXRlLnZpbS5vcHRpb25zW25hbWVdID0ge3ZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSwgY20sIGNmZykge1xuICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICBjZmcgPSBjZmcgfHwge307XG4gICAgICB2YXIgc2NvcGUgPSBjZmcuc2NvcGU7XG4gICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIG9wdGlvbjogJyArIG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5jYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9jYWwgPSBjbSAmJiBvcHRpb24uY2FsbGJhY2sodW5kZWZpbmVkLCBjbSk7XG4gICAgICAgIGlmIChzY29wZSAhPT0gJ2dsb2JhbCcgJiYgbG9jYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBsb2NhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxvY2FsID0gKHNjb3BlICE9PSAnZ2xvYmFsJykgJiYgKGNtICYmIGNtLnN0YXRlLnZpbS5vcHRpb25zW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIChsb2NhbCB8fCAoc2NvcGUgIT09ICdsb2NhbCcpICYmIG9wdGlvbiB8fCB7fSkudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmaW5lT3B0aW9uKCdmaWxldHlwZScsIHVuZGVmaW5lZCwgJ3N0cmluZycsIFsnZnQnXSwgZnVuY3Rpb24obmFtZSwgY20pIHtcbiAgICAgIC8vIE9wdGlvbiBpcyBsb2NhbC4gRG8gbm90aGluZyBmb3IgZ2xvYmFsLlxuICAgICAgaWYgKGNtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlICdmaWxldHlwZScgb3B0aW9uIHByb3hpZXMgdG8gdGhlIENvZGVNaXJyb3IgJ21vZGUnIG9wdGlvbi5cbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBjbS5nZXRPcHRpb24oJ21vZGUnKTtcbiAgICAgICAgcmV0dXJuIG1vZGUgPT0gJ251bGwnID8gJycgOiBtb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1vZGUgPSBuYW1lID09ICcnID8gJ251bGwnIDogbmFtZTtcbiAgICAgICAgY20uc2V0T3B0aW9uKCdtb2RlJywgbW9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlQ2lyY3VsYXJKdW1wTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNpemUgPSAxMDA7XG4gICAgICB2YXIgcG9pbnRlciA9IC0xO1xuICAgICAgdmFyIGhlYWQgPSAwO1xuICAgICAgdmFyIHRhaWwgPSAwO1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGZ1bmN0aW9uIGFkZChjbSwgb2xkQ3VyLCBuZXdDdXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwb2ludGVyICUgc2l6ZTtcbiAgICAgICAgdmFyIGN1ck1hcmsgPSBidWZmZXJbY3VycmVudF07XG4gICAgICAgIGZ1bmN0aW9uIHVzZU5leHRTbG90KGN1cnNvcikge1xuICAgICAgICAgIHZhciBuZXh0ID0gKytwb2ludGVyICUgc2l6ZTtcbiAgICAgICAgICB2YXIgdHJhc2hNYXJrID0gYnVmZmVyW25leHRdO1xuICAgICAgICAgIGlmICh0cmFzaE1hcmspIHtcbiAgICAgICAgICAgIHRyYXNoTWFyay5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXJbbmV4dF0gPSBjbS5zZXRCb29rbWFyayhjdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJNYXJrKSB7XG4gICAgICAgICAgdmFyIG1hcmtQb3MgPSBjdXJNYXJrLmZpbmQoKTtcbiAgICAgICAgICAvLyBhdm9pZCByZWNvcmRpbmcgcmVkdW5kYW50IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgIGlmIChtYXJrUG9zICYmICFjdXJzb3JFcXVhbChtYXJrUG9zLCBvbGRDdXIpKSB7XG4gICAgICAgICAgICB1c2VOZXh0U2xvdChvbGRDdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VOZXh0U2xvdChvbGRDdXIpO1xuICAgICAgICB9XG4gICAgICAgIHVzZU5leHRTbG90KG5ld0N1cik7XG4gICAgICAgIGhlYWQgPSBwb2ludGVyO1xuICAgICAgICB0YWlsID0gcG9pbnRlciAtIHNpemUgKyAxO1xuICAgICAgICBpZiAodGFpbCA8IDApIHtcbiAgICAgICAgICB0YWlsID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZShjbSwgb2Zmc2V0KSB7XG4gICAgICAgIHBvaW50ZXIgKz0gb2Zmc2V0O1xuICAgICAgICBpZiAocG9pbnRlciA+IGhlYWQpIHtcbiAgICAgICAgICBwb2ludGVyID0gaGVhZDtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyIDwgdGFpbCkge1xuICAgICAgICAgIHBvaW50ZXIgPSB0YWlsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrID0gYnVmZmVyWyhzaXplICsgcG9pbnRlcikgJSBzaXplXTtcbiAgICAgICAgLy8gc2tpcCBtYXJrcyB0aGF0IGFyZSB0ZW1wb3JhcmlseSByZW1vdmVkIGZyb20gdGV4dCBidWZmZXJcbiAgICAgICAgaWYgKG1hcmsgJiYgIW1hcmsuZmluZCgpKSB7XG4gICAgICAgICAgdmFyIGluYyA9IG9mZnNldCA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgdmFyIG5ld0N1cjtcbiAgICAgICAgICB2YXIgb2xkQ3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9pbnRlciArPSBpbmM7XG4gICAgICAgICAgICBtYXJrID0gYnVmZmVyWyhzaXplICsgcG9pbnRlcikgJSBzaXplXTtcbiAgICAgICAgICAgIC8vIHNraXAgbWFya3MgdGhhdCBhcmUgdGhlIHNhbWUgYXMgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKG1hcmsgJiZcbiAgICAgICAgICAgICAgICAobmV3Q3VyID0gbWFyay5maW5kKCkpICYmXG4gICAgICAgICAgICAgICAgIWN1cnNvckVxdWFsKG9sZEN1ciwgbmV3Q3VyKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChwb2ludGVyIDwgaGVhZCAmJiBwb2ludGVyID4gdGFpbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcms7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmaW5kKGNtLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIG9sZFBvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgICB2YXIgbWFyayA9IG1vdmUoY20sIG9mZnNldCk7XG4gICAgICAgIHBvaW50ZXIgPSBvbGRQb2ludGVyO1xuICAgICAgICByZXR1cm4gbWFyayAmJiBtYXJrLmZpbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhY2hlZEN1cnNvcjogdW5kZWZpbmVkLCAvL3VzZWQgZm9yICMgYW5kICoganVtcHNcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICAgIG1vdmU6IG1vdmVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHRvIHRyYWNrIHRoZSBjaGFuZ2VzIGFzc29jaWF0ZWQgaW5zZXJ0IG1vZGUuICBJdFxuICAgIC8vIGNsb25lcyB0aGUgb2JqZWN0IHRoYXQgaXMgcGFzc2VkIGluLCBvciBjcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBvbmUgaWZcbiAgICAvLyBub25lIGlzIHByb3ZpZGVkLlxuICAgIHZhciBjcmVhdGVJbnNlcnRNb2RlQ2hhbmdlcyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIC8vIENvcHkgY29uc3RydWN0aW9uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlczogYy5jaGFuZ2VzLFxuICAgICAgICAgIGV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlOiBjLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBDaGFuZ2UgbGlzdFxuICAgICAgICBjaGFuZ2VzOiBbXSxcbiAgICAgICAgLy8gU2V0IHRvIHRydWUgb24gY2hhbmdlLCBmYWxzZSBvbiBjdXJzb3JBY3Rpdml0eS5cbiAgICAgICAgZXhwZWN0Q3Vyc29yQWN0aXZpdHlGb3JDaGFuZ2U6IGZhbHNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBNYWNyb01vZGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMubGF0ZXN0UmVnaXN0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1JlY29yZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXBsYXlTZWFyY2hRdWVyaWVzID0gW107XG4gICAgICB0aGlzLm9uUmVjb3JkaW5nRG9uZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdEluc2VydE1vZGVDaGFuZ2VzID0gY3JlYXRlSW5zZXJ0TW9kZUNoYW5nZXMoKTtcbiAgICB9XG4gICAgTWFjcm9Nb2RlU3RhdGUucHJvdG90eXBlID0ge1xuICAgICAgZXhpdE1hY3JvUmVjb3JkTW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgICBpZiAobWFjcm9Nb2RlU3RhdGUub25SZWNvcmRpbmdEb25lKSB7XG4gICAgICAgICAgbWFjcm9Nb2RlU3RhdGUub25SZWNvcmRpbmdEb25lKCk7IC8vIGNsb3NlIGRpYWxvZ1xuICAgICAgICB9XG4gICAgICAgIG1hY3JvTW9kZVN0YXRlLm9uUmVjb3JkaW5nRG9uZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlbnRlck1hY3JvUmVjb3JkTW9kZTogZnVuY3Rpb24oY20sIHJlZ2lzdGVyTmFtZSkge1xuICAgICAgICB2YXIgcmVnaXN0ZXIgPVxuICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSk7XG4gICAgICAgIGlmIChyZWdpc3Rlcikge1xuICAgICAgICAgIHJlZ2lzdGVyLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5sYXRlc3RSZWdpc3RlciA9IHJlZ2lzdGVyTmFtZTtcbiAgICAgICAgICBpZiAoY20ub3BlbkRpYWxvZykge1xuICAgICAgICAgICAgdGhpcy5vblJlY29yZGluZ0RvbmUgPSBjbS5vcGVuRGlhbG9nKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcocmVjb3JkaW5nKVsnK3JlZ2lzdGVyTmFtZSsnXScpLCBudWxsLCB7Ym90dG9tOnRydWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pc1JlY29yZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVJbml0VmltU3RhdGUoY20pIHtcbiAgICAgIGlmICghY20uc3RhdGUudmltKSB7XG4gICAgICAgIC8vIFN0b3JlIGluc3RhbmNlIHN0YXRlIGluIHRoZSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICAgICAgY20uc3RhdGUudmltID0ge1xuICAgICAgICAgIGlucHV0U3RhdGU6IG5ldyBJbnB1dFN0YXRlKCksXG4gICAgICAgICAgLy8gVmltJ3MgaW5wdXQgc3RhdGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGxhc3QgZWRpdCwgdXNlZCB0byByZXBlYXRcbiAgICAgICAgICAvLyBtb3Rpb25zIGFuZCBvcGVyYXRvcnMgd2l0aCAnLicuXG4gICAgICAgICAgbGFzdEVkaXRJbnB1dFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgLy8gVmltJ3MgYWN0aW9uIGNvbW1hbmQgYmVmb3JlIHRoZSBsYXN0IGVkaXQsIHVzZWQgdG8gcmVwZWF0IGFjdGlvbnNcbiAgICAgICAgICAvLyB3aXRoICcuJyBhbmQgaW5zZXJ0IG1vZGUgcmVwZWF0LlxuICAgICAgICAgIGxhc3RFZGl0QWN0aW9uQ29tbWFuZDogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIFdoZW4gdXNpbmcgamsgZm9yIG5hdmlnYXRpb24sIGlmIHlvdSBtb3ZlIGZyb20gYSBsb25nZXIgbGluZSB0byBhXG4gICAgICAgICAgLy8gc2hvcnRlciBsaW5lLCB0aGUgY3Vyc29yIG1heSBjbGlwIHRvIHRoZSBlbmQgb2YgdGhlIHNob3J0ZXIgbGluZS5cbiAgICAgICAgICAvLyBJZiBqIGlzIHByZXNzZWQgYWdhaW4gYW5kIGN1cnNvciBnb2VzIHRvIHRoZSBuZXh0IGxpbmUsIHRoZVxuICAgICAgICAgIC8vIGN1cnNvciBzaG91bGQgZ28gYmFjayB0byBpdHMgaG9yaXpvbnRhbCBwb3NpdGlvbiBvbiB0aGUgbG9uZ2VyXG4gICAgICAgICAgLy8gbGluZSBpZiBpdCBjYW4uIFRoaXMgaXMgdG8ga2VlcCB0cmFjayBvZiB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgICAgICBsYXN0SFBvczogLTEsXG4gICAgICAgICAgLy8gRG9pbmcgdGhlIHNhbWUgd2l0aCBzY3JlZW4tcG9zaXRpb24gZm9yIGdqL2drXG4gICAgICAgICAgbGFzdEhTUG9zOiAtMSxcbiAgICAgICAgICAvLyBUaGUgbGFzdCBtb3Rpb24gY29tbWFuZCBydW4uIENsZWFyZWQgaWYgYSBub24tbW90aW9uIGNvbW1hbmQgZ2V0c1xuICAgICAgICAgIC8vIGV4ZWN1dGVkIGluIGJldHdlZW4uXG4gICAgICAgICAgbGFzdE1vdGlvbjogbnVsbCxcbiAgICAgICAgICBtYXJrczoge30sXG4gICAgICAgICAgaW5zZXJ0TW9kZTogZmFsc2UsXG4gICAgICAgICAgLy8gUmVwZWF0IGNvdW50IGZvciBjaGFuZ2VzIG1hZGUgaW4gaW5zZXJ0IG1vZGUsIHRyaWdnZXJlZCBieSBrZXlcbiAgICAgICAgICAvLyBzZXF1ZW5jZXMgbGlrZSAzLGkuIE9ubHkgZXhpc3RzIHdoZW4gaW5zZXJ0TW9kZSBpcyB0cnVlLlxuICAgICAgICAgIGluc2VydE1vZGVSZXBlYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB2aXN1YWxNb2RlOiBmYWxzZSxcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gdmlzdWFsIGxpbmUgbW9kZS4gTm8gZWZmZWN0IGlmIHZpc3VhbE1vZGUgaXMgZmFsc2UuXG4gICAgICAgICAgdmlzdWFsTGluZTogZmFsc2UsXG4gICAgICAgICAgdmlzdWFsQmxvY2s6IGZhbHNlLFxuICAgICAgICAgIGxhc3RTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgbGFzdFBhc3RlZFRleHQ6IG51bGwsXG4gICAgICAgICAgc2VsOiB7fSxcbiAgICAgICAgICAvLyBCdWZmZXItbG9jYWwvd2luZG93LWxvY2FsIHZhbHVlcyBvZiB2aW0gb3B0aW9ucy5cbiAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNtLnN0YXRlLnZpbTtcbiAgICB9XG4gICAgdmFyIHZpbUdsb2JhbFN0YXRlO1xuICAgIGZ1bmN0aW9uIHJlc2V0VmltR2xvYmFsU3RhdGUoKSB7XG4gICAgICB2aW1HbG9iYWxTdGF0ZSA9IHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LlxuICAgICAgICBzZWFyY2hRdWVyeTogbnVsbCxcbiAgICAgICAgLy8gV2hldGhlciB3ZSBhcmUgc2VhcmNoaW5nIGJhY2t3YXJkcy5cbiAgICAgICAgc2VhcmNoSXNSZXZlcnNlZDogZmFsc2UsXG4gICAgICAgIC8vIFJlcGxhY2UgcGFydCBvZiB0aGUgbGFzdCBzdWJzdGl0dXRlZCBwYXR0ZXJuXG4gICAgICAgIGxhc3RTdWJzdGl0dXRlUmVwbGFjZVBhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAganVtcExpc3Q6IGNyZWF0ZUNpcmN1bGFySnVtcExpc3QoKSxcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGU6IG5ldyBNYWNyb01vZGVTdGF0ZSxcbiAgICAgICAgLy8gUmVjb3JkaW5nIGxhdGVzdCBmLCB0LCBGIG9yIFQgbW90aW9uIGNvbW1hbmQuXG4gICAgICAgIGxhc3RDaGFyYWN0ZXJTZWFyY2g6IHtpbmNyZW1lbnQ6MCwgZm9yd2FyZDp0cnVlLCBzZWxlY3RlZENoYXJhY3RlcjonJ30sXG4gICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlcjogbmV3IFJlZ2lzdGVyQ29udHJvbGxlcih7fSksXG4gICAgICAgIC8vIHNlYXJjaCBoaXN0b3J5IGJ1ZmZlclxuICAgICAgICBzZWFyY2hIaXN0b3J5Q29udHJvbGxlcjogbmV3IEhpc3RvcnlDb250cm9sbGVyKCksXG4gICAgICAgIC8vIGV4IENvbW1hbmQgaGlzdG9yeSBidWZmZXJcbiAgICAgICAgZXhDb21tYW5kSGlzdG9yeUNvbnRyb2xsZXIgOiBuZXcgSGlzdG9yeUNvbnRyb2xsZXIoKVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdEluc2VydE1vZGVLZXlUaW1lcjtcbiAgICB2YXIgdmltQXBpPSB7XG4gICAgICBidWlsZEtleU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE86IENvbnZlcnQga2V5bWFwIGludG8gZGljdGlvbmFyeSBmb3JtYXQgZm9yIGZhc3QgbG9va3VwLlxuICAgICAgfSxcbiAgICAgIC8vIFRlc3RpbmcgaG9vaywgdGhvdWdoIGl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBleHBvc2UgdGhlIHJlZ2lzdGVyXG4gICAgICAvLyBjb250cm9sbGVyIGFueXdheS5cbiAgICAgIGdldFJlZ2lzdGVyQ29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXI7XG4gICAgICB9LFxuICAgICAgLy8gVGVzdGluZyBob29rLlxuICAgICAgcmVzZXRWaW1HbG9iYWxTdGF0ZV86IHJlc2V0VmltR2xvYmFsU3RhdGUsXG5cbiAgICAgIC8vIFRlc3RpbmcgaG9vay5cbiAgICAgIGdldFZpbUdsb2JhbFN0YXRlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFRlc3RpbmcgaG9vay5cbiAgICAgIG1heWJlSW5pdFZpbVN0YXRlXzogbWF5YmVJbml0VmltU3RhdGUsXG5cbiAgICAgIHN1cHByZXNzRXJyb3JMb2dnaW5nOiBmYWxzZSxcblxuICAgICAgSW5zZXJ0TW9kZUtleTogSW5zZXJ0TW9kZUtleSxcbiAgICAgIG1hcDogZnVuY3Rpb24obGhzLCByaHMsIGN0eCkge1xuICAgICAgICAvLyBBZGQgdXNlciBkZWZpbmVkIGtleSBiaW5kaW5ncy5cbiAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5tYXAobGhzLCByaHMsIGN0eCk7XG4gICAgICB9LFxuICAgICAgdW5tYXA6IGZ1bmN0aW9uKGxocywgY3R4KSB7XG4gICAgICAgIHJldHVybiBleENvbW1hbmREaXNwYXRjaGVyLnVubWFwKGxocywgY3R4KTtcbiAgICAgIH0sXG4gICAgICAvLyBOb24tcmVjdXJzaXZlIG1hcCBmdW5jdGlvbi5cbiAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBub3QgY3JlYXRlIG1hcHBpbmdzIHRvIGtleSBtYXBzIHRoYXQgYXJlbid0IHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSBkZWZhdWx0IGtleSBtYXAuIFNlZSBUT0RPIGF0IGJvdHRvbSBvZiBmdW5jdGlvbi5cbiAgICAgIG5vcmVtYXA6IGZ1bmN0aW9uKGxocywgcmhzLCBjdHgpIHtcbiAgICAgICAgZnVuY3Rpb24gdG9DdHhBcnJheShjdHgpIHtcbiAgICAgICAgICByZXR1cm4gY3R4ID8gW2N0eF0gOiBbJ25vcm1hbCcsICdpbnNlcnQnLCAndmlzdWFsJ107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0eHNUb01hcCA9IHRvQ3R4QXJyYXkoY3R4KTtcbiAgICAgICAgLy8gTG9vayB0aHJvdWdoIGFsbCBhY3R1YWwgZGVmYXVsdHMgdG8gZmluZCBhIG1hcCBjYW5kaWRhdGUuXG4gICAgICAgIHZhciBhY3R1YWxMZW5ndGggPSBkZWZhdWx0S2V5bWFwLmxlbmd0aCwgb3JpZ0xlbmd0aCA9IGRlZmF1bHRLZXltYXBMZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSBhY3R1YWxMZW5ndGggLSBvcmlnTGVuZ3RoO1xuICAgICAgICAgICAgIGkgPCBhY3R1YWxMZW5ndGggJiYgY3R4c1RvTWFwLmxlbmd0aDtcbiAgICAgICAgICAgICBpKyspIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IGRlZmF1bHRLZXltYXBbaV07XG4gICAgICAgICAgLy8gT21pdCBtYXBwaW5ncyB0aGF0IG9wZXJhdGUgaW4gdGhlIHdyb25nIGNvbnRleHQocykgYW5kIHRob3NlIG9mIGludmFsaWQgdHlwZS5cbiAgICAgICAgICBpZiAobWFwcGluZy5rZXlzID09IHJocyAmJlxuICAgICAgICAgICAgICAoIWN0eCB8fCAhbWFwcGluZy5jb250ZXh0IHx8IG1hcHBpbmcuY29udGV4dCA9PT0gY3R4KSAmJlxuICAgICAgICAgICAgICBtYXBwaW5nLnR5cGUuc3Vic3RyKDAsIDIpICE9PSAnZXgnICYmXG4gICAgICAgICAgICAgIG1hcHBpbmcudHlwZS5zdWJzdHIoMCwgMykgIT09ICdrZXknKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBvcmlnaW5hbCBrZXltYXAgZW50cnkuXG4gICAgICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgbmV3TWFwcGluZ1trZXldID0gbWFwcGluZ1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW9kaWZ5IGl0IHBvaW50IHRvIHRoZSBuZXcgbWFwcGluZyB3aXRoIHRoZSBwcm9wZXIgY29udGV4dC5cbiAgICAgICAgICAgIG5ld01hcHBpbmcua2V5cyA9IGxocztcbiAgICAgICAgICAgIGlmIChjdHggJiYgIW5ld01hcHBpbmcuY29udGV4dCkge1xuICAgICAgICAgICAgICBuZXdNYXBwaW5nLmNvbnRleHQgPSBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGtleW1hcCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5IHRoYW4gdGhlIG9yaWdpbmFsLlxuICAgICAgICAgICAgdGhpcy5fbWFwQ29tbWFuZChuZXdNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgbWFwcGVkIGNvbnRleHRzIGFzIGNvbXBsZXRlLlxuICAgICAgICAgICAgdmFyIG1hcHBlZEN0eHMgPSB0b0N0eEFycmF5KG1hcHBpbmcuY29udGV4dCk7XG4gICAgICAgICAgICBjdHhzVG9NYXAgPSBjdHhzVG9NYXAuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBtYXBwZWRDdHhzLmluZGV4T2YoZWwpID09PSAtMTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IENyZWF0ZSBub24tcmVjdXJzaXZlIGtleVRvS2V5IG1hcHBpbmdzIGZvciB0aGUgdW5tYXBwZWQgY29udGV4dHMgb25jZSB0aG9zZSBleGlzdC5cbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYWxsIHVzZXItZGVmaW5lZCBtYXBwaW5ncyBmb3IgdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gICAgICBtYXBjbGVhcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vIFBhcnRpdGlvbiB0aGUgZXhpc3Rpbmcga2V5bWFwIGludG8gdXNlci1kZWZpbmVkIGFuZCB0cnVlIGRlZmF1bHRzLlxuICAgICAgICB2YXIgYWN0dWFsTGVuZ3RoID0gZGVmYXVsdEtleW1hcC5sZW5ndGgsXG4gICAgICAgICAgICBvcmlnTGVuZ3RoID0gZGVmYXVsdEtleW1hcExlbmd0aDtcbiAgICAgICAgdmFyIHVzZXJLZXltYXAgPSBkZWZhdWx0S2V5bWFwLnNsaWNlKDAsIGFjdHVhbExlbmd0aCAtIG9yaWdMZW5ndGgpO1xuICAgICAgICBkZWZhdWx0S2V5bWFwID0gZGVmYXVsdEtleW1hcC5zbGljZShhY3R1YWxMZW5ndGggLSBvcmlnTGVuZ3RoKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIC8vIElmIGEgc3BlY2lmaWMgY29udGV4dCBpcyBiZWluZyBjbGVhcmVkLCB3ZSBuZWVkIHRvIGtlZXAgbWFwcGluZ3NcbiAgICAgICAgICAvLyBmcm9tIGFsbCBvdGhlciBjb250ZXh0cy5cbiAgICAgICAgICBmb3IgKHZhciBpID0gdXNlcktleW1hcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB1c2VyS2V5bWFwW2ldO1xuICAgICAgICAgICAgaWYgKGN0eCAhPT0gbWFwcGluZy5jb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmIChtYXBwaW5nLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBDb21tYW5kKG1hcHBpbmcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGBtYXBwaW5nYCBhcHBsaWVzIHRvIGFsbCBjb250ZXh0cyBzbyBjcmVhdGUga2V5bWFwIGNvcGllc1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGNvbnRleHQgZXhjZXB0IHRoZSBvbmUgYmVpbmcgY2xlYXJlZC5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBbJ25vcm1hbCcsICdpbnNlcnQnLCAndmlzdWFsJ107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBjb250ZXh0cykge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRzW2pdICE9PSBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdNYXBwaW5nW2tleV0gPSBtYXBwaW5nW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3TWFwcGluZy5jb250ZXh0ID0gY29udGV4dHNbal07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcENvbW1hbmQobmV3TWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVE9ETzogRXhwb3NlIHNldE9wdGlvbiBhbmQgZ2V0T3B0aW9uIGFzIGluc3RhbmNlIG1ldGhvZHMuIE5lZWQgdG8gZGVjaWRlIGhvdyB0byBuYW1lc3BhY2VcbiAgICAgIC8vIHRoZW0sIG9yIHNvbWVob3cgbWFrZSB0aGVtIHdvcmsgd2l0aCB0aGUgZXhpc3RpbmcgQ29kZU1pcnJvciBzZXRPcHRpb24vZ2V0T3B0aW9uIEFQSS5cbiAgICAgIHNldE9wdGlvbjogc2V0T3B0aW9uLFxuICAgICAgZ2V0T3B0aW9uOiBnZXRPcHRpb24sXG4gICAgICBkZWZpbmVPcHRpb246IGRlZmluZU9wdGlvbixcbiAgICAgIGRlZmluZUV4OiBmdW5jdGlvbihuYW1lLCBwcmVmaXgsIGZ1bmMpe1xuICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgIHByZWZpeCA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhWaW0uZGVmaW5lRXgpIFwiJytwcmVmaXgrJ1wiIGlzIG5vdCBhIHByZWZpeCBvZiBcIicrbmFtZSsnXCIsIGNvbW1hbmQgbm90IHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBleENvbW1hbmRzW25hbWVdPWZ1bmM7XG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIuY29tbWFuZE1hcF9bcHJlZml4XT17bmFtZTpuYW1lLCBzaG9ydE5hbWU6cHJlZml4LCB0eXBlOidhcGknfTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVLZXk6IGZ1bmN0aW9uIChjbSwga2V5LCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmZpbmRLZXkoY20sIGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGZ1bmN0aW9uIGNhbGxlZCBieSBDb2RlTWlycm9yLCBhZnRlciBrZXlzIGhhdmVcbiAgICAgICAqIGJlZW4gbWFwcGVkIHRvIHRoZWlyIFZpbSBlcXVpdmFsZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBGaW5kcyBhIGNvbW1hbmQgYmFzZWQgb24gdGhlIGtleSAoYW5kIGNhY2hlZCBrZXlzIGlmIHRoZXJlIGlzIGFcbiAgICAgICAqIG11bHRpLWtleSBzZXF1ZW5jZSkuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8ga2V5IGlzIG1hdGNoZWQsIGEgbm9vcFxuICAgICAgICogZnVuY3Rpb24gaWYgYSBwYXJ0aWFsIG1hdGNoIGlzIGZvdW5kIChtdWx0aS1rZXkpLCBhbmQgYSBmdW5jdGlvbiB0b1xuICAgICAgICogZXhlY3V0ZSB0aGUgYm91bmQgY29tbWFuZCBpZiBhIGEga2V5IGlzIG1hdGNoZWQuIFRoZSBmdW5jdGlvbiBhbHdheXNcbiAgICAgICAqIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgZmluZEtleTogZnVuY3Rpb24oY20sIGtleSwgb3JpZ2luKSB7XG4gICAgICAgIHZhciB2aW0gPSBtYXliZUluaXRWaW1TdGF0ZShjbSk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1hY3JvUmVjb3JkaW5nKCkge1xuICAgICAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1JlY29yZGluZykge1xuICAgICAgICAgICAgaWYgKGtleSA9PSAncScpIHtcbiAgICAgICAgICAgICAgbWFjcm9Nb2RlU3RhdGUuZXhpdE1hY3JvUmVjb3JkTW9kZSgpO1xuICAgICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmlnaW4gIT0gJ21hcHBpbmcnKSB7XG4gICAgICAgICAgICAgIGxvZ0tleShtYWNyb01vZGVTdGF0ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXNjKCkge1xuICAgICAgICAgIGlmIChrZXkgPT0gJzxFc2M+Jykge1xuICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgc3RhdGUgYW5kIGdldCBiYWNrIHRvIG5vcm1hbCBtb2RlLlxuICAgICAgICAgICAgY2xlYXJJbnB1dFN0YXRlKGNtKTtcbiAgICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgICBleGl0VmlzdWFsTW9kZShjbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICAgIGV4aXRJbnNlcnRNb2RlKGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb0tleVRvS2V5KGtleXMpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgd2hpbGUgKGtleXMpIHtcbiAgICAgICAgICAgIC8vIFB1bGwgb2ZmIG9uZSBjb21tYW5kIGtleSwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gb3IgYSBzcGVjaWFsIHNlcXVlbmNlIHdyYXBwZWQgaW4gJzwnIGFuZCAnPicsIGUuZy4gJzxTcGFjZT4nLlxuICAgICAgICAgICAgbWF0Y2ggPSAoLzxcXHcrLS4rPz58PFxcdys+fC4vKS5leGVjKGtleXMpO1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5zdWJzdHJpbmcobWF0Y2guaW5kZXggKyBrZXkubGVuZ3RoKTtcbiAgICAgICAgICAgIHZpbUFwaS5oYW5kbGVLZXkoY20sIGtleSwgJ21hcHBpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVLZXlJbnNlcnRNb2RlKCkge1xuICAgICAgICAgIGlmIChoYW5kbGVFc2MoKSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgIHZhciBrZXlzID0gdmltLmlucHV0U3RhdGUua2V5QnVmZmVyID0gdmltLmlucHV0U3RhdGUua2V5QnVmZmVyICsga2V5O1xuICAgICAgICAgIHZhciBrZXlzQXJlQ2hhcnMgPSBrZXkubGVuZ3RoID09IDE7XG4gICAgICAgICAgdmFyIG1hdGNoID0gY29tbWFuZERpc3BhdGNoZXIubWF0Y2hDb21tYW5kKGtleXMsIGRlZmF1bHRLZXltYXAsIHZpbS5pbnB1dFN0YXRlLCAnaW5zZXJ0Jyk7XG4gICAgICAgICAgLy8gTmVlZCB0byBjaGVjayBhbGwga2V5IHN1YnN0cmluZ3MgaW4gaW5zZXJ0IG1vZGUuXG4gICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMSAmJiBtYXRjaC50eXBlICE9ICdmdWxsJykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgPSBrZXlzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIHRoaXNNYXRjaCA9IGNvbW1hbmREaXNwYXRjaGVyLm1hdGNoQ29tbWFuZChrZXlzLCBkZWZhdWx0S2V5bWFwLCB2aW0uaW5wdXRTdGF0ZSwgJ2luc2VydCcpO1xuICAgICAgICAgICAgaWYgKHRoaXNNYXRjaC50eXBlICE9ICdub25lJykgeyBtYXRjaCA9IHRoaXNNYXRjaDsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2gudHlwZSA9PSAnbm9uZScpIHsgY2xlYXJJbnB1dFN0YXRlKGNtKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2gudHlwZSA9PSAncGFydGlhbCcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQobGFzdEluc2VydE1vZGVLZXlUaW1lcik7IH1cbiAgICAgICAgICAgIGxhc3RJbnNlcnRNb2RlS2V5VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGlmICh2aW0uaW5zZXJ0TW9kZSAmJiB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIpIHsgY2xlYXJJbnB1dFN0YXRlKGNtKTsgfSB9LFxuICAgICAgICAgICAgICBnZXRPcHRpb24oJ2luc2VydE1vZGVFc2NLZXlzVGltZW91dCcpKTtcbiAgICAgICAgICAgIHJldHVybiAha2V5c0FyZUNoYXJzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQobGFzdEluc2VydE1vZGVLZXlUaW1lcik7IH1cbiAgICAgICAgICBpZiAoa2V5c0FyZUNoYXJzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGhlcmUgPSBzZWxlY3Rpb25zW2ldLmhlYWQ7XG4gICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgb2Zmc2V0Q3Vyc29yKGhlcmUsIDAsIC0oa2V5cy5sZW5ndGggLSAxKSksIGhlcmUsICcraW5wdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy5jaGFuZ2VzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgIHJldHVybiBtYXRjaC5jb21tYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlS2V5Tm9uSW5zZXJ0TW9kZSgpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlTWFjcm9SZWNvcmRpbmcoKSB8fCBoYW5kbGVFc2MoKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgICAgdmFyIGtleXMgPSB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgPSB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgKyBrZXk7XG4gICAgICAgICAgaWYgKC9eWzEtOV1cXGQqJC8udGVzdChrZXlzKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgICAgdmFyIGtleXNNYXRjaGVyID0gL14oXFxkKikoLiopJC8uZXhlYyhrZXlzKTtcbiAgICAgICAgICBpZiAoIWtleXNNYXRjaGVyKSB7IGNsZWFySW5wdXRTdGF0ZShjbSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgIHZhciBjb250ZXh0ID0gdmltLnZpc3VhbE1vZGUgPyAndmlzdWFsJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3JtYWwnO1xuICAgICAgICAgIHZhciBtYWluS2V5ID0ga2V5c01hdGNoZXJbMl0gfHwga2V5c01hdGNoZXJbMV07XG4gICAgICAgICAgaWYgKHZpbS5pbnB1dFN0YXRlLm9wZXJhdG9yU2hvcnRjdXQgJiYgdmltLmlucHV0U3RhdGUub3BlcmF0b3JTaG9ydGN1dC5zbGljZSgtMSkgPT0gbWFpbktleSkge1xuICAgICAgICAgICAgLy8gbXVsdGlrZXkgb3BlcmF0b3JzIGFjdCBsaW5ld2lzZSBieSByZXBlYXRpbmcgb25seSB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIG1haW5LZXkgPSB2aW0uaW5wdXRTdGF0ZS5vcGVyYXRvclNob3J0Y3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBjb21tYW5kRGlzcGF0Y2hlci5tYXRjaENvbW1hbmQobWFpbktleSwgZGVmYXVsdEtleW1hcCwgdmltLmlucHV0U3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChtYXRjaC50eXBlID09ICdub25lJykgeyBjbGVhcklucHV0U3RhdGUoY20pOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICBlbHNlIGlmIChtYXRjaC50eXBlID09ICdwYXJ0aWFsJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgICAgdmltLmlucHV0U3RhdGUua2V5QnVmZmVyID0gJyc7XG4gICAgICAgICAgdmFyIGtleXNNYXRjaGVyID0gL14oXFxkKikoLiopJC8uZXhlYyhrZXlzKTtcbiAgICAgICAgICBpZiAoa2V5c01hdGNoZXJbMV0gJiYga2V5c01hdGNoZXJbMV0gIT0gJzAnKSB7XG4gICAgICAgICAgICB2aW0uaW5wdXRTdGF0ZS5wdXNoUmVwZWF0RGlnaXQoa2V5c01hdGNoZXJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2guY29tbWFuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tYW5kO1xuICAgICAgICBpZiAodmltLmluc2VydE1vZGUpIHsgY29tbWFuZCA9IGhhbmRsZUtleUluc2VydE1vZGUoKTsgfVxuICAgICAgICBlbHNlIHsgY29tbWFuZCA9IGhhbmRsZUtleU5vbkluc2VydE1vZGUoKTsgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gIXZpbS5pbnNlcnRNb2RlICYmIGtleS5sZW5ndGggPT09IDEgPyBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIFRPRE86IExvb2sgaW50byB1c2luZyBDb2RlTWlycm9yJ3MgbXVsdGkta2V5IGhhbmRsaW5nLlxuICAgICAgICAgIC8vIFJldHVybiBuby1vcCBzaW5jZSB3ZSBhcmUgY2FjaGluZyB0aGUga2V5LiBDb3VudHMgYXMgaGFuZGxlZCwgYnV0XG4gICAgICAgICAgLy8gZG9uJ3Qgd2FudCBhY3Qgb24gaXQganVzdCB5ZXQuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbS5jdXJPcC5pc1ZpbU9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC50eXBlID09ICdrZXlUb0tleScpIHtcbiAgICAgICAgICAgICAgICAgIGRvS2V5VG9LZXkoY29tbWFuZC50b0tleXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBWSU0gc3RhdGUgaW4gY2FzZSBpdCdzIGluIGEgYmFkIHN0YXRlLlxuICAgICAgICAgICAgICAgIGNtLnN0YXRlLnZpbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtYXliZUluaXRWaW1TdGF0ZShjbSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aW1BcGkuc3VwcHJlc3NFcnJvckxvZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGVbJ2xvZyddKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhbmRsZUV4OiBmdW5jdGlvbihjbSwgaW5wdXQpIHtcbiAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgaW5wdXQpO1xuICAgICAgfSxcblxuICAgICAgZGVmaW5lTW90aW9uOiBkZWZpbmVNb3Rpb24sXG4gICAgICBkZWZpbmVBY3Rpb246IGRlZmluZUFjdGlvbixcbiAgICAgIGRlZmluZU9wZXJhdG9yOiBkZWZpbmVPcGVyYXRvcixcbiAgICAgIG1hcENvbW1hbmQ6IG1hcENvbW1hbmQsXG4gICAgICBfbWFwQ29tbWFuZDogX21hcENvbW1hbmQsXG5cbiAgICAgIGRlZmluZVJlZ2lzdGVyOiBkZWZpbmVSZWdpc3RlcixcblxuICAgICAgZXhpdFZpc3VhbE1vZGU6IGV4aXRWaXN1YWxNb2RlLFxuICAgICAgZXhpdEluc2VydE1vZGU6IGV4aXRJbnNlcnRNb2RlXG4gICAgfTtcblxuICAgIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgaW5wdXQgc3RhdGUuXG4gICAgZnVuY3Rpb24gSW5wdXRTdGF0ZSgpIHtcbiAgICAgIHRoaXMucHJlZml4UmVwZWF0ID0gW107XG4gICAgICB0aGlzLm1vdGlvblJlcGVhdCA9IFtdO1xuXG4gICAgICB0aGlzLm9wZXJhdG9yID0gbnVsbDtcbiAgICAgIHRoaXMub3BlcmF0b3JBcmdzID0gbnVsbDtcbiAgICAgIHRoaXMubW90aW9uID0gbnVsbDtcbiAgICAgIHRoaXMubW90aW9uQXJncyA9IG51bGw7XG4gICAgICB0aGlzLmtleUJ1ZmZlciA9IFtdOyAvLyBGb3IgbWF0Y2hpbmcgbXVsdGkta2V5IGNvbW1hbmRzLlxuICAgICAgdGhpcy5yZWdpc3Rlck5hbWUgPSBudWxsOyAvLyBEZWZhdWx0cyB0byB0aGUgdW5uYW1lZCByZWdpc3Rlci5cbiAgICB9XG4gICAgSW5wdXRTdGF0ZS5wcm90b3R5cGUucHVzaFJlcGVhdERpZ2l0ID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgIHRoaXMucHJlZml4UmVwZWF0ID0gdGhpcy5wcmVmaXhSZXBlYXQuY29uY2F0KG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb3Rpb25SZXBlYXQgPSB0aGlzLm1vdGlvblJlcGVhdC5jb25jYXQobik7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnB1dFN0YXRlLnByb3RvdHlwZS5nZXRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXBlYXQgPSAwO1xuICAgICAgaWYgKHRoaXMucHJlZml4UmVwZWF0Lmxlbmd0aCA+IDAgfHwgdGhpcy5tb3Rpb25SZXBlYXQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXBlYXQgPSAxO1xuICAgICAgICBpZiAodGhpcy5wcmVmaXhSZXBlYXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcGVhdCAqPSBwYXJzZUludCh0aGlzLnByZWZpeFJlcGVhdC5qb2luKCcnKSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vdGlvblJlcGVhdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVwZWF0ICo9IHBhcnNlSW50KHRoaXMubW90aW9uUmVwZWF0LmpvaW4oJycpLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBlYXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsZWFySW5wdXRTdGF0ZShjbSwgcmVhc29uKSB7XG4gICAgICBjbS5zdGF0ZS52aW0uaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKCk7XG4gICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgJ3ZpbS1jb21tYW5kLWRvbmUnLCByZWFzb24pO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVnaXN0ZXIgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGNvcHkgYW5kIHBhc3RlIHJlZ2lzdGVycy4gIEJlc2lkZXNcbiAgICAgKiB0ZXh0LCBhIHJlZ2lzdGVyIG11c3Qgc3RvcmUgd2hldGhlciBpdCBpcyBsaW5ld2lzZSAoaS5lLiwgd2hlbiBpdCBpc1xuICAgICAqIHBhc3RlZCwgc2hvdWxkIGl0IGluc2VydCBpdHNlbGYgaW50byBhIG5ldyBsaW5lLCBvciBzaG91bGQgdGhlIHRleHQgYmVcbiAgICAgKiBpbnNlcnRlZCBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uLilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWdpc3Rlcih0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLmtleUJ1ZmZlciA9IFt0ZXh0IHx8ICcnXTtcbiAgICAgIHRoaXMuaW5zZXJ0TW9kZUNoYW5nZXMgPSBbXTtcbiAgICAgIHRoaXMuc2VhcmNoUXVlcmllcyA9IFtdO1xuICAgICAgdGhpcy5saW5ld2lzZSA9ICEhbGluZXdpc2U7XG4gICAgICB0aGlzLmJsb2Nrd2lzZSA9ICEhYmxvY2t3aXNlO1xuICAgIH1cbiAgICBSZWdpc3Rlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKSB7XG4gICAgICAgIHRoaXMua2V5QnVmZmVyID0gW3RleHQgfHwgJyddO1xuICAgICAgICB0aGlzLmxpbmV3aXNlID0gISFsaW5ld2lzZTtcbiAgICAgICAgdGhpcy5ibG9ja3dpc2UgPSAhIWJsb2Nrd2lzZTtcbiAgICAgIH0sXG4gICAgICBwdXNoVGV4dDogZnVuY3Rpb24odGV4dCwgbGluZXdpc2UpIHtcbiAgICAgICAgLy8gaWYgdGhpcyByZWdpc3RlciBoYXMgZXZlciBiZWVuIHNldCB0byBsaW5ld2lzZSwgdXNlIGxpbmV3aXNlLlxuICAgICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGluZXdpc2UpIHtcbiAgICAgICAgICAgIHRoaXMua2V5QnVmZmVyLnB1c2goJ1xcbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxpbmV3aXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleUJ1ZmZlci5wdXNoKHRleHQpO1xuICAgICAgfSxcbiAgICAgIHB1c2hJbnNlcnRNb2RlQ2hhbmdlczogZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAgICB0aGlzLmluc2VydE1vZGVDaGFuZ2VzLnB1c2goY3JlYXRlSW5zZXJ0TW9kZUNoYW5nZXMoY2hhbmdlcykpO1xuICAgICAgfSxcbiAgICAgIHB1c2hTZWFyY2hRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hRdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5rZXlCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbnNlcnRNb2RlQ2hhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLnNlYXJjaFF1ZXJpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5ld2lzZSA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5QnVmZmVyLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGFuIGV4dGVybmFsIHJlZ2lzdGVyLlxuICAgICAqXG4gICAgICogVGhlIG5hbWUgc2hvdWxkIGJlIGEgc2luZ2xlIGNoYXJhY3RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIHJlZ2lzdGVyLlxuICAgICAqIFRoZSByZWdpc3RlciBzaG91bGQgc3VwcG9ydCBzZXRUZXh0LCBwdXNoVGV4dCwgY2xlYXIsIGFuZCB0b1N0cmluZygpLiBTZWUgUmVnaXN0ZXJcbiAgICAgKiBmb3IgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lUmVnaXN0ZXIobmFtZSwgcmVnaXN0ZXIpIHtcbiAgICAgIHZhciByZWdpc3RlcnMgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucmVnaXN0ZXJzO1xuICAgICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JlZ2lzdGVyIG5hbWUgbXVzdCBiZSAxIGNoYXJhY3RlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdGVyc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBFcnJvcignUmVnaXN0ZXIgYWxyZWFkeSBkZWZpbmVkICcgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyc1tuYW1lXSA9IHJlZ2lzdGVyO1xuICAgICAgdmFsaWRSZWdpc3RlcnMucHVzaChuYW1lKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHZpbSByZWdpc3RlcnMgYWxsb3cgeW91IHRvIGtlZXAgbWFueSBpbmRlcGVuZGVudCBjb3B5IGFuZCBwYXN0ZSBidWZmZXJzLlxuICAgICAqIFNlZSBodHRwOi8vdXNldmltLmNvbS8yMDEyLzA0LzEzL3JlZ2lzdGVycy8gZm9yIGFuIGludHJvZHVjdGlvbi5cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVyQ29udHJvbGxlciBrZWVwcyB0aGUgc3RhdGUgb2YgYWxsIHRoZSByZWdpc3RlcnMuICBBbiBpbml0aWFsXG4gICAgICogc3RhdGUgbWF5IGJlIHBhc3NlZCBpbi4gIFRoZSB1bm5hbWVkIHJlZ2lzdGVyICdcIicgd2lsbCBhbHdheXMgYmVcbiAgICAgKiBvdmVycmlkZGVuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZ2lzdGVyQ29udHJvbGxlcihyZWdpc3RlcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJzID0gcmVnaXN0ZXJzO1xuICAgICAgdGhpcy51bm5hbWVkUmVnaXN0ZXIgPSByZWdpc3RlcnNbJ1wiJ10gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgIHJlZ2lzdGVyc1snLiddID0gbmV3IFJlZ2lzdGVyKCk7XG4gICAgICByZWdpc3RlcnNbJzonXSA9IG5ldyBSZWdpc3RlcigpO1xuICAgICAgcmVnaXN0ZXJzWycvJ10gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgUmVnaXN0ZXJDb250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIHB1c2hUZXh0OiBmdW5jdGlvbihyZWdpc3Rlck5hbWUsIG9wZXJhdG9yLCB0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKSB7XG4gICAgICAgIC8vIFRoZSBibGFjayBob2xlIHJlZ2lzdGVyLCBcIl8sIG1lYW5zIGRlbGV0ZS95YW5rIHRvIG5vd2hlcmUuXG4gICAgICAgIGlmIChyZWdpc3Rlck5hbWUgPT09ICdfJykgcmV0dXJuO1xuICAgICAgICBpZiAobGluZXdpc2UgJiYgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKSAhPT0gJ1xcbicpe1xuICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG93ZXJjYXNlIGFuZCB1cHBlcmNhc2UgcmVnaXN0ZXJzIHJlZmVyIHRvIHRoZSBzYW1lIHJlZ2lzdGVyLlxuICAgICAgICAvLyBVcHBlcmNhc2UganVzdCBtZWFucyBhcHBlbmQuXG4gICAgICAgIHZhciByZWdpc3RlciA9IHRoaXMuaXNWYWxpZFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgbm8gcmVnaXN0ZXIvYW4gaW52YWxpZCByZWdpc3RlciB3YXMgc3BlY2lmaWVkLCB0aGluZ3MgZ28gdG8gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgcmVnaXN0ZXJzXG4gICAgICAgIGlmICghcmVnaXN0ZXIpIHtcbiAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICd5YW5rJzpcbiAgICAgICAgICAgICAgLy8gVGhlIDAgcmVnaXN0ZXIgY29udGFpbnMgdGhlIHRleHQgZnJvbSB0aGUgbW9zdCByZWNlbnQgeWFuay5cbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcnNbJzAnXSA9IG5ldyBSZWdpc3Rlcih0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgY2FzZSAnY2hhbmdlJzpcbiAgICAgICAgICAgICAgaWYgKHRleHQuaW5kZXhPZignXFxuJykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgbGVzcyB0aGFuIDEgbGluZS4gVXBkYXRlIHRoZSBzbWFsbCBkZWxldGUgcmVnaXN0ZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcnNbJy0nXSA9IG5ldyBSZWdpc3Rlcih0ZXh0LCBsaW5ld2lzZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgZG93biB0aGUgY29udGVudHMgb2YgdGhlIG51bWJlcmVkIHJlZ2lzdGVycyBhbmQgcHV0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZWQgdGV4dCBpbnRvIHJlZ2lzdGVyIDEuXG4gICAgICAgICAgICAgICAgdGhpcy5zaGlmdE51bWVyaWNSZWdpc3RlcnNfKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcnNbJzEnXSA9IG5ldyBSZWdpc3Rlcih0ZXh0LCBsaW5ld2lzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdW5uYW1lZCByZWdpc3RlciBpcyBzZXQgdG8gd2hhdCBqdXN0IGhhcHBlbmVkXG4gICAgICAgICAgdGhpcy51bm5hbWVkUmVnaXN0ZXIuc2V0VGV4dCh0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgd2UndmUgYWN0dWFsbHkgc3BlY2lmaWVkIGEgcmVnaXN0ZXJcbiAgICAgICAgdmFyIGFwcGVuZCA9IGlzVXBwZXJDYXNlKHJlZ2lzdGVyTmFtZSk7XG4gICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICByZWdpc3Rlci5wdXNoVGV4dCh0ZXh0LCBsaW5ld2lzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaXN0ZXIuc2V0VGV4dCh0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdW5uYW1lZCByZWdpc3RlciBhbHdheXMgaGFzIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBsYXN0IHVzZWRcbiAgICAgICAgLy8gcmVnaXN0ZXIuXG4gICAgICAgIHRoaXMudW5uYW1lZFJlZ2lzdGVyLnNldFRleHQocmVnaXN0ZXIudG9TdHJpbmcoKSwgbGluZXdpc2UpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldHMgdGhlIHJlZ2lzdGVyIG5hbWVkIEBuYW1lLiAgSWYgb25lIG9mIEBuYW1lIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCxcbiAgICAgIC8vIGNyZWF0ZSBpdC4gIElmIEBuYW1lIGlzIGludmFsaWQsIHJldHVybiB0aGUgdW5uYW1lZFJlZ2lzdGVyLlxuICAgICAgZ2V0UmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRSZWdpc3RlcihuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVubmFtZWRSZWdpc3RlcjtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMucmVnaXN0ZXJzW25hbWVdKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcnNbbmFtZV0gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcnNbbmFtZV07XG4gICAgICB9LFxuICAgICAgaXNWYWxpZFJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lICYmIGluQXJyYXkobmFtZSwgdmFsaWRSZWdpc3RlcnMpO1xuICAgICAgfSxcbiAgICAgIHNoaWZ0TnVtZXJpY1JlZ2lzdGVyc186IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gOTsgaSA+PSAyOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyc1tpXSA9IHRoaXMuZ2V0UmVnaXN0ZXIoJycgKyAoaSAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gSGlzdG9yeUNvbnRyb2xsZXIoKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gMDtcbiAgICAgICAgdGhpcy5pbml0aWFsUHJlZml4ID0gbnVsbDtcbiAgICB9XG4gICAgSGlzdG9yeUNvbnRyb2xsZXIucHJvdG90eXBlID0ge1xuICAgICAgLy8gdGhlIGlucHV0IGFyZ3VtZW50IGhlcmUgYWN0cyBhIHVzZXIgZW50ZXJlZCBwcmVmaXggZm9yIGEgc21hbGwgdGltZVxuICAgICAgLy8gdW50aWwgd2Ugc3RhcnQgYXV0b2NvbXBsZXRpb24gaW4gd2hpY2ggY2FzZSBpdCBpcyB0aGUgYXV0b2NvbXBsZXRlZC5cbiAgICAgIG5leHRNYXRjaDogZnVuY3Rpb24gKGlucHV0LCB1cCkge1xuICAgICAgICB2YXIgaGlzdG9yeUJ1ZmZlciA9IHRoaXMuaGlzdG9yeUJ1ZmZlcjtcbiAgICAgICAgdmFyIGRpciA9IHVwID8gLTEgOiAxO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJlZml4ID09PSBudWxsKSB0aGlzLmluaXRpYWxQcmVmaXggPSBpbnB1dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaXRlcmF0b3IgKyBkaXI7IHVwID8gaSA+PSAwIDogaSA8IGhpc3RvcnlCdWZmZXIubGVuZ3RoOyBpKz0gZGlyKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBoaXN0b3J5QnVmZmVyW2ldO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGVsZW1lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxQcmVmaXggPT0gZWxlbWVudC5zdWJzdHJpbmcoMCwgaikpIHtcbiAgICAgICAgICAgICAgdGhpcy5pdGVyYXRvciA9IGk7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaG91bGQgcmV0dXJuIHRoZSB1c2VyIGlucHV0IGluIGNhc2Ugd2UgcmVhY2ggdGhlIGVuZCBvZiBidWZmZXIuXG4gICAgICAgIGlmIChpID49IGhpc3RvcnlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5pdGVyYXRvciA9IGhpc3RvcnlCdWZmZXIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IGF1dG9jb21wbGV0ZWQgcXVlcnkgb3IgZXhDb21tYW5kIGFzIGl0IGlzLlxuICAgICAgICBpZiAoaSA8IDAgKSByZXR1cm4gaW5wdXQ7XG4gICAgICB9LFxuICAgICAgcHVzaElucHV0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhpc3RvcnlCdWZmZXIuaW5kZXhPZihpbnB1dCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB0aGlzLmhpc3RvcnlCdWZmZXIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCkgdGhpcy5oaXN0b3J5QnVmZmVyLnB1c2goaW5wdXQpO1xuICAgICAgfSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsUHJlZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IHRoaXMuaGlzdG9yeUJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tbWFuZERpc3BhdGNoZXIgPSB7XG4gICAgICBtYXRjaENvbW1hbmQ6IGZ1bmN0aW9uKGtleXMsIGtleU1hcCwgaW5wdXRTdGF0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbW1hbmRNYXRjaGVzKGtleXMsIGtleU1hcCwgY29udGV4dCwgaW5wdXRTdGF0ZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcy5mdWxsICYmICFtYXRjaGVzLnBhcnRpYWwpIHtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6ICdub25lJ307XG4gICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMuZnVsbCAmJiBtYXRjaGVzLnBhcnRpYWwpIHtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6ICdwYXJ0aWFsJ307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVzdE1hdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMuZnVsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXMuZnVsbFtpXTtcbiAgICAgICAgICBpZiAoIWJlc3RNYXRjaCkge1xuICAgICAgICAgICAgYmVzdE1hdGNoID0gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2gua2V5cy5zbGljZSgtMTEpID09ICc8Y2hhcmFjdGVyPicpIHtcbiAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gbGFzdENoYXIoa2V5cyk7XG4gICAgICAgICAgaWYgKCFjaGFyYWN0ZXIpIHJldHVybiB7dHlwZTogJ25vbmUnfTtcbiAgICAgICAgICBpbnB1dFN0YXRlLnNlbGVjdGVkQ2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogJ2Z1bGwnLCBjb21tYW5kOiBiZXN0TWF0Y2h9O1xuICAgICAgfSxcbiAgICAgIHByb2Nlc3NDb21tYW5kOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIHZpbS5pbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlID0gY29tbWFuZC5yZXBlYXRPdmVycmlkZTtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdtb3Rpb24nOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTW90aW9uKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzT3BlcmF0b3IoY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvcGVyYXRvck1vdGlvbic6XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvck1vdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NBY3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzZWFyY2gnOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2VhcmNoKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXgnOlxuICAgICAgICAgIGNhc2UgJ2tleVRvRXgnOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXgoY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9jZXNzTW90aW9uOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIHZpbS5pbnB1dFN0YXRlLm1vdGlvbiA9IGNvbW1hbmQubW90aW9uO1xuICAgICAgICB2aW0uaW5wdXRTdGF0ZS5tb3Rpb25BcmdzID0gY29weUFyZ3MoY29tbWFuZC5tb3Rpb25BcmdzKTtcbiAgICAgICAgdGhpcy5ldmFsSW5wdXQoY20sIHZpbSk7XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc09wZXJhdG9yOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlID0gdmltLmlucHV0U3RhdGU7XG4gICAgICAgIGlmIChpbnB1dFN0YXRlLm9wZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGlucHV0U3RhdGUub3BlcmF0b3IgPT0gY29tbWFuZC5vcGVyYXRvcikge1xuICAgICAgICAgICAgLy8gVHlwaW5nIGFuIG9wZXJhdG9yIHR3aWNlIGxpa2UgJ2RkJyBtYWtlcyB0aGUgb3BlcmF0b3Igb3BlcmF0ZVxuICAgICAgICAgICAgLy8gbGluZXdpc2VcbiAgICAgICAgICAgIGlucHV0U3RhdGUubW90aW9uID0gJ2V4cGFuZFRvTGluZSc7XG4gICAgICAgICAgICBpbnB1dFN0YXRlLm1vdGlvbkFyZ3MgPSB7IGxpbmV3aXNlOiB0cnVlIH07XG4gICAgICAgICAgICB0aGlzLmV2YWxJbnB1dChjbSwgdmltKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gMiBkaWZmZXJlbnQgb3BlcmF0b3JzIGluIGEgcm93IGRvZXNuJ3QgbWFrZSBzZW5zZS5cbiAgICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0U3RhdGUub3BlcmF0b3IgPSBjb21tYW5kLm9wZXJhdG9yO1xuICAgICAgICBpbnB1dFN0YXRlLm9wZXJhdG9yQXJncyA9IGNvcHlBcmdzKGNvbW1hbmQub3BlcmF0b3JBcmdzKTtcbiAgICAgICAgaWYgKGNvbW1hbmQua2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaW5wdXRTdGF0ZS5vcGVyYXRvclNob3J0Y3V0ID0gY29tbWFuZC5rZXlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLmV4aXRWaXN1YWxCbG9jaykge1xuICAgICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB1cGRhdGVDbVNlbGVjdGlvbihjbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgLy8gT3BlcmF0aW5nIG9uIGEgc2VsZWN0aW9uIGluIHZpc3VhbCBtb2RlLiBXZSBkb24ndCBuZWVkIGEgbW90aW9uLlxuICAgICAgICAgIHRoaXMuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc09wZXJhdG9yTW90aW9uOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIHZhciB2aXN1YWxNb2RlID0gdmltLnZpc3VhbE1vZGU7XG4gICAgICAgIHZhciBvcGVyYXRvck1vdGlvbkFyZ3MgPSBjb3B5QXJncyhjb21tYW5kLm9wZXJhdG9yTW90aW9uQXJncyk7XG4gICAgICAgIGlmIChvcGVyYXRvck1vdGlvbkFyZ3MpIHtcbiAgICAgICAgICAvLyBPcGVyYXRvciBtb3Rpb25zIG1heSBoYXZlIHNwZWNpYWwgYmVoYXZpb3IgaW4gdmlzdWFsIG1vZGUuXG4gICAgICAgICAgaWYgKHZpc3VhbE1vZGUgJiYgb3BlcmF0b3JNb3Rpb25BcmdzLnZpc3VhbExpbmUpIHtcbiAgICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzT3BlcmF0b3IoY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgIGlmICghdmlzdWFsTW9kZSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc01vdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb2Nlc3NBY3Rpb246IGZ1bmN0aW9uKGNtLCB2aW0sIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGlucHV0U3RhdGUuZ2V0UmVwZWF0KCk7XG4gICAgICAgIHZhciByZXBlYXRJc0V4cGxpY2l0ID0gISFyZXBlYXQ7XG4gICAgICAgIHZhciBhY3Rpb25BcmdzID0gY29weUFyZ3MoY29tbWFuZC5hY3Rpb25BcmdzKSB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyID0gaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBY3Rpb25zIG1heSBvciBtYXkgbm90IGhhdmUgbW90aW9ucyBhbmQgb3BlcmF0b3JzLiBEbyB0aGVzZSBmaXJzdC5cbiAgICAgICAgaWYgKGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvcihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5tb3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NNb3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQubW90aW9uIHx8IGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLmV2YWxJbnB1dChjbSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25BcmdzLnJlcGVhdCA9IHJlcGVhdCB8fCAxO1xuICAgICAgICBhY3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSByZXBlYXRJc0V4cGxpY2l0O1xuICAgICAgICBhY3Rpb25BcmdzLnJlZ2lzdGVyTmFtZSA9IGlucHV0U3RhdGUucmVnaXN0ZXJOYW1lO1xuICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICB2aW0ubGFzdE1vdGlvbiA9IG51bGw7XG4gICAgICAgIGlmIChjb21tYW5kLmlzRWRpdCkge1xuICAgICAgICAgIHRoaXMucmVjb3JkTGFzdEVkaXQodmltLCBpbnB1dFN0YXRlLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zW2NvbW1hbmQuYWN0aW9uXShjbSwgYWN0aW9uQXJncywgdmltKTtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzU2VhcmNoOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIGlmICghY20uZ2V0U2VhcmNoQ3Vyc29yKSB7XG4gICAgICAgICAgLy8gU2VhcmNoIGRlcGVuZHMgb24gU2VhcmNoQ3Vyc29yLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9yd2FyZCA9IGNvbW1hbmQuc2VhcmNoQXJncy5mb3J3YXJkO1xuICAgICAgICB2YXIgd2hvbGVXb3JkT25seSA9IGNvbW1hbmQuc2VhcmNoQXJncy53aG9sZVdvcmRPbmx5O1xuICAgICAgICBnZXRTZWFyY2hTdGF0ZShjbSkuc2V0UmV2ZXJzZWQoIWZvcndhcmQpO1xuICAgICAgICB2YXIgcHJvbXB0UHJlZml4ID0gKGZvcndhcmQpID8gJy8nIDogJz8nO1xuICAgICAgICB2YXIgb3JpZ2luYWxRdWVyeSA9IGdldFNlYXJjaFN0YXRlKGNtKS5nZXRRdWVyeSgpO1xuICAgICAgICB2YXIgb3JpZ2luYWxTY3JvbGxQb3MgPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5KHF1ZXJ5LCBpZ25vcmVDYXNlLCBzbWFydENhc2UpIHtcbiAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5zZWFyY2hIaXN0b3J5Q29udHJvbGxlci5wdXNoSW5wdXQocXVlcnkpO1xuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnNlYXJjaEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCBxdWVyeSwgaWdub3JlQ2FzZSwgc21hcnRDYXNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgcmVnZXg6ICcgKyBxdWVyeSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzTW90aW9uKGNtLCB2aW0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3Rpb24nLFxuICAgICAgICAgICAgbW90aW9uOiAnZmluZE5leHQnLFxuICAgICAgICAgICAgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiBjb21tYW5kLnNlYXJjaEFyZ3MudG9KdW1wbGlzdCB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9tcHRDbG9zZShxdWVyeSkge1xuICAgICAgICAgIGNtLnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsUG9zLmxlZnQsIG9yaWdpbmFsU2Nyb2xsUG9zLnRvcCk7XG4gICAgICAgICAgaGFuZGxlUXVlcnkocXVlcnksIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sIHRydWUgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBsb2dTZWFyY2hRdWVyeShtYWNyb01vZGVTdGF0ZSwgcXVlcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb21wdEtleVVwKGUsIHF1ZXJ5LCBjbG9zZSkge1xuICAgICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpLCB1cCwgb2Zmc2V0O1xuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIHVwID0ga2V5TmFtZSA9PSAnVXAnID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZS50YXJnZXQgPyBlLnRhcmdldC5zZWxlY3Rpb25FbmQgOiAwO1xuICAgICAgICAgICAgcXVlcnkgPSB2aW1HbG9iYWxTdGF0ZS5zZWFyY2hIaXN0b3J5Q29udHJvbGxlci5uZXh0TWF0Y2gocXVlcnksIHVwKSB8fCAnJztcbiAgICAgICAgICAgIGNsb3NlKHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgJiYgZS50YXJnZXQpIGUudGFyZ2V0LnNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIGtleU5hbWUgIT0gJ0xlZnQnICYmIGtleU5hbWUgIT0gJ1JpZ2h0JyAmJiBrZXlOYW1lICE9ICdDdHJsJyAmJiBrZXlOYW1lICE9ICdBbHQnICYmIGtleU5hbWUgIT0gJ1NoaWZ0JylcbiAgICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhcnNlZFF1ZXJ5O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWRRdWVyeSA9IHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCBxdWVyeSxcbiAgICAgICAgICAgICAgICB0cnVlIC8qKiBpZ25vcmVDYXNlICovLCB0cnVlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgYmFkIHJlZ2V4ZXMgZm9yIGluY3JlbWVudGFsIHNlYXJjaC5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFF1ZXJ5KSB7XG4gICAgICAgICAgICBjbS5zY3JvbGxJbnRvVmlldyhmaW5kTmV4dChjbSwgIWZvcndhcmQsIHBhcnNlZFF1ZXJ5KSwgMzApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbFBvcy5sZWZ0LCBvcmlnaW5hbFNjcm9sbFBvcy50b3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb21wdEtleURvd24oZSwgcXVlcnksIGNsb3NlKSB7XG4gICAgICAgICAgdmFyIGtleU5hbWUgPSBDb2RlTWlycm9yLmtleU5hbWUoZSk7XG4gICAgICAgICAgaWYgKGtleU5hbWUgPT0gJ0VzYycgfHwga2V5TmFtZSA9PSAnQ3RybC1DJyB8fCBrZXlOYW1lID09ICdDdHJsLVsnIHx8XG4gICAgICAgICAgICAgIChrZXlOYW1lID09ICdCYWNrc3BhY2UnICYmIHF1ZXJ5ID09ICcnKSkge1xuICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucHVzaElucHV0KHF1ZXJ5KTtcbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnNlYXJjaEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB1cGRhdGVTZWFyY2hRdWVyeShjbSwgb3JpZ2luYWxRdWVyeSk7XG4gICAgICAgICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbFBvcy5sZWZ0LCBvcmlnaW5hbFNjcm9sbFBvcy50b3ApO1xuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5TmFtZSA9PSAnQ3RybC1VJykge1xuICAgICAgICAgICAgLy8gQ3RybC1VIGNsZWFycyBpbnB1dC5cbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgICAgY2xvc2UoJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQuc2VhcmNoQXJncy5xdWVyeVNyYykge1xuICAgICAgICAgIGNhc2UgJ3Byb21wdCc6XG4gICAgICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbWFjcm9Nb2RlU3RhdGUucmVwbGF5U2VhcmNoUXVlcmllcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBoYW5kbGVRdWVyeShxdWVyeSwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLywgZmFsc2UgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7XG4gICAgICAgICAgICAgICAgICBvbkNsb3NlOiBvblByb21wdENsb3NlLFxuICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcm9tcHRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICBkZXNjOiAnKEphdmFTY3JpcHQgcmVnZXhwKScsXG4gICAgICAgICAgICAgICAgICBvbktleVVwOiBvblByb21wdEtleVVwLFxuICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3b3JkVW5kZXJDdXJzb3InOlxuICAgICAgICAgICAgdmFyIHdvcmQgPSBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIGZhbHNlIC8qKiBpbmNsdXNpdmUgKi8sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvKiogZm9yd2FyZCAqLywgZmFsc2UgLyoqIGJpZ1dvcmQgKi8sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvKiogbm9TeW1ib2wgKi8pO1xuICAgICAgICAgICAgdmFyIGlzS2V5d29yZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgICAgd29yZCA9IGV4cGFuZFdvcmRVbmRlckN1cnNvcihjbSwgZmFsc2UgLyoqIGluY2x1c2l2ZSAqLyxcbiAgICAgICAgICAgICAgICAgIHRydWUgLyoqIGZvcndhcmQgKi8sIGZhbHNlIC8qKiBiaWdXb3JkICovLFxuICAgICAgICAgICAgICAgICAgZmFsc2UgLyoqIG5vU3ltYm9sICovKTtcbiAgICAgICAgICAgICAgaXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gY20uZ2V0TGluZSh3b3JkLnN0YXJ0LmxpbmUpLnN1YnN0cmluZyh3b3JkLnN0YXJ0LmNoLFxuICAgICAgICAgICAgICAgIHdvcmQuZW5kLmNoKTtcbiAgICAgICAgICAgIGlmIChpc0tleXdvcmQgJiYgd2hvbGVXb3JkT25seSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gJ1xcXFxiJyArIHF1ZXJ5ICsgJ1xcXFxiJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gZXNjYXBlUmVnZXgocXVlcnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWNoZWRDdXJzb3IgaXMgdXNlZCB0byBzYXZlIHRoZSBvbGQgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgLy8gd2hlbiAqIG9yICMgY2F1c2VzIHZpbSB0byBzZWVrIGZvciB0aGUgbmVhcmVzdCB3b3JkIGFuZCBzaGlmdFxuICAgICAgICAgICAgLy8gdGhlIGN1cnNvciBiZWZvcmUgZW50ZXJpbmcgdGhlIG1vdGlvbi5cbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0LmNhY2hlZEN1cnNvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHdvcmQuc3RhcnQpO1xuXG4gICAgICAgICAgICBoYW5kbGVRdWVyeShxdWVyeSwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLywgZmFsc2UgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb2Nlc3NFeDogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgICBmdW5jdGlvbiBvblByb21wdENsb3NlKGlucHV0KSB7XG4gICAgICAgICAgLy8gR2l2ZSB0aGUgcHJvbXB0IHNvbWUgdGltZSB0byBjbG9zZSBzbyB0aGF0IGlmIHByb2Nlc3NDb21tYW5kIHNob3dzXG4gICAgICAgICAgLy8gYW4gZXJyb3IsIHRoZSBlbGVtZW50cyBkb24ndCBvdmVybGFwLlxuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChpbnB1dCk7XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUuZXhDb21tYW5kSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9tcHRLZXlEb3duKGUsIGlucHV0LCBjbG9zZSkge1xuICAgICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpLCB1cCwgb2Zmc2V0O1xuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdFc2MnIHx8IGtleU5hbWUgPT0gJ0N0cmwtQycgfHwga2V5TmFtZSA9PSAnQ3RybC1bJyB8fFxuICAgICAgICAgICAgICAoa2V5TmFtZSA9PSAnQmFja3NwYWNlJyAmJiBpbnB1dCA9PSAnJykpIHtcbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgICAgdXAgPSBrZXlOYW1lID09ICdVcCcgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICBvZmZzZXQgPSBlLnRhcmdldCA/IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCA6IDA7XG4gICAgICAgICAgICBpbnB1dCA9IHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLm5leHRNYXRjaChpbnB1dCwgdXApIHx8ICcnO1xuICAgICAgICAgICAgY2xvc2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCAmJiBlLnRhcmdldCkgZS50YXJnZXQuc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSBNYXRoLm1pbihvZmZzZXQsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICdDdHJsLVUnKSB7XG4gICAgICAgICAgICAvLyBDdHJsLVUgY2xlYXJzIGlucHV0LlxuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbG9zZSgnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgga2V5TmFtZSAhPSAnTGVmdCcgJiYga2V5TmFtZSAhPSAnUmlnaHQnICYmIGtleU5hbWUgIT0gJ0N0cmwnICYmIGtleU5hbWUgIT0gJ0FsdCcgJiYga2V5TmFtZSAhPSAnU2hpZnQnKVxuICAgICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC50eXBlID09ICdrZXlUb0V4Jykge1xuICAgICAgICAgIC8vIEhhbmRsZSB1c2VyIGRlZmluZWQgRXggdG8gRXggbWFwcGluZ3NcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBjb21tYW5kLmV4QXJncy5pbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7IG9uQ2xvc2U6IG9uUHJvbXB0Q2xvc2UsIHByZWZpeDogJzonLCB2YWx1ZTogJ1xcJzwsXFwnPicsXG4gICAgICAgICAgICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd24sIHNlbGVjdFZhbHVlT25PcGVuOiBmYWxzZX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7IG9uQ2xvc2U6IG9uUHJvbXB0Q2xvc2UsIHByZWZpeDogJzonLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogb25Qcm9tcHRLZXlEb3dufSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZhbElucHV0OiBmdW5jdGlvbihjbSwgdmltKSB7XG4gICAgICAgIC8vIElmIHRoZSBtb3Rpb24gY29tbWFuZCBpcyBzZXQsIGV4ZWN1dGUgYm90aCB0aGUgb3BlcmF0b3IgYW5kIG1vdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybi5cbiAgICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgICAgdmFyIG1vdGlvbiA9IGlucHV0U3RhdGUubW90aW9uO1xuICAgICAgICB2YXIgbW90aW9uQXJncyA9IGlucHV0U3RhdGUubW90aW9uQXJncyB8fCB7fTtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gaW5wdXRTdGF0ZS5vcGVyYXRvcjtcbiAgICAgICAgdmFyIG9wZXJhdG9yQXJncyA9IGlucHV0U3RhdGUub3BlcmF0b3JBcmdzIHx8IHt9O1xuICAgICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gaW5wdXRTdGF0ZS5yZWdpc3Rlck5hbWU7XG4gICAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgY20gYW5kIHZpbSBzZWxlY3Rpb25zIGFyZSBpZGVudGljYWwgb3V0c2lkZSB2aXN1YWwgbW9kZS5cbiAgICAgICAgdmFyIG9yaWdIZWFkID0gY29weUN1cnNvcih2aW0udmlzdWFsTW9kZSA/IGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIHNlbC5oZWFkKTogY20uZ2V0Q3Vyc29yKCdoZWFkJykpO1xuICAgICAgICB2YXIgb3JpZ0FuY2hvciA9IGNvcHlDdXJzb3IodmltLnZpc3VhbE1vZGUgPyBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBzZWwuYW5jaG9yKSA6IGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgICB2YXIgb2xkSGVhZCA9IGNvcHlDdXJzb3Iob3JpZ0hlYWQpO1xuICAgICAgICB2YXIgb2xkQW5jaG9yID0gY29weUN1cnNvcihvcmlnQW5jaG9yKTtcbiAgICAgICAgdmFyIG5ld0hlYWQsIG5ld0FuY2hvcjtcbiAgICAgICAgdmFyIHJlcGVhdDtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRMYXN0RWRpdCh2aW0sIGlucHV0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBJZiByZXBlYXRPdmVycmlkZSBpcyBzcGVjaWZpZWQsIHRoYXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZVxuICAgICAgICAgIC8vIGlucHV0IHN0YXRlJ3MgcmVwZWF0LiBVc2VkIGJ5IEV4IG1vZGUgYW5kIGNhbiBiZSB1c2VyIGRlZmluZWQuXG4gICAgICAgICAgcmVwZWF0ID0gaW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBlYXQgPSBpbnB1dFN0YXRlLmdldFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgPiAwICYmIG1vdGlvbkFyZ3MuZXhwbGljaXRSZXBlYXQpIHtcbiAgICAgICAgICBtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdGlvbkFyZ3Mubm9SZXBlYXQgfHxcbiAgICAgICAgICAgICghbW90aW9uQXJncy5leHBsaWNpdFJlcGVhdCAmJiByZXBlYXQgPT09IDApKSB7XG4gICAgICAgICAgcmVwZWF0ID0gMTtcbiAgICAgICAgICBtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3Rlcikge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgY2hhcmFjdGVyIGlucHV0LCBzdGljayBpdCBpbiBhbGwgb2YgdGhlIGFyZyBhcnJheXMuXG4gICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciA9IG9wZXJhdG9yQXJncy5zZWxlY3RlZENoYXJhY3RlciA9XG4gICAgICAgICAgICAgIGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgbW90aW9uQXJncy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgIGlmIChtb3Rpb24pIHtcbiAgICAgICAgICB2YXIgbW90aW9uUmVzdWx0ID0gbW90aW9uc1ttb3Rpb25dKGNtLCBvcmlnSGVhZCwgbW90aW9uQXJncywgdmltLCBpbnB1dFN0YXRlKTtcbiAgICAgICAgICB2aW0ubGFzdE1vdGlvbiA9IG1vdGlvbnNbbW90aW9uXTtcbiAgICAgICAgICBpZiAoIW1vdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW90aW9uQXJncy50b0p1bXBsaXN0KSB7XG4gICAgICAgICAgICB2YXIganVtcExpc3QgPSB2aW1HbG9iYWxTdGF0ZS5qdW1wTGlzdDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG1vdGlvbiBpcyAjIG9yICosIHVzZSBjYWNoZWRDdXJzb3JcbiAgICAgICAgICAgIHZhciBjYWNoZWRDdXJzb3IgPSBqdW1wTGlzdC5jYWNoZWRDdXJzb3I7XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgY2FjaGVkQ3Vyc29yLCBtb3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICBkZWxldGUganVtcExpc3QuY2FjaGVkQ3Vyc29yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkSnVtcFBvc2l0aW9uKGNtLCBvcmlnSGVhZCwgbW90aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vdGlvblJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBuZXdBbmNob3IgPSBtb3Rpb25SZXN1bHRbMF07XG4gICAgICAgICAgICBuZXdIZWFkID0gbW90aW9uUmVzdWx0WzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIZWFkID0gbW90aW9uUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgbnVsbCByZXR1cm5zIGZyb20gbW90aW9uIGNvbW1hbmRzIGJldHRlci5cbiAgICAgICAgICBpZiAoIW5ld0hlYWQpIHtcbiAgICAgICAgICAgIG5ld0hlYWQgPSBjb3B5Q3Vyc29yKG9yaWdIZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICBpZiAoISh2aW0udmlzdWFsQmxvY2sgJiYgbmV3SGVhZC5jaCA9PT0gSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgIG5ld0hlYWQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXdIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdBbmNob3IpIHtcbiAgICAgICAgICAgICAgbmV3QW5jaG9yID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3QW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FuY2hvciA9IG5ld0FuY2hvciB8fCBvbGRBbmNob3I7XG4gICAgICAgICAgICBzZWwuYW5jaG9yID0gbmV3QW5jaG9yO1xuICAgICAgICAgICAgc2VsLmhlYWQgPSBuZXdIZWFkO1xuICAgICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPCcsXG4gICAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobmV3QW5jaG9yLCBuZXdIZWFkKSA/IG5ld0FuY2hvclxuICAgICAgICAgICAgICAgICAgICA6IG5ld0hlYWQpO1xuICAgICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsXG4gICAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobmV3QW5jaG9yLCBuZXdIZWFkKSA/IG5ld0hlYWRcbiAgICAgICAgICAgICAgICAgICAgOiBuZXdBbmNob3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICBuZXdIZWFkID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3SGVhZCk7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3IobmV3SGVhZC5saW5lLCBuZXdIZWFkLmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKG9wZXJhdG9yQXJncy5sYXN0U2VsKSB7XG4gICAgICAgICAgICAvLyBSZXBsYXlpbmcgYSB2aXN1YWwgbW9kZSBvcGVyYXRpb25cbiAgICAgICAgICAgIG5ld0FuY2hvciA9IG9sZEFuY2hvcjtcbiAgICAgICAgICAgIHZhciBsYXN0U2VsID0gb3BlcmF0b3JBcmdzLmxhc3RTZWw7XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IE1hdGguYWJzKGxhc3RTZWwuaGVhZC5saW5lIC0gbGFzdFNlbC5hbmNob3IubGluZSk7XG4gICAgICAgICAgICB2YXIgY2hPZmZzZXQgPSBNYXRoLmFicyhsYXN0U2VsLmhlYWQuY2ggLSBsYXN0U2VsLmFuY2hvci5jaCk7XG4gICAgICAgICAgICBpZiAobGFzdFNlbC52aXN1YWxMaW5lKSB7XG4gICAgICAgICAgICAgIC8vIExpbmV3aXNlIFZpc3VhbCBtb2RlOiBUaGUgc2FtZSBudW1iZXIgb2YgbGluZXMuXG4gICAgICAgICAgICAgIG5ld0hlYWQgPSBuZXcgUG9zKG9sZEFuY2hvci5saW5lICsgbGluZU9mZnNldCwgb2xkQW5jaG9yLmNoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFNlbC52aXN1YWxCbG9jaykge1xuICAgICAgICAgICAgICAvLyBCbG9ja3dpc2UgVmlzdWFsIG1vZGU6IFRoZSBzYW1lIG51bWJlciBvZiBsaW5lcyBhbmQgY29sdW1ucy5cbiAgICAgICAgICAgICAgbmV3SGVhZCA9IG5ldyBQb3Mob2xkQW5jaG9yLmxpbmUgKyBsaW5lT2Zmc2V0LCBvbGRBbmNob3IuY2ggKyBjaE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTZWwuaGVhZC5saW5lID09IGxhc3RTZWwuYW5jaG9yLmxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gTm9ybWFsIFZpc3VhbCBtb2RlIHdpdGhpbiBvbmUgbGluZTogVGhlIHNhbWUgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIG5ld0hlYWQgPSBuZXcgUG9zKG9sZEFuY2hvci5saW5lLCBvbGRBbmNob3IuY2ggKyBjaE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3JtYWwgVmlzdWFsIG1vZGUgd2l0aCBzZXZlcmFsIGxpbmVzOiBUaGUgc2FtZSBudW1iZXIgb2YgbGluZXMsIGluIHRoZVxuICAgICAgICAgICAgICAvLyBsYXN0IGxpbmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYXMgaW4gdGhlIGxhc3QgbGluZSB0aGUgbGFzdCB0aW1lLlxuICAgICAgICAgICAgICBuZXdIZWFkID0gbmV3IFBvcyhvbGRBbmNob3IubGluZSArIGxpbmVPZmZzZXQsIG9sZEFuY2hvci5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aW0udmlzdWFsTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB2aW0udmlzdWFsTGluZSA9IGxhc3RTZWwudmlzdWFsTGluZTtcbiAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGxhc3RTZWwudmlzdWFsQmxvY2s7XG4gICAgICAgICAgICBzZWwgPSB2aW0uc2VsID0ge1xuICAgICAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICAgICAgICAgICAgaGVhZDogbmV3SGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwZGF0ZUNtU2VsZWN0aW9uKGNtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICBvcGVyYXRvckFyZ3MubGFzdFNlbCA9IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBjb3B5Q3Vyc29yKHNlbC5hbmNob3IpLFxuICAgICAgICAgICAgICBoZWFkOiBjb3B5Q3Vyc29yKHNlbC5oZWFkKSxcbiAgICAgICAgICAgICAgdmlzdWFsQmxvY2s6IHZpbS52aXN1YWxCbG9jayxcbiAgICAgICAgICAgICAgdmlzdWFsTGluZTogdmltLnZpc3VhbExpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJTdGFydCwgY3VyRW5kLCBsaW5ld2lzZSwgbW9kZTtcbiAgICAgICAgICB2YXIgY21TZWw7XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICAvLyBJbml0IHZpc3VhbCBvcFxuICAgICAgICAgICAgY3VyU3RhcnQgPSBjdXJzb3JNaW4oc2VsLmhlYWQsIHNlbC5hbmNob3IpO1xuICAgICAgICAgICAgY3VyRW5kID0gY3Vyc29yTWF4KHNlbC5oZWFkLCBzZWwuYW5jaG9yKTtcbiAgICAgICAgICAgIGxpbmV3aXNlID0gdmltLnZpc3VhbExpbmUgfHwgb3BlcmF0b3JBcmdzLmxpbmV3aXNlO1xuICAgICAgICAgICAgbW9kZSA9IHZpbS52aXN1YWxCbG9jayA/ICdibG9jaycgOlxuICAgICAgICAgICAgICAgICAgIGxpbmV3aXNlID8gJ2xpbmUnIDpcbiAgICAgICAgICAgICAgICAgICAnY2hhcic7XG4gICAgICAgICAgICBjbVNlbCA9IG1ha2VDbVNlbGVjdGlvbihjbSwge1xuICAgICAgICAgICAgICBhbmNob3I6IGN1clN0YXJ0LFxuICAgICAgICAgICAgICBoZWFkOiBjdXJFbmRcbiAgICAgICAgICAgIH0sIG1vZGUpO1xuICAgICAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgICAgIHZhciByYW5nZXMgPSBjbVNlbC5yYW5nZXM7XG4gICAgICAgICAgICAgIGlmIChtb2RlID09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5ld2lzZSBvcGVyYXRvcnMgaW4gdmlzdWFsIGJsb2NrIG1vZGUgZXh0ZW5kIHRvIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHJhbmdlc1tpXS5oZWFkLmNoID0gbGluZUxlbmd0aChjbSwgcmFuZ2VzW2ldLmhlYWQubGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzWzBdLmhlYWQgPSBuZXcgUG9zKHJhbmdlc1swXS5oZWFkLmxpbmUgKyAxLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbml0IG1vdGlvbiBvcFxuICAgICAgICAgICAgY3VyU3RhcnQgPSBjb3B5Q3Vyc29yKG5ld0FuY2hvciB8fCBvbGRBbmNob3IpO1xuICAgICAgICAgICAgY3VyRW5kID0gY29weUN1cnNvcihuZXdIZWFkIHx8IG9sZEhlYWQpO1xuICAgICAgICAgICAgaWYgKGN1cnNvcklzQmVmb3JlKGN1ckVuZCwgY3VyU3RhcnQpKSB7XG4gICAgICAgICAgICAgIHZhciB0bXAgPSBjdXJTdGFydDtcbiAgICAgICAgICAgICAgY3VyU3RhcnQgPSBjdXJFbmQ7XG4gICAgICAgICAgICAgIGN1ckVuZCA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmV3aXNlID0gbW90aW9uQXJncy5saW5ld2lzZSB8fCBvcGVyYXRvckFyZ3MubGluZXdpc2U7XG4gICAgICAgICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgICAgICAgLy8gRXhwYW5kIHNlbGVjdGlvbiB0byBlbnRpcmUgbGluZS5cbiAgICAgICAgICAgICAgZXhwYW5kU2VsZWN0aW9uVG9MaW5lKGNtLCBjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgICAgIC8vIENsaXAgdG8gdHJhaWxpbmcgbmV3bGluZXMgb25seSBpZiB0aGUgbW90aW9uIGdvZXMgZm9yd2FyZC5cbiAgICAgICAgICAgICAgY2xpcFRvTGluZShjbSwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlID0gJ2NoYXInO1xuICAgICAgICAgICAgdmFyIGV4Y2x1c2l2ZSA9ICFtb3Rpb25BcmdzLmluY2x1c2l2ZSB8fCBsaW5ld2lzZTtcbiAgICAgICAgICAgIGNtU2VsID0gbWFrZUNtU2VsZWN0aW9uKGNtLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogY3VyU3RhcnQsXG4gICAgICAgICAgICAgIGhlYWQ6IGN1ckVuZFxuICAgICAgICAgICAgfSwgbW9kZSwgZXhjbHVzaXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhjbVNlbC5yYW5nZXMsIGNtU2VsLnByaW1hcnkpO1xuICAgICAgICAgIHZpbS5sYXN0TW90aW9uID0gbnVsbDtcbiAgICAgICAgICBvcGVyYXRvckFyZ3MucmVwZWF0ID0gcmVwZWF0OyAvLyBGb3IgaW5kZW50IGluIHZpc3VhbCBtb2RlLlxuICAgICAgICAgIG9wZXJhdG9yQXJncy5yZWdpc3Rlck5hbWUgPSByZWdpc3Rlck5hbWU7XG4gICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBsaW5ld2lzZSBhcyBpdCBhZmZlY3RzIGhvdyBwYXN0ZSBhbmQgY2hhbmdlIGJlaGF2ZS5cbiAgICAgICAgICBvcGVyYXRvckFyZ3MubGluZXdpc2UgPSBsaW5ld2lzZTtcbiAgICAgICAgICB2YXIgb3BlcmF0b3JNb3ZlVG8gPSBvcGVyYXRvcnNbb3BlcmF0b3JdKFxuICAgICAgICAgICAgY20sIG9wZXJhdG9yQXJncywgY21TZWwucmFuZ2VzLCBvbGRBbmNob3IsIG5ld0hlYWQpO1xuICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIG9wZXJhdG9yTW92ZVRvICE9IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlcmF0b3JNb3ZlVG8pIHtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihvcGVyYXRvck1vdmVUbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVjb3JkTGFzdEVkaXQ6IGZ1bmN0aW9uKHZpbSwgaW5wdXRTdGF0ZSwgYWN0aW9uQ29tbWFuZCkge1xuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgICAgdmltLmxhc3RFZGl0SW5wdXRTdGF0ZSA9IGlucHV0U3RhdGU7XG4gICAgICAgIHZpbS5sYXN0RWRpdEFjdGlvbkNvbW1hbmQgPSBhY3Rpb25Db21tYW5kO1xuICAgICAgICBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXMuY2hhbmdlcyA9IFtdO1xuICAgICAgICBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXMuZXhwZWN0Q3Vyc29yQWN0aXZpdHlGb3JDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLnZpc3VhbEJsb2NrID0gdmltLnZpc3VhbEJsb2NrID8gdmltLnNlbC5oZWFkLmxpbmUgLSB2aW0uc2VsLmFuY2hvci5saW5lIDogMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHlwZWRlZiB7T2JqZWN0e2xpbmU6bnVtYmVyLGNoOm51bWJlcn19IEN1cnNvciBBbiBvYmplY3QgY29udGFpbmluZyB0aGVcbiAgICAgKiAgICAgcG9zaXRpb24gb2YgdGhlIGN1cnNvci5cbiAgICAgKi9cbiAgICAvLyBBbGwgb2YgdGhlIGZ1bmN0aW9ucyBiZWxvdyByZXR1cm4gQ3Vyc29yIG9iamVjdHMuXG4gICAgdmFyIG1vdGlvbnMgPSB7XG4gICAgICBtb3ZlVG9Ub3BMaW5lOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBnZXRVc2VyVmlzaWJsZUxpbmVzKGNtKS50b3AgKyBtb3Rpb25BcmdzLnJlcGVhdCAtMTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvTWlkZGxlTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZ2V0VXNlclZpc2libGVMaW5lcyhjbSk7XG4gICAgICAgIHZhciBsaW5lID0gTWF0aC5mbG9vcigocmFuZ2UudG9wICsgcmFuZ2UuYm90dG9tKSAqIDAuNSk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmUsIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShsaW5lKSkpO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0JvdHRvbUxpbmU6IGZ1bmN0aW9uKGNtLCBfaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICB2YXIgbGluZSA9IGdldFVzZXJWaXNpYmxlTGluZXMoY20pLmJvdHRvbSAtIG1vdGlvbkFyZ3MucmVwZWF0ICsxO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUobGluZSkpKTtcbiAgICAgIH0sXG4gICAgICBleHBhbmRUb0xpbmU6IGZ1bmN0aW9uKF9jbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICAvLyBFeHBhbmRzIGZvcndhcmQgdG8gZW5kIG9mIGxpbmUsIGFuZCB0aGVuIHRvIG5leHQgbGluZSBpZiByZXBlYXQgaXNcbiAgICAgICAgLy8gPjEuIERvZXMgbm90IGhhbmRsZSBiYWNrd2FyZCBtb3Rpb24hXG4gICAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhjdXIubGluZSArIG1vdGlvbkFyZ3MucmVwZWF0IC0gMSwgSW5maW5pdHkpO1xuICAgICAgfSxcbiAgICAgIGZpbmROZXh0OiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gIW1vdGlvbkFyZ3MuZm9yd2FyZDtcbiAgICAgICAgLy8gSWYgc2VhcmNoIGlzIGluaXRpYXRlZCB3aXRoID8gaW5zdGVhZCBvZiAvLCBuZWdhdGUgZGlyZWN0aW9uLlxuICAgICAgICBwcmV2ID0gKHN0YXRlLmlzUmV2ZXJzZWQoKSkgPyAhcHJldiA6IHByZXY7XG4gICAgICAgIGhpZ2hsaWdodFNlYXJjaE1hdGNoZXMoY20sIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGZpbmROZXh0KGNtLCBwcmV2LyoqIHByZXYgKi8sIHF1ZXJ5LCBtb3Rpb25BcmdzLnJlcGVhdCk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LiBJZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseVxuICAgICAgICogd2l0aGluIGEgbWF0Y2gsIHRoZW4gZmluZCBhbmQgc2VsZWN0IHRoZSBjdXJyZW50IG1hdGNoLiBPdGhlcndpc2UsIGZpbmQgdGhlIG5leHQgb2NjdXJyZW5jZSBpbiB0aGVcbiAgICAgICAqIGFwcHJvcHJpYXRlIGRpcmVjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGRpZmZlcnMgZnJvbSBgZmluZE5leHRgIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAgICAgICAqXG4gICAgICAgKiAxLiBJbnN0ZWFkIG9mIG9ubHkgcmV0dXJuaW5nIHRoZSBcImZyb21cIiwgdGhpcyByZXR1cm5zIGEgXCJmcm9tXCIsIFwidG9cIiByYW5nZS5cbiAgICAgICAqIDIuIElmIHRoZSBjdXJzb3IgaXMgY3VycmVudGx5IGluc2lkZSBhIHNlYXJjaCBtYXRjaCwgdGhpcyBzZWxlY3RzIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiAgICBpbnN0ZWFkIG9mIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICogMy4gSWYgdGhlcmUgaXMgbm8gYXNzb2NpYXRlZCBvcGVyYXRvciwgdGhpcyB3aWxsIHR1cm4gb24gdmlzdWFsIG1vZGUuXG4gICAgICAgKi9cbiAgICAgIGZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgcHJldklucHV0U3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuXG4gICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldiA9ICFtb3Rpb25BcmdzLmZvcndhcmQ7XG4gICAgICAgIHByZXYgPSAoc3RhdGUuaXNSZXZlcnNlZCgpKSA/ICFwcmV2IDogcHJldjtcblxuICAgICAgICAvLyBuZXh0OiBbZnJvbSwgdG9dIHwgbnVsbFxuICAgICAgICB2YXIgbmV4dCA9IGZpbmROZXh0RnJvbUFuZFRvSW5jbHVzaXZlKGNtLCBwcmV2LCBxdWVyeSwgbW90aW9uQXJncy5yZXBlYXQsIHZpbSk7XG5cbiAgICAgICAgLy8gTm8gbWF0Y2hlcy5cbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBvcGVyYXRvciB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQsIHJldHVybiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICBpZiAocHJldklucHV0U3RhdGUub3BlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhhdCB0aGVyZSBpcyBubyBhY2NvbXBhbnlpbmcgb3BlcmF0b3IgLS0gbGV0J3NcbiAgICAgICAgLy8gZGVhbCB3aXRoIHZpc3VhbCBtb2RlIGluIG9yZGVyIHRvIHNlbGVjdCBhbiBhcHByb3ByaWF0ZSBtYXRjaC5cblxuICAgICAgICB2YXIgZnJvbSA9IG5leHRbMF07XG4gICAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIHdoZW4gd2UgdXNlIHRoZSBcInRvXCIgYXMgcmV0dXJuZWQgYnkgc2VhcmNoY3Vyc29yLmpzIGRpcmVjdGx5LFxuICAgICAgICAvLyB0aGUgcmVzdWx0aW5nIHNlbGVjdGlvbiBpcyBleHRlbmRlZCBieSAxIGNoYXIuIExldCdzIHNocmluayBpdCBzbyB0aGF0IG9ubHkgdGhlXG4gICAgICAgIC8vIG1hdGNoIGlzIHNlbGVjdGVkLlxuICAgICAgICB2YXIgdG8gPSBuZXcgUG9zKG5leHRbMV0ubGluZSwgbmV4dFsxXS5jaCAtIDEpO1xuXG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIC8vIElmIHdlIHdlcmUgaW4gdmlzdWFsTGluZSBvciB2aXN1YWxCbG9jayBtb2RlLCBnZXQgb3V0IG9mIGl0LlxuICAgICAgICAgIGlmICh2aW0udmlzdWFsTGluZSB8fCB2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB2aW0udmlzdWFsQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJ2aXN1YWxcIiwgc3ViTW9kZTogXCJcIn0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiB2aXN1YWwgbW9kZSwgd2Ugc2hvdWxkIGV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIGluY2x1ZGVcbiAgICAgICAgICAvLyB0aGUgc2VhcmNoIHJlc3VsdC5cbiAgICAgICAgICB2YXIgYW5jaG9yID0gdmltLnNlbC5hbmNob3I7XG4gICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzUmV2ZXJzZWQoKSkge1xuICAgICAgICAgICAgICBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbmNob3IsIGZyb21dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFthbmNob3IsIHRvXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChtb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FuY2hvciwgdG9dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFthbmNob3IsIGZyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZXQncyB0dXJuIHZpc3VhbCBtb2RlIG9uLlxuICAgICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgICB2aW0udmlzdWFsTGluZSA9IGZhbHNlO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGZhbHNlO1xuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJ2aXN1YWxcIiwgc3ViTW9kZTogXCJcIn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZXYgPyBbdG8sIGZyb21dIDogW2Zyb20sIHRvXTtcbiAgICAgIH0sXG4gICAgICBnb1RvTWFyazogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmFyIHBvcyA9IGdldE1hcmtQb3MoY20sIHZpbSwgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3Rlcik7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICByZXR1cm4gbW90aW9uQXJncy5saW5ld2lzZSA/IHsgbGluZTogcG9zLmxpbmUsIGNoOiBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUocG9zLmxpbmUpKSB9IDogcG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb090aGVySGlnaGxpZ2h0ZWRFbmQ6IGZ1bmN0aW9uKGNtLCBfaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIGlmICh2aW0udmlzdWFsQmxvY2sgJiYgbW90aW9uQXJncy5zYW1lTGluZSkge1xuICAgICAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXcgUG9zKHNlbC5hbmNob3IubGluZSwgc2VsLmhlYWQuY2gpKSxcbiAgICAgICAgICAgIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIG5ldyBQb3Moc2VsLmhlYWQubGluZSwgc2VsLmFuY2hvci5jaCkpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKFt2aW0uc2VsLmhlYWQsIHZpbS5zZWwuYW5jaG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBqdW1wVG9NYXJrOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBiZXN0ID0gaGVhZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3Rpb25BcmdzLnJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGJlc3Q7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHZpbS5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFpc0xvd2VyQ2FzZShrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hcmsgPSB2aW0ubWFya3Nba2V5XS5maW5kKCk7XG4gICAgICAgICAgICB2YXIgaXNXcm9uZ0RpcmVjdGlvbiA9IChtb3Rpb25BcmdzLmZvcndhcmQpID9cbiAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobWFyaywgY3Vyc29yKSA6IGN1cnNvcklzQmVmb3JlKGN1cnNvciwgbWFyayk7XG5cbiAgICAgICAgICAgIGlmIChpc1dyb25nRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UgJiYgKG1hcmsubGluZSA9PSBjdXJzb3IubGluZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlcXVhbCA9IGN1cnNvckVxdWFsKGN1cnNvciwgYmVzdCk7XG4gICAgICAgICAgICB2YXIgYmV0d2VlbiA9IChtb3Rpb25BcmdzLmZvcndhcmQpID9cbiAgICAgICAgICAgICAgY3Vyc29ySXNCZXR3ZWVuKGN1cnNvciwgbWFyaywgYmVzdCkgOlxuICAgICAgICAgICAgICBjdXJzb3JJc0JldHdlZW4oYmVzdCwgbWFyaywgY3Vyc29yKTtcblxuICAgICAgICAgICAgaWYgKGVxdWFsIHx8IGJldHdlZW4pIHtcbiAgICAgICAgICAgICAgYmVzdCA9IG1hcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UpIHtcbiAgICAgICAgICAvLyBWaW0gcGxhY2VzIHRoZSBjdXJzb3Igb24gdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvZlxuICAgICAgICAgIC8vIHRoZSBsaW5lIGlmIHRoZXJlIGlzIG9uZSwgZWxzZSBpdCBwbGFjZXMgdGhlIGN1cnNvciBhdCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIGxpbmUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhIG1hcmsgd2FzIGZvdW5kLlxuICAgICAgICAgIGJlc3QgPSBuZXcgUG9zKGJlc3QubGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGJlc3QubGluZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlDaGFyYWN0ZXJzOiBmdW5jdGlvbihfY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGN1ciA9IGhlYWQ7XG4gICAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgdmFyIGNoID0gbW90aW9uQXJncy5mb3J3YXJkID8gY3VyLmNoICsgcmVwZWF0IDogY3VyLmNoIC0gcmVwZWF0O1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhjdXIubGluZSwgY2gpO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeUxpbmVzOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgICB2YXIgZW5kQ2ggPSBjdXIuY2g7XG4gICAgICAgIC8vIERlcGVuZGluZyB3aGF0IG91ciBsYXN0IG1vdGlvbiB3YXMsIHdlIG1heSB3YW50IHRvIGRvIGRpZmZlcmVudFxuICAgICAgICAvLyB0aGluZ3MuIElmIG91ciBsYXN0IG1vdGlvbiB3YXMgbW92aW5nIHZlcnRpY2FsbHksIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgdGhlIEhQb3MgZnJvbSBvdXIgbGFzdCBob3Jpem9udGFsIG1vdmUuICBJZiBvdXIgbGFzdCBtb3Rpb25cbiAgICAgICAgLy8gd2FzIGdvaW5nIHRvIHRoZSBlbmQgb2YgYSBsaW5lLCBtb3ZpbmcgdmVydGljYWxseSB3ZSBzaG91bGQgZ28gdG9cbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgbGluZSwgZXRjLlxuICAgICAgICBzd2l0Y2ggKHZpbS5sYXN0TW90aW9uKSB7XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVCeUxpbmVzOlxuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlEaXNwbGF5TGluZXM6XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVCeVNjcm9sbDpcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZVRvQ29sdW1uOlxuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Fb2w6XG4gICAgICAgICAgICBlbmRDaCA9IHZpbS5sYXN0SFBvcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2aW0ubGFzdEhQb3MgPSBlbmRDaDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQrKG1vdGlvbkFyZ3MucmVwZWF0T2Zmc2V0fHwwKTtcbiAgICAgICAgdmFyIGxpbmUgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjdXIubGluZSArIHJlcGVhdCA6IGN1ci5saW5lIC0gcmVwZWF0O1xuICAgICAgICB2YXIgZmlyc3QgPSBjbS5maXJzdExpbmUoKTtcbiAgICAgICAgdmFyIGxhc3QgPSBjbS5sYXN0TGluZSgpO1xuICAgICAgICB2YXIgcG9zViA9IGNtLmZpbmRQb3NWKGN1ciwgKG1vdGlvbkFyZ3MuZm9yd2FyZCA/IHJlcGVhdCA6IC1yZXBlYXQpLCAnbGluZScsIHZpbS5sYXN0SFNQb3MpO1xuICAgICAgICB2YXIgaGFzTWFya2VkVGV4dCA9IG1vdGlvbkFyZ3MuZm9yd2FyZCA/IHBvc1YubGluZSA+IGxpbmUgOiBwb3NWLmxpbmUgPCBsaW5lO1xuICAgICAgICBpZiAoaGFzTWFya2VkVGV4dCkge1xuICAgICAgICAgIGxpbmUgPSBwb3NWLmxpbmU7XG4gICAgICAgICAgZW5kQ2ggPSBwb3NWLmNoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZpbSBnbyB0byBsaW5lIGJlZ2luIG9yIGxpbmUgZW5kIHdoZW4gY3Vyc29yIGF0IGZpcnN0L2xhc3QgbGluZSBhbmRcbiAgICAgICAgLy8gbW92ZSB0byBwcmV2aW91cy9uZXh0IGxpbmUgaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAobGluZSA8IGZpcnN0ICYmIGN1ci5saW5lID09IGZpcnN0KXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlVG9TdGFydE9mTGluZShjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lID4gbGFzdCAmJiBjdXIubGluZSA9PSBsYXN0KXtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlVG9Fb2woY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdGlvbkFyZ3MudG9GaXJzdENoYXIpe1xuICAgICAgICAgIGVuZENoPWZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShsaW5lKSk7XG4gICAgICAgICAgdmltLmxhc3RIUG9zID0gZW5kQ2g7XG4gICAgICAgIH1cbiAgICAgICAgdmltLmxhc3RIU1BvcyA9IGNtLmNoYXJDb29yZHMobmV3IFBvcyhsaW5lLCBlbmRDaCksJ2RpdicpLmxlZnQ7XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmUsIGVuZENoKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlEaXNwbGF5TGluZXM6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmFyIGN1ciA9IGhlYWQ7XG4gICAgICAgIHN3aXRjaCAodmltLmxhc3RNb3Rpb24pIHtcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZUJ5RGlzcGxheUxpbmVzOlxuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlTY3JvbGw6XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVCeUxpbmVzOlxuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Db2x1bW46XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVUb0VvbDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2aW0ubGFzdEhTUG9zID0gY20uY2hhckNvb3JkcyhjdXIsJ2RpdicpLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICB2YXIgcmVzPWNtLmZpbmRQb3NWKGN1ciwobW90aW9uQXJncy5mb3J3YXJkID8gcmVwZWF0IDogLXJlcGVhdCksJ2xpbmUnLHZpbS5sYXN0SFNQb3MpO1xuICAgICAgICBpZiAocmVzLmhpdFNpZGUpIHtcbiAgICAgICAgICBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoYXJDb29yZHMgPSBjbS5jaGFyQ29vcmRzKHJlcywgJ2RpdicpO1xuICAgICAgICAgICAgdmFyIGdvYWxDb29yZHMgPSB7IHRvcDogbGFzdENoYXJDb29yZHMudG9wICsgOCwgbGVmdDogdmltLmxhc3RIU1BvcyB9O1xuICAgICAgICAgICAgdmFyIHJlcyA9IGNtLmNvb3Jkc0NoYXIoZ29hbENvb3JkcywgJ2RpdicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzQ29vcmRzID0gY20uY2hhckNvb3JkcyhuZXcgUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgJ2RpdicpO1xuICAgICAgICAgICAgcmVzQ29vcmRzLmxlZnQgPSB2aW0ubGFzdEhTUG9zO1xuICAgICAgICAgICAgcmVzID0gY20uY29vcmRzQ2hhcihyZXNDb29yZHMsICdkaXYnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmltLmxhc3RIUG9zID0gcmVzLmNoO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeVBhZ2U6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIC8vIENvZGVNaXJyb3Igb25seSBleHBvc2VzIGZ1bmN0aW9ucyB0aGF0IG1vdmUgdGhlIGN1cnNvciBwYWdlIGRvd24sIHNvXG4gICAgICAgIC8vIGRvaW5nIHRoaXMgYmFkIGhhY2sgdG8gbW92ZSB0aGUgY3Vyc29yIGFuZCBtb3ZlIGl0IGJhY2suIGV2YWxJbnB1dFxuICAgICAgICAvLyB3aWxsIG1vdmUgdGhlIGN1cnNvciB0byB3aGVyZSBpdCBzaG91bGQgYmUgaW4gdGhlIGVuZC5cbiAgICAgICAgdmFyIGN1clN0YXJ0ID0gaGVhZDtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICByZXR1cm4gY20uZmluZFBvc1YoY3VyU3RhcnQsIChtb3Rpb25BcmdzLmZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KSwgJ3BhZ2UnKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlQYXJhZ3JhcGg6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBkaXIgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBmaW5kUGFyYWdyYXBoKGNtLCBoZWFkLCBtb3Rpb25BcmdzLnJlcGVhdCwgZGlyKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlTZW50ZW5jZTogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGRpciA9IG1vdGlvbkFyZ3MuZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGZpbmRTZW50ZW5jZShjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsIGRpcik7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5U2Nyb2xsOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBzY3JvbGxib3ggPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgICAgIHZhciBjdXJFbmQgPSBudWxsO1xuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgcmVwZWF0ID0gc2Nyb2xsYm94LmNsaWVudEhlaWdodCAvICgyICogY20uZGVmYXVsdFRleHRIZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWcgPSBjbS5jaGFyQ29vcmRzKGhlYWQsICdsb2NhbCcpO1xuICAgICAgICBtb3Rpb25BcmdzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgdmFyIGN1ckVuZCA9IG1vdGlvbnMubW92ZUJ5RGlzcGxheUxpbmVzKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pO1xuICAgICAgICBpZiAoIWN1ckVuZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXN0ID0gY20uY2hhckNvb3JkcyhjdXJFbmQsICdsb2NhbCcpO1xuICAgICAgICBjbS5zY3JvbGxUbyhudWxsLCBzY3JvbGxib3gudG9wICsgZGVzdC50b3AgLSBvcmlnLnRvcCk7XG4gICAgICAgIHJldHVybiBjdXJFbmQ7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5V29yZHM6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9Xb3JkKGNtLCBoZWFkLCBtb3Rpb25BcmdzLnJlcGVhdCwgISFtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgICAhIW1vdGlvbkFyZ3Mud29yZEVuZCwgISFtb3Rpb25BcmdzLmJpZ1dvcmQpO1xuICAgICAgfSxcbiAgICAgIG1vdmVUaWxsQ2hhcmFjdGVyOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICB2YXIgY3VyRW5kID0gbW92ZVRvQ2hhcmFjdGVyKGNtLCByZXBlYXQsIG1vdGlvbkFyZ3MuZm9yd2FyZCxcbiAgICAgICAgICAgIG1vdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXIpO1xuICAgICAgICB2YXIgaW5jcmVtZW50ID0gbW90aW9uQXJncy5mb3J3YXJkID8gLTEgOiAxO1xuICAgICAgICByZWNvcmRMYXN0Q2hhcmFjdGVyU2VhcmNoKGluY3JlbWVudCwgbW90aW9uQXJncyk7XG4gICAgICAgIGlmICghY3VyRW5kKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY3VyRW5kLmNoICs9IGluY3JlbWVudDtcbiAgICAgICAgcmV0dXJuIGN1ckVuZDtcbiAgICAgIH0sXG4gICAgICBtb3ZlVG9DaGFyYWN0ZXI6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgcmVjb3JkTGFzdENoYXJhY3RlclNlYXJjaCgwLCBtb3Rpb25BcmdzKTtcbiAgICAgICAgcmV0dXJuIG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgICBtb3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyKSB8fCBoZWFkO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb1N5bWJvbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICByZXR1cm4gZmluZFN5bWJvbChjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgICBtb3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyKSB8fCBoZWFkO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0NvbHVtbjogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIC8vIHJlcGVhdCBpcyBlcXVpdmFsZW50IHRvIHdoaWNoIGNvbHVtbiB3ZSB3YW50IHRvIG1vdmUgdG8hXG4gICAgICAgIHZpbS5sYXN0SFBvcyA9IHJlcGVhdCAtIDE7XG4gICAgICAgIHZpbS5sYXN0SFNQb3MgPSBjbS5jaGFyQ29vcmRzKGhlYWQsJ2RpdicpLmxlZnQ7XG4gICAgICAgIHJldHVybiBtb3ZlVG9Db2x1bW4oY20sIHJlcGVhdCk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvRW9sOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9Fb2woY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcjogZnVuY3Rpb24oY20sIGhlYWQpIHtcbiAgICAgICAgLy8gR28gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHdoZXJlIHRoZSB0ZXh0IGJlZ2lucywgb3IgdGhlIGVuZCBmb3JcbiAgICAgICAgLy8gd2hpdGVzcGFjZS1vbmx5IGxpbmVzXG4gICAgICAgIHZhciBjdXJzb3IgPSBoZWFkO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhjdXJzb3IubGluZSxcbiAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUoY3Vyc29yLmxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvTWF0Y2hlZFN5bWJvbDogZnVuY3Rpb24oY20sIGhlYWQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGhlYWQ7XG4gICAgICAgIHZhciBsaW5lID0gY3Vyc29yLmxpbmU7XG4gICAgICAgIHZhciBjaCA9IGN1cnNvci5jaDtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgZm9yICg7IGNoIDwgbGluZVRleHQubGVuZ3RoOyBjaCsrKSB7XG4gICAgICAgICAgc3ltYm9sID0gbGluZVRleHQuY2hhckF0KGNoKTtcbiAgICAgICAgICBpZiAoc3ltYm9sICYmIGlzTWF0Y2hhYmxlU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNtLmdldFRva2VuVHlwZUF0KG5ldyBQb3MobGluZSwgY2ggKyAxKSk7XG4gICAgICAgICAgICBpZiAoc3R5bGUgIT09IFwic3RyaW5nXCIgJiYgc3R5bGUgIT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPCBsaW5lVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBPbmx5IGluY2x1ZGUgYW5nbGUgYnJhY2tldHMgaW4gYW5hbHlzaXMgaWYgdGhleSBhcmUgYmVpbmcgbWF0Y2hlZC5cbiAgICAgICAgICB2YXIgcmUgPSAoY2ggPT09ICc8JyB8fCBjaCA9PT0gJz4nKSA/IC9bKCl7fVtcXF08Pl0vIDogL1soKXt9W1xcXV0vO1xuICAgICAgICAgIHZhciBtYXRjaGVkID0gY20uZmluZE1hdGNoaW5nQnJhY2tldChuZXcgUG9zKGxpbmUsIGNoKSwge2JyYWNrZXRSZWdleDogcmV9KTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlZC50bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW92ZVRvU3RhcnRPZkxpbmU6IGZ1bmN0aW9uKF9jbSwgaGVhZCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhoZWFkLmxpbmUsIDApO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50OiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjbS5sYXN0TGluZSgpIDogY20uZmlyc3RMaW5lKCk7XG4gICAgICAgIGlmIChtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQpIHtcbiAgICAgICAgICBsaW5lTnVtID0gbW90aW9uQXJncy5yZXBlYXQgLSBjbS5nZXRPcHRpb24oJ2ZpcnN0TGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmVOdW0sXG4gICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmVOdW0pKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvU3RhcnRPZkRpc3BsYXlMaW5lOiBmdW5jdGlvbihjbSkge1xuICAgICAgICBjbS5leGVjQ29tbWFuZChcImdvTGluZUxlZnRcIik7XG4gICAgICAgIHJldHVybiBjbS5nZXRDdXJzb3IoKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlVG9FbmRPZkRpc3BsYXlMaW5lOiBmdW5jdGlvbihjbSkge1xuICAgICAgICBjbS5leGVjQ29tbWFuZChcImdvTGluZVJpZ2h0XCIpO1xuICAgICAgICB2YXIgaGVhZCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAoaGVhZC5zdGlja3kgPT0gXCJiZWZvcmVcIikgaGVhZC5jaC0tO1xuICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgIH0sXG4gICAgICB0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIC8vIFRPRE86IGxvdHMgb2YgcG9zc2libGUgZXhjZXB0aW9ucyB0aGF0IGNhbiBiZSB0aHJvd24gaGVyZS4gVHJ5IGRhKFxuICAgICAgICAvLyAgICAgb3V0c2lkZSBvZiBhICgpIGJsb2NrLlxuICAgICAgICB2YXIgbWlycm9yZWRQYWlycyA9IHsnKCc6ICcpJywgJyknOiAnKCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7JzogJ30nLCAnfSc6ICd7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snOiAnXScsICddJzogJ1snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPCc6ICc+JywgJz4nOiAnPCd9O1xuICAgICAgICB2YXIgc2VsZlBhaXJlZCA9IHsnXFwnJzogdHJ1ZSwgJ1wiJzogdHJ1ZSwgJ2AnOiB0cnVlfTtcblxuICAgICAgICB2YXIgY2hhcmFjdGVyID0gbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgICAgLy8gJ2InIHJlZmVycyB0byAgJygpJyBibG9jay5cbiAgICAgICAgLy8gJ0InIHJlZmVycyB0byAgJ3t9JyBibG9jay5cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PSAnYicpIHtcbiAgICAgICAgICBjaGFyYWN0ZXIgPSAnKCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09ICdCJykge1xuICAgICAgICAgIGNoYXJhY3RlciA9ICd7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY2x1c2l2ZSBpcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgYW5kIGlcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB1c2luZyB0aGUgYWRkaXRpb25hbCB0ZXh0IG9iamVjdCBtYXAgdG8gcGVyZm9ybSB0ZXh0XG4gICAgICAgIC8vICAgICBvYmplY3Qgb3BlcmF0aW9ucywgbWVyZ2UgdGhlIG1hcCBpbnRvIHRoZSBkZWZhdWx0S2V5TWFwIGFuZCB1c2VcbiAgICAgICAgLy8gICAgIG1vdGlvbkFyZ3MgdG8gZGVmaW5lIGJlaGF2aW9yLiBEZWZpbmUgc2VwYXJhdGUgZW50cmllcyBmb3IgJ2F3JyxcbiAgICAgICAgLy8gICAgICdpdycsICdhWycsICdpWycsIGV0Yy5cbiAgICAgICAgdmFyIGluY2x1c2l2ZSA9ICFtb3Rpb25BcmdzLnRleHRPYmplY3RJbm5lcjtcblxuICAgICAgICB2YXIgdG1wO1xuICAgICAgICBpZiAobWlycm9yZWRQYWlyc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgdG1wID0gc2VsZWN0Q29tcGFuaW9uT2JqZWN0KGNtLCBoZWFkLCBjaGFyYWN0ZXIsIGluY2x1c2l2ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZlBhaXJlZFtjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgdG1wID0gZmluZEJlZ2lubmluZ0FuZEVuZChjbSwgaGVhZCwgY2hhcmFjdGVyLCBpbmNsdXNpdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1cnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCBpbmNsdXNpdmUsIHRydWUgLyoqIGZvcndhcmQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgLyoqIGJpZ1dvcmQgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ3cnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCBpbmNsdXNpdmUsIHRydWUgLyoqIGZvcndhcmQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIC8qKiBiaWdXb3JkICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICdwJykge1xuICAgICAgICAgIHRtcCA9IGZpbmRQYXJhZ3JhcGgoY20sIGhlYWQsIG1vdGlvbkFyZ3MucmVwZWF0LCAwLCBpbmNsdXNpdmUpO1xuICAgICAgICAgIG1vdGlvbkFyZ3MubGluZXdpc2UgPSB0cnVlO1xuICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgaWYgKCF2aW0udmlzdWFsTGluZSkgeyB2aW0udmlzdWFsTGluZSA9IHRydWU7IH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yQXJncyA9IHZpbS5pbnB1dFN0YXRlLm9wZXJhdG9yQXJncztcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckFyZ3MpIHsgb3BlcmF0b3JBcmdzLmxpbmV3aXNlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdG1wLmVuZC5saW5lLS07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ3QnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kVGFnVW5kZXJDdXJzb3IoY20sIGhlYWQsIGluY2x1c2l2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gdGV4dCBvYmplY3QgZGVmaW5lZCBmb3IgdGhpcywgZG9uJ3QgbW92ZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY20uc3RhdGUudmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gW3RtcC5zdGFydCwgdG1wLmVuZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGFuZFNlbGVjdGlvbihjbSwgdG1wLnN0YXJ0LCB0bXAuZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVwZWF0TGFzdENoYXJhY3RlclNlYXJjaDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxhc3RTZWFyY2ggPSB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoO1xuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHZhciBmb3J3YXJkID0gbW90aW9uQXJncy5mb3J3YXJkID09PSBsYXN0U2VhcmNoLmZvcndhcmQ7XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSAobGFzdFNlYXJjaC5pbmNyZW1lbnQgPyAxIDogMCkgKiAoZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgICAgIGNtLm1vdmVIKC1pbmNyZW1lbnQsICdjaGFyJyk7XG4gICAgICAgIG1vdGlvbkFyZ3MuaW5jbHVzaXZlID0gZm9yd2FyZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIGN1ckVuZCA9IG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBmb3J3YXJkLCBsYXN0U2VhcmNoLnNlbGVjdGVkQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKCFjdXJFbmQpIHtcbiAgICAgICAgICBjbS5tb3ZlSChpbmNyZW1lbnQsICdjaGFyJyk7XG4gICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VyRW5kLmNoICs9IGluY3JlbWVudDtcbiAgICAgICAgcmV0dXJuIGN1ckVuZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lTW90aW9uKG5hbWUsIGZuKSB7XG4gICAgICBtb3Rpb25zW25hbWVdID0gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbEFycmF5KHZhbCwgdGltZXMpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xuICAgICAgICBhcnIucHVzaCh2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3BlcmF0b3IgYWN0cyBvbiBhIHRleHQgc2VsZWN0aW9uLiBJdCByZWNlaXZlcyB0aGUgbGlzdCBvZiBzZWxlY3Rpb25zXG4gICAgICogYXMgaW5wdXQuIFRoZSBjb3JyZXNwb25kaW5nIENvZGVNaXJyb3Igc2VsZWN0aW9uIGlzIGd1YXJhbnRlZWQgdG9cbiAgICAqIG1hdGNoIHRoZSBpbnB1dCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgIGNoYW5nZTogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgICB2YXIgZmluYWxIZWFkLCB0ZXh0O1xuICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICB2YXIgYW5jaG9yID0gcmFuZ2VzWzBdLmFuY2hvcixcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZXNbMF0uaGVhZDtcbiAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIHRleHQgPSBjbS5nZXRSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICAgIHZhciBsYXN0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlIHx8IHt9O1xuICAgICAgICAgIGlmIChsYXN0U3RhdGUubW90aW9uID09IFwibW92ZUJ5V29yZHNcIiAmJiAhaXNXaGl0ZVNwYWNlU3RyaW5nKHRleHQpKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaWYgdGhlIHJhbmdlIGlzIG5vdCBhbGwgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9ICgvXFxzKyQvKS5leGVjKHRleHQpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGxhc3RTdGF0ZS5tb3Rpb25BcmdzICYmIGxhc3RTdGF0ZS5tb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZXZMaW5lRW5kID0gbmV3IFBvcyhhbmNob3IubGluZSAtIDEsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgIHZhciB3YXNMYXN0TGluZSA9IGNtLmZpcnN0TGluZSgpID09IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgICAgaWYgKGhlYWQubGluZSA+IGNtLmxhc3RMaW5lKCkgJiYgYXJncy5saW5ld2lzZSAmJiAhd2FzTGFzdExpbmUpIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgcHJldkxpbmVFbmQsIGhlYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcmdzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgICAvLyBQdXNoIHRoZSBuZXh0IGxpbmUgYmFjayBkb3duLCBpZiB0aGVyZSBpcyBhIG5leHQgbGluZS5cbiAgICAgICAgICAgIGlmICghd2FzTGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHByZXZMaW5lRW5kKTtcbiAgICAgICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50KGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjdXJzb3IgZW5kcyB1cCBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICAgICAgYW5jaG9yLmNoID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxIZWFkID0gYW5jaG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MuZnVsbExpbmUpIHtcbiAgICAgICAgICAgIGhlYWQuY2ggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgaGVhZC5saW5lLS07XG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKVxuICAgICAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiKTtcbiAgICAgICAgICAgIGZpbmFsSGVhZCA9IGFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmlsbEFycmF5KCcnLCByYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudCk7XG4gICAgICAgICAgZmluYWxIZWFkID0gY3Vyc29yTWluKHJhbmdlc1swXS5oZWFkLCByYW5nZXNbMF0uYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgICBhcmdzLnJlZ2lzdGVyTmFtZSwgJ2NoYW5nZScsIHRleHQsXG4gICAgICAgICAgICBhcmdzLmxpbmV3aXNlLCByYW5nZXMubGVuZ3RoID4gMSk7XG4gICAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7aGVhZDogZmluYWxIZWFkfSwgY20uc3RhdGUudmltKTtcbiAgICAgIH0sXG4gICAgICAvLyBkZWxldGUgaXMgYSBqYXZhc2NyaXB0IGtleXdvcmQuXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgICB2YXIgZmluYWxIZWFkLCB0ZXh0O1xuICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICBpZiAoIXZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgIHZhciBhbmNob3IgPSByYW5nZXNbMF0uYW5jaG9yLFxuICAgICAgICAgICAgICBoZWFkID0gcmFuZ2VzWzBdLmhlYWQ7XG4gICAgICAgICAgaWYgKGFyZ3MubGluZXdpc2UgJiZcbiAgICAgICAgICAgICAgaGVhZC5saW5lICE9IGNtLmZpcnN0TGluZSgpICYmXG4gICAgICAgICAgICAgIGFuY2hvci5saW5lID09IGNtLmxhc3RMaW5lKCkgJiZcbiAgICAgICAgICAgICAgYW5jaG9yLmxpbmUgPT0gaGVhZC5saW5lIC0gMSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkZCBvbiBsYXN0IGxpbmUgKGFuZCBmaXJzdCBsaW5lKS5cbiAgICAgICAgICAgIGlmIChhbmNob3IubGluZSA9PSBjbS5maXJzdExpbmUoKSkge1xuICAgICAgICAgICAgICBhbmNob3IuY2ggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IFBvcyhhbmNob3IubGluZSAtIDEsIGxpbmVMZW5ndGgoY20sIGFuY2hvci5saW5lIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0ID0gY20uZ2V0UmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgZmluYWxIZWFkID0gYW5jaG9yO1xuICAgICAgICAgIGlmIChhcmdzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgICBmaW5hbEhlYWQgPSBtb3Rpb25zLm1vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbSwgYW5jaG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IGZpbGxBcnJheSgnJywgcmFuZ2VzLmxlbmd0aCk7XG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMocmVwbGFjZW1lbnQpO1xuICAgICAgICAgIGZpbmFsSGVhZCA9IGN1cnNvck1pbihyYW5nZXNbMF0uaGVhZCwgcmFuZ2VzWzBdLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLnB1c2hUZXh0KFxuICAgICAgICAgICAgYXJncy5yZWdpc3Rlck5hbWUsICdkZWxldGUnLCB0ZXh0LFxuICAgICAgICAgICAgYXJncy5saW5ld2lzZSwgdmltLnZpc3VhbEJsb2NrKTtcbiAgICAgICAgcmV0dXJuIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIGZpbmFsSGVhZCk7XG4gICAgICB9LFxuICAgICAgaW5kZW50OiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzKSB7XG4gICAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICAgIHZhciBzdGFydExpbmUgPSByYW5nZXNbMF0uYW5jaG9yLmxpbmU7XG4gICAgICAgIHZhciBlbmRMaW5lID0gdmltLnZpc3VhbEJsb2NrID9cbiAgICAgICAgICByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmFuY2hvci5saW5lIDpcbiAgICAgICAgICByYW5nZXNbMF0uaGVhZC5saW5lO1xuICAgICAgICAvLyBJbiB2aXN1YWwgbW9kZSwgbj4gc2hpZnRzIHRoZSBzZWxlY3Rpb24gcmlnaHQgbiB0aW1lcywgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzaGlmdGluZyBuIGxpbmVzIHJpZ2h0IG9uY2UuXG4gICAgICAgIHZhciByZXBlYXQgPSAodmltLnZpc3VhbE1vZGUpID8gYXJncy5yZXBlYXQgOiAxO1xuICAgICAgICBpZiAoYXJncy5saW5ld2lzZSkge1xuICAgICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBkZWxldGUgYSBuZXdsaW5lIGlzIHRvIGRlbGV0ZSB1bnRpbCB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAvLyB0aGUgbmV4dCBsaW5lLCBzbyBpbiBsaW5ld2lzZSBtb2RlIGV2YWxJbnB1dCB3aWxsIGluY2x1ZGUgdGhlIG5leHRcbiAgICAgICAgICAvLyBsaW5lLiBXZSBkb24ndCB3YW50IHRoaXMgaW4gaW5kZW50LCBzbyB3ZSBnbyBiYWNrIGEgbGluZS5cbiAgICAgICAgICBlbmRMaW5lLS07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGVhdDsgaisrKSB7XG4gICAgICAgICAgICBjbS5pbmRlbnRMaW5lKGksIGFyZ3MuaW5kZW50UmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIHJhbmdlc1swXS5hbmNob3IpO1xuICAgICAgfSxcbiAgICAgIGluZGVudEF1dG86IGZ1bmN0aW9uKGNtLCBfYXJncywgcmFuZ2VzKSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKFwiaW5kZW50QXV0b1wiKTtcbiAgICAgICAgcmV0dXJuIG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCByYW5nZXNbMF0uYW5jaG9yKTtcbiAgICAgIH0sXG4gICAgICBjaGFuZ2VDYXNlOiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzLCBvbGRBbmNob3IsIG5ld0hlYWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSBjbS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHZhciBzd2FwcGVkID0gW107XG4gICAgICAgIHZhciB0b0xvd2VyID0gYXJncy50b0xvd2VyO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdG9Td2FwID0gc2VsZWN0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICAgIGlmICh0b0xvd2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdG9Td2FwLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b0xvd2VyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRvU3dhcC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvU3dhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gdG9Td2FwLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgdGV4dCArPSBpc1VwcGVyQ2FzZShjaGFyYWN0ZXIpID8gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3YXBwZWQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzd2FwcGVkKTtcbiAgICAgICAgaWYgKGFyZ3Muc2hvdWxkTW92ZUN1cnNvcil7XG4gICAgICAgICAgcmV0dXJuIG5ld0hlYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLnN0YXRlLnZpbS52aXN1YWxNb2RlICYmIGFyZ3MubGluZXdpc2UgJiYgcmFuZ2VzWzBdLmFuY2hvci5saW5lICsgMSA9PSByYW5nZXNbMF0uaGVhZC5saW5lKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCBvbGRBbmNob3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGluZXdpc2Upe1xuICAgICAgICAgIHJldHVybiBvbGRBbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnNvck1pbihyYW5nZXNbMF0uYW5jaG9yLCByYW5nZXNbMF0uaGVhZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB5YW5rOiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzLCBvbGRBbmNob3IpIHtcbiAgICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGVuZFBvcyA9IHZpbS52aXN1YWxNb2RlXG4gICAgICAgICAgPyBjdXJzb3JNaW4odmltLnNlbC5hbmNob3IsIHZpbS5zZWwuaGVhZCwgcmFuZ2VzWzBdLmhlYWQsIHJhbmdlc1swXS5hbmNob3IpXG4gICAgICAgICAgOiBvbGRBbmNob3I7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5wdXNoVGV4dChcbiAgICAgICAgICAgIGFyZ3MucmVnaXN0ZXJOYW1lLCAneWFuaycsXG4gICAgICAgICAgICB0ZXh0LCBhcmdzLmxpbmV3aXNlLCB2aW0udmlzdWFsQmxvY2spO1xuICAgICAgICByZXR1cm4gZW5kUG9zO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVPcGVyYXRvcihuYW1lLCBmbikge1xuICAgICAgb3BlcmF0b3JzW25hbWVdID0gZm47XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbnMgPSB7XG4gICAgICBqdW1wTGlzdFdhbGs6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgdmFyIGZvcndhcmQgPSBhY3Rpb25BcmdzLmZvcndhcmQ7XG4gICAgICAgIHZhciBqdW1wTGlzdCA9IHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0O1xuXG4gICAgICAgIHZhciBtYXJrID0ganVtcExpc3QubW92ZShjbSwgZm9yd2FyZCA/IHJlcGVhdCA6IC1yZXBlYXQpO1xuICAgICAgICB2YXIgbWFya1BvcyA9IG1hcmsgPyBtYXJrLmZpbmQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWFya1BvcyA9IG1hcmtQb3MgPyBtYXJrUG9zIDogY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGNtLnNldEN1cnNvcihtYXJrUG9zKTtcbiAgICAgIH0sXG4gICAgICBzY3JvbGw6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdCB8fCAxO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGNtLmRlZmF1bHRUZXh0SGVpZ2h0KCk7XG4gICAgICAgIHZhciB0b3AgPSBjbS5nZXRTY3JvbGxJbmZvKCkudG9wO1xuICAgICAgICB2YXIgZGVsdGEgPSBsaW5lSGVpZ2h0ICogcmVwZWF0O1xuICAgICAgICB2YXIgbmV3UG9zID0gYWN0aW9uQXJncy5mb3J3YXJkID8gdG9wICsgZGVsdGEgOiB0b3AgLSBkZWx0YTtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgICB2YXIgY3Vyc29yQ29vcmRzID0gY20uY2hhckNvb3JkcyhjdXJzb3IsICdsb2NhbCcpO1xuICAgICAgICBpZiAoYWN0aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgaWYgKG5ld1BvcyA+IGN1cnNvckNvb3Jkcy50b3ApIHtcbiAgICAgICAgICAgICBjdXJzb3IubGluZSArPSAobmV3UG9zIC0gY3Vyc29yQ29vcmRzLnRvcCkgLyBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgIGN1cnNvci5saW5lID0gTWF0aC5jZWlsKGN1cnNvci5saW5lKTtcbiAgICAgICAgICAgICBjbS5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgICAgICBjdXJzb3JDb29yZHMgPSBjbS5jaGFyQ29vcmRzKGN1cnNvciwgJ2xvY2FsJyk7XG4gICAgICAgICAgICAgY20uc2Nyb2xsVG8obnVsbCwgY3Vyc29yQ29vcmRzLnRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAvLyBDdXJzb3Igc3RheXMgd2l0aGluIGJvdW5kcy4gIEp1c3QgcmVwb3NpdGlvbiB0aGUgc2Nyb2xsIHdpbmRvdy5cbiAgICAgICAgICAgICBjbS5zY3JvbGxUbyhudWxsLCBuZXdQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3Qm90dG9tID0gbmV3UG9zICsgY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodDtcbiAgICAgICAgICBpZiAobmV3Qm90dG9tIDwgY3Vyc29yQ29vcmRzLmJvdHRvbSkge1xuICAgICAgICAgICAgIGN1cnNvci5saW5lIC09IChjdXJzb3JDb29yZHMuYm90dG9tIC0gbmV3Qm90dG9tKSAvIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgY3Vyc29yLmxpbmUgPSBNYXRoLmZsb29yKGN1cnNvci5saW5lKTtcbiAgICAgICAgICAgICBjbS5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgICAgICBjdXJzb3JDb29yZHMgPSBjbS5jaGFyQ29vcmRzKGN1cnNvciwgJ2xvY2FsJyk7XG4gICAgICAgICAgICAgY20uc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgIG51bGwsIGN1cnNvckNvb3Jkcy5ib3R0b20gLSBjbS5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIC8vIEN1cnNvciBzdGF5cyB3aXRoaW4gYm91bmRzLiAgSnVzdCByZXBvc2l0aW9uIHRoZSBzY3JvbGwgd2luZG93LlxuICAgICAgICAgICAgIGNtLnNjcm9sbFRvKG51bGwsIG5ld1Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Nyb2xsVG9DdXJzb3I6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBsaW5lTnVtID0gY20uZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgICAgdmFyIGNoYXJDb29yZHMgPSBjbS5jaGFyQ29vcmRzKG5ldyBQb3MobGluZU51bSwgMCksICdsb2NhbCcpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHkgPSBjaGFyQ29vcmRzLnRvcDtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBjaGFyQ29vcmRzLmJvdHRvbSAtIHk7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uQXJncy5wb3NpdGlvbikge1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6IHkgPSB5IC0gKGhlaWdodCAvIDIpICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6IHkgPSB5IC0gaGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNjcm9sbFRvKG51bGwsIHkpO1xuICAgICAgfSxcbiAgICAgIHJlcGxheU1hY3JvOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgICAgICB2YXIgcmVwZWF0ID0gYWN0aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgICBpZiAocmVnaXN0ZXJOYW1lID09ICdAJykge1xuICAgICAgICAgIHJlZ2lzdGVyTmFtZSA9IG1hY3JvTW9kZVN0YXRlLmxhdGVzdFJlZ2lzdGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hY3JvTW9kZVN0YXRlLmxhdGVzdFJlZ2lzdGVyID0gcmVnaXN0ZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlcGVhdC0tKXtcbiAgICAgICAgICBleGVjdXRlTWFjcm9SZWdpc3RlcihjbSwgdmltLCBtYWNyb01vZGVTdGF0ZSwgcmVnaXN0ZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVudGVyTWFjcm9SZWNvcmRNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgdmFyIHJlZ2lzdGVyTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIGlmICh2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuaXNWYWxpZFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSkpIHtcbiAgICAgICAgICBtYWNyb01vZGVTdGF0ZS5lbnRlck1hY3JvUmVjb3JkTW9kZShjbSwgcmVnaXN0ZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgaWYgKCFjbS5zdGF0ZS5vdmVyd3JpdGUpIHtcbiAgICAgICAgICBjbS50b2dnbGVPdmVyd3JpdGUodHJ1ZSk7XG4gICAgICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltLXJlcGxhY2UnKTtcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwicmVwbGFjZVwifSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY20udG9nZ2xlT3ZlcndyaXRlKGZhbHNlKTtcbiAgICAgICAgICBjbS5zZXRPcHRpb24oJ2tleU1hcCcsICd2aW0taW5zZXJ0Jyk7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcImluc2VydFwifSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnRlckluc2VydE1vZGU6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgaWYgKGNtLmdldE9wdGlvbigncmVhZE9ubHknKSkgeyByZXR1cm47IH1cbiAgICAgICAgdmltLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgICB2aW0uaW5zZXJ0TW9kZVJlcGVhdCA9IGFjdGlvbkFyZ3MgJiYgYWN0aW9uQXJncy5yZXBlYXQgfHwgMTtcbiAgICAgICAgdmFyIGluc2VydEF0ID0gKGFjdGlvbkFyZ3MpID8gYWN0aW9uQXJncy5pbnNlcnRBdCA6IG51bGw7XG4gICAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgICB2YXIgaGVhZCA9IGFjdGlvbkFyZ3MuaGVhZCB8fCBjbS5nZXRDdXJzb3IoJ2hlYWQnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgICBpZiAoaW5zZXJ0QXQgPT0gJ2VvbCcpIHtcbiAgICAgICAgICBoZWFkID0gbmV3IFBvcyhoZWFkLmxpbmUsIGxpbmVMZW5ndGgoY20sIGhlYWQubGluZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdib2wnKSB7XG4gICAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnY2hhckFmdGVyJykge1xuICAgICAgICAgIGhlYWQgPSBvZmZzZXRDdXJzb3IoaGVhZCwgMCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2ZpcnN0Tm9uQmxhbmsnKSB7XG4gICAgICAgICAgaGVhZCA9IG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCBoZWFkKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnc3RhcnRPZlNlbGVjdGVkQXJlYScpIHtcbiAgICAgICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKCF2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgICAgICAgIGlmIChzZWwuaGVhZC5saW5lIDwgc2VsLmFuY2hvci5saW5lKSB7XG4gICAgICAgICAgICAgIGhlYWQgPSBzZWwuaGVhZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlYWQgPSBuZXcgUG9zKHNlbC5hbmNob3IubGluZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSBuZXcgUG9zKFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHNlbC5oZWFkLmxpbmUsIHNlbC5hbmNob3IubGluZSksXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc2VsLmhlYWQuY2gsIHNlbC5hbmNob3IuY2gpKTtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKHNlbC5oZWFkLmxpbmUgLSBzZWwuYW5jaG9yLmxpbmUpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2VuZE9mU2VsZWN0ZWRBcmVhJykge1xuICAgICAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmICghdmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoc2VsLmhlYWQubGluZSA+PSBzZWwuYW5jaG9yLmxpbmUpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihzZWwuaGVhZCwgMCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWFkID0gbmV3IFBvcyhzZWwuYW5jaG9yLmxpbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gbmV3IFBvcyhcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihzZWwuaGVhZC5saW5lLCBzZWwuYW5jaG9yLmxpbmUpLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHNlbC5oZWFkLmNoLCBzZWwuYW5jaG9yLmNoKSArIDEpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5hYnMoc2VsLmhlYWQubGluZSAtIHNlbC5hbmNob3IubGluZSkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnaW5wbGFjZScpIHtcbiAgICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnbGFzdEVkaXQnKSB7XG4gICAgICAgICAgaGVhZCA9IGdldExhc3RFZGl0UG9zKGNtKSB8fCBoZWFkO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgZmFsc2UpO1xuICAgICAgICBpZiAoYWN0aW9uQXJncyAmJiBhY3Rpb25BcmdzLnJlcGxhY2UpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgUmVwbGFjZS1tb2RlIGFzIGEgc3BlY2lhbCBjYXNlIG9mIGluc2VydCBtb2RlLlxuICAgICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZSh0cnVlKTtcbiAgICAgICAgICBjbS5zZXRPcHRpb24oJ2tleU1hcCcsICd2aW0tcmVwbGFjZScpO1xuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJyZXBsYWNlXCJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbS50b2dnbGVPdmVyd3JpdGUoZmFsc2UpO1xuICAgICAgICAgIGNtLnNldE9wdGlvbigna2V5TWFwJywgJ3ZpbS1pbnNlcnQnKTtcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwiaW5zZXJ0XCJ9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykge1xuICAgICAgICAgIC8vIE9ubHkgcmVjb3JkIGlmIG5vdCByZXBsYXlpbmcuXG4gICAgICAgICAgY20ub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgICBDb2RlTWlycm9yLm9uKGNtLmdldElucHV0RmllbGQoKSwgJ2tleWRvd24nLCBvbktleUV2ZW50VGFyZ2V0S2V5RG93bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdEZvckluc2VydChjbSwgaGVhZCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVWaXN1YWxNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgdmFyIGFuY2hvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgaGVhZDtcbiAgICAgICAgLy8gVE9ETzogVGhlIHJlcGVhdCBzaG91bGQgYWN0dWFsbHkgc2VsZWN0IG51bWJlciBvZiBjaGFyYWN0ZXJzL2xpbmVzXG4gICAgICAgIC8vICAgICBlcXVhbCB0byB0aGUgcmVwZWF0IHRpbWVzIHRoZSBzaXplIG9mIHRoZSBwcmV2aW91cyB2aXN1YWxcbiAgICAgICAgLy8gICAgIG9wZXJhdGlvbi5cbiAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIC8vIEVudGVyaW5nIHZpc3VhbCBtb2RlXG4gICAgICAgICAgdmltLnZpc3VhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gISFhY3Rpb25BcmdzLmxpbmV3aXNlO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9ICEhYWN0aW9uQXJncy5ibG9ja3dpc2U7XG4gICAgICAgICAgaGVhZCA9IGNsaXBDdXJzb3JUb0NvbnRlbnQoXG4gICAgICAgICAgICAgIGNtLCBuZXcgUG9zKGFuY2hvci5saW5lLCBhbmNob3IuY2ggKyByZXBlYXQgLSAxKSk7XG4gICAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgICAgaGVhZDogaGVhZFxuICAgICAgICAgIH07XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/IFwibGluZXdpc2VcIiA6IHZpbS52aXN1YWxCbG9jayA/IFwiYmxvY2t3aXNlXCIgOiBcIlwifSk7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2aW0udmlzdWFsTGluZSBeIGFjdGlvbkFyZ3MubGluZXdpc2UgfHxcbiAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayBeIGFjdGlvbkFyZ3MuYmxvY2t3aXNlKSB7XG4gICAgICAgICAgLy8gVG9nZ2xpbmcgYmV0d2VlbiBtb2Rlc1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gISFhY3Rpb25BcmdzLmxpbmV3aXNlO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9ICEhYWN0aW9uQXJncy5ibG9ja3dpc2U7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/IFwibGluZXdpc2VcIiA6IHZpbS52aXN1YWxCbG9jayA/IFwiYmxvY2t3aXNlXCIgOiBcIlwifSk7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2VsZWN0TGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oY20sIF9hY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmFyIGxhc3RTZWxlY3Rpb24gPSB2aW0ubGFzdFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgdXBkYXRlTGFzdFNlbGVjdGlvbihjbSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBhbmNob3IgPSBsYXN0U2VsZWN0aW9uLmFuY2hvck1hcmsuZmluZCgpO1xuICAgICAgICAgIHZhciBoZWFkID0gbGFzdFNlbGVjdGlvbi5oZWFkTWFyay5maW5kKCk7XG4gICAgICAgICAgaWYgKCFhbmNob3IgfHwgIWhlYWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBtYXJrcyBoYXZlIGJlZW4gZGVzdHJveWVkIGR1ZSB0byBlZGl0cywgZG8gbm90aGluZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgICAgaGVhZDogaGVhZFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmltLnZpc3VhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gbGFzdFNlbGVjdGlvbi52aXN1YWxMaW5lO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGxhc3RTZWxlY3Rpb24udmlzdWFsQmxvY2s7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgJ3ZpbS1tb2RlLWNoYW5nZScsIHtcbiAgICAgICAgICAgIG1vZGU6ICd2aXN1YWwnLFxuICAgICAgICAgICAgc3ViTW9kZTogdmltLnZpc3VhbExpbmUgPyAnbGluZXdpc2UnIDpcbiAgICAgICAgICAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA/ICdibG9ja3dpc2UnIDogJyd9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGpvaW5MaW5lczogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgY3VyU3RhcnQsIGN1ckVuZDtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgY3VyU3RhcnQgPSBjbS5nZXRDdXJzb3IoJ2FuY2hvcicpO1xuICAgICAgICAgIGN1ckVuZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgICAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShjdXJFbmQsIGN1clN0YXJ0KSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGN1ckVuZDtcbiAgICAgICAgICAgIGN1ckVuZCA9IGN1clN0YXJ0O1xuICAgICAgICAgICAgY3VyU3RhcnQgPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckVuZC5jaCA9IGxpbmVMZW5ndGgoY20sIGN1ckVuZC5saW5lKSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVwZWF0IGlzIHRoZSBudW1iZXIgb2YgbGluZXMgdG8gam9pbi4gTWluaW11bSAyIGxpbmVzLlxuICAgICAgICAgIHZhciByZXBlYXQgPSBNYXRoLm1heChhY3Rpb25BcmdzLnJlcGVhdCwgMik7XG4gICAgICAgICAgY3VyU3RhcnQgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgICBjdXJFbmQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXcgUG9zKGN1clN0YXJ0LmxpbmUgKyByZXBlYXQgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmZpbml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5hbENoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGN1clN0YXJ0LmxpbmU7IGkgPCBjdXJFbmQubGluZTsgaSsrKSB7XG4gICAgICAgICAgZmluYWxDaCA9IGxpbmVMZW5ndGgoY20sIGN1clN0YXJ0LmxpbmUpO1xuICAgICAgICAgIHZhciB0bXAgPSBuZXcgUG9zKGN1clN0YXJ0LmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUxlbmd0aChjbSwgY3VyU3RhcnQubGluZSArIDEpKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCB0bXApO1xuICAgICAgICAgIHRleHQgPSBhY3Rpb25BcmdzLmtlZXBTcGFjZXNcbiAgICAgICAgICAgID8gdGV4dC5yZXBsYWNlKC9cXG5cXHI/L2csICcnKVxuICAgICAgICAgICAgOiB0ZXh0LnJlcGxhY2UoL1xcblxccyovZywgJyAnKTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgY3VyU3RhcnQsIHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1ckZpbmFsUG9zID0gbmV3IFBvcyhjdXJTdGFydC5saW5lLCBmaW5hbENoKTtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRDdXJzb3IoY3VyRmluYWxQb3MpO1xuICAgICAgfSxcbiAgICAgIG5ld0xpbmVBbmRFbnRlckluc2VydE1vZGU6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmltLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgaW5zZXJ0QXQgPSBjb3B5Q3Vyc29yKGNtLmdldEN1cnNvcigpKTtcbiAgICAgICAgaWYgKGluc2VydEF0LmxpbmUgPT09IGNtLmZpcnN0TGluZSgpICYmICFhY3Rpb25BcmdzLmFmdGVyKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBpbnNlcnRpbmcgbmV3bGluZSBiZWZvcmUgc3RhcnQgb2YgZG9jdW1lbnQuXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCdcXG4nLCBuZXcgUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGNtLmZpcnN0TGluZSgpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRBdC5saW5lID0gKGFjdGlvbkFyZ3MuYWZ0ZXIpID8gaW5zZXJ0QXQubGluZSA6XG4gICAgICAgICAgICAgIGluc2VydEF0LmxpbmUgLSAxO1xuICAgICAgICAgIGluc2VydEF0LmNoID0gbGluZUxlbmd0aChjbSwgaW5zZXJ0QXQubGluZSk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGluc2VydEF0KTtcbiAgICAgICAgICB2YXIgbmV3bGluZUZuID0gQ29kZU1pcnJvci5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50Q29udGludWVDb21tZW50IHx8XG4gICAgICAgICAgICAgIENvZGVNaXJyb3IuY29tbWFuZHMubmV3bGluZUFuZEluZGVudDtcbiAgICAgICAgICBuZXdsaW5lRm4oY20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7IHJlcGVhdDogYWN0aW9uQXJncy5yZXBlYXQgfSwgdmltKTtcbiAgICAgIH0sXG4gICAgICBwYXN0ZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgY3VyID0gY29weUN1cnNvcihjbS5nZXRDdXJzb3IoKSk7XG4gICAgICAgIHZhciByZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihcbiAgICAgICAgICAgIGFjdGlvbkFyZ3MucmVnaXN0ZXJOYW1lKTtcbiAgICAgICAgdmFyIHRleHQgPSByZWdpc3Rlci50b1N0cmluZygpO1xuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbkFyZ3MubWF0Y2hJbmRlbnQpIHtcbiAgICAgICAgICB2YXIgdGFiU2l6ZSA9IGNtLmdldE9wdGlvbihcInRhYlNpemVcIik7XG4gICAgICAgICAgLy8gbGVuZ3RoIHRoYXQgY29uc2lkZXJzIHRhYnMgYW5kIHRhYlNpemVcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHRhYnMgPSAoc3RyLnNwbGl0KFwiXFx0XCIpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdmFyIHNwYWNlcyA9IChzdHIuc3BsaXQoXCIgXCIpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRhYnMgKiB0YWJTaXplICsgc3BhY2VzICogMTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjdXJyZW50TGluZSA9IGNtLmdldExpbmUoY20uZ2V0Q3Vyc29yKCkubGluZSk7XG4gICAgICAgICAgdmFyIGluZGVudCA9IHdoaXRlc3BhY2VMZW5ndGgoY3VycmVudExpbmUubWF0Y2goL15cXHMqLylbMF0pO1xuICAgICAgICAgIC8vIGNob21wIGxhc3QgbmV3bGluZSBiL2MgZG9uJ3Qgd2FudCBpdCB0byBtYXRjaCAvXlxccyovZ21cbiAgICAgICAgICB2YXIgY2hvbXBlZFRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgICAgICAgdmFyIHdhc0Nob21wZWQgPSB0ZXh0ICE9PSBjaG9tcGVkVGV4dDtcbiAgICAgICAgICB2YXIgZmlyc3RJbmRlbnQgPSB3aGl0ZXNwYWNlTGVuZ3RoKHRleHQubWF0Y2goL15cXHMqLylbMF0pO1xuICAgICAgICAgIHZhciB0ZXh0ID0gY2hvbXBlZFRleHQucmVwbGFjZSgvXlxccyovZ20sIGZ1bmN0aW9uKHdzcGFjZSkge1xuICAgICAgICAgICAgdmFyIG5ld0luZGVudCA9IGluZGVudCArICh3aGl0ZXNwYWNlTGVuZ3RoKHdzcGFjZSkgLSBmaXJzdEluZGVudCk7XG4gICAgICAgICAgICBpZiAobmV3SW5kZW50IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtLmdldE9wdGlvbihcImluZGVudFdpdGhUYWJzXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBxdW90aWVudCA9IE1hdGguZmxvb3IobmV3SW5kZW50IC8gdGFiU2l6ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheShxdW90aWVudCArIDEpLmpvaW4oJ1xcdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheShuZXdJbmRlbnQgKyAxKS5qb2luKCcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGV4dCArPSB3YXNDaG9tcGVkID8gXCJcXG5cIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbkFyZ3MucmVwZWF0ID4gMSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gQXJyYXkoYWN0aW9uQXJncy5yZXBlYXQgKyAxKS5qb2luKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5ld2lzZSA9IHJlZ2lzdGVyLmxpbmV3aXNlO1xuICAgICAgICB2YXIgYmxvY2t3aXNlID0gcmVnaXN0ZXIuYmxvY2t3aXNlO1xuICAgICAgICBpZiAoYmxvY2t3aXNlKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICAgICAgICB0ZXh0LnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHRbaV0gPSAodGV4dFtpXSA9PSAnJykgPyAnICcgOiB0ZXh0W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXIuY2ggKz0gYWN0aW9uQXJncy5hZnRlciA/IDEgOiAwO1xuICAgICAgICAgIGN1ci5jaCA9IE1hdGgubWluKGxpbmVMZW5ndGgoY20sIGN1ci5saW5lKSwgY3VyLmNoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5ld2lzZSkge1xuICAgICAgICAgIGlmKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdmltLnZpc3VhbExpbmUgPyB0ZXh0LnNsaWNlKDAsIC0xKSA6ICdcXG4nICsgdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpICsgJ1xcbic7XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb25BcmdzLmFmdGVyKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBuZXdsaW5lIGF0IHRoZSBlbmQgdG8gdGhlIHN0YXJ0IGluc3RlYWQsIGFuZCBwYXN0ZSBqdXN0XG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIG9mIHRoZSBsaW5lIHdlIGFyZSBvbiByaWdodCBub3cuXG4gICAgICAgICAgICB0ZXh0ID0gJ1xcbicgKyB0ZXh0LnNsaWNlKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjdXIuY2ggPSBsaW5lTGVuZ3RoKGNtLCBjdXIubGluZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1ci5jaCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ci5jaCArPSBhY3Rpb25BcmdzLmFmdGVyID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1clBvc0ZpbmFsO1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAvLyAgc2F2ZSB0aGUgcGFzdGVkIHRleHQgZm9yIHJlc2VsZWN0aW9uIGlmIHRoZSBuZWVkIGFyaXNlc1xuICAgICAgICAgIHZpbS5sYXN0UGFzdGVkVGV4dCA9IHRleHQ7XG4gICAgICAgICAgdmFyIGxhc3RTZWxlY3Rpb25DdXJFbmQ7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkQXJlYSA9IGdldFNlbGVjdGVkQXJlYVJhbmdlKGNtLCB2aW0pO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGVkQXJlYVswXTtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gc2VsZWN0ZWRBcmVhWzFdO1xuICAgICAgICAgIHZhciBzZWxlY3RlZFRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgdmFyIGVtcHR5U3RyaW5ncyA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCkuam9pbignMScpLnNwbGl0KCcxJyk7XG4gICAgICAgICAgLy8gc2F2ZSB0aGUgY3VyRW5kIG1hcmtlciBiZWZvcmUgaXQgZ2V0IGNsZWFyZWQgZHVlIHRvIGNtLnJlcGxhY2VSYW5nZS5cbiAgICAgICAgICBpZiAodmltLmxhc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25DdXJFbmQgPSB2aW0ubGFzdFNlbGVjdGlvbi5oZWFkTWFyay5maW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHB1c2ggdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgdGV4dCB0byB1bm5hbWVkIHJlZ2lzdGVyXG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLnVubmFtZWRSZWdpc3Rlci5zZXRUZXh0KHNlbGVjdGVkVGV4dCk7XG4gICAgICAgICAgaWYgKGJsb2Nrd2lzZSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgZGVsZXRlIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhlbXB0eVN0cmluZ3MpO1xuICAgICAgICAgICAgLy8gU2V0IG5ldyBzZWxlY3Rpb25zIGFzIHBlciB0aGUgYmxvY2sgbGVuZ3RoIG9mIHRoZSB5YW5rZWQgdGV4dFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gbmV3IFBvcyhzZWxlY3Rpb25TdGFydC5saW5lICsgdGV4dC5sZW5ndGgtMSwgc2VsZWN0aW9uU3RhcnQuY2gpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIHNlbGVjdEJsb2NrKGNtLCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnModGV4dCk7XG4gICAgICAgICAgICBjdXJQb3NGaW5hbCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhlbXB0eVN0cmluZ3MpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBjbS5wb3NGcm9tSW5kZXgoY20uaW5kZXhGcm9tUG9zKHNlbGVjdGlvblN0YXJ0KSArIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHRoZSBjdXJFbmQgbWFya2VyXG4gICAgICAgICAgaWYobGFzdFNlbGVjdGlvbkN1ckVuZCkge1xuICAgICAgICAgICAgdmltLmxhc3RTZWxlY3Rpb24uaGVhZE1hcmsgPSBjbS5zZXRCb29rbWFyayhsYXN0U2VsZWN0aW9uQ3VyRW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgICBjdXJQb3NGaW5hbC5jaD0wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYmxvY2t3aXNlKSB7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3IoY3VyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbGluZSA9IGN1ci5saW5lK2k7XG4gICAgICAgICAgICAgIGlmIChsaW5lID4gY20ubGFzdExpbmUoKSkge1xuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnXFxuJywgIG5ldyBQb3MobGluZSwgMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBsYXN0Q2ggPSBsaW5lTGVuZ3RoKGNtLCBsaW5lKTtcbiAgICAgICAgICAgICAgaWYgKGxhc3RDaCA8IGN1ci5jaCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmVUb0NvbHVtbihjbSwgbGluZSwgY3VyLmNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGN1cik7XG4gICAgICAgICAgICBzZWxlY3RCbG9jayhjbSwgbmV3IFBvcyhjdXIubGluZSArIHRleHQubGVuZ3RoLTEsIGN1ci5jaCkpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnModGV4dCk7XG4gICAgICAgICAgICBjdXJQb3NGaW5hbCA9IGN1cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIGN1cik7XG4gICAgICAgICAgICAvLyBOb3cgZmluZSB0dW5lIHRoZSBjdXJzb3IgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAgICAgICAgIGlmIChsaW5ld2lzZSAmJiBhY3Rpb25BcmdzLmFmdGVyKSB7XG4gICAgICAgICAgICAgIGN1clBvc0ZpbmFsID0gbmV3IFBvcyhcbiAgICAgICAgICAgICAgY3VyLmxpbmUgKyAxLFxuICAgICAgICAgICAgICBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUoY3VyLmxpbmUgKyAxKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5ld2lzZSAmJiAhYWN0aW9uQXJncy5hZnRlcikge1xuICAgICAgICAgICAgICBjdXJQb3NGaW5hbCA9IG5ldyBQb3MoXG4gICAgICAgICAgICAgICAgY3VyLmxpbmUsXG4gICAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGN1ci5saW5lKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZXdpc2UgJiYgYWN0aW9uQXJncy5hZnRlcikge1xuICAgICAgICAgICAgICBpZHggPSBjbS5pbmRleEZyb21Qb3MoY3VyKTtcbiAgICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBjbS5wb3NGcm9tSW5kZXgoaWR4ICsgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlkeCA9IGNtLmluZGV4RnJvbVBvcyhjdXIpO1xuICAgICAgICAgICAgICBjdXJQb3NGaW5hbCA9IGNtLnBvc0Zyb21JbmRleChpZHggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY20uc2V0Q3Vyc29yKGN1clBvc0ZpbmFsKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVwZWF0Rm4oY20sIENvZGVNaXJyb3IuY29tbWFuZHMudW5kbywgYWN0aW9uQXJncy5yZXBlYXQpKCk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZWRvOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICByZXBlYXRGbihjbSwgQ29kZU1pcnJvci5jb21tYW5kcy5yZWRvLCBhY3Rpb25BcmdzLnJlcGVhdCkoKTtcbiAgICAgIH0sXG4gICAgICBzZXRSZWdpc3RlcjogZnVuY3Rpb24oX2NtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmltLmlucHV0U3RhdGUucmVnaXN0ZXJOYW1lID0gYWN0aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgIH0sXG4gICAgICBzZXRNYXJrOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBtYXJrTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgbWFya05hbWUsIGNtLmdldEN1cnNvcigpKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciByZXBsYWNlV2l0aCA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIHZhciBjdXJTdGFydCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgcmVwbGFjZVRvO1xuICAgICAgICB2YXIgY3VyRW5kO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgICAgICAgIGN1ckVuZCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1clN0YXJ0LmxpbmUpO1xuICAgICAgICAgIHJlcGxhY2VUbyA9IGN1clN0YXJ0LmNoICsgYWN0aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgICAgaWYgKHJlcGxhY2VUbyA+IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXBsYWNlVG89bGluZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckVuZCA9IG5ldyBQb3MoY3VyU3RhcnQubGluZSwgcmVwbGFjZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwbGFjZVdpdGg9PSdcXG4nKSB7XG4gICAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSkgY20ucmVwbGFjZVJhbmdlKCcnLCBjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIHdoZXJlIHZpbSBoZWxwIHNheXMgdG8gcmVwbGFjZSBieSBqdXN0IG9uZSBsaW5lLWJyZWFrXG4gICAgICAgICAgKENvZGVNaXJyb3IuY29tbWFuZHMubmV3bGluZUFuZEluZGVudENvbnRpbnVlQ29tbWVudCB8fCBDb2RlTWlycm9yLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnQpKGNtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZVdpdGhTdHIgPSBjbS5nZXRSYW5nZShjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICAvL3JlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gcmFuZ2UgYnkgc2VsZWN0ZWQsIGJ1dCBrZWVwIGxpbmVicmVha3NcbiAgICAgICAgICByZXBsYWNlV2l0aFN0ciA9IHJlcGxhY2VXaXRoU3RyLnJlcGxhY2UoL1teXFxuXS9nLCByZXBsYWNlV2l0aCk7XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgICAgLy8gVGFicyBhcmUgc3BsaXQgaW4gdmlzdWEgYmxvY2sgYmVmb3JlIHJlcGxhY2luZ1xuICAgICAgICAgICAgdmFyIHNwYWNlcyA9IG5ldyBBcnJheShjbS5nZXRPcHRpb24oXCJ0YWJTaXplXCIpKzEpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoU3RyID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXBsYWNlV2l0aFN0ciA9IHJlcGxhY2VXaXRoU3RyLnJlcGxhY2UoL1xcdC9nLCBzcGFjZXMpLnJlcGxhY2UoL1teXFxuXS9nLCByZXBsYWNlV2l0aCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMocmVwbGFjZVdpdGhTdHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UocmVwbGFjZVdpdGhTdHIsIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgIGN1clN0YXJ0ID0gY3Vyc29ySXNCZWZvcmUoc2VsZWN0aW9uc1swXS5hbmNob3IsIHNlbGVjdGlvbnNbMF0uaGVhZCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnNbMF0uYW5jaG9yIDogc2VsZWN0aW9uc1swXS5oZWFkO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGN1clN0YXJ0KTtcbiAgICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihvZmZzZXRDdXJzb3IoY3VyRW5kLCAwLCAtMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluY3JlbWVudE51bWJlclRva2VuOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciBsaW5lU3RyID0gY20uZ2V0TGluZShjdXIubGluZSk7XG4gICAgICAgIHZhciByZSA9IC8oLT8pKD86KDB4KShbXFxkYS1mXSspfCgwYnwwfCkoXFxkKykpL2dpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgdmFyIG51bWJlclN0cjtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobGluZVN0cikpICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY3VyLmNoIDwgZW5kKWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aW9uQXJncy5iYWNrdHJhY2sgJiYgKGVuZCA8PSBjdXIuY2gpKXJldHVybjtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIGJhc2VTdHIgPSBtYXRjaFsyXSB8fCBtYXRjaFs0XVxuICAgICAgICAgIHZhciBkaWdpdHMgPSBtYXRjaFszXSB8fCBtYXRjaFs1XVxuICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBhY3Rpb25BcmdzLmluY3JlYXNlID8gMSA6IC0xO1xuICAgICAgICAgIHZhciBiYXNlID0geycwYic6IDIsICcwJzogOCwgJyc6IDEwLCAnMHgnOiAxNn1bYmFzZVN0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbMV0gKyBkaWdpdHMsIGJhc2UpICsgKGluY3JlbWVudCAqIGFjdGlvbkFyZ3MucmVwZWF0KTtcbiAgICAgICAgICBudW1iZXJTdHIgPSBudW1iZXIudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgdmFyIHplcm9QYWRkaW5nID0gYmFzZVN0ciA/IG5ldyBBcnJheShkaWdpdHMubGVuZ3RoIC0gbnVtYmVyU3RyLmxlbmd0aCArIDEgKyBtYXRjaFsxXS5sZW5ndGgpLmpvaW4oJzAnKSA6ICcnXG4gICAgICAgICAgaWYgKG51bWJlclN0ci5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgbnVtYmVyU3RyID0gJy0nICsgYmFzZVN0ciArIHplcm9QYWRkaW5nICsgbnVtYmVyU3RyLnN1YnN0cigxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtYmVyU3RyID0gYmFzZVN0ciArIHplcm9QYWRkaW5nICsgbnVtYmVyU3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZnJvbSA9IG5ldyBQb3MoY3VyLmxpbmUsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgdG8gPSBuZXcgUG9zKGN1ci5saW5lLCBlbmQpO1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShudW1iZXJTdHIsIGZyb20sIHRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY20uc2V0Q3Vyc29yKG5ldyBQb3MoY3VyLmxpbmUsIHN0YXJ0ICsgbnVtYmVyU3RyLmxlbmd0aCAtIDEpKTtcbiAgICAgIH0sXG4gICAgICByZXBlYXRMYXN0RWRpdDogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgbGFzdEVkaXRJbnB1dFN0YXRlID0gdmltLmxhc3RFZGl0SW5wdXRTdGF0ZTtcbiAgICAgICAgaWYgKCFsYXN0RWRpdElucHV0U3RhdGUpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgaWYgKHJlcGVhdCAmJiBhY3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQpIHtcbiAgICAgICAgICB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlID0gcmVwZWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGVhdCA9IHZpbS5sYXN0RWRpdElucHV0U3RhdGUucmVwZWF0T3ZlcnJpZGUgfHwgcmVwZWF0O1xuICAgICAgICB9XG4gICAgICAgIHJlcGVhdExhc3RFZGl0KGNtLCB2aW0sIHJlcGVhdCwgZmFsc2UgLyoqIHJlcGVhdEZvckluc2VydCAqLyk7XG4gICAgICB9LFxuICAgICAgaW5kZW50OiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICBjbS5pbmRlbnRMaW5lKGNtLmdldEN1cnNvcigpLmxpbmUsIGFjdGlvbkFyZ3MuaW5kZW50UmlnaHQpO1xuICAgICAgfSxcbiAgICAgIGV4aXRJbnNlcnRNb2RlOiBleGl0SW5zZXJ0TW9kZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY3Rpb24obmFtZSwgZm4pIHtcbiAgICAgIGFjdGlvbnNbbmFtZV0gPSBmbjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEJlbG93IGFyZSBtaXNjZWxsYW5lb3VzIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgYnkgdmltLmpzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDbGlwcyBjdXJzb3IgdG8gZW5zdXJlIHRoYXQgbGluZSBpcyB3aXRoaW4gdGhlIGJ1ZmZlcidzIHJhbmdlXG4gICAgICogSWYgaW5jbHVkZUxpbmVCcmVhayBpcyB0cnVlLCB0aGVuIGFsbG93IGN1ci5jaCA9PSBsaW5lTGVuZ3RoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIGN1cikge1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIHZhciBpbmNsdWRlTGluZUJyZWFrID0gdmltLmluc2VydE1vZGUgfHwgdmltLnZpc3VhbE1vZGU7XG4gICAgICB2YXIgbGluZSA9IE1hdGgubWluKE1hdGgubWF4KGNtLmZpcnN0TGluZSgpLCBjdXIubGluZSksIGNtLmxhc3RMaW5lKCkgKTtcbiAgICAgIHZhciBtYXhDaCA9IGxpbmVMZW5ndGgoY20sIGxpbmUpIC0gMSArICEhaW5jbHVkZUxpbmVCcmVhaztcbiAgICAgIHZhciBjaCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGN1ci5jaCksIG1heENoKTtcbiAgICAgIHJldHVybiBuZXcgUG9zKGxpbmUsIGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weUFyZ3MoYXJncykge1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcmV0W3Byb3BdID0gYXJnc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2Zmc2V0Q3Vyc29yKGN1ciwgb2Zmc2V0TGluZSwgb2Zmc2V0Q2gpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0TGluZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb2Zmc2V0Q2ggPSBvZmZzZXRMaW5lLmNoO1xuICAgICAgICBvZmZzZXRMaW5lID0gb2Zmc2V0TGluZS5saW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQb3MoY3VyLmxpbmUgKyBvZmZzZXRMaW5lLCBjdXIuY2ggKyBvZmZzZXRDaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1hbmRNYXRjaGVzKGtleXMsIGtleU1hcCwgY29udGV4dCwgaW5wdXRTdGF0ZSkge1xuICAgICAgLy8gUGFydGlhbCBtYXRjaGVzIGFyZSBub3QgYXBwbGllZC4gVGhleSBpbmZvcm0gdGhlIGtleSBoYW5kbGVyXG4gICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IGtleSBzZXF1ZW5jZSBpcyBhIHN1YnNlcXVlbmNlIG9mIGEgdmFsaWQga2V5XG4gICAgICAvLyBzZXF1ZW5jZSwgc28gdGhhdCB0aGUga2V5IGJ1ZmZlciBpcyBub3QgY2xlYXJlZC5cbiAgICAgIHZhciBtYXRjaCwgcGFydGlhbCA9IFtdLCBmdWxsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGtleU1hcFtpXTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT0gJ2luc2VydCcgJiYgY29tbWFuZC5jb250ZXh0ICE9ICdpbnNlcnQnIHx8XG4gICAgICAgICAgICBjb21tYW5kLmNvbnRleHQgJiYgY29tbWFuZC5jb250ZXh0ICE9IGNvbnRleHQgfHxcbiAgICAgICAgICAgIGlucHV0U3RhdGUub3BlcmF0b3IgJiYgY29tbWFuZC50eXBlID09ICdhY3Rpb24nIHx8XG4gICAgICAgICAgICAhKG1hdGNoID0gY29tbWFuZE1hdGNoKGtleXMsIGNvbW1hbmQua2V5cykpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChtYXRjaCA9PSAncGFydGlhbCcpIHsgcGFydGlhbC5wdXNoKGNvbW1hbmQpOyB9XG4gICAgICAgIGlmIChtYXRjaCA9PSAnZnVsbCcpIHsgZnVsbC5wdXNoKGNvbW1hbmQpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aWFsOiBwYXJ0aWFsLmxlbmd0aCAmJiBwYXJ0aWFsLFxuICAgICAgICBmdWxsOiBmdWxsLmxlbmd0aCAmJiBmdWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21tYW5kTWF0Y2gocHJlc3NlZCwgbWFwcGVkKSB7XG4gICAgICBpZiAobWFwcGVkLnNsaWNlKC0xMSkgPT0gJzxjaGFyYWN0ZXI+Jykge1xuICAgICAgICAvLyBMYXN0IGNoYXJhY3RlciBtYXRjaGVzIGFueXRoaW5nLlxuICAgICAgICB2YXIgcHJlZml4TGVuID0gbWFwcGVkLmxlbmd0aCAtIDExO1xuICAgICAgICB2YXIgcHJlc3NlZFByZWZpeCA9IHByZXNzZWQuc2xpY2UoMCwgcHJlZml4TGVuKTtcbiAgICAgICAgdmFyIG1hcHBlZFByZWZpeCA9IG1hcHBlZC5zbGljZSgwLCBwcmVmaXhMZW4pO1xuICAgICAgICByZXR1cm4gcHJlc3NlZFByZWZpeCA9PSBtYXBwZWRQcmVmaXggJiYgcHJlc3NlZC5sZW5ndGggPiBwcmVmaXhMZW4gPyAnZnVsbCcgOlxuICAgICAgICAgICAgICAgbWFwcGVkUHJlZml4LmluZGV4T2YocHJlc3NlZFByZWZpeCkgPT0gMCA/ICdwYXJ0aWFsJyA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZXNzZWQgPT0gbWFwcGVkID8gJ2Z1bGwnIDpcbiAgICAgICAgICAgICAgIG1hcHBlZC5pbmRleE9mKHByZXNzZWQpID09IDAgPyAncGFydGlhbCcgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFzdENoYXIoa2V5cykge1xuICAgICAgdmFyIG1hdGNoID0gL14uKig8W14+XSs+KSQvLmV4ZWMoa2V5cyk7XG4gICAgICB2YXIgc2VsZWN0ZWRDaGFyYWN0ZXIgPSBtYXRjaCA/IG1hdGNoWzFdIDoga2V5cy5zbGljZSgtMSk7XG4gICAgICBpZiAoc2VsZWN0ZWRDaGFyYWN0ZXIubGVuZ3RoID4gMSl7XG4gICAgICAgIHN3aXRjaChzZWxlY3RlZENoYXJhY3Rlcil7XG4gICAgICAgICAgY2FzZSAnPENSPic6XG4gICAgICAgICAgICBzZWxlY3RlZENoYXJhY3Rlcj0nXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzxTcGFjZT4nOlxuICAgICAgICAgICAgc2VsZWN0ZWRDaGFyYWN0ZXI9JyAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNlbGVjdGVkQ2hhcmFjdGVyPScnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZENoYXJhY3RlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwZWF0Rm4oY20sIGZuLCByZXBlYXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIGZuKGNtKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weUN1cnNvcihjdXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJzb3JFcXVhbChjdXIxLCBjdXIyKSB7XG4gICAgICByZXR1cm4gY3VyMS5jaCA9PSBjdXIyLmNoICYmIGN1cjEubGluZSA9PSBjdXIyLmxpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnNvcklzQmVmb3JlKGN1cjEsIGN1cjIpIHtcbiAgICAgIGlmIChjdXIxLmxpbmUgPCBjdXIyLmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VyMS5saW5lID09IGN1cjIubGluZSAmJiBjdXIxLmNoIDwgY3VyMi5jaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Vyc29yTWluKGN1cjEsIGN1cjIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBjdXIyID0gY3Vyc29yTWluLmFwcGx5KHVuZGVmaW5lZCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMikgPyBjdXIxIDogY3VyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Vyc29yTWF4KGN1cjEsIGN1cjIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBjdXIyID0gY3Vyc29yTWF4LmFwcGx5KHVuZGVmaW5lZCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMikgPyBjdXIyIDogY3VyMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Vyc29ySXNCZXR3ZWVuKGN1cjEsIGN1cjIsIGN1cjMpIHtcbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBjdXIyIGlzIGJldHdlZW4gY3VyMSBhbmQgY3VyMy5cbiAgICAgIHZhciBjdXIxYmVmb3JlMiA9IGN1cnNvcklzQmVmb3JlKGN1cjEsIGN1cjIpO1xuICAgICAgdmFyIGN1cjJiZWZvcmUzID0gY3Vyc29ySXNCZWZvcmUoY3VyMiwgY3VyMyk7XG4gICAgICByZXR1cm4gY3VyMWJlZm9yZTIgJiYgY3VyMmJlZm9yZTM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVMZW5ndGgoY20sIGxpbmVOdW0pIHtcbiAgICAgIHJldHVybiBjbS5nZXRMaW5lKGxpbmVOdW0pLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgICBpZiAocy50cmltKSB7XG4gICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXgocykge1xuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuPyorJFxcW1xcXVxcL1xcXFwoKXt9fFxcLV0pL2csICdcXFxcJDEnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kTGluZVRvQ29sdW1uKGNtLCBsaW5lTnVtLCBjb2x1bW4pIHtcbiAgICAgIHZhciBlbmRDaCA9IGxpbmVMZW5ndGgoY20sIGxpbmVOdW0pO1xuICAgICAgdmFyIHNwYWNlcyA9IG5ldyBBcnJheShjb2x1bW4tZW5kQ2grMSkuam9pbignICcpO1xuICAgICAgY20uc2V0Q3Vyc29yKG5ldyBQb3MobGluZU51bSwgZW5kQ2gpKTtcbiAgICAgIGNtLnJlcGxhY2VSYW5nZShzcGFjZXMsIGNtLmdldEN1cnNvcigpKTtcbiAgICB9XG4gICAgLy8gVGhpcyBmdW5jdGlvbnMgc2VsZWN0cyBhIHJlY3Rhbmd1bGFyIGJsb2NrXG4gICAgLy8gb2YgdGV4dCB3aXRoIHNlbGVjdGlvbkVuZCBhcyBhbnkgb2YgaXRzIGNvcm5lclxuICAgIC8vIEhlaWdodCBvZiBibG9jazpcbiAgICAvLyBEaWZmZXJlbmNlIGluIHNlbGVjdGlvbkVuZC5saW5lIGFuZCBmaXJzdC9sYXN0IHNlbGVjdGlvbi5saW5lXG4gICAgLy8gV2lkdGggb2YgdGhlIGJsb2NrOlxuICAgIC8vIERpc3RhbmNlIGJldHdlZW4gc2VsZWN0aW9uRW5kLmNoIGFuZCBhbnkoZmlyc3QgY29uc2lkZXJlZCBoZXJlKSBzZWxlY3Rpb24uY2hcbiAgICBmdW5jdGlvbiBzZWxlY3RCbG9jayhjbSwgc2VsZWN0aW9uRW5kKSB7XG4gICAgICB2YXIgc2VsZWN0aW9ucyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgdmFyIGhlYWQgPSBjb3B5Q3Vyc29yKGNtLmNsaXBQb3Moc2VsZWN0aW9uRW5kKSk7XG4gICAgICB2YXIgaXNDbGlwcGVkID0gIWN1cnNvckVxdWFsKHNlbGVjdGlvbkVuZCwgaGVhZCk7XG4gICAgICB2YXIgY3VySGVhZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgICAgdmFyIHByaW1JbmRleCA9IGdldEluZGV4KHJhbmdlcywgY3VySGVhZCk7XG4gICAgICB2YXIgd2FzQ2xpcHBlZCA9IGN1cnNvckVxdWFsKHJhbmdlc1twcmltSW5kZXhdLmhlYWQsIHJhbmdlc1twcmltSW5kZXhdLmFuY2hvcik7XG4gICAgICB2YXIgbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaW5kZXggPSBtYXggLSBwcmltSW5kZXggPiBwcmltSW5kZXggPyBtYXggOiAwO1xuICAgICAgdmFyIGJhc2UgPSByYW5nZXNbaW5kZXhdLmFuY2hvcjtcblxuICAgICAgdmFyIGZpcnN0TGluZSA9IE1hdGgubWluKGJhc2UubGluZSwgaGVhZC5saW5lKTtcbiAgICAgIHZhciBsYXN0TGluZSA9IE1hdGgubWF4KGJhc2UubGluZSwgaGVhZC5saW5lKTtcbiAgICAgIHZhciBiYXNlQ2ggPSBiYXNlLmNoLCBoZWFkQ2ggPSBoZWFkLmNoO1xuXG4gICAgICB2YXIgZGlyID0gcmFuZ2VzW2luZGV4XS5oZWFkLmNoIC0gYmFzZUNoO1xuICAgICAgdmFyIG5ld0RpciA9IGhlYWRDaCAtIGJhc2VDaDtcbiAgICAgIGlmIChkaXIgPiAwICYmIG5ld0RpciA8PSAwKSB7XG4gICAgICAgIGJhc2VDaCsrO1xuICAgICAgICBpZiAoIWlzQ2xpcHBlZCkgeyBoZWFkQ2gtLTsgfVxuICAgICAgfSBlbHNlIGlmIChkaXIgPCAwICYmIG5ld0RpciA+PSAwKSB7XG4gICAgICAgIGJhc2VDaC0tO1xuICAgICAgICBpZiAoIXdhc0NsaXBwZWQpIHsgaGVhZENoKys7IH1cbiAgICAgIH0gZWxzZSBpZiAoZGlyIDwgMCAmJiBuZXdEaXIgPT0gLTEpIHtcbiAgICAgICAgYmFzZUNoLS07XG4gICAgICAgIGhlYWRDaCsrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbGluZSA9IGZpcnN0TGluZTsgbGluZSA8PSBsYXN0TGluZTsgbGluZSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHthbmNob3I6IG5ldyBQb3MobGluZSwgYmFzZUNoKSwgaGVhZDogbmV3IFBvcyhsaW5lLCBoZWFkQ2gpfTtcbiAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMoc2VsZWN0aW9ucyk7XG4gICAgICBzZWxlY3Rpb25FbmQuY2ggPSBoZWFkQ2g7XG4gICAgICBiYXNlLmNoID0gYmFzZUNoO1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbGVjdEZvckluc2VydChjbSwgaGVhZCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgc2VsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lSGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCBpLCAwKTtcbiAgICAgICAgc2VsLnB1c2goe2FuY2hvcjogbGluZUhlYWQsIGhlYWQ6IGxpbmVIZWFkfSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKHNlbCwgMCk7XG4gICAgfVxuICAgIC8vIGdldEluZGV4IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJzb3IgaW4gdGhlIHNlbGVjdGlvbnMuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgocmFuZ2VzLCBjdXJzb3IsIGVuZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0QW5jaG9yID0gZW5kICE9ICdoZWFkJyAmJiBjdXJzb3JFcXVhbChyYW5nZXNbaV0uYW5jaG9yLCBjdXJzb3IpO1xuICAgICAgICB2YXIgYXRIZWFkID0gZW5kICE9ICdhbmNob3InICYmIGN1cnNvckVxdWFsKHJhbmdlc1tpXS5oZWFkLCBjdXJzb3IpO1xuICAgICAgICBpZiAoYXRBbmNob3IgfHwgYXRIZWFkKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRBcmVhUmFuZ2UoY20sIHZpbSkge1xuICAgICAgdmFyIGxhc3RTZWxlY3Rpb24gPSB2aW0ubGFzdFNlbGVjdGlvbjtcbiAgICAgIHZhciBnZXRDdXJyZW50U2VsZWN0ZWRBcmVhUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgc3RhcnQgPSAgc2VsZWN0aW9uc1swXTtcbiAgICAgICAgdmFyIGVuZCA9IHNlbGVjdGlvbnNbc2VsZWN0aW9ucy5sZW5ndGgtMV07XG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGN1cnNvcklzQmVmb3JlKHN0YXJ0LmFuY2hvciwgc3RhcnQuaGVhZCkgPyBzdGFydC5hbmNob3IgOiBzdGFydC5oZWFkO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gY3Vyc29ySXNCZWZvcmUoZW5kLmFuY2hvciwgZW5kLmhlYWQpID8gZW5kLmhlYWQgOiBlbmQuYW5jaG9yO1xuICAgICAgICByZXR1cm4gW3NlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmRdO1xuICAgICAgfTtcbiAgICAgIHZhciBnZXRMYXN0U2VsZWN0ZWRBcmVhUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIGJsb2NrID0gbGFzdFNlbGVjdGlvbi52aXN1YWxCbG9jaztcbiAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gYmxvY2sud2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGJsb2NrLmhlaWdodDtcbiAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBuZXcgUG9zKHNlbGVjdGlvblN0YXJ0LmxpbmUgKyBoZWlnaHQsIHNlbGVjdGlvblN0YXJ0LmNoICsgd2lkdGgpO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gW107XG4gICAgICAgICAgLy8gc2VsZWN0QmxvY2sgY3JlYXRlcyBhICdwcm9wZXInIHJlY3Rhbmd1bGFyIGJsb2NrLlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRoYXQgaW4gYWxsIGNhc2VzLCBzbyB3ZSBtYW51YWxseSBzZXQgc2VsZWN0aW9ucy5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZWN0aW9uU3RhcnQubGluZTsgaSA8IHNlbGVjdGlvbkVuZC5saW5lOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgUG9zKGksIHNlbGVjdGlvblN0YXJ0LmNoKTtcbiAgICAgICAgICAgIHZhciBoZWFkID0gbmV3IFBvcyhpLCBzZWxlY3Rpb25FbmQuY2gpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0ge2FuY2hvcjogYW5jaG9yLCBoZWFkOiBoZWFkfTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChyYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMoc2VsZWN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbGFzdFNlbGVjdGlvbi5hbmNob3JNYXJrLmZpbmQoKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGFzdFNlbGVjdGlvbi5oZWFkTWFyay5maW5kKCk7XG4gICAgICAgICAgdmFyIGxpbmUgPSBlbmQubGluZSAtIHN0YXJ0LmxpbmU7XG4gICAgICAgICAgdmFyIGNoID0gZW5kLmNoIC0gc3RhcnQuY2g7XG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0ge2xpbmU6IHNlbGVjdGlvbkVuZC5saW5lICsgbGluZSwgY2g6IGxpbmUgPyBzZWxlY3Rpb25FbmQuY2ggOiBjaCArIHNlbGVjdGlvbkVuZC5jaH07XG4gICAgICAgICAgaWYgKGxhc3RTZWxlY3Rpb24udmlzdWFsTGluZSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBuZXcgUG9zKHNlbGVjdGlvblN0YXJ0LmxpbmUsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gbmV3IFBvcyhzZWxlY3Rpb25FbmQubGluZSwgbGluZUxlbmd0aChjbSwgc2VsZWN0aW9uRW5kLmxpbmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZF07XG4gICAgICB9O1xuICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiByZXBsYXlpbmcgdGhlIGFjdGlvbi5cbiAgICAgICAgcmV0dXJuIGdldExhc3RTZWxlY3RlZEFyZWFSYW5nZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRTZWxlY3RlZEFyZWFSYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVcGRhdGVzIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gd2l0aCB0aGUgY3VycmVudCBzZWxlY3Rpb24ncyB2YWx1ZXMuIFRoaXNcbiAgICAvLyBzaG91bGQgb25seSBiZSBjYWxsZWQgaW4gdmlzdWFsIG1vZGUuXG4gICAgZnVuY3Rpb24gdXBkYXRlTGFzdFNlbGVjdGlvbihjbSwgdmltKSB7XG4gICAgICB2YXIgYW5jaG9yID0gdmltLnNlbC5hbmNob3I7XG4gICAgICB2YXIgaGVhZCA9IHZpbS5zZWwuaGVhZDtcbiAgICAgIC8vIFRvIGFjY29tbW9kYXRlIHRoZSBlZmZlY3Qgb2YgbGFzdFBhc3RlZFRleHQgaW4gdGhlIGxhc3Qgc2VsZWN0aW9uXG4gICAgICBpZiAodmltLmxhc3RQYXN0ZWRUZXh0KSB7XG4gICAgICAgIGhlYWQgPSBjbS5wb3NGcm9tSW5kZXgoY20uaW5kZXhGcm9tUG9zKGFuY2hvcikgKyB2aW0ubGFzdFBhc3RlZFRleHQubGVuZ3RoKTtcbiAgICAgICAgdmltLmxhc3RQYXN0ZWRUZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZpbS5sYXN0U2VsZWN0aW9uID0geydhbmNob3JNYXJrJzogY20uc2V0Qm9va21hcmsoYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWFkTWFyayc6IGNtLnNldEJvb2ttYXJrKGhlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FuY2hvcic6IGNvcHlDdXJzb3IoYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWFkJzogY29weUN1cnNvcihoZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICd2aXN1YWxNb2RlJzogdmltLnZpc3VhbE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAndmlzdWFsTGluZSc6IHZpbS52aXN1YWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc3VhbEJsb2NrJzogdmltLnZpc3VhbEJsb2NrfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXhwYW5kU2VsZWN0aW9uKGNtLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgc2VsID0gY20uc3RhdGUudmltLnNlbDtcbiAgICAgIHZhciBoZWFkID0gc2VsLmhlYWQ7XG4gICAgICB2YXIgYW5jaG9yID0gc2VsLmFuY2hvcjtcbiAgICAgIHZhciB0bXA7XG4gICAgICBpZiAoY3Vyc29ySXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgICAgdG1wID0gZW5kO1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSB0bXA7XG4gICAgICB9XG4gICAgICBpZiAoY3Vyc29ySXNCZWZvcmUoaGVhZCwgYW5jaG9yKSkge1xuICAgICAgICBoZWFkID0gY3Vyc29yTWluKHN0YXJ0LCBoZWFkKTtcbiAgICAgICAgYW5jaG9yID0gY3Vyc29yTWF4KGFuY2hvciwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvciA9IGN1cnNvck1pbihzdGFydCwgYW5jaG9yKTtcbiAgICAgICAgaGVhZCA9IGN1cnNvck1heChoZWFkLCBlbmQpO1xuICAgICAgICBoZWFkID0gb2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIC0xKTtcbiAgICAgICAgaWYgKGhlYWQuY2ggPT0gLTEgJiYgaGVhZC5saW5lICE9IGNtLmZpcnN0TGluZSgpKSB7XG4gICAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lIC0gMSwgbGluZUxlbmd0aChjbSwgaGVhZC5saW5lIC0gMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2FuY2hvciwgaGVhZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENvZGVNaXJyb3Igc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBwcm92aWRlZCB2aW0gc2VsZWN0aW9uLlxuICAgICAqIElmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW4sIGl0IHVzZXMgdGhlIGN1cnJlbnQgdmltIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVDbVNlbGVjdGlvbihjbSwgc2VsLCBtb2RlKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgc2VsID0gc2VsIHx8IHZpbS5zZWw7XG4gICAgICB2YXIgbW9kZSA9IG1vZGUgfHxcbiAgICAgICAgdmltLnZpc3VhbExpbmUgPyAnbGluZScgOiB2aW0udmlzdWFsQmxvY2sgPyAnYmxvY2snIDogJ2NoYXInO1xuICAgICAgdmFyIGNtU2VsID0gbWFrZUNtU2VsZWN0aW9uKGNtLCBzZWwsIG1vZGUpO1xuICAgICAgY20uc2V0U2VsZWN0aW9ucyhjbVNlbC5yYW5nZXMsIGNtU2VsLnByaW1hcnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQ21TZWxlY3Rpb24oY20sIHNlbCwgbW9kZSwgZXhjbHVzaXZlKSB7XG4gICAgICB2YXIgaGVhZCA9IGNvcHlDdXJzb3Ioc2VsLmhlYWQpO1xuICAgICAgdmFyIGFuY2hvciA9IGNvcHlDdXJzb3Ioc2VsLmFuY2hvcik7XG4gICAgICBpZiAobW9kZSA9PSAnY2hhcicpIHtcbiAgICAgICAgdmFyIGhlYWRPZmZzZXQgPSAhZXhjbHVzaXZlICYmICFjdXJzb3JJc0JlZm9yZShzZWwuaGVhZCwgc2VsLmFuY2hvcikgPyAxIDogMDtcbiAgICAgICAgdmFyIGFuY2hvck9mZnNldCA9IGN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSA/IDEgOiAwO1xuICAgICAgICBoZWFkID0gb2Zmc2V0Q3Vyc29yKHNlbC5oZWFkLCAwLCBoZWFkT2Zmc2V0KTtcbiAgICAgICAgYW5jaG9yID0gb2Zmc2V0Q3Vyc29yKHNlbC5hbmNob3IsIDAsIGFuY2hvck9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2VzOiBbe2FuY2hvcjogYW5jaG9yLCBoZWFkOiBoZWFkfV0sXG4gICAgICAgICAgcHJpbWFyeTogMFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09ICdsaW5lJykge1xuICAgICAgICBpZiAoIWN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSkge1xuICAgICAgICAgIGFuY2hvci5jaCA9IDA7XG5cbiAgICAgICAgICB2YXIgbGFzdExpbmUgPSBjbS5sYXN0TGluZSgpO1xuICAgICAgICAgIGlmIChoZWFkLmxpbmUgPiBsYXN0TGluZSkge1xuICAgICAgICAgICAgaGVhZC5saW5lID0gbGFzdExpbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWQuY2ggPSBsaW5lTGVuZ3RoKGNtLCBoZWFkLmxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWQuY2ggPSAwO1xuICAgICAgICAgIGFuY2hvci5jaCA9IGxpbmVMZW5ndGgoY20sIGFuY2hvci5saW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlczogW3thbmNob3I6IGFuY2hvciwgaGVhZDogaGVhZH1dLFxuICAgICAgICAgIHByaW1hcnk6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnYmxvY2snKSB7XG4gICAgICAgIHZhciB0b3AgPSBNYXRoLm1pbihhbmNob3IubGluZSwgaGVhZC5saW5lKSxcbiAgICAgICAgICAgIGZyb21DaCA9IGFuY2hvci5jaCxcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGFuY2hvci5saW5lLCBoZWFkLmxpbmUpLFxuICAgICAgICAgICAgdG9DaCA9IGhlYWQuY2g7XG4gICAgICAgIGlmIChmcm9tQ2ggPCB0b0NoKSB7IHRvQ2ggKz0gMSB9XG4gICAgICAgIGVsc2UgeyBmcm9tQ2ggKz0gMSB9O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgMTtcbiAgICAgICAgdmFyIHByaW1hcnkgPSBoZWFkLmxpbmUgPT0gdG9wID8gMCA6IGhlaWdodCAtIDE7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIGFuY2hvcjogbmV3IFBvcyh0b3AgKyBpLCBmcm9tQ2gpLFxuICAgICAgICAgICAgaGVhZDogbmV3IFBvcyh0b3AgKyBpLCB0b0NoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgcHJpbWFyeTogcHJpbWFyeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIZWFkKGNtKSB7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICBpZiAoY20uZ2V0U2VsZWN0aW9uKCkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gU21hbGwgY29ybmVyIGNhc2Ugd2hlbiBvbmx5IDEgY2hhcmFjdGVyIGlzIHNlbGVjdGVkLiBUaGUgXCJyZWFsXCJcbiAgICAgICAgLy8gaGVhZCBpcyB0aGUgbGVmdCBvZiBoZWFkIGFuZCBhbmNob3IuXG4gICAgICAgIGN1ciA9IGN1cnNvck1pbihjdXIsIGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBtb3ZlSGVhZCBpcyBzZXQgdG8gZmFsc2UsIHRoZSBDb2RlTWlycm9yIHNlbGVjdGlvbiB3aWxsIG5vdCBiZVxuICAgICAqIHRvdWNoZWQuIFRoZSBjYWxsZXIgYXNzdW1lcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgcHV0dGluZyB0aGUgY3Vyc29yXG4gICAgKiBpbiB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhpdFZpc3VhbE1vZGUoY20sIG1vdmVIZWFkKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgaWYgKG1vdmVIZWFkICE9PSBmYWxzZSkge1xuICAgICAgICBjbS5zZXRDdXJzb3IoY2xpcEN1cnNvclRvQ29udGVudChjbSwgdmltLnNlbC5oZWFkKSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVMYXN0U2VsZWN0aW9uKGNtLCB2aW0pO1xuICAgICAgdmltLnZpc3VhbE1vZGUgPSBmYWxzZTtcbiAgICAgIHZpbS52aXN1YWxMaW5lID0gZmFsc2U7XG4gICAgICB2aW0udmlzdWFsQmxvY2sgPSBmYWxzZTtcbiAgICAgIGlmICghdmltLmluc2VydE1vZGUpIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJub3JtYWxcIn0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgdHJhaWxpbmcgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0aW9uLiBGb3JcbiAgICAvLyBleGFtcGxlLCB3aXRoIHRoZSBjYXJldCBhdCB0aGUgc3RhcnQgb2YgdGhlIGxhc3Qgd29yZCBvbiB0aGUgbGluZSxcbiAgICAvLyAnZHcnIHNob3VsZCB3b3JkLCBidXQgbm90IHRoZSBuZXdsaW5lLCB3aGlsZSAndycgc2hvdWxkIGFkdmFuY2UgdGhlXG4gICAgLy8gY2FyZXQgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgbmV4dCBsaW5lLlxuICAgIGZ1bmN0aW9uIGNsaXBUb0xpbmUoY20sIGN1clN0YXJ0LCBjdXJFbmQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBjbS5nZXRSYW5nZShjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgIC8vIE9ubHkgY2xpcCBpZiB0aGUgc2VsZWN0aW9uIGVuZHMgd2l0aCB0cmFpbGluZyBuZXdsaW5lICsgd2hpdGVzcGFjZVxuICAgICAgaWYgKC9cXG5cXHMqJC8udGVzdChzZWxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHNlbGVjdGlvbi5zcGxpdCgnXFxuJyk7XG4gICAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhbGwgd2hpdGVzcGFjZS5cbiAgICAgICAgbGluZXMucG9wKCk7XG5cbiAgICAgICAgLy8gQ2FzZXM6XG4gICAgICAgIC8vIDEuIExhc3Qgd29yZCBpcyBhbiBlbXB0eSBsaW5lIC0gZG8gbm90IGNsaXAgdGhlIHRyYWlsaW5nICdcXG4nXG4gICAgICAgIC8vIDIuIExhc3Qgd29yZCBpcyBub3QgYW4gZW1wdHkgbGluZSAtIGNsaXAgdGhlIHRyYWlsaW5nICdcXG4nXG4gICAgICAgIHZhciBsaW5lO1xuICAgICAgICAvLyBGaW5kIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhlIGxhc3Qgd29yZCwgYW5kIGNsaXAgYWxsIHdoaXRlc3BhY2UgdXBcbiAgICAgICAgLy8gdG8gaXQuXG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBsaW5lcy5wb3AoKTsgbGluZXMubGVuZ3RoID4gMCAmJiBsaW5lICYmIGlzV2hpdGVTcGFjZVN0cmluZyhsaW5lKTsgbGluZSA9IGxpbmVzLnBvcCgpKSB7XG4gICAgICAgICAgY3VyRW5kLmxpbmUtLTtcbiAgICAgICAgICBjdXJFbmQuY2ggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IHdvcmQgaXMgbm90IGFuIGVtcHR5IGxpbmUsIGNsaXAgYW4gYWRkaXRpb25hbCBuZXdsaW5lXG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgY3VyRW5kLmxpbmUtLTtcbiAgICAgICAgICBjdXJFbmQuY2ggPSBsaW5lTGVuZ3RoKGNtLCBjdXJFbmQubGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyRW5kLmNoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGxpbmUgZW5kcy5cbiAgICBmdW5jdGlvbiBleHBhbmRTZWxlY3Rpb25Ub0xpbmUoX2NtLCBjdXJTdGFydCwgY3VyRW5kKSB7XG4gICAgICBjdXJTdGFydC5jaCA9IDA7XG4gICAgICBjdXJFbmQuY2ggPSAwO1xuICAgICAgY3VyRW5kLmxpbmUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKHRleHQpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdE5vbldTID0gdGV4dC5zZWFyY2goL1xcUy8pO1xuICAgICAgcmV0dXJuIGZpcnN0Tm9uV1MgPT0gLTEgPyB0ZXh0Lmxlbmd0aCA6IGZpcnN0Tm9uV1M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCBpbmNsdXNpdmUsIF9mb3J3YXJkLCBiaWdXb3JkLCBub1N5bWJvbCkge1xuICAgICAgdmFyIGN1ciA9IGdldEhlYWQoY20pO1xuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICAgIHZhciBpZHggPSBjdXIuY2g7XG5cbiAgICAgIC8vIFNlZWsgdG8gZmlyc3Qgd29yZCBvciBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIsIGRlcGVuZGluZyBvbiBpZlxuICAgICAgLy8gbm9TeW1ib2wgaXMgdHJ1ZS5cbiAgICAgIHZhciB0ZXN0ID0gbm9TeW1ib2wgPyB3b3JkQ2hhclRlc3RbMF0gOiBiaWdXb3JkQ2hhclRlc3QgWzBdO1xuICAgICAgd2hpbGUgKCF0ZXN0KGxpbmUuY2hhckF0KGlkeCkpKSB7XG4gICAgICAgIGlkeCsrO1xuICAgICAgICBpZiAoaWR4ID49IGxpbmUubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiaWdXb3JkKSB7XG4gICAgICAgIHRlc3QgPSBiaWdXb3JkQ2hhclRlc3RbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXN0ID0gd29yZENoYXJUZXN0WzBdO1xuICAgICAgICBpZiAoIXRlc3QobGluZS5jaGFyQXQoaWR4KSkpIHtcbiAgICAgICAgICB0ZXN0ID0gd29yZENoYXJUZXN0WzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmQgPSBpZHgsIHN0YXJ0ID0gaWR4O1xuICAgICAgd2hpbGUgKHRlc3QobGluZS5jaGFyQXQoZW5kKSkgJiYgZW5kIDwgbGluZS5sZW5ndGgpIHsgZW5kKys7IH1cbiAgICAgIHdoaWxlICh0ZXN0KGxpbmUuY2hhckF0KHN0YXJ0KSkgJiYgc3RhcnQgPj0gMCkgeyBzdGFydC0tOyB9XG4gICAgICBzdGFydCsrO1xuXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIC8vIElmIHByZXNlbnQsIGluY2x1ZGUgYWxsIHdoaXRlc3BhY2UgYWZ0ZXIgd29yZC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbmNsdWRlIGFsbCB3aGl0ZXNwYWNlIGJlZm9yZSB3b3JkLCBleGNlcHQgaW5kZW50YXRpb24uXG4gICAgICAgIHZhciB3b3JkRW5kID0gZW5kO1xuICAgICAgICB3aGlsZSAoL1xccy8udGVzdChsaW5lLmNoYXJBdChlbmQpKSAmJiBlbmQgPCBsaW5lLmxlbmd0aCkgeyBlbmQrKzsgfVxuICAgICAgICBpZiAod29yZEVuZCA9PSBlbmQpIHtcbiAgICAgICAgICB2YXIgd29yZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3QobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkgJiYgc3RhcnQgPiAwKSB7IHN0YXJ0LS07IH1cbiAgICAgICAgICBpZiAoIXN0YXJ0KSB7IHN0YXJ0ID0gd29yZFN0YXJ0OyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXJ0OiBuZXcgUG9zKGN1ci5saW5lLCBzdGFydCksIGVuZDogbmV3IFBvcyhjdXIubGluZSwgZW5kKSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGVuZHMgb24gdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIC0gZWRpdG9yIG1vZGUgc2hvdWxkIGJlIGh0bWxtaXhlZG1vZGUgLyB4bWxcbiAgICAgKiAtIG1vZGUveG1sL3htbC5qcyBzaG91bGQgYmUgbG9hZGVkXG4gICAgICogLSBhZGRvbi9mb2xkL3htbC1mb2xkLmpzIHNob3VsZCBiZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB0aGUgYWJvdmUgcmVxdWlyZW1lbnRzIGFyZSBub3QgdHJ1ZSwgdGhpcyBmdW5jdGlvbiBub29wcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgX05PVF8gYSAxMDAlIGFjY3VyYXRlIGltcGxlbWVudGF0aW9uIG9mIHZpbSB0YWcgdGV4dCBvYmplY3RzLlxuICAgICAqIFRoZSBmb2xsb3dpbmcgY2F2ZWF0cyBhcHBseSAoYmFzZWQgb2ZmIGN1cnNvcnkgdGVzdGluZywgSSdtIHN1cmUgdGhlcmVcbiAgICAgKiBhcmUgb3RoZXIgZGlzY3JlcGFuY2llcyk6XG4gICAgICpcbiAgICAgKiAtIERvZXMgbm90IHdvcmsgaW5zaWRlIGNvbW1lbnRzOlxuICAgICAqICAgYGBgXG4gICAgICogICA8IS0tIDxkaXY+YnJva2VuPC9kaXY+IC0tPlxuICAgICAqICAgYGBgXG4gICAgICogLSBEb2VzIG5vdCB3b3JrIHdoZW4gdGFncyBoYXZlIGRpZmZlcmVudCBjYXNlczpcbiAgICAgKiAgIGBgYFxuICAgICAqICAgPGRpdj5icm9rZW48L0RJVj5cbiAgICAgKiAgIGBgYFxuICAgICAqIC0gRG9lcyBub3Qgd29yayB3aGVuIGN1cnNvciBpcyBpbnNpZGUgYSBicm9rZW4gdGFnOlxuICAgICAqICAgYGBgXG4gICAgICogICA8ZGl2Pjxicm9rPjxlbj48L2Rpdj5cbiAgICAgKiAgIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4cGFuZFRhZ1VuZGVyQ3Vyc29yKGNtLCBoZWFkLCBpbmNsdXNpdmUpIHtcbiAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgaWYgKCFDb2RlTWlycm9yLmZpbmRNYXRjaGluZ1RhZyB8fCAhQ29kZU1pcnJvci5maW5kRW5jbG9zaW5nVGFnKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBjdXIsIGVuZDogY3VyIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdzID0gQ29kZU1pcnJvci5maW5kTWF0Y2hpbmdUYWcoY20sIGhlYWQpIHx8IENvZGVNaXJyb3IuZmluZEVuY2xvc2luZ1RhZyhjbSwgaGVhZCk7XG4gICAgICBpZiAoIXRhZ3MgfHwgIXRhZ3Mub3BlbiB8fCAhdGFncy5jbG9zZSkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogY3VyLCBlbmQ6IGN1ciB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiB0YWdzLm9wZW4uZnJvbSwgZW5kOiB0YWdzLmNsb3NlLnRvIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGFydDogdGFncy5vcGVuLnRvLCBlbmQ6IHRhZ3MuY2xvc2UuZnJvbSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgb2xkQ3VyLCBuZXdDdXIpIHtcbiAgICAgIGlmICghY3Vyc29yRXF1YWwob2xkQ3VyLCBuZXdDdXIpKSB7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0LmFkZChjbSwgb2xkQ3VyLCBuZXdDdXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY29yZExhc3RDaGFyYWN0ZXJTZWFyY2goaW5jcmVtZW50LCBhcmdzKSB7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guaW5jcmVtZW50ID0gaW5jcmVtZW50O1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoLmZvcndhcmQgPSBhcmdzLmZvcndhcmQ7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guc2VsZWN0ZWRDaGFyYWN0ZXIgPSBhcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xUb01vZGUgPSB7XG4gICAgICAgICcoJzogJ2JyYWNrZXQnLCAnKSc6ICdicmFja2V0JywgJ3snOiAnYnJhY2tldCcsICd9JzogJ2JyYWNrZXQnLFxuICAgICAgICAnWyc6ICdzZWN0aW9uJywgJ10nOiAnc2VjdGlvbicsXG4gICAgICAgICcqJzogJ2NvbW1lbnQnLCAnLyc6ICdjb21tZW50JyxcbiAgICAgICAgJ20nOiAnbWV0aG9kJywgJ00nOiAnbWV0aG9kJyxcbiAgICAgICAgJyMnOiAncHJlcHJvY2VzcydcbiAgICB9O1xuICAgIHZhciBmaW5kU3ltYm9sTW9kZXMgPSB7XG4gICAgICBicmFja2V0OiB7XG4gICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLm5leHRDaCA9PT0gc3RhdGUuc3ltYikge1xuICAgICAgICAgICAgc3RhdGUuZGVwdGgrKztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kZXB0aCA+PSAxKXJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubmV4dENoID09PSBzdGF0ZS5yZXZlcnNlU3ltYikge1xuICAgICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VjdGlvbjoge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmN1ck1vdmVUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS5zeW1iID0gKHN0YXRlLmZvcndhcmQgPyAnXScgOiAnWycpID09PSBzdGF0ZS5zeW1iID8gJ3snIDogJ30nO1xuICAgICAgICB9LFxuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5pbmRleCA9PT0gMCAmJiBzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnN5bWI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gc3RhdGUubGFzdENoID09PSAnKicgJiYgc3RhdGUubmV4dENoID09PSAnLyc7XG4gICAgICAgICAgc3RhdGUubGFzdENoID0gc3RhdGUubmV4dENoO1xuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFRPRE86IFRoZSBvcmlnaW5hbCBWaW0gaW1wbGVtZW50YXRpb24gb25seSBvcGVyYXRlcyBvbiBsZXZlbCAxIGFuZCAyLlxuICAgICAgLy8gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndCBjaGVjayBmb3IgY29kZSBibG9jayBsZXZlbCBhbmRcbiAgICAgIC8vIHRoZXJlZm9yZSBpdCBvcGVyYXRlcyBvbiBhbnkgbGV2ZWxzLlxuICAgICAgbWV0aG9kOiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUuc3ltYiA9IChzdGF0ZS5zeW1iID09PSAnbScgPyAneycgOiAnfScpO1xuICAgICAgICAgIHN0YXRlLnJldmVyc2VTeW1iID0gc3RhdGUuc3ltYiA9PT0gJ3snID8gJ30nIDogJ3snO1xuICAgICAgICB9LFxuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnN5bWIpcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJlcHJvY2Vzczoge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmluZGV4ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21wbGV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUubmV4dENoID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXRlLmxpbmVUZXh0Lm1hdGNoKC9eIyhcXHcrKS8pWzFdO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnZW5kaWYnKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5mb3J3YXJkICYmIHN0YXRlLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuZGVwdGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdpZicpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mb3J3YXJkICYmIHN0YXRlLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ2Vsc2UnICYmIHN0YXRlLmRlcHRoID09PSAwKXJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpbmRTeW1ib2woY20sIHJlcGVhdCwgZm9yd2FyZCwgc3ltYikge1xuICAgICAgdmFyIGN1ciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgdmFyIGluY3JlbWVudCA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICB2YXIgZW5kTGluZSA9IGZvcndhcmQgPyBjbS5saW5lQ291bnQoKSA6IC0xO1xuICAgICAgdmFyIGN1ckNoID0gY3VyLmNoO1xuICAgICAgdmFyIGxpbmUgPSBjdXIubGluZTtcbiAgICAgIHZhciBsaW5lVGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGxpbmVUZXh0OiBsaW5lVGV4dCxcbiAgICAgICAgbmV4dENoOiBsaW5lVGV4dC5jaGFyQXQoY3VyQ2gpLFxuICAgICAgICBsYXN0Q2g6IG51bGwsXG4gICAgICAgIGluZGV4OiBjdXJDaCxcbiAgICAgICAgc3ltYjogc3ltYixcbiAgICAgICAgcmV2ZXJzZVN5bWI6IChmb3J3YXJkID8gIHsgJyknOiAnKCcsICd9JzogJ3snIH0gOiB7ICcoJzogJyknLCAneyc6ICd9JyB9KVtzeW1iXSxcbiAgICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIGN1ck1vdmVUaHJvdWdoOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBtb2RlID0gc3ltYm9sVG9Nb2RlW3N5bWJdO1xuICAgICAgaWYgKCFtb2RlKXJldHVybiBjdXI7XG4gICAgICB2YXIgaW5pdCA9IGZpbmRTeW1ib2xNb2Rlc1ttb2RlXS5pbml0O1xuICAgICAgdmFyIGlzQ29tcGxldGUgPSBmaW5kU3ltYm9sTW9kZXNbbW9kZV0uaXNDb21wbGV0ZTtcbiAgICAgIGlmIChpbml0KSB7IGluaXQoc3RhdGUpOyB9XG4gICAgICB3aGlsZSAobGluZSAhPT0gZW5kTGluZSAmJiByZXBlYXQpIHtcbiAgICAgICAgc3RhdGUuaW5kZXggKz0gaW5jcmVtZW50O1xuICAgICAgICBzdGF0ZS5uZXh0Q2ggPSBzdGF0ZS5saW5lVGV4dC5jaGFyQXQoc3RhdGUuaW5kZXgpO1xuICAgICAgICBpZiAoIXN0YXRlLm5leHRDaCkge1xuICAgICAgICAgIGxpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgICAgIHN0YXRlLmxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKSB8fCAnJztcbiAgICAgICAgICBpZiAoaW5jcmVtZW50ID4gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZXggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGluZUxlbiA9IHN0YXRlLmxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gKGxpbmVMZW4gPiAwKSA/IChsaW5lTGVuLTEpIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUubmV4dENoID0gc3RhdGUubGluZVRleHQuY2hhckF0KHN0YXRlLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb21wbGV0ZShzdGF0ZSkpIHtcbiAgICAgICAgICBjdXIubGluZSA9IGxpbmU7XG4gICAgICAgICAgY3VyLmNoID0gc3RhdGUuaW5kZXg7XG4gICAgICAgICAgcmVwZWF0LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5uZXh0Q2ggfHwgc3RhdGUuY3VyTW92ZVRocm91Z2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZSwgc3RhdGUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIG5leHQgd29yZC4gSWYgdGhlIGN1cnNvciBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICogdGhlIHdvcmQsIHRoZW4gcmV0dXJucyB0aGUgYm91bmRhcmllcyBvZiB0aGUgY3VycmVudCB3b3JkLCBzdGFydGluZyBhdFxuICAgICAqIHRoZSBjdXJzb3IuIElmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0L2VuZCBvZiBhIHdvcmQsIGFuZCB3ZSBhcmUgZ29pbmdcbiAgICAgKiBmb3J3YXJkL2JhY2t3YXJkLCByZXNwZWN0aXZlbHksIGZpbmQgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIG5leHQgd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29kZU1pcnJvcn0gY20gQ29kZU1pcnJvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtDdXJzb3J9IGN1ciBUaGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZCBUcnVlIHRvIHNlYXJjaCBmb3J3YXJkLiBGYWxzZSB0byBzZWFyY2hcbiAgICAgKiAgICAgYmFja3dhcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaWdXb3JkIFRydWUgaWYgcHVuY3R1YXRpb24gY291bnQgYXMgcGFydCBvZiB0aGUgd29yZC5cbiAgICAgKiAgICAgRmFsc2UgaWYgb25seSBbYS16QS1aMC05XSBjaGFyYWN0ZXJzIGNvdW50IGFzIHBhcnQgb2YgdGhlIHdvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbXB0eUxpbmVJc1dvcmQgVHJ1ZSBpZiBlbXB0eSBsaW5lcyBzaG91bGQgYmUgdHJlYXRlZFxuICAgICAqICAgICBhcyB3b3Jkcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R7ZnJvbTpudW1iZXIsIHRvOm51bWJlciwgbGluZTogbnVtYmVyfX0gVGhlIGJvdW5kYXJpZXMgb2ZcbiAgICAgKiAgICAgdGhlIHdvcmQsIG9yIG51bGwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgd29yZHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFdvcmQoY20sIGN1ciwgZm9yd2FyZCwgYmlnV29yZCwgZW1wdHlMaW5lSXNXb3JkKSB7XG4gICAgICB2YXIgbGluZU51bSA9IGN1ci5saW5lO1xuICAgICAgdmFyIHBvcyA9IGN1ci5jaDtcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsaW5lTnVtKTtcbiAgICAgIHZhciBkaXIgPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgdmFyIGNoYXJUZXN0cyA9IGJpZ1dvcmQgPyBiaWdXb3JkQ2hhclRlc3Q6IHdvcmRDaGFyVGVzdDtcblxuICAgICAgaWYgKGVtcHR5TGluZUlzV29yZCAmJiBsaW5lID09ICcnKSB7XG4gICAgICAgIGxpbmVOdW0gKz0gZGlyO1xuICAgICAgICBsaW5lID0gY20uZ2V0TGluZShsaW5lTnVtKTtcbiAgICAgICAgaWYgKCFpc0xpbmUoY20sIGxpbmVOdW0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gKGZvcndhcmQpID8gMCA6IGxpbmUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoZW1wdHlMaW5lSXNXb3JkICYmIGxpbmUgPT0gJycpIHtcbiAgICAgICAgICByZXR1cm4geyBmcm9tOiAwLCB0bzogMCwgbGluZTogbGluZU51bSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9wID0gKGRpciA+IDApID8gbGluZS5sZW5ndGggOiAtMTtcbiAgICAgICAgdmFyIHdvcmRTdGFydCA9IHN0b3AsIHdvcmRFbmQgPSBzdG9wO1xuICAgICAgICAvLyBGaW5kIGJvdW5kcyBvZiBuZXh0IHdvcmQuXG4gICAgICAgIHdoaWxlIChwb3MgIT0gc3RvcCkge1xuICAgICAgICAgIHZhciBmb3VuZFdvcmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJUZXN0cy5sZW5ndGggJiYgIWZvdW5kV29yZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2hhclRlc3RzW2ldKGxpbmUuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgIHdvcmRTdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byBlbmQgb2Ygd29yZC5cbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyAhPSBzdG9wICYmIGNoYXJUZXN0c1tpXShsaW5lLmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29yZEVuZCA9IHBvcztcbiAgICAgICAgICAgICAgZm91bmRXb3JkID0gd29yZFN0YXJ0ICE9IHdvcmRFbmQ7XG4gICAgICAgICAgICAgIGlmICh3b3JkU3RhcnQgPT0gY3VyLmNoICYmIGxpbmVOdW0gPT0gY3VyLmxpbmUgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmRFbmQgPT0gd29yZFN0YXJ0ICsgZGlyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RhcnRlZCBhdCB0aGUgZW5kIG9mIGEgd29yZC4gRmluZCB0aGUgbmV4dCBvbmUuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGZyb206IE1hdGgubWluKHdvcmRTdGFydCwgd29yZEVuZCArIDEpLFxuICAgICAgICAgICAgICAgICAgdG86IE1hdGgubWF4KHdvcmRTdGFydCwgd29yZEVuZCksXG4gICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZFdvcmQpIHtcbiAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dC9wcmV2IGxpbmUuXG4gICAgICAgIGxpbmVOdW0gKz0gZGlyO1xuICAgICAgICBpZiAoIWlzTGluZShjbSwgbGluZU51bSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gY20uZ2V0TGluZShsaW5lTnVtKTtcbiAgICAgICAgcG9zID0gKGRpciA+IDApID8gMCA6IGxpbmUubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29kZU1pcnJvcn0gY20gQ29kZU1pcnJvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtQb3N9IGN1ciBUaGUgcG9zaXRpb24gdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge2ludH0gcmVwZWF0IE51bWJlciBvZiB3b3JkcyB0byBtb3ZlIHBhc3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkIFRydWUgdG8gc2VhcmNoIGZvcndhcmQuIEZhbHNlIHRvIHNlYXJjaFxuICAgICAqICAgICBiYWNrd2FyZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdvcmRFbmQgVHJ1ZSB0byBtb3ZlIHRvIGVuZCBvZiB3b3JkLiBGYWxzZSB0byBtb3ZlIHRvXG4gICAgICogICAgIGJlZ2lubmluZyBvZiB3b3JkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmlnV29yZCBUcnVlIGlmIHB1bmN0dWF0aW9uIGNvdW50IGFzIHBhcnQgb2YgdGhlIHdvcmQuXG4gICAgICogICAgIEZhbHNlIGlmIG9ubHkgYWxwaGFiZXQgY2hhcmFjdGVycyBjb3VudCBhcyBwYXJ0IG9mIHRoZSB3b3JkLlxuICAgICAqIEByZXR1cm4ge0N1cnNvcn0gVGhlIHBvc2l0aW9uIHRoZSBjdXJzb3Igc2hvdWxkIG1vdmUgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW92ZVRvV29yZChjbSwgY3VyLCByZXBlYXQsIGZvcndhcmQsIHdvcmRFbmQsIGJpZ1dvcmQpIHtcbiAgICAgIHZhciBjdXJTdGFydCA9IGNvcHlDdXJzb3IoY3VyKTtcbiAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgaWYgKGZvcndhcmQgJiYgIXdvcmRFbmQgfHwgIWZvcndhcmQgJiYgd29yZEVuZCkge1xuICAgICAgICByZXBlYXQrKztcbiAgICAgIH1cbiAgICAgIC8vIEZvciAnZScsIGVtcHR5IGxpbmVzIGFyZSBub3QgY29uc2lkZXJlZCB3b3JkcywgZ28gZmlndXJlLlxuICAgICAgdmFyIGVtcHR5TGluZUlzV29yZCA9ICEoZm9yd2FyZCAmJiB3b3JkRW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgdmFyIHdvcmQgPSBmaW5kV29yZChjbSwgY3VyLCBmb3J3YXJkLCBiaWdXb3JkLCBlbXB0eUxpbmVJc1dvcmQpO1xuICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICB2YXIgZW9kQ2ggPSBsaW5lTGVuZ3RoKGNtLCBjbS5sYXN0TGluZSgpKTtcbiAgICAgICAgICB3b3Jkcy5wdXNoKGZvcndhcmRcbiAgICAgICAgICAgICAgPyB7bGluZTogY20ubGFzdExpbmUoKSwgZnJvbTogZW9kQ2gsIHRvOiBlb2RDaH1cbiAgICAgICAgICAgICAgOiB7bGluZTogMCwgZnJvbTogMCwgdG86IDB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuICAgICAgICBjdXIgPSBuZXcgUG9zKHdvcmQubGluZSwgZm9yd2FyZCA/ICh3b3JkLnRvIC0gMSkgOiB3b3JkLmZyb20pO1xuICAgICAgfVxuICAgICAgdmFyIHNob3J0Q2lyY3VpdCA9IHdvcmRzLmxlbmd0aCAhPSByZXBlYXQ7XG4gICAgICB2YXIgZmlyc3RXb3JkID0gd29yZHNbMF07XG4gICAgICB2YXIgbGFzdFdvcmQgPSB3b3Jkcy5wb3AoKTtcbiAgICAgIGlmIChmb3J3YXJkICYmICF3b3JkRW5kKSB7XG4gICAgICAgIC8vIHdcbiAgICAgICAgaWYgKCFzaG9ydENpcmN1aXQgJiYgKGZpcnN0V29yZC5mcm9tICE9IGN1clN0YXJ0LmNoIHx8IGZpcnN0V29yZC5saW5lICE9IGN1clN0YXJ0LmxpbmUpKSB7XG4gICAgICAgICAgLy8gV2UgZGlkIG5vdCBzdGFydCBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC4gRGlzY2FyZCB0aGUgZXh0cmEgd29yZCBhdCB0aGUgZW5kLlxuICAgICAgICAgIGxhc3RXb3JkID0gd29yZHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGFzdFdvcmQubGluZSwgbGFzdFdvcmQuZnJvbSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgd29yZEVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhsYXN0V29yZC5saW5lLCBsYXN0V29yZC50byAtIDEpO1xuICAgICAgfSBlbHNlIGlmICghZm9yd2FyZCAmJiB3b3JkRW5kKSB7XG4gICAgICAgIC8vIGdlXG4gICAgICAgIGlmICghc2hvcnRDaXJjdWl0ICYmIChmaXJzdFdvcmQudG8gIT0gY3VyU3RhcnQuY2ggfHwgZmlyc3RXb3JkLmxpbmUgIT0gY3VyU3RhcnQubGluZSkpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbm90IHN0YXJ0IGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLiBEaXNjYXJkIHRoZSBleHRyYSB3b3JkIGF0IHRoZSBlbmQuXG4gICAgICAgICAgbGFzdFdvcmQgPSB3b3Jkcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvcyhsYXN0V29yZC5saW5lLCBsYXN0V29yZC50byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiXG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxhc3RXb3JkLmxpbmUsIGxhc3RXb3JkLmZyb20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVUb0VvbChjbSwgaGVhZCwgbW90aW9uQXJncywgdmltLCBrZWVwSFBvcykge1xuICAgICAgdmFyIGN1ciA9IGhlYWQ7XG4gICAgICB2YXIgcmV0dmFsPSBuZXcgUG9zKGN1ci5saW5lICsgbW90aW9uQXJncy5yZXBlYXQgLSAxLCBJbmZpbml0eSk7XG4gICAgICB2YXIgZW5kPWNtLmNsaXBQb3MocmV0dmFsKTtcbiAgICAgIGVuZC5jaC0tO1xuICAgICAgaWYgKCFrZWVwSFBvcykge1xuICAgICAgICB2aW0ubGFzdEhQb3MgPSBJbmZpbml0eTtcbiAgICAgICAgdmltLmxhc3RIU1BvcyA9IGNtLmNoYXJDb29yZHMoZW5kLCdkaXYnKS5sZWZ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlVG9DaGFyYWN0ZXIoY20sIHJlcGVhdCwgZm9yd2FyZCwgY2hhcmFjdGVyKSB7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICB2YXIgc3RhcnQgPSBjdXIuY2g7XG4gICAgICB2YXIgaWR4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkgKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICAgICAgaWR4ID0gY2hhcklkeEluTGluZShzdGFydCwgbGluZSwgY2hhcmFjdGVyLCBmb3J3YXJkLCB0cnVlKTtcbiAgICAgICAgaWYgKGlkeCA9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQb3MoY20uZ2V0Q3Vyc29yKCkubGluZSwgaWR4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlVG9Db2x1bW4oY20sIHJlcGVhdCkge1xuICAgICAgLy8gcmVwZWF0IGlzIGFsd2F5cyA+PSAxLCBzbyByZXBlYXQgLSAxIGFsd2F5cyBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNvbHVtbiB3ZSB3YW50IHRvIGdvIHRvLlxuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRDdXJzb3IoKS5saW5lO1xuICAgICAgcmV0dXJuIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIG5ldyBQb3MobGluZSwgcmVwZWF0IC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hcmsoY20sIHZpbSwgbWFya05hbWUsIHBvcykge1xuICAgICAgaWYgKCFpbkFycmF5KG1hcmtOYW1lLCB2YWxpZE1hcmtzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmltLm1hcmtzW21hcmtOYW1lXSkge1xuICAgICAgICB2aW0ubWFya3NbbWFya05hbWVdLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB2aW0ubWFya3NbbWFya05hbWVdID0gY20uc2V0Qm9va21hcmsocG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFySWR4SW5MaW5lKHN0YXJ0LCBsaW5lLCBjaGFyYWN0ZXIsIGZvcndhcmQsIGluY2x1ZGVDaGFyKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGNoYXIgaW4gbGluZS5cbiAgICAgIC8vIG1vdGlvbl9vcHRpb25zOiB7Zm9yd2FyZCwgaW5jbHVkZUNoYXJ9XG4gICAgICAvLyBJZiBpbmNsdWRlQ2hhciA9IHRydWUsIGluY2x1ZGUgaXQgdG9vLlxuICAgICAgLy8gSWYgZm9yd2FyZCA9IHRydWUsIHNlYXJjaCBmb3J3YXJkLCBlbHNlIHNlYXJjaCBiYWNrd2FyZHMuXG4gICAgICAvLyBJZiBjaGFyIGlzIG5vdCBmb3VuZCBvbiB0aGlzIGxpbmUsIGRvIG5vdGhpbmdcbiAgICAgIHZhciBpZHg7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBpZHggPSBsaW5lLmluZGV4T2YoY2hhcmFjdGVyLCBzdGFydCArIDEpO1xuICAgICAgICBpZiAoaWR4ICE9IC0xICYmICFpbmNsdWRlQ2hhcikge1xuICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSBsaW5lLmxhc3RJbmRleE9mKGNoYXJhY3Rlciwgc3RhcnQgLSAxKTtcbiAgICAgICAgaWYgKGlkeCAhPSAtMSAmJiAhaW5jbHVkZUNoYXIpIHtcbiAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kUGFyYWdyYXBoKGNtLCBoZWFkLCByZXBlYXQsIGRpciwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgbGluZSA9IGhlYWQubGluZTtcbiAgICAgIHZhciBtaW4gPSBjbS5maXJzdExpbmUoKTtcbiAgICAgIHZhciBtYXggPSBjbS5sYXN0TGluZSgpO1xuICAgICAgdmFyIHN0YXJ0LCBlbmQsIGkgPSBsaW5lO1xuICAgICAgZnVuY3Rpb24gaXNFbXB0eShpKSB7IHJldHVybiAhY20uZ2V0TGluZShpKTsgfVxuICAgICAgZnVuY3Rpb24gaXNCb3VuZGFyeShpLCBkaXIsIGFueSkge1xuICAgICAgICBpZiAoYW55KSB7IHJldHVybiBpc0VtcHR5KGkpICE9IGlzRW1wdHkoaSArIGRpcik7IH1cbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KGkpICYmIGlzRW1wdHkoaSArIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHdoaWxlIChtaW4gPD0gaSAmJiBpIDw9IG1heCAmJiByZXBlYXQgPiAwKSB7XG4gICAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgZGlyKSkgeyByZXBlYXQtLTsgfVxuICAgICAgICAgIGkgKz0gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgaWYgKHZpbS52aXN1YWxMaW5lICYmIGlzQm91bmRhcnkobGluZSwgMSwgdHJ1ZSkpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHZpbS5zZWwuYW5jaG9yO1xuICAgICAgICBpZiAoaXNCb3VuZGFyeShhbmNob3IubGluZSwgLTEsIHRydWUpKSB7XG4gICAgICAgICAgaWYgKCFpbmNsdXNpdmUgfHwgYW5jaG9yLmxpbmUgIT0gbGluZSkge1xuICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBpc0VtcHR5KGxpbmUpO1xuICAgICAgZm9yIChpID0gbGluZTsgaSA8PSBtYXggJiYgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgMSwgdHJ1ZSkpIHtcbiAgICAgICAgICBpZiAoIWluY2x1c2l2ZSB8fCBpc0VtcHR5KGkpICE9IHN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHJlcGVhdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gbmV3IFBvcyhpLCAwKTtcbiAgICAgIC8vIHNlbGVjdCBib3VuZGFyeSBiZWZvcmUgcGFyYWdyYXBoIGZvciB0aGUgbGFzdCBvbmVcbiAgICAgIGlmIChpID4gbWF4ICYmICFzdGFydFN0YXRlKSB7IHN0YXJ0U3RhdGUgPSB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW5jbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgIGZvciAoaSA9IGxpbmU7IGkgPiBtaW47IGktLSkge1xuICAgICAgICBpZiAoIWluY2x1c2l2ZSB8fCBpc0VtcHR5KGkpID09IHN0YXJ0U3RhdGUgfHwgaSA9PSBsaW5lKSB7XG4gICAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgLTEsIHRydWUpKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmV3IFBvcyhpLCAwKTtcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU2VudGVuY2UoY20sIGN1ciwgcmVwZWF0LCBkaXIpIHtcblxuICAgICAgLypcbiAgICAgICAgVGFrZXMgYW4gaW5kZXggb2JqZWN0XG4gICAgICAgIHtcbiAgICAgICAgICBsaW5lOiB0aGUgbGluZSBzdHJpbmcsXG4gICAgICAgICAgbG46IGxpbmUgbnVtYmVyLFxuICAgICAgICAgIHBvczogaW5kZXggaW4gbGluZSxcbiAgICAgICAgICBkaXI6IGRpcmVjdGlvbiBvZiB0cmF2ZXJzYWwgKC0xIG9yIDEpXG4gICAgICAgIH1cbiAgICAgICAgYW5kIG1vZGlmaWVzIHRoZSBsaW5lLCBsbiwgYW5kIHBvcyBtZW1iZXJzIHRvIHJlcHJlc2VudCB0aGVcbiAgICAgICAgbmV4dCB2YWxpZCBwb3NpdGlvbiBvciBzZXRzIHRoZW0gdG8gbnVsbCBpZiB0aGVyZSBhcmVcbiAgICAgICAgbm8gbW9yZSB2YWxpZCBwb3NpdGlvbnMuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG5leHRDaGFyKGNtLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeC5wb3MgKyBpZHguZGlyIDwgMCB8fCBpZHgucG9zICsgaWR4LmRpciA+PSBpZHgubGluZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZHgubG4gKz0gaWR4LmRpcjtcbiAgICAgICAgICBpZiAoIWlzTGluZShjbSwgaWR4LmxuKSkge1xuICAgICAgICAgICAgaWR4LmxpbmUgPSBudWxsO1xuICAgICAgICAgICAgaWR4LmxuID0gbnVsbDtcbiAgICAgICAgICAgIGlkeC5wb3MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgubGluZSA9IGNtLmdldExpbmUoaWR4LmxuKTtcbiAgICAgICAgICBpZHgucG9zID0gKGlkeC5kaXIgPiAwKSA/IDAgOiBpZHgubGluZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlkeC5wb3MgKz0gaWR4LmRpcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgICAgICBSZXR1cm5zIGFuIGluZGV4IG9iamVjdCBvZiB0aGUgbmV3IGxvY2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGZvcndhcmQoY20sIGxuLCBwb3MsIGRpcikge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuICAgICAgICB2YXIgc3RvcCA9IChsaW5lID09PSBcIlwiKTtcblxuICAgICAgICB2YXIgY3VyciA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgIGxuOiBsbixcbiAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICBkaXI6IGRpcixcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0X3ZhbGlkID0ge1xuICAgICAgICAgIGxuOiBjdXJyLmxuLFxuICAgICAgICAgIHBvczogY3Vyci5wb3MsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2tpcF9lbXB0eV9saW5lcyA9IChjdXJyLmxpbmUgPT09IFwiXCIpO1xuXG4gICAgICAgIC8vIE1vdmUgb25lIHN0ZXAgdG8gc2tpcCBjaGFyYWN0ZXIgd2Ugc3RhcnQgb25cbiAgICAgICAgbmV4dENoYXIoY20sIGN1cnIpO1xuXG4gICAgICAgIHdoaWxlIChjdXJyLmxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X3ZhbGlkLmxuID0gY3Vyci5sbjtcbiAgICAgICAgICBsYXN0X3ZhbGlkLnBvcyA9IGN1cnIucG9zO1xuXG4gICAgICAgICAgaWYgKGN1cnIubGluZSA9PT0gXCJcIiAmJiAhc2tpcF9lbXB0eV9saW5lcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MsIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0b3AgJiYgY3Vyci5saW5lICE9PSBcIlwiICYmICFpc1doaXRlU3BhY2VTdHJpbmcoY3Vyci5saW5lW2N1cnIucG9zXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zLCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0VuZE9mU2VudGVuY2VTeW1ib2woY3Vyci5saW5lW2N1cnIucG9zXSlcbiAgICAgICAgICAgICYmICFzdG9wXG4gICAgICAgICAgICAmJiAoY3Vyci5wb3MgPT09IGN1cnIubGluZS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIHx8IGlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3MgKyAxXSkpKSB7XG4gICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0Q2hhcihjbSwgY3Vycik7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgIFNldCB0aGUgcG9zaXRpb24gdG8gdGhlIGxhc3Qgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoZSBsYXN0XG4gICAgICAgICAgdmFsaWQgbGluZSBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAqL1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobGFzdF92YWxpZC5sbik7XG4gICAgICAgIGxhc3RfdmFsaWQucG9zID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gbGluZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIGlmICghaXNXaGl0ZVNwYWNlU3RyaW5nKGxpbmVbaV0pKSB7XG4gICAgICAgICAgICBsYXN0X3ZhbGlkLnBvcyA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdF92YWxpZDtcblxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICBSZXR1cm5zIGFuIGluZGV4IG9iamVjdCBvZiB0aGUgbmV3IGxvY2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJldmVyc2UoY20sIGxuLCBwb3MsIGRpcikge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuXG4gICAgICAgIHZhciBjdXJyID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgbG46IGxuLFxuICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgIGRpcjogZGlyLFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RfdmFsaWQgPSB7XG4gICAgICAgICAgbG46IGN1cnIubG4sXG4gICAgICAgICAgcG9zOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBza2lwX2VtcHR5X2xpbmVzID0gKGN1cnIubGluZSA9PT0gXCJcIik7XG5cbiAgICAgICAgLy8gTW92ZSBvbmUgc3RlcCB0byBza2lwIGNoYXJhY3RlciB3ZSBzdGFydCBvblxuICAgICAgICBuZXh0Q2hhcihjbSwgY3Vycik7XG5cbiAgICAgICAgd2hpbGUgKGN1cnIubGluZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgaWYgKGN1cnIubGluZSA9PT0gXCJcIiAmJiAhc2tpcF9lbXB0eV9saW5lcykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdmFsaWQucG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzRW5kT2ZTZW50ZW5jZVN5bWJvbChjdXJyLmxpbmVbY3Vyci5wb3NdKVxuICAgICAgICAgICAgICAmJiBsYXN0X3ZhbGlkLnBvcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAmJiAhKGN1cnIubG4gPT09IGxhc3RfdmFsaWQubG4gJiYgY3Vyci5wb3MgKyAxID09PSBsYXN0X3ZhbGlkLnBvcykpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjdXJyLmxpbmUgIT09IFwiXCIgJiYgIWlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3NdKSkge1xuICAgICAgICAgICAgc2tpcF9lbXB0eV9saW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGFzdF92YWxpZCA9IHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAgU2V0IHRoZSBwb3NpdGlvbiB0byB0aGUgZmlyc3Qgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoZSBsYXN0XG4gICAgICAgICAgdmFsaWQgbGluZSBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlYWNoIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAqL1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobGFzdF92YWxpZC5sbik7XG4gICAgICAgIGxhc3RfdmFsaWQucG9zID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWlzV2hpdGVTcGFjZVN0cmluZyhsaW5lW2ldKSkge1xuICAgICAgICAgICAgbGFzdF92YWxpZC5wb3MgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3Vycl9pbmRleCA9IHtcbiAgICAgICAgbG46IGN1ci5saW5lLFxuICAgICAgICBwb3M6IGN1ci5jaCxcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChyZXBlYXQgPiAwKSB7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgY3Vycl9pbmRleCA9IHJldmVyc2UoY20sIGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zLCBkaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN1cnJfaW5kZXggPSBmb3J3YXJkKGNtLCBjdXJyX2luZGV4LmxuLCBjdXJyX2luZGV4LnBvcywgZGlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXBlYXQtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQb3MoY3Vycl9pbmRleC5sbiwgY3Vycl9pbmRleC5wb3MpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHBlcmhhcHMgdGhpcyBmaW5hZ2xpbmcgb2Ygc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgYmVsb25nc1xuICAgIC8vIGluIGNvZGVtaXJyb3IvcmVwbGFjZVJhbmdlP1xuICAgIGZ1bmN0aW9uIHNlbGVjdENvbXBhbmlvbk9iamVjdChjbSwgaGVhZCwgc3ltYiwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgY3VyID0gaGVhZCwgc3RhcnQsIGVuZDtcblxuICAgICAgdmFyIGJyYWNrZXRSZWdleHAgPSAoe1xuICAgICAgICAnKCc6IC9bKCldLywgJyknOiAvWygpXS8sXG4gICAgICAgICdbJzogL1tbXFxdXS8sICddJzogL1tbXFxdXS8sXG4gICAgICAgICd7JzogL1t7fV0vLCAnfSc6IC9be31dLyxcbiAgICAgICAgJzwnOiAvWzw+XS8sICc+JzogL1s8Pl0vfSlbc3ltYl07XG4gICAgICB2YXIgb3BlblN5bSA9ICh7XG4gICAgICAgICcoJzogJygnLCAnKSc6ICcoJyxcbiAgICAgICAgJ1snOiAnWycsICddJzogJ1snLFxuICAgICAgICAneyc6ICd7JywgJ30nOiAneycsXG4gICAgICAgICc8JzogJzwnLCAnPic6ICc8J30pW3N5bWJdO1xuICAgICAgdmFyIGN1ckNoYXIgPSBjbS5nZXRMaW5lKGN1ci5saW5lKS5jaGFyQXQoY3VyLmNoKTtcbiAgICAgIC8vIER1ZSB0byB0aGUgYmVoYXZpb3Igb2Ygc2NhbkZvckJyYWNrZXQsIHdlIG5lZWQgdG8gYWRkIGFuIG9mZnNldCBpZiB0aGVcbiAgICAgIC8vIGN1cnNvciBpcyBvbiBhIG1hdGNoaW5nIG9wZW4gYnJhY2tldC5cbiAgICAgIHZhciBvZmZzZXQgPSBjdXJDaGFyID09PSBvcGVuU3ltID8gMSA6IDA7XG5cbiAgICAgIHN0YXJ0ID0gY20uc2NhbkZvckJyYWNrZXQobmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgb2Zmc2V0KSwgLTEsIHVuZGVmaW5lZCwgeydicmFja2V0UmVnZXgnOiBicmFja2V0UmVnZXhwfSk7XG4gICAgICBlbmQgPSBjbS5zY2FuRm9yQnJhY2tldChuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyBvZmZzZXQpLCAxLCB1bmRlZmluZWQsIHsnYnJhY2tldFJlZ2V4JzogYnJhY2tldFJlZ2V4cH0pO1xuXG4gICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGN1ciwgZW5kOiBjdXIgfTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBzdGFydC5wb3M7XG4gICAgICBlbmQgPSBlbmQucG9zO1xuXG4gICAgICBpZiAoKHN0YXJ0LmxpbmUgPT0gZW5kLmxpbmUgJiYgc3RhcnQuY2ggPiBlbmQuY2gpXG4gICAgICAgICAgfHwgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSkpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgZW5kID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIGVuZC5jaCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQuY2ggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH1cblxuICAgIC8vIFRha2VzIGluIGEgc3ltYm9sIGFuZCBhIGN1cnNvciBhbmQgdHJpZXMgdG8gc2ltdWxhdGUgdGV4dCBvYmplY3RzIHRoYXRcbiAgICAvLyBoYXZlIGlkZW50aWNhbCBvcGVuaW5nIGFuZCBjbG9zaW5nIHN5bWJvbHNcbiAgICAvLyBUT0RPIHN1cHBvcnQgYWNyb3NzIG11bHRpcGxlIGxpbmVzXG4gICAgZnVuY3Rpb24gZmluZEJlZ2lubmluZ0FuZEVuZChjbSwgaGVhZCwgc3ltYiwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgY3VyID0gY29weUN1cnNvcihoZWFkKTtcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShjdXIubGluZSk7XG4gICAgICB2YXIgY2hhcnMgPSBsaW5lLnNwbGl0KCcnKTtcbiAgICAgIHZhciBzdGFydCwgZW5kLCBpLCBsZW47XG4gICAgICB2YXIgZmlyc3RJbmRleCA9IGNoYXJzLmluZGV4T2Yoc3ltYik7XG5cbiAgICAgIC8vIHRoZSBkZWNpc2lvbiB0cmVlIGlzIHRvIGFsd2F5cyBsb29rIGJhY2t3YXJkcyBmb3IgdGhlIGJlZ2lubmluZyBmaXJzdCxcbiAgICAgIC8vIGJ1dCBpZiB0aGUgY3Vyc29yIGlzIGluIGZyb250IG9mIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgc3ltYixcbiAgICAgIC8vIHRoZW4gbW92ZSB0aGUgY3Vyc29yIGZvcndhcmRcbiAgICAgIGlmIChjdXIuY2ggPCBmaXJzdEluZGV4KSB7XG4gICAgICAgIGN1ci5jaCA9IGZpcnN0SW5kZXg7XG4gICAgICAgIC8vIFdoeSBpcyB0aGlzIGxpbmUgZXZlbiBoZXJlPz8/XG4gICAgICAgIC8vIGNtLnNldEN1cnNvcihjdXIubGluZSwgZmlyc3RJbmRleCsxKTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSBvbiB0aGUgY2xvc2luZyBzeW1ib2xcbiAgICAgIGVsc2UgaWYgKGZpcnN0SW5kZXggPCBjdXIuY2ggJiYgY2hhcnNbY3VyLmNoXSA9PSBzeW1iKSB7XG4gICAgICAgIGVuZCA9IGN1ci5jaDsgLy8gYXNzaWduIGVuZCB0byB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgICAgLS1jdXIuY2g7IC8vIG1ha2Ugc3VyZSB0byBsb29rIGJhY2t3YXJkc1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgb24gdGhlIHN5bWJvbCwgd2UndmUgZ290IGEgc3RhcnRcbiAgICAgIGlmIChjaGFyc1tjdXIuY2hdID09IHN5bWIgJiYgIWVuZCkge1xuICAgICAgICBzdGFydCA9IGN1ci5jaCArIDE7IC8vIGFzc2lnbiBzdGFydCB0byBhaGVhZCBvZiB0aGUgY3Vyc29yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyBiYWNrd2FyZHMgdG8gZmluZCB0aGUgc3RhcnRcbiAgICAgICAgZm9yIChpID0gY3VyLmNoOyBpID4gLTEgJiYgIXN0YXJ0OyBpLS0pIHtcbiAgICAgICAgICBpZiAoY2hhcnNbaV0gPT0gc3ltYikge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9vayBmb3J3YXJkcyBmb3IgdGhlIGVuZCBzeW1ib2xcbiAgICAgIGlmIChzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0LCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW4gJiYgIWVuZDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoYXJzW2ldID09IHN5bWIpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdGhpbmcgZm91bmRcbiAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogY3VyLCBlbmQ6IGN1ciB9O1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzeW1ib2xzXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIC0tc3RhcnQ7ICsrZW5kO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbmV3IFBvcyhjdXIubGluZSwgc3RhcnQpLFxuICAgICAgICBlbmQ6IG5ldyBQb3MoY3VyLmxpbmUsIGVuZClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZ1bmN0aW9uc1xuICAgIGRlZmluZU9wdGlvbigncGNyZScsIHRydWUsICdib29sZWFuJyk7XG4gICAgZnVuY3Rpb24gU2VhcmNoU3RhdGUoKSB7fVxuICAgIFNlYXJjaFN0YXRlLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldFF1ZXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZpbUdsb2JhbFN0YXRlLnF1ZXJ5O1xuICAgICAgfSxcbiAgICAgIHNldFF1ZXJ5OiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgfSxcbiAgICAgIGdldE92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hPdmVybGF5O1xuICAgICAgfSxcbiAgICAgIHNldE92ZXJsYXk6IGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgIH0sXG4gICAgICBpc1JldmVyc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZpbUdsb2JhbFN0YXRlLmlzUmV2ZXJzZWQ7XG4gICAgICB9LFxuICAgICAgc2V0UmV2ZXJzZWQ6IGZ1bmN0aW9uKHJldmVyc2VkKSB7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmlzUmV2ZXJzZWQgPSByZXZlcnNlZDtcbiAgICAgIH0sXG4gICAgICBnZXRTY3JvbGxiYXJBbm5vdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFubm90YXRlO1xuICAgICAgfSxcbiAgICAgIHNldFNjcm9sbGJhckFubm90YXRlOiBmdW5jdGlvbihhbm5vdGF0ZSkge1xuICAgICAgICB0aGlzLmFubm90YXRlID0gYW5ub3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRTZWFyY2hTdGF0ZShjbSkge1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIHJldHVybiB2aW0uc2VhcmNoU3RhdGVfIHx8ICh2aW0uc2VhcmNoU3RhdGVfID0gbmV3IFNlYXJjaFN0YXRlKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdEJ5U2xhc2goYXJnU3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3BsaXRCeVNlcGFyYXRvcihhcmdTdHJpbmcsICcvJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFVuZXNjYXBlZFNsYXNoZXMoYXJnU3RyaW5nKSB7XG4gICAgICByZXR1cm4gZmluZFVuZXNjYXBlZFNlcGFyYXRvcnMoYXJnU3RyaW5nLCAnLycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwbGl0QnlTZXBhcmF0b3IoYXJnU3RyaW5nLCBzZXBhcmF0b3IpIHtcbiAgICAgIHZhciBzbGFzaGVzID0gZmluZFVuZXNjYXBlZFNlcGFyYXRvcnMoYXJnU3RyaW5nLCBzZXBhcmF0b3IpIHx8IFtdO1xuICAgICAgaWYgKCFzbGFzaGVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgLy8gaW4gY2FzZSBvZiBzdHJpbmdzIGxpa2UgZm9vL2JhclxuICAgICAgaWYgKHNsYXNoZXNbMF0gIT09IDApIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIHNsYXNoZXNbaV0gPT0gJ251bWJlcicpXG4gICAgICAgICAgdG9rZW5zLnB1c2goYXJnU3RyaW5nLnN1YnN0cmluZyhzbGFzaGVzW2ldICsgMSwgc2xhc2hlc1tpKzFdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRVbmVzY2FwZWRTZXBhcmF0b3JzKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgICBpZiAoIXNlcGFyYXRvcilcbiAgICAgICAgc2VwYXJhdG9yID0gJy8nO1xuXG4gICAgICB2YXIgZXNjYXBlTmV4dENoYXIgPSBmYWxzZTtcbiAgICAgIHZhciBzbGFzaGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGlmICghZXNjYXBlTmV4dENoYXIgJiYgYyA9PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICBzbGFzaGVzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlTmV4dENoYXIgPSAhZXNjYXBlTmV4dENoYXIgJiYgKGMgPT0gJ1xcXFwnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGFzaGVzO1xuICAgIH1cblxuICAgIC8vIFRyYW5zbGF0ZXMgYSBzZWFyY2ggc3RyaW5nIGZyb20gZXggKHZpbSkgc3ludGF4IGludG8gamF2YXNjcmlwdCBmb3JtLlxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlZ2V4KHN0cikge1xuICAgICAgLy8gV2hlbiB0aGVzZSBtYXRjaCwgYWRkIGEgJ1xcJyBpZiB1bmVzY2FwZWQgb3IgcmVtb3ZlIG9uZSBpZiBlc2NhcGVkLlxuICAgICAgdmFyIHNwZWNpYWxzID0gJ3woKXsnO1xuICAgICAgLy8gUmVtb3ZlLCBidXQgbmV2ZXIgYWRkLCBhICdcXCcgZm9yIHRoZXNlLlxuICAgICAgdmFyIHVuZXNjYXBlID0gJ30nO1xuICAgICAgdmFyIGVzY2FwZU5leHRDaGFyID0gZmFsc2U7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gLTE7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpIHx8ICcnO1xuICAgICAgICB2YXIgbiA9IHN0ci5jaGFyQXQoaSsxKSB8fCAnJztcbiAgICAgICAgdmFyIHNwZWNpYWxDb21lc05leHQgPSAobiAmJiBzcGVjaWFscy5pbmRleE9mKG4pICE9IC0xKTtcbiAgICAgICAgaWYgKGVzY2FwZU5leHRDaGFyKSB7XG4gICAgICAgICAgaWYgKGMgIT09ICdcXFxcJyB8fCAhc3BlY2lhbENvbWVzTmV4dCkge1xuICAgICAgICAgICAgb3V0LnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZU5leHRDaGFyID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgZXNjYXBlTmV4dENoYXIgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVHJlYXQgdGhlIHVuZXNjYXBlIGxpc3QgYXMgc3BlY2lhbCBmb3IgcmVtb3ZpbmcsIGJ1dCBub3QgYWRkaW5nICdcXCcuXG4gICAgICAgICAgICBpZiAobiAmJiB1bmVzY2FwZS5pbmRleE9mKG4pICE9IC0xKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxDb21lc05leHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90IHBhc3NpbmcgdGhpcyB0ZXN0IG1lYW5zIHJlbW92aW5nIGEgJ1xcJy5cbiAgICAgICAgICAgIGlmICghc3BlY2lhbENvbWVzTmV4dCB8fCBuID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGMpO1xuICAgICAgICAgICAgaWYgKHNwZWNpYWxDb21lc05leHQgJiYgbiAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKCdcXFxcJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8vIFRyYW5zbGF0ZXMgdGhlIHJlcGxhY2UgcGFydCBvZiBhIHNlYXJjaCBhbmQgcmVwbGFjZSBmcm9tIGV4ICh2aW0pIHN5bnRheCBpbnRvXG4gICAgLy8gamF2YXNjcmlwdCBmb3JtLiAgU2ltaWxhciB0byB0cmFuc2xhdGVSZWdleCwgYnV0IGFkZGl0aW9uYWxseSBmaXhlcyBiYWNrIHJlZmVyZW5jZXNcbiAgICAvLyAodHJhbnNsYXRlcyAnXFxbMC4uOV0nIHRvICckWzAuLjldJykgYW5kIGZvbGxvd3MgZGlmZmVyZW50IHJ1bGVzIGZvciBlc2NhcGluZyAnJCcuXG4gICAgdmFyIGNoYXJVbmVzY2FwZXMgPSB7J1xcXFxuJzogJ1xcbicsICdcXFxccic6ICdcXHInLCAnXFxcXHQnOiAnXFx0J307XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlUmVnZXhSZXBsYWNlKHN0cikge1xuICAgICAgdmFyIGVzY2FwZU5leHRDaGFyID0gZmFsc2U7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gLTE7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpIHx8ICcnO1xuICAgICAgICB2YXIgbiA9IHN0ci5jaGFyQXQoaSsxKSB8fCAnJztcbiAgICAgICAgaWYgKGNoYXJVbmVzY2FwZXNbYyArIG5dKSB7XG4gICAgICAgICAgb3V0LnB1c2goY2hhclVuZXNjYXBlc1tjK25dKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSBpZiAoZXNjYXBlTmV4dENoYXIpIHtcbiAgICAgICAgICAvLyBBdCBhbnkgcG9pbnQgaW4gdGhlIGxvb3AsIGVzY2FwZU5leHRDaGFyIGlzIHRydWUgaWYgdGhlIHByZXZpb3VzXG4gICAgICAgICAgLy8gY2hhcmFjdGVyIHdhcyBhICdcXCcgYW5kIHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICBvdXQucHVzaChjKTtcbiAgICAgICAgICBlc2NhcGVOZXh0Q2hhciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY2FwZU5leHRDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgoaXNOdW1iZXIobikgfHwgbiA9PT0gJyQnKSkge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnJCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9PSAnLycgJiYgbiAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKCdcXFxcJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goJyQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5wdXNoKGMpO1xuICAgICAgICAgICAgaWYgKG4gPT09ICcvJykge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnXFxcXCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvLyBVbmVzY2FwZSBcXCBhbmQgLyBpbiB0aGUgcmVwbGFjZSBwYXJ0LCBmb3IgUENSRSBtb2RlLlxuICAgIHZhciB1bmVzY2FwZXMgPSB7J1xcXFwvJzogJy8nLCAnXFxcXFxcXFwnOiAnXFxcXCcsICdcXFxcbic6ICdcXG4nLCAnXFxcXHInOiAnXFxyJywgJ1xcXFx0JzogJ1xcdCcsICdcXFxcJic6JyYnfTtcbiAgICBmdW5jdGlvbiB1bmVzY2FwZVJlZ2V4UmVwbGFjZShzdHIpIHtcbiAgICAgIHZhciBzdHJlYW0gPSBuZXcgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0oc3RyKTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgXFwuXG4gICAgICAgIHdoaWxlIChzdHJlYW0ucGVlaygpICYmIHN0cmVhbS5wZWVrKCkgIT0gJ1xcXFwnKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyZWFtLm5leHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgbWF0Y2hlciBpbiB1bmVzY2FwZXMpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG1hdGNoZXIsIHRydWUpKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHVuZXNjYXBlc1ttYXRjaGVyXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIGFueXRoaW5nXG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyZWFtLm5leHQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIHF1ZXJ5IGFuZCByZXR1cm4gYSBSZWdleHAgb2JqZWN0LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgcXVlcnkgaXMgYmxhbmsuXG4gICAgICogSWYgaWdub3JlQ2FzZSBpcyBwYXNzZWQgaW4sIHRoZSBSZWdleHAgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgJ2knIGZsYWcgc2V0LlxuICAgICAqIElmIHNtYXJ0Q2FzZSBpcyBwYXNzZWQgaW4sIGFuZCB0aGUgcXVlcnkgY29udGFpbnMgdXBwZXIgY2FzZSBsZXR0ZXJzLFxuICAgICAqICAgdGhlbiBpZ25vcmVDYXNlIGlzIG92ZXJyaWRkZW4sIGFuZCB0aGUgJ2knIGZsYWcgd2lsbCBub3QgYmUgc2V0LlxuICAgICAqIElmIHRoZSBxdWVyeSBjb250YWlucyB0aGUgL2kgaW4gdGhlIGZsYWcgcGFydCBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uLFxuICAgICAqICAgdGhlbiBib3RoIGlnbm9yZUNhc2UgYW5kIHNtYXJ0Q2FzZSBhcmUgaWdub3JlZCwgYW5kICdpJyB3aWxsIGJlIHBhc3NlZFxuICAgICAqICAgdGhyb3VnaCB0byB0aGUgUmVnZXggb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlUXVlcnkocXVlcnksIGlnbm9yZUNhc2UsIHNtYXJ0Q2FzZSkge1xuICAgICAgLy8gRmlyc3QgdXBkYXRlIHRoZSBsYXN0IHNlYXJjaCByZWdpc3RlclxuICAgICAgdmFyIGxhc3RTZWFyY2hSZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcignLycpO1xuICAgICAgbGFzdFNlYXJjaFJlZ2lzdGVyLnNldFRleHQocXVlcnkpO1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHF1ZXJ5IGlzIGFscmVhZHkgYSByZWdleC5cbiAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFJlZ0V4cCkgeyByZXR1cm4gcXVlcnk7IH1cbiAgICAgIC8vIEZpcnN0IHRyeSB0byBleHRyYWN0IHJlZ2V4ICsgZmxhZ3MgZnJvbSB0aGUgaW5wdXQuIElmIG5vIGZsYWdzIGZvdW5kLFxuICAgICAgLy8gZXh0cmFjdCBqdXN0IHRoZSByZWdleC4gSUUgZG9lcyBub3QgYWNjZXB0IGZsYWdzIGRpcmVjdGx5IGRlZmluZWQgaW5cbiAgICAgIC8vIHRoZSByZWdleCBzdHJpbmcgaW4gdGhlIGZvcm0gL3JlZ2V4L2ZsYWdzXG4gICAgICB2YXIgc2xhc2hlcyA9IGZpbmRVbmVzY2FwZWRTbGFzaGVzKHF1ZXJ5KTtcbiAgICAgIHZhciByZWdleFBhcnQ7XG4gICAgICB2YXIgZm9yY2VJZ25vcmVDYXNlO1xuICAgICAgaWYgKCFzbGFzaGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBRdWVyeSBsb29rcyBsaWtlICdyZWdleHAnXG4gICAgICAgIHJlZ2V4UGFydCA9IHF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUXVlcnkgbG9va3MgbGlrZSAncmVnZXhwLy4uLidcbiAgICAgICAgcmVnZXhQYXJ0ID0gcXVlcnkuc3Vic3RyaW5nKDAsIHNsYXNoZXNbMF0pO1xuICAgICAgICB2YXIgZmxhZ3NQYXJ0ID0gcXVlcnkuc3Vic3RyaW5nKHNsYXNoZXNbMF0pO1xuICAgICAgICBmb3JjZUlnbm9yZUNhc2UgPSAoZmxhZ3NQYXJ0LmluZGV4T2YoJ2knKSAhPSAtMSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2V4UGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghZ2V0T3B0aW9uKCdwY3JlJykpIHtcbiAgICAgICAgcmVnZXhQYXJ0ID0gdHJhbnNsYXRlUmVnZXgocmVnZXhQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzbWFydENhc2UpIHtcbiAgICAgICAgaWdub3JlQ2FzZSA9ICgvXlteQS1aXSokLykudGVzdChyZWdleFBhcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnZXhQYXJ0LFxuICAgICAgICAgIChpZ25vcmVDYXNlIHx8IGZvcmNlSWdub3JlQ2FzZSkgPyAnaW0nIDogJ20nKTtcbiAgICAgIHJldHVybiByZWdleHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZG9tIC0gRG9jdW1lbnQgT2JqZWN0IE1hbmlwdWxhdG9yXG4gICAgICogVXNhZ2U6XG4gICAgICogICBkb20oJzx0YWc+J3w8bm9kZT5bLCAuLi57PGF0dHJpYnV0ZXM+fDwkc3R5bGVzPn18PGNoaWxkLW5vZGU+fCc8dGV4dD4nXSlcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgIGRvbSgnZGl2Jywge2lkOid4eXonfSwgZG9tKCdwJywgJ0NNIHJvY2tzIScsIHskY29sb3I6J3JlZCd9KSlcbiAgICAgKiAgIGRvbShkb2N1bWVudC5oZWFkLCBkb20oJ3NjcmlwdCcsICdhbGVydChcImhlbGxvIVwiKScpKVxuICAgICAqIE5vdCBzdXBwb3J0ZWQ6XG4gICAgICogICBkb20oJ3AnLCBbJ2FycmF5cyBhcmUgb2JqZWN0cyddLCBFcnJvcignb2JqZWN0cyBzcGVjaWZ5IGF0dHJpYnV0ZXMnKSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb20obikge1xuICAgICAgaWYgKHR5cGVvZiBuID09PSAnc3RyaW5nJykgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobik7XG4gICAgICBmb3IgKHZhciBhLCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIShhID0gYXJndW1lbnRzW2ldKSkgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIGEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKTtcbiAgICAgICAgaWYgKGEubm9kZVR5cGUpIG4uYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcpIG4uc3R5bGVba2V5LnNsaWNlKDEpXSA9IGFba2V5XTtcbiAgICAgICAgICBlbHNlIG4uc2V0QXR0cmlidXRlKGtleSwgYVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0NvbmZpcm0oY20sIHRlbXBsYXRlKSB7XG4gICAgICB2YXIgcHJlID0gZG9tKCdwcmUnLCB7JGNvbG9yOiAncmVkJywgY2xhc3M6ICdjbS12aW0tbWVzc2FnZSd9LCB0ZW1wbGF0ZSk7XG4gICAgICBpZiAoY20ub3Blbk5vdGlmaWNhdGlvbikge1xuICAgICAgICBjbS5vcGVuTm90aWZpY2F0aW9uKHByZSwge2JvdHRvbTogdHJ1ZSwgZHVyYXRpb246IDUwMDB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KHByZS5pbm5lclRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VQcm9tcHQocHJlZml4LCBkZXNjKSB7XG4gICAgICByZXR1cm4gZG9tKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgIGRvbSgnc3BhbicsIHskZm9udEZhbWlseTogJ21vbm9zcGFjZScsICR3aGl0ZVNwYWNlOiAncHJlJ30sXG4gICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgZG9tKCdpbnB1dCcsIHt0eXBlOiAndGV4dCcsIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsIHNwZWxsY2hlY2s6ICdmYWxzZSd9KSksXG4gICAgICAgICAgICAgICBkZXNjICYmIGRvbSgnc3BhbicsIHskY29sb3I6ICcjODg4J30sIGRlc2MpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93UHJvbXB0KGNtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBtYWtlUHJvbXB0KG9wdGlvbnMucHJlZml4LCBvcHRpb25zLmRlc2MpO1xuICAgICAgaWYgKGNtLm9wZW5EaWFsb2cpIHtcbiAgICAgICAgY20ub3BlbkRpYWxvZyh0ZW1wbGF0ZSwgb3B0aW9ucy5vbkNsb3NlLCB7XG4gICAgICAgICAgb25LZXlEb3duOiBvcHRpb25zLm9uS2V5RG93biwgb25LZXlVcDogb3B0aW9ucy5vbktleVVwLFxuICAgICAgICAgIGJvdHRvbTogdHJ1ZSwgc2VsZWN0VmFsdWVPbk9wZW46IGZhbHNlLCB2YWx1ZTogb3B0aW9ucy52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc2hvcnRUZXh0ID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVmaXggIT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLnByZWZpeCkgc2hvcnRUZXh0ICs9IG9wdGlvbnMucHJlZml4LnRleHRDb250ZW50O1xuICAgICAgICBpZiAob3B0aW9ucy5kZXNjKSBzaG9ydFRleHQgKz0gXCIgXCIgKyBvcHRpb25zLmRlc2M7XG4gICAgICAgIG9wdGlvbnMub25DbG9zZShwcm9tcHQoc2hvcnRUZXh0LCAnJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXF1YWwocjEsIHIyKSB7XG4gICAgICBpZiAocjEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcjIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBbJ2dsb2JhbCcsICdtdWx0aWxpbmUnLCAnaWdub3JlQ2FzZScsICdzb3VyY2UnXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgICAgICAgIGlmIChyMVtwcm9wXSAhPT0gcjJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBxdWVyeSBpcyB2YWxpZC5cbiAgICBmdW5jdGlvbiB1cGRhdGVTZWFyY2hRdWVyeShjbSwgcmF3UXVlcnksIGlnbm9yZUNhc2UsIHNtYXJ0Q2FzZSkge1xuICAgICAgaWYgKCFyYXdRdWVyeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgICB2YXIgcXVlcnkgPSBwYXJzZVF1ZXJ5KHJhd1F1ZXJ5LCAhIWlnbm9yZUNhc2UsICEhc21hcnRDYXNlKTtcbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGlnaGxpZ2h0U2VhcmNoTWF0Y2hlcyhjbSwgcXVlcnkpO1xuICAgICAgaWYgKHJlZ2V4RXF1YWwocXVlcnksIHN0YXRlLmdldFF1ZXJ5KCkpKSB7XG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VhcmNoT3ZlcmxheShxdWVyeSkge1xuICAgICAgaWYgKHF1ZXJ5LnNvdXJjZS5jaGFyQXQoMCkgPT0gJ14nKSB7XG4gICAgICAgIHZhciBtYXRjaFNvbCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKG1hdGNoU29sICYmICFzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1hdGNoID0gc3RyZWFtLm1hdGNoKHF1ZXJ5LCBmYWxzZSk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBlbXB0eSBzdHJpbmcsIHNraXAgdG8gbmV4dC5cbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuICdzZWFyY2hpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgICAgLy8gQmFja3RyYWNrIDEgdG8gbWF0Y2ggXFxiXG4gICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgICAgIGlmICghcXVlcnkuZXhlYyhzdHJlYW0ubmV4dCgpICsgbWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIHJldHVybiAnc2VhcmNoaW5nJztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHF1ZXJ5LCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGlnaGxpZ2h0VGltZW91dCA9IDA7XG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0U2VhcmNoTWF0Y2hlcyhjbSwgcXVlcnkpIHtcbiAgICAgIGNsZWFyVGltZW91dChoaWdobGlnaHRUaW1lb3V0KTtcbiAgICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWNtLnN0YXRlLnZpbSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2VhcmNoU3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgICAgIHZhciBvdmVybGF5ID0gc2VhcmNoU3RhdGUuZ2V0T3ZlcmxheSgpO1xuICAgICAgICBpZiAoIW92ZXJsYXkgfHwgcXVlcnkgIT0gb3ZlcmxheS5xdWVyeSkge1xuICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICBjbS5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdmVybGF5ID0gc2VhcmNoT3ZlcmxheShxdWVyeSk7XG4gICAgICAgICAgY20uYWRkT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgICBpZiAoY20uc2hvd01hdGNoZXNPblNjcm9sbGJhcikge1xuICAgICAgICAgICAgaWYgKHNlYXJjaFN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkpIHtcbiAgICAgICAgICAgICAgc2VhcmNoU3RhdGUuZ2V0U2Nyb2xsYmFyQW5ub3RhdGUoKS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VhcmNoU3RhdGUuc2V0U2Nyb2xsYmFyQW5ub3RhdGUoY20uc2hvd01hdGNoZXNPblNjcm9sbGJhcihxdWVyeSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWFyY2hTdGF0ZS5zZXRPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmROZXh0KGNtLCBwcmV2LCBxdWVyeSwgcmVwZWF0KSB7XG4gICAgICBpZiAocmVwZWF0ID09PSB1bmRlZmluZWQpIHsgcmVwZWF0ID0gMTsgfVxuICAgICAgcmV0dXJuIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCBwb3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgaWYgKGkgPT0gMCAmJiBmb3VuZCAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBwb3MpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEVuZFBvcyA9IHByZXYgPyBjdXJzb3IuZnJvbSgpIDogY3Vyc29yLnRvKCk7XG4gICAgICAgICAgICBmb3VuZCA9IGN1cnNvci5maW5kKHByZXYpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICFmb3VuZFswXSAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBsYXN0RW5kUG9zKSkge1xuICAgICAgICAgICAgICBpZiAoY20uZ2V0TGluZShsYXN0RW5kUG9zLmxpbmUpLmxlbmd0aCA9PSBsYXN0RW5kUG9zLmNoKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIC8vIFNlYXJjaEN1cnNvciBtYXkgaGF2ZSByZXR1cm5lZCBudWxsIGJlY2F1c2UgaXQgaGl0IEVPRiwgd3JhcFxuICAgICAgICAgICAgLy8gYXJvdW5kIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICBjdXJzb3IgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksXG4gICAgICAgICAgICAgICAgKHByZXYpID8gbmV3IFBvcyhjbS5sYXN0TGluZSgpKSA6IG5ldyBQb3MoY20uZmlyc3RMaW5lKCksIDApICk7XG4gICAgICAgICAgICBpZiAoIWN1cnNvci5maW5kKHByZXYpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvci5mcm9tKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldHR5IG11Y2ggdGhlIHNhbWUgYXMgYGZpbmROZXh0YCwgZXhjZXB0IGZvciB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogMS4gQmVmb3JlIHN0YXJ0aW5nIHRoZSBzZWFyY2gsIG1vdmUgdG8gdGhlIHByZXZpb3VzIHNlYXJjaC4gVGhpcyB3YXkgaWYgb3VyIGN1cnNvciBpc1xuICAgICAqIGFscmVhZHkgaW5zaWRlIGEgbWF0Y2gsIHdlIHNob3VsZCByZXR1cm4gdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICogMi4gUmF0aGVyIHRoYW4gb25seSByZXR1cm5pbmcgdGhlIGN1cnNvcidzIGZyb20sIHdlIHJldHVybiB0aGUgY3Vyc29yJ3MgZnJvbSBhbmQgdG8gYXMgYSB0dXBsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTmV4dEZyb21BbmRUb0luY2x1c2l2ZShjbSwgcHJldiwgcXVlcnksIHJlcGVhdCwgdmltKSB7XG4gICAgICBpZiAocmVwZWF0ID09PSB1bmRlZmluZWQpIHsgcmVwZWF0ID0gMTsgfVxuICAgICAgcmV0dXJuIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCBwb3MpO1xuXG4gICAgICAgIC8vIEdvIGJhY2sgb25lIHJlc3VsdCB0byBlbnN1cmUgdGhhdCBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSBhIG1hdGNoLCB3ZSBrZWVwIGl0LlxuICAgICAgICB2YXIgZm91bmQgPSBjdXJzb3IuZmluZCghcHJldik7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBtb3ZlZCwgZ28gYmFjayBvbmUgbW9yZSAoc2ltaWxhciB0byBpZiBpPT0wIGxvZ2ljIGluIGZpbmROZXh0KS5cbiAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSAmJiBmb3VuZCAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBwb3MpKSB7XG4gICAgICAgICAgY3Vyc29yLmZpbmQoIXByZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgLy8gU2VhcmNoQ3Vyc29yIG1heSBoYXZlIHJldHVybmVkIG51bGwgYmVjYXVzZSBpdCBoaXQgRU9GLCB3cmFwXG4gICAgICAgICAgICAvLyBhcm91bmQgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSxcbiAgICAgICAgICAgICAgICAocHJldikgPyBuZXcgUG9zKGNtLmxhc3RMaW5lKCkpIDogbmV3IFBvcyhjbS5maXJzdExpbmUoKSwgMCkgKTtcbiAgICAgICAgICAgIGlmICghY3Vyc29yLmZpbmQocHJldikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2N1cnNvci5mcm9tKCksIGN1cnNvci50bygpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgY20ucmVtb3ZlT3ZlcmxheShnZXRTZWFyY2hTdGF0ZShjbSkuZ2V0T3ZlcmxheSgpKTtcbiAgICAgIHN0YXRlLnNldE92ZXJsYXkobnVsbCk7XG4gICAgICBpZiAoc3RhdGUuZ2V0U2Nyb2xsYmFyQW5ub3RhdGUoKSkge1xuICAgICAgICBzdGF0ZS5nZXRTY3JvbGxiYXJBbm5vdGF0ZSgpLmNsZWFyKCk7XG4gICAgICAgIHN0YXRlLnNldFNjcm9sbGJhckFubm90YXRlKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBwb3MgaXMgaW4gdGhlIHNwZWNpZmllZCByYW5nZSwgSU5DTFVTSVZFLlxuICAgICAqIFJhbmdlIGNhbiBiZSBzcGVjaWZpZWQgd2l0aCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqIElmIHRoZSBmaXJzdCByYW5nZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgdHJlYXQgaXQgYXMgYW4gYXJyYXkgb2YgbGluZVxuICAgICAqIG51bWJlcnMuIE1hdGNoIHBvcyBhZ2FpbnN0IGFueSBvZiB0aGUgbGluZXMuXG4gICAgICogSWYgdGhlIGZpcnN0IHJhbmdlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLFxuICAgICAqICAgaWYgdGhlcmUgaXMgb25seSAxIHJhbmdlIGFyZ3VtZW50LCBjaGVjayBpZiBwb3MgaGFzIHRoZSBzYW1lIGxpbmVcbiAgICAgKiAgICAgICBudW1iZXJcbiAgICAgKiAgIGlmIHRoZXJlIGFyZSAyIHJhbmdlIGFyZ3VtZW50cywgdGhlbiBjaGVjayBpZiBwb3MgaXMgaW4gYmV0d2VlbiB0aGUgdHdvXG4gICAgICogICAgICAgcmFuZ2UgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5SYW5nZShwb3MsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zICE9ICdudW1iZXInKSB7XG4gICAgICAgIC8vIEFzc3VtZSBpdCBpcyBhIGN1cnNvciBwb3NpdGlvbi4gR2V0IHRoZSBsaW5lIG51bWJlci5cbiAgICAgICAgcG9zID0gcG9zLmxpbmU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gaW5BcnJheShwb3MsIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIChwb3MgPj0gc3RhcnQgJiYgcG9zIDw9IGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBvcyA9PSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVc2VyVmlzaWJsZUxpbmVzKGNtKSB7XG4gICAgICB2YXIgc2Nyb2xsSW5mbyA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICAgIHZhciBvY2NsdWRlVG9sZXJhbmNlVG9wID0gNjtcbiAgICAgIHZhciBvY2NsdWRlVG9sZXJhbmNlQm90dG9tID0gMTA7XG4gICAgICB2YXIgZnJvbSA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6MCwgdG9wOiBvY2NsdWRlVG9sZXJhbmNlVG9wICsgc2Nyb2xsSW5mby50b3B9LCAnbG9jYWwnKTtcbiAgICAgIHZhciBib3R0b21ZID0gc2Nyb2xsSW5mby5jbGllbnRIZWlnaHQgLSBvY2NsdWRlVG9sZXJhbmNlQm90dG9tICsgc2Nyb2xsSW5mby50b3A7XG4gICAgICB2YXIgdG8gPSBjbS5jb29yZHNDaGFyKHtsZWZ0OjAsIHRvcDogYm90dG9tWX0sICdsb2NhbCcpO1xuICAgICAgcmV0dXJuIHt0b3A6IGZyb20ubGluZSwgYm90dG9tOiB0by5saW5lfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXJrUG9zKGNtLCB2aW0sIG1hcmtOYW1lKSB7XG4gICAgICBpZiAobWFya05hbWUgPT0gJ1xcJycgfHwgbWFya05hbWUgPT0gJ2AnKSB7XG4gICAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZS5qdW1wTGlzdC5maW5kKGNtLCAtMSkgfHwgbmV3IFBvcygwLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXN0RWRpdFBvcyhjbSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJrID0gdmltLm1hcmtzW21hcmtOYW1lXTtcbiAgICAgIHJldHVybiBtYXJrICYmIG1hcmsuZmluZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExhc3RFZGl0UG9zKGNtKSB7XG4gICAgICB2YXIgZG9uZSA9IGNtLmRvYy5oaXN0b3J5LmRvbmU7XG4gICAgICBmb3IgKHZhciBpID0gZG9uZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaWYgKGRvbmVbaV0uY2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiBjb3B5Q3Vyc29yKGRvbmVbaV0uY2hhbmdlc1swXS50byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRXhDb21tYW5kRGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5idWlsZENvbW1hbmRNYXBfKCk7XG4gICAgfTtcbiAgICBFeENvbW1hbmREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIHByb2Nlc3NDb21tYW5kOiBmdW5jdGlvbihjbSwgaW5wdXQsIG9wdF9wYXJhbXMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNtLmN1ck9wLmlzVmltT3AgPSB0cnVlO1xuICAgICAgICAgIHRoYXQuX3Byb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCwgb3B0X3BhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9wcm9jZXNzQ29tbWFuZDogZnVuY3Rpb24oY20sIGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gICAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICAgIHZhciBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKCc6Jyk7XG4gICAgICAgIHZhciBwcmV2aW91c0NvbW1hbmQgPSBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRTdHJlYW0gPSBuZXcgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0oaW5wdXQpO1xuICAgICAgICAvLyB1cGRhdGUgXCI6IHdpdGggdGhlIGxhdGVzdCBjb21tYW5kIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZFxuICAgICAgICBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyLnNldFRleHQoaW5wdXQpO1xuICAgICAgICB2YXIgcGFyYW1zID0gb3B0X3BhcmFtcyB8fCB7fTtcbiAgICAgICAgcGFyYW1zLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wYXJzZUlucHV0XyhjbSwgaW5wdXRTdHJlYW0sIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1hbmQ7XG4gICAgICAgIHZhciBjb21tYW5kTmFtZTtcbiAgICAgICAgaWYgKCFwYXJhbXMuY29tbWFuZE5hbWUpIHtcbiAgICAgICAgICAvLyBJZiBvbmx5IGEgbGluZSByYW5nZSBpcyBkZWZpbmVkLCBtb3ZlIHRvIHRoZSBsaW5lLlxuICAgICAgICAgIGlmIChwYXJhbXMubGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21tYW5kTmFtZSA9ICdtb3ZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWFuZCA9IHRoaXMubWF0Y2hDb21tYW5kXyhwYXJhbXMuY29tbWFuZE5hbWUpO1xuICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjb21tYW5kTmFtZSA9IGNvbW1hbmQubmFtZTtcbiAgICAgICAgICAgIGlmIChjb21tYW5kLmV4Y2x1ZGVGcm9tQ29tbWFuZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgY29tbWFuZEhpc3RvcnlSZWdpc3Rlci5zZXRUZXh0KHByZXZpb3VzQ29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29tbWFuZEFyZ3NfKGlucHV0U3RyZWFtLCBwYXJhbXMsIGNvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PSAnZXhUb0tleScpIHtcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIEV4IHRvIEtleSBtYXBwaW5nLlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmQudG9LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmltQXBpLmhhbmRsZUtleShjbSwgY29tbWFuZC50b0tleXNbaV0sICdtYXBwaW5nJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kLnR5cGUgPT0gJ2V4VG9FeCcpIHtcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIEV4IHRvIEV4IG1hcHBpbmcuXG4gICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbW1hbmQoY20sIGNvbW1hbmQudG9JbnB1dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21tYW5kTmFtZSkge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnTm90IGFuIGVkaXRvciBjb21tYW5kIFwiOicgKyBpbnB1dCArICdcIicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4Q29tbWFuZHNbY29tbWFuZE5hbWVdKGNtLCBwYXJhbXMpO1xuICAgICAgICAgIC8vIFBvc3NpYmx5IGFzeW5jaHJvbm91cyBjb21tYW5kcyAoZS5nLiBzdWJzdGl0dXRlLCB3aGljaCBtaWdodCBoYXZlIGFcbiAgICAgICAgICAvLyB1c2VyIGNvbmZpcm1hdGlvbiksIGFyZSByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgY2FsbGJhY2sgd2hlblxuICAgICAgICAgIC8vIGRvbmUuIEFsbCBvdGhlcnMgaGF2ZSBpdCB0YWtlbiBjYXJlIG9mIGZvciB0aGVtIGhlcmUuXG4gICAgICAgICAgaWYgKCghY29tbWFuZCB8fCAhY29tbWFuZC5wb3NzaWJseUFzeW5jKSAmJiBwYXJhbXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHBhcmFtcy5jYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcnNlSW5wdXRfOiBmdW5jdGlvbihjbSwgaW5wdXRTdHJlYW0sIHJlc3VsdCkge1xuICAgICAgICBpbnB1dFN0cmVhbS5lYXRXaGlsZSgnOicpO1xuICAgICAgICAvLyBQYXJzZSByYW5nZS5cbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmVhdCgnJScpKSB7XG4gICAgICAgICAgcmVzdWx0LmxpbmUgPSBjbS5maXJzdExpbmUoKTtcbiAgICAgICAgICByZXN1bHQubGluZUVuZCA9IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmxpbmUgPSB0aGlzLnBhcnNlTGluZVNwZWNfKGNtLCBpbnB1dFN0cmVhbSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5saW5lICE9PSB1bmRlZmluZWQgJiYgaW5wdXRTdHJlYW0uZWF0KCcsJykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5saW5lRW5kID0gdGhpcy5wYXJzZUxpbmVTcGVjXyhjbSwgaW5wdXRTdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIGNvbW1hbmQgbmFtZS5cbiAgICAgICAgdmFyIGNvbW1hbmRNYXRjaCA9IGlucHV0U3RyZWFtLm1hdGNoKC9eKFxcdyt8ISF8QEB8WyEjJio8PT5Afl0pLyk7XG4gICAgICAgIGlmIChjb21tYW5kTWF0Y2gpIHtcbiAgICAgICAgICByZXN1bHQuY29tbWFuZE5hbWUgPSBjb21tYW5kTWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmNvbW1hbmROYW1lID0gaW5wdXRTdHJlYW0ubWF0Y2goLy4qLylbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGluZVNwZWNfOiBmdW5jdGlvbihjbSwgaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgdmFyIG51bWJlck1hdGNoID0gaW5wdXRTdHJlYW0ubWF0Y2goL14oXFxkKykvKTtcbiAgICAgICAgaWYgKG51bWJlck1hdGNoKSB7XG4gICAgICAgICAgLy8gQWJzb2x1dGUgbGluZSBudW1iZXIgcGx1cyBvZmZzZXQgKE4rTSBvciBOLU0pIGlzIHByb2JhYmx5IGEgdHlwbyxcbiAgICAgICAgICAvLyBub3Qgc29tZXRoaW5nIHRoZSB1c2VyIGFjdHVhbGx5IHdhbnRlZC4gKE5COiB2aW0gZG9lcyBhbGxvdyB0aGlzLilcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtYmVyTWF0Y2hbMV0sIDEwKSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpbnB1dFN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGluZVNwZWNPZmZzZXRfKGlucHV0U3RyZWFtLCBjbS5nZXRDdXJzb3IoKS5saW5lKTtcbiAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGluZVNwZWNPZmZzZXRfKGlucHV0U3RyZWFtLCBjbS5sYXN0TGluZSgpKTtcbiAgICAgICAgICBjYXNlICdcXCcnOlxuICAgICAgICAgICAgdmFyIG1hcmtOYW1lID0gaW5wdXRTdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgdmFyIG1hcmtQb3MgPSBnZXRNYXJrUG9zKGNtLCBjbS5zdGF0ZS52aW0sIG1hcmtOYW1lKTtcbiAgICAgICAgICAgIGlmICghbWFya1BvcykgdGhyb3cgbmV3IEVycm9yKCdNYXJrIG5vdCBzZXQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGluZVNwZWNPZmZzZXRfKGlucHV0U3RyZWFtLCBtYXJrUG9zLmxpbmUpO1xuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgICAgLy8gT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIGN1cnJlbnQgbGluZSBpZiBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGluZVNwZWNPZmZzZXRfKGlucHV0U3RyZWFtLCBjbS5nZXRDdXJzb3IoKS5saW5lKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcnNlTGluZVNwZWNPZmZzZXRfOiBmdW5jdGlvbihpbnB1dFN0cmVhbSwgbGluZSkge1xuICAgICAgICB2YXIgb2Zmc2V0TWF0Y2ggPSBpbnB1dFN0cmVhbS5tYXRjaCgvXihbKy1dKT8oXFxkKykvKTtcbiAgICAgICAgaWYgKG9mZnNldE1hdGNoKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KG9mZnNldE1hdGNoWzJdLCAxMCk7XG4gICAgICAgICAgaWYgKG9mZnNldE1hdGNoWzFdID09IFwiLVwiKSB7XG4gICAgICAgICAgICBsaW5lIC09IG9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZSArPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ29tbWFuZEFyZ3NfOiBmdW5jdGlvbihpbnB1dFN0cmVhbSwgcGFyYW1zLCBjb21tYW5kKSB7XG4gICAgICAgIGlmIChpbnB1dFN0cmVhbS5lb2woKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuYXJnU3RyaW5nID0gaW5wdXRTdHJlYW0ubWF0Y2goLy4qLylbMF07XG4gICAgICAgIC8vIFBhcnNlIGNvbW1hbmQtbGluZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIGRlbGltID0gY29tbWFuZC5hcmdEZWxpbWl0ZXIgfHwgL1xccysvO1xuICAgICAgICB2YXIgYXJncyA9IHRyaW0ocGFyYW1zLmFyZ1N0cmluZykuc3BsaXQoZGVsaW0pO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggJiYgYXJnc1swXSkge1xuICAgICAgICAgIHBhcmFtcy5hcmdzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hdGNoQ29tbWFuZF86IGZ1bmN0aW9uKGNvbW1hbmROYW1lKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgY29tbWFuZCBpbiB0aGUgY29tbWFuZCBtYXAgdGhhdCBtYXRjaGVzIHRoZSBzaG9ydGVzdFxuICAgICAgICAvLyBwcmVmaXggb2YgdGhlIHBhc3NlZCBpbiBjb21tYW5kIG5hbWUuIFRoZSBtYXRjaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAgICAgIC8vIHVuYW1iaWd1b3VzIGlmIHRoZSBkZWZhdWx0RXhDb21tYW5kTWFwJ3Mgc2hvcnROYW1lcyBhcmUgc2V0IHVwXG4gICAgICAgIC8vIGNvcnJlY3RseS4gKHNlZSBAY29kZXtkZWZhdWx0RXhDb21tYW5kTWFwfSkuXG4gICAgICAgIGZvciAodmFyIGkgPSBjb21tYW5kTmFtZS5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gY29tbWFuZE5hbWUuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbW1hbmRNYXBfW3ByZWZpeF0pIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5jb21tYW5kTWFwX1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQubmFtZS5pbmRleE9mKGNvbW1hbmROYW1lKSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgYnVpbGRDb21tYW5kTWFwXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hcF8gPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0RXhDb21tYW5kTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbW1hbmQgPSBkZWZhdWx0RXhDb21tYW5kTWFwW2ldO1xuICAgICAgICAgIHZhciBrZXkgPSBjb21tYW5kLnNob3J0TmFtZSB8fCBjb21tYW5kLm5hbWU7XG4gICAgICAgICAgdGhpcy5jb21tYW5kTWFwX1trZXldID0gY29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hcDogZnVuY3Rpb24obGhzLCByaHMsIGN0eCkge1xuICAgICAgICBpZiAobGhzICE9ICc6JyAmJiBsaHMuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAgIGlmIChjdHgpIHsgdGhyb3cgRXJyb3IoJ01vZGUgbm90IHN1cHBvcnRlZCBmb3IgZXggbWFwcGluZ3MnKTsgfVxuICAgICAgICAgIHZhciBjb21tYW5kTmFtZSA9IGxocy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgaWYgKHJocyAhPSAnOicgJiYgcmhzLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgICAgIC8vIEV4IHRvIEV4IG1hcHBpbmdcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdID0ge1xuICAgICAgICAgICAgICBuYW1lOiBjb21tYW5kTmFtZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2V4VG9FeCcsXG4gICAgICAgICAgICAgIHRvSW5wdXQ6IHJocy5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgIHVzZXI6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV4IHRvIGtleSBtYXBwaW5nXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRNYXBfW2NvbW1hbmROYW1lXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogY29tbWFuZE5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdleFRvS2V5JyxcbiAgICAgICAgICAgICAgdG9LZXlzOiByaHMsXG4gICAgICAgICAgICAgIHVzZXI6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyaHMgIT0gJzonICYmIHJocy5jaGFyQXQoMCkgPT0gJzonKSB7XG4gICAgICAgICAgICAvLyBLZXkgdG8gRXggbWFwcGluZy5cbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICBrZXlzOiBsaHMsXG4gICAgICAgICAgICAgIHR5cGU6ICdrZXlUb0V4JyxcbiAgICAgICAgICAgICAgZXhBcmdzOiB7IGlucHV0OiByaHMuc3Vic3RyaW5nKDEpIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4KSB7IG1hcHBpbmcuY29udGV4dCA9IGN0eDsgfVxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcC51bnNoaWZ0KG1hcHBpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBLZXkgdG8ga2V5IG1hcHBpbmdcbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICBrZXlzOiBsaHMsXG4gICAgICAgICAgICAgIHR5cGU6ICdrZXlUb0tleScsXG4gICAgICAgICAgICAgIHRvS2V5czogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN0eCkgeyBtYXBwaW5nLmNvbnRleHQgPSBjdHg7IH1cbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXAudW5zaGlmdChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1hcDogZnVuY3Rpb24obGhzLCBjdHgpIHtcbiAgICAgICAgaWYgKGxocyAhPSAnOicgJiYgbGhzLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgICAvLyBFeCB0byBFeCBvciBFeCB0byBrZXkgbWFwcGluZ1xuICAgICAgICAgIGlmIChjdHgpIHsgdGhyb3cgRXJyb3IoJ01vZGUgbm90IHN1cHBvcnRlZCBmb3IgZXggbWFwcGluZ3MnKTsgfVxuICAgICAgICAgIHZhciBjb21tYW5kTmFtZSA9IGxocy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgaWYgKHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdICYmIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdLnVzZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbW1hbmRNYXBfW2NvbW1hbmROYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBLZXkgdG8gRXggb3Iga2V5IHRvIGtleSBtYXBwaW5nXG4gICAgICAgICAgdmFyIGtleXMgPSBsaHM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0S2V5bWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoa2V5cyA9PSBkZWZhdWx0S2V5bWFwW2ldLmtleXNcbiAgICAgICAgICAgICAgICAmJiBkZWZhdWx0S2V5bWFwW2ldLmNvbnRleHQgPT09IGN0eCkge1xuICAgICAgICAgICAgICBkZWZhdWx0S2V5bWFwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBleENvbW1hbmRzID0ge1xuICAgICAgY29sb3JzY2hlbWU6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMuYXJncyB8fCBwYXJhbXMuYXJncy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sIGNtLmdldE9wdGlvbigndGhlbWUnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldE9wdGlvbigndGhlbWUnLCBwYXJhbXMuYXJnc1swXSk7XG4gICAgICB9LFxuICAgICAgbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIG1hcEFyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgICAgaWYgKCFtYXBBcmdzIHx8IG1hcEFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgIGlmIChjbSkge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5tYXAobWFwQXJnc1swXSwgbWFwQXJnc1sxXSwgY3R4KTtcbiAgICAgIH0sXG4gICAgICBpbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdpbnNlcnQnKTsgfSxcbiAgICAgIG5tYXA6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHsgdGhpcy5tYXAoY20sIHBhcmFtcywgJ25vcm1hbCcpOyB9LFxuICAgICAgdm1hcDogZnVuY3Rpb24oY20sIHBhcmFtcykgeyB0aGlzLm1hcChjbSwgcGFyYW1zLCAndmlzdWFsJyk7IH0sXG4gICAgICB1bm1hcDogZnVuY3Rpb24oY20sIHBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBtYXBBcmdzID0gcGFyYW1zLmFyZ3M7XG4gICAgICAgIGlmICghbWFwQXJncyB8fCBtYXBBcmdzLmxlbmd0aCA8IDEgfHwgIWV4Q29tbWFuZERpc3BhdGNoZXIudW5tYXAobWFwQXJnc1swXSwgY3R4KSkge1xuICAgICAgICAgIGlmIChjbSkge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdObyBzdWNoIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vdmU6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgY29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIGNtLnN0YXRlLnZpbSwge1xuICAgICAgICAgICAgdHlwZTogJ21vdGlvbicsXG4gICAgICAgICAgICBtb3Rpb246ICdtb3ZlVG9MaW5lT3JFZGdlT2ZEb2N1bWVudCcsXG4gICAgICAgICAgICBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBleHBsaWNpdFJlcGVhdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbGluZXdpc2U6IHRydWUgfSxcbiAgICAgICAgICAgIHJlcGVhdE92ZXJyaWRlOiBwYXJhbXMubGluZSsxfSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBzZXRBcmdzID0gcGFyYW1zLmFyZ3M7XG4gICAgICAgIC8vIE9wdGlvbnMgcGFzc2VkIHRocm91Z2ggdG8gdGhlIHNldE9wdGlvbi9nZXRPcHRpb24gY2FsbHMuIE1heSBiZSBwYXNzZWQgaW4gYnkgdGhlXG4gICAgICAgIC8vIGxvY2FsL2dsb2JhbCB2ZXJzaW9ucyBvZiB0aGUgc2V0IGNvbW1hbmRcbiAgICAgICAgdmFyIHNldENmZyA9IHBhcmFtcy5zZXRDZmcgfHwge307XG4gICAgICAgIGlmICghc2V0QXJncyB8fCBzZXRBcmdzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICBpZiAoY20pIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBtYXBwaW5nOiAnICsgcGFyYW1zLmlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHByID0gc2V0QXJnc1swXS5zcGxpdCgnPScpO1xuICAgICAgICB2YXIgb3B0aW9uTmFtZSA9IGV4cHJbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHJbMV07XG4gICAgICAgIHZhciBmb3JjZUdldCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25OYW1lLmNoYXJBdChvcHRpb25OYW1lLmxlbmd0aCAtIDEpID09ICc/Jykge1xuICAgICAgICAgIC8vIElmIHBvc3QtZml4ZWQgd2l0aCA/LCB0aGVuIHRoZSBzZXQgaXMgYWN0dWFsbHkgYSBnZXQuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7IHRocm93IEVycm9yKCdUcmFpbGluZyBjaGFyYWN0ZXJzOiAnICsgcGFyYW1zLmFyZ1N0cmluZyk7IH1cbiAgICAgICAgICBvcHRpb25OYW1lID0gb3B0aW9uTmFtZS5zdWJzdHJpbmcoMCwgb3B0aW9uTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICBmb3JjZUdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9uTmFtZS5zdWJzdHJpbmcoMCwgMikgPT0gJ25vJykge1xuICAgICAgICAgIC8vIFRvIHNldCBib29sZWFuIG9wdGlvbnMgdG8gZmFsc2UsIHRoZSBvcHRpb24gbmFtZSBpcyBwcmVmaXhlZCB3aXRoXG4gICAgICAgICAgLy8gJ25vJy5cbiAgICAgICAgICBvcHRpb25OYW1lID0gb3B0aW9uTmFtZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25Jc0Jvb2xlYW4gPSBvcHRpb25zW29wdGlvbk5hbWVdICYmIG9wdGlvbnNbb3B0aW9uTmFtZV0udHlwZSA9PSAnYm9vbGVhbic7XG4gICAgICAgIGlmIChvcHRpb25Jc0Jvb2xlYW4gJiYgdmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQ2FsbGluZyBzZXQgd2l0aCBhIGJvb2xlYW4gb3B0aW9uIHNldHMgaXQgdG8gdHJ1ZS5cbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsIHRoZW4gd2UgYXNzdW1lIHRoaXMgaXMgYSBnZXQuXG4gICAgICAgIGlmICghb3B0aW9uSXNCb29sZWFuICYmIHZhbHVlID09PSB1bmRlZmluZWQgfHwgZm9yY2VHZXQpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBnZXRPcHRpb24ob3B0aW9uTmFtZSwgY20sIHNldENmZyk7XG4gICAgICAgICAgaWYgKG9sZFZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCBvbGRWYWx1ZS5tZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB0cnVlIHx8IG9sZFZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICcgJyArIChvbGRWYWx1ZSA/ICcnIDogJ25vJykgKyBvcHRpb25OYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICcgICcgKyBvcHRpb25OYW1lICsgJz0nICsgb2xkVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2V0T3B0aW9uUmV0dXJuID0gc2V0T3B0aW9uKG9wdGlvbk5hbWUsIHZhbHVlLCBjbSwgc2V0Q2ZnKTtcbiAgICAgICAgICBpZiAoc2V0T3B0aW9uUmV0dXJuIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCBzZXRPcHRpb25SZXR1cm4ubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0bG9jYWw6IGZ1bmN0aW9uIChjbSwgcGFyYW1zKSB7XG4gICAgICAgIC8vIHNldENmZyBpcyBwYXNzZWQgdGhyb3VnaCB0byBzZXRPcHRpb25cbiAgICAgICAgcGFyYW1zLnNldENmZyA9IHtzY29wZTogJ2xvY2FsJ307XG4gICAgICAgIHRoaXMuc2V0KGNtLCBwYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIHNldGdsb2JhbDogZnVuY3Rpb24gKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gc2V0Q2ZnIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHNldE9wdGlvblxuICAgICAgICBwYXJhbXMuc2V0Q2ZnID0ge3Njb3BlOiAnZ2xvYmFsJ307XG4gICAgICAgIHRoaXMuc2V0KGNtLCBwYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICB2YXIgcmVnQXJncyA9IHBhcmFtcy5hcmdzO1xuICAgICAgICB2YXIgcmVnaXN0ZXJzID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLnJlZ2lzdGVycztcbiAgICAgICAgdmFyIHJlZ0luZm8gPSAnLS0tLS0tLS0tLVJlZ2lzdGVycy0tLS0tLS0tLS1cXG5cXG4nO1xuICAgICAgICBpZiAoIXJlZ0FyZ3MpIHtcbiAgICAgICAgICBmb3IgKHZhciByZWdpc3Rlck5hbWUgaW4gcmVnaXN0ZXJzKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHJlZ2lzdGVyc1tyZWdpc3Rlck5hbWVdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVnSW5mbyArPSAnXCInICsgcmVnaXN0ZXJOYW1lICsgJyAgICAnICsgdGV4dCArICdcXG4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWdpc3Rlck5hbWU7XG4gICAgICAgICAgcmVnQXJncyA9IHJlZ0FyZ3Muam9pbignJyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdBcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWdpc3Rlck5hbWUgPSByZWdBcmdzLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICghdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmlzVmFsaWRSZWdpc3RlcihyZWdpc3Rlck5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyID0gcmVnaXN0ZXJzW3JlZ2lzdGVyTmFtZV0gfHwgbmV3IFJlZ2lzdGVyKCk7XG4gICAgICAgICAgICByZWdJbmZvICs9ICdcIicgKyByZWdpc3Rlck5hbWUgKyAnICAgICcgKyByZWdpc3Rlci50b1N0cmluZygpICsgJ1xcbidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvd0NvbmZpcm0oY20sIHJlZ0luZm8pO1xuICAgICAgfSxcbiAgICAgIHNvcnQ6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHJldmVyc2UsIGlnbm9yZUNhc2UsIHVuaXF1ZSwgbnVtYmVyLCBwYXR0ZXJuO1xuICAgICAgICBmdW5jdGlvbiBwYXJzZUFyZ3MoKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5hcmdTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKHBhcmFtcy5hcmdTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKGFyZ3MuZWF0KCchJykpIHsgcmV2ZXJzZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmIChhcmdzLmVvbCgpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKCFhcmdzLmVhdFNwYWNlKCkpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50cyc7IH1cbiAgICAgICAgICAgIHZhciBvcHRzID0gYXJncy5tYXRjaCgvKFtkaW51b3hdKyk/XFxzKihcXC8uK1xcLyk/XFxzKi8pO1xuICAgICAgICAgICAgaWYgKCFvcHRzICYmICFhcmdzLmVvbCgpKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudHMnOyB9XG4gICAgICAgICAgICBpZiAob3B0c1sxXSkge1xuICAgICAgICAgICAgICBpZ25vcmVDYXNlID0gb3B0c1sxXS5pbmRleE9mKCdpJykgIT0gLTE7XG4gICAgICAgICAgICAgIHVuaXF1ZSA9IG9wdHNbMV0uaW5kZXhPZigndScpICE9IC0xO1xuICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IG9wdHNbMV0uaW5kZXhPZignZCcpICE9IC0xIHx8IG9wdHNbMV0uaW5kZXhPZignbicpICE9IC0xICYmIDE7XG4gICAgICAgICAgICAgIHZhciBoZXggPSBvcHRzWzFdLmluZGV4T2YoJ3gnKSAhPSAtMSAmJiAxO1xuICAgICAgICAgICAgICB2YXIgb2N0YWwgPSBvcHRzWzFdLmluZGV4T2YoJ28nKSAhPSAtMSAmJiAxO1xuICAgICAgICAgICAgICBpZiAoZGVjaW1hbCArIGhleCArIG9jdGFsID4gMSkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnRzJzsgfVxuICAgICAgICAgICAgICBudW1iZXIgPSBkZWNpbWFsICYmICdkZWNpbWFsJyB8fCBoZXggJiYgJ2hleCcgfHwgb2N0YWwgJiYgJ29jdGFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzWzJdKSB7XG4gICAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKG9wdHNbMl0uc3Vic3RyKDEsIG9wdHNbMl0ubGVuZ3RoIC0gMiksIGlnbm9yZUNhc2UgPyAnaScgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlcnIgPSBwYXJzZUFyZ3MoKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCBlcnIgKyAnOiAnICsgcGFyYW1zLmFyZ1N0cmluZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lU3RhcnQgPSBwYXJhbXMubGluZSB8fCBjbS5maXJzdExpbmUoKTtcbiAgICAgICAgdmFyIGxpbmVFbmQgPSBwYXJhbXMubGluZUVuZCB8fCBwYXJhbXMubGluZSB8fCBjbS5sYXN0TGluZSgpO1xuICAgICAgICBpZiAobGluZVN0YXJ0ID09IGxpbmVFbmQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBjdXJTdGFydCA9IG5ldyBQb3MobGluZVN0YXJ0LCAwKTtcbiAgICAgICAgdmFyIGN1ckVuZCA9IG5ldyBQb3MobGluZUVuZCwgbGluZUxlbmd0aChjbSwgbGluZUVuZCkpO1xuICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIG51bWJlclJlZ2V4ID0gcGF0dGVybiA/IHBhdHRlcm4gOlxuICAgICAgICAgICAobnVtYmVyID09ICdkZWNpbWFsJykgPyAvKC0/KShbXFxkXSspLyA6XG4gICAgICAgICAgIChudW1iZXIgPT0gJ2hleCcpID8gLygtPykoPzoweCk/KFswLTlhLWZdKykvaSA6XG4gICAgICAgICAgIChudW1iZXIgPT0gJ29jdGFsJykgPyAvKFswLTddKykvIDogbnVsbDtcbiAgICAgICAgdmFyIHJhZGl4ID0gKG51bWJlciA9PSAnZGVjaW1hbCcpID8gMTAgOiAobnVtYmVyID09ICdoZXgnKSA/IDE2IDogKG51bWJlciA9PSAnb2N0YWwnKSA/IDggOiBudWxsO1xuICAgICAgICB2YXIgbnVtUGFydCA9IFtdLCB0ZXh0UGFydCA9IFtdO1xuICAgICAgICBpZiAobnVtYmVyIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaFBhcnQgPSBwYXR0ZXJuID8gdGV4dFtpXS5tYXRjaChwYXR0ZXJuKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2hQYXJ0ICYmIG1hdGNoUGFydFswXSAhPSAnJykge1xuICAgICAgICAgICAgICBudW1QYXJ0LnB1c2gobWF0Y2hQYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdHRlcm4gJiYgbnVtYmVyUmVnZXguZXhlYyh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICBudW1QYXJ0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0UGFydC5wdXNoKHRleHRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0UGFydCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUZuKGEsIGIpIHtcbiAgICAgICAgICBpZiAocmV2ZXJzZSkgeyB2YXIgdG1wOyB0bXAgPSBhOyBhID0gYjsgYiA9IHRtcDsgfVxuICAgICAgICAgIGlmIChpZ25vcmVDYXNlKSB7IGEgPSBhLnRvTG93ZXJDYXNlKCk7IGIgPSBiLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgICB2YXIgYW51bSA9IG51bWJlciAmJiBudW1iZXJSZWdleC5leGVjKGEpO1xuICAgICAgICAgIHZhciBibnVtID0gbnVtYmVyICYmIG51bWJlclJlZ2V4LmV4ZWMoYik7XG4gICAgICAgICAgaWYgKCFhbnVtKSB7IHJldHVybiBhIDwgYiA/IC0xIDogMTsgfVxuICAgICAgICAgIGFudW0gPSBwYXJzZUludCgoYW51bVsxXSArIGFudW1bMl0pLnRvTG93ZXJDYXNlKCksIHJhZGl4KTtcbiAgICAgICAgICBibnVtID0gcGFyc2VJbnQoKGJudW1bMV0gKyBibnVtWzJdKS50b0xvd2VyQ2FzZSgpLCByYWRpeCk7XG4gICAgICAgICAgcmV0dXJuIGFudW0gLSBibnVtO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVQYXR0ZXJuRm4oYSwgYikge1xuICAgICAgICAgIGlmIChyZXZlcnNlKSB7IHZhciB0bXA7IHRtcCA9IGE7IGEgPSBiOyBiID0gdG1wOyB9XG4gICAgICAgICAgaWYgKGlnbm9yZUNhc2UpIHsgYVswXSA9IGFbMF0udG9Mb3dlckNhc2UoKTsgYlswXSA9IGJbMF0udG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICAgIHJldHVybiAoYVswXSA8IGJbMF0pID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIG51bVBhcnQuc29ydChwYXR0ZXJuID8gY29tcGFyZVBhdHRlcm5GbiA6IGNvbXBhcmVGbik7XG4gICAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW1QYXJ0W2ldID0gbnVtUGFydFtpXS5pbnB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW51bWJlcikgeyB0ZXh0UGFydC5zb3J0KGNvbXBhcmVGbik7IH1cbiAgICAgICAgdGV4dCA9ICghcmV2ZXJzZSkgPyB0ZXh0UGFydC5jb25jYXQobnVtUGFydCkgOiBudW1QYXJ0LmNvbmNhdCh0ZXh0UGFydCk7XG4gICAgICAgIGlmICh1bmlxdWUpIHsgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBsaW5lc1xuICAgICAgICAgIHZhciB0ZXh0T2xkID0gdGV4dDtcbiAgICAgICAgICB2YXIgbGFzdExpbmU7XG4gICAgICAgICAgdGV4dCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dE9sZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRleHRPbGRbaV0gIT0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgdGV4dC5wdXNoKHRleHRPbGRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdExpbmUgPSB0ZXh0T2xkW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dC5qb2luKCdcXG4nKSwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICB9LFxuICAgICAgdmdsb2JhbDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICAvLyBnbG9iYWwgaW5zcGVjdHMgcGFyYW1zLmNvbW1hbmROYW1lXG4gICAgICAgIHRoaXMuZ2xvYmFsKGNtLCBwYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIGdsb2JhbDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICAvLyBhIGdsb2JhbCBjb21tYW5kIGlzIG9mIHRoZSBmb3JtXG4gICAgICAgIC8vIDpbcmFuZ2VdZy9wYXR0ZXJuL1tjbWRdXG4gICAgICAgIC8vIGFyZ1N0cmluZyBob2xkcyB0aGUgc3RyaW5nIC9wYXR0ZXJuL1tjbWRdXG4gICAgICAgIHZhciBhcmdTdHJpbmcgPSBwYXJhbXMuYXJnU3RyaW5nO1xuICAgICAgICBpZiAoIWFyZ1N0cmluZykge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnUmVndWxhciBFeHByZXNzaW9uIG1pc3NpbmcgZnJvbSBnbG9iYWwnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludmVydGVkID0gcGFyYW1zLmNvbW1hbmROYW1lWzBdID09PSAndic7XG4gICAgICAgIC8vIHJhbmdlIGlzIHNwZWNpZmllZCBoZXJlXG4gICAgICAgIHZhciBsaW5lU3RhcnQgPSAocGFyYW1zLmxpbmUgIT09IHVuZGVmaW5lZCkgPyBwYXJhbXMubGluZSA6IGNtLmZpcnN0TGluZSgpO1xuICAgICAgICB2YXIgbGluZUVuZCA9IHBhcmFtcy5saW5lRW5kIHx8IHBhcmFtcy5saW5lIHx8IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgIC8vIGdldCB0aGUgdG9rZW5zIGZyb20gYXJnU3RyaW5nXG4gICAgICAgIHZhciB0b2tlbnMgPSBzcGxpdEJ5U2xhc2goYXJnU3RyaW5nKTtcbiAgICAgICAgdmFyIHJlZ2V4UGFydCA9IGFyZ1N0cmluZywgY21kO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgIHJlZ2V4UGFydCA9IHRva2Vuc1swXTtcbiAgICAgICAgICBjbWQgPSB0b2tlbnMuc2xpY2UoMSwgdG9rZW5zLmxlbmd0aCkuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdleFBhcnQpIHtcbiAgICAgICAgICAvLyBJZiByZWdleCBwYXJ0IGlzIGVtcHR5LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgcXVlcnkuIE90aGVyd2lzZVxuICAgICAgICAgIC8vIHVzZSB0aGUgcmVnZXggcGFydCBhcyB0aGUgbmV3IHF1ZXJ5LlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCByZWdleFBhcnQsIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sXG4gICAgICAgICAgICAgdHJ1ZSAvKiogc21hcnRDYXNlICovKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCByZWdleDogJyArIHJlZ2V4UGFydCk7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgcmVnZXhQYXJ0LCBzZWFyY2ggZm9yIHJlZ2V4IG1hdGNoZXMgaW4gdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCByYW5nZSBvZiBsaW5lc1xuICAgICAgICB2YXIgcXVlcnkgPSBnZXRTZWFyY2hTdGF0ZShjbSkuZ2V0UXVlcnkoKTtcbiAgICAgICAgdmFyIG1hdGNoZWRMaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gbGluZVN0YXJ0OyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShpKTtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHF1ZXJ5LnRlc3QobGluZS50ZXh0KTtcbiAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gaW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgIG1hdGNoZWRMaW5lcy5wdXNoKGNtZCA/IGxpbmUgOiBsaW5lLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBbY21kXSwganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIG1hdGNoZWQgbGluZXNcbiAgICAgICAgaWYgKCFjbWQpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgbWF0Y2hlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5leHRDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgbWF0Y2hlZExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBtYXRjaGVkTGluZXNbaW5kZXgrK107XG4gICAgICAgICAgICB2YXIgbGluZU51bSA9IGNtLmdldExpbmVOdW1iZXIobGluZSk7XG4gICAgICAgICAgICBpZiAobGluZU51bSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gKGxpbmVOdW0gKyAxKSArIGNtZDtcbiAgICAgICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIGNvbW1hbmQsIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG5leHRDb21tYW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgICB9LFxuICAgICAgc3Vic3RpdHV0ZTogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICBpZiAoIWNtLmdldFNlYXJjaEN1cnNvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoIGZlYXR1cmUgbm90IGF2YWlsYWJsZS4gUmVxdWlyZXMgc2VhcmNoY3Vyc29yLmpzIG9yICcgK1xuICAgICAgICAgICAgICAnYW55IG90aGVyIGdldFNlYXJjaEN1cnNvciBpbXBsZW1lbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnU3RyaW5nID0gcGFyYW1zLmFyZ1N0cmluZztcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ1N0cmluZyA/IHNwbGl0QnlTZXBhcmF0b3IoYXJnU3RyaW5nLCBhcmdTdHJpbmdbMF0pIDogW107XG4gICAgICAgIHZhciByZWdleFBhcnQsIHJlcGxhY2VQYXJ0ID0gJycsIHRyYWlsaW5nLCBmbGFnc1BhcnQsIGNvdW50O1xuICAgICAgICB2YXIgY29uZmlybSA9IGZhbHNlOyAvLyBXaGV0aGVyIHRvIGNvbmZpcm0gZWFjaCByZXBsYWNlLlxuICAgICAgICB2YXIgZ2xvYmFsID0gZmFsc2U7IC8vIFRydWUgdG8gcmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9uIGEgbGluZSwgZmFsc2UgdG8gcmVwbGFjZSBvbmx5IDEuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVnZXhQYXJ0ID0gdG9rZW5zWzBdO1xuICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3BjcmUnKSAmJiByZWdleFBhcnQgIT09ICcnKSB7XG4gICAgICAgICAgICAgIHJlZ2V4UGFydCA9IG5ldyBSZWdFeHAocmVnZXhQYXJ0KS5zb3VyY2U7IC8vbm9ybWFsaXplIG5vdCBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZVBhcnQgPSB0b2tlbnNbMV07XG4gICAgICAgICAgaWYgKHJlcGxhY2VQYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3BjcmUnKSkge1xuICAgICAgICAgICAgICByZXBsYWNlUGFydCA9IHVuZXNjYXBlUmVnZXhSZXBsYWNlKHJlcGxhY2VQYXJ0LnJlcGxhY2UoLyhbXlxcXFxdKSYvZyxcIiQxJCQmXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VQYXJ0ID0gdHJhbnNsYXRlUmVnZXhSZXBsYWNlKHJlcGxhY2VQYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RTdWJzdGl0dXRlUmVwbGFjZVBhcnQgPSByZXBsYWNlUGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhaWxpbmcgPSB0b2tlbnNbMl0gPyB0b2tlbnNbMl0uc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVpdGhlciB0aGUgYXJnU3RyaW5nIGlzIGVtcHR5IG9yIGl0cyBvZiB0aGUgZm9ybSAnIGhlbGxvL3dvcmxkJ1xuICAgICAgICAgIC8vIGFjdHVhbGx5IHNwbGl0QnlTbGFzaCByZXR1cm5zIGEgbGlzdCBvZiB0b2tlbnNcbiAgICAgICAgICAvLyBvbmx5IGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYSAnLydcbiAgICAgICAgICBpZiAoYXJnU3RyaW5nICYmIGFyZ1N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnU3Vic3RpdHV0aW9ucyBzaG91bGQgYmUgb2YgdGhlIGZvcm0gJyArXG4gICAgICAgICAgICAgICAgJzpzL3BhdHRlcm4vcmVwbGFjZS8nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIDNyZCBzbGFzaCwgd2UgY2FuIGhhdmUgZmxhZ3MgZm9sbG93ZWQgYnkgYSBzcGFjZSBmb2xsb3dlZFxuICAgICAgICAvLyBieSBjb3VudC5cbiAgICAgICAgaWYgKHRyYWlsaW5nKSB7XG4gICAgICAgICAgZmxhZ3NQYXJ0ID0gdHJhaWxpbmdbMF07XG4gICAgICAgICAgY291bnQgPSBwYXJzZUludCh0cmFpbGluZ1sxXSk7XG4gICAgICAgICAgaWYgKGZsYWdzUGFydCkge1xuICAgICAgICAgICAgaWYgKGZsYWdzUGFydC5pbmRleE9mKCdjJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uZmlybSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3NQYXJ0LmluZGV4T2YoJ2cnKSAhPSAtMSkge1xuICAgICAgICAgICAgICBnbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldE9wdGlvbigncGNyZScpKSB7XG4gICAgICAgICAgICAgICByZWdleFBhcnQgPSByZWdleFBhcnQgKyAnLycgKyBmbGFnc1BhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmVnZXhQYXJ0ID0gcmVnZXhQYXJ0LnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpICsgJy8nICsgZmxhZ3NQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnZXhQYXJ0KSB7XG4gICAgICAgICAgLy8gSWYgcmVnZXggcGFydCBpcyBlbXB0eSwgdGhlbiB1c2UgdGhlIHByZXZpb3VzIHF1ZXJ5LiBPdGhlcndpc2UgdXNlXG4gICAgICAgICAgLy8gdGhlIHJlZ2V4IHBhcnQgYXMgdGhlIG5ldyBxdWVyeS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXBkYXRlU2VhcmNoUXVlcnkoY20sIHJlZ2V4UGFydCwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLyxcbiAgICAgICAgICAgICAgdHJ1ZSAvKiogc21hcnRDYXNlICovKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgcmVnZXg6ICcgKyByZWdleFBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlUGFydCA9IHJlcGxhY2VQYXJ0IHx8IHZpbUdsb2JhbFN0YXRlLmxhc3RTdWJzdGl0dXRlUmVwbGFjZVBhcnQ7XG4gICAgICAgIGlmIChyZXBsYWNlUGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdObyBwcmV2aW91cyBzdWJzdGl0dXRlIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgICAgIHZhciBxdWVyeSA9IHN0YXRlLmdldFF1ZXJ5KCk7XG4gICAgICAgIHZhciBsaW5lU3RhcnQgPSAocGFyYW1zLmxpbmUgIT09IHVuZGVmaW5lZCkgPyBwYXJhbXMubGluZSA6IGNtLmdldEN1cnNvcigpLmxpbmU7XG4gICAgICAgIHZhciBsaW5lRW5kID0gcGFyYW1zLmxpbmVFbmQgfHwgbGluZVN0YXJ0O1xuICAgICAgICBpZiAobGluZVN0YXJ0ID09IGNtLmZpcnN0TGluZSgpICYmIGxpbmVFbmQgPT0gY20ubGFzdExpbmUoKSkge1xuICAgICAgICAgIGxpbmVFbmQgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICAgICAgICAgIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBjb3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3IFBvcyhsaW5lU3RhcnQsIDApKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgc3RhcnRQb3MpO1xuICAgICAgICBkb1JlcGxhY2UoY20sIGNvbmZpcm0sIGdsb2JhbCwgbGluZVN0YXJ0LCBsaW5lRW5kLCBjdXJzb3IsIHF1ZXJ5LCByZXBsYWNlUGFydCwgcGFyYW1zLmNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICByZWRvOiBDb2RlTWlycm9yLmNvbW1hbmRzLnJlZG8sXG4gICAgICB1bmRvOiBDb2RlTWlycm9yLmNvbW1hbmRzLnVuZG8sXG4gICAgICB3cml0ZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY29tbWFuZHMuc2F2ZSkge1xuICAgICAgICAgIC8vIElmIGEgc2F2ZSBjb21tYW5kIGlzIGRlZmluZWQsIGNhbGwgaXQuXG4gICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5zYXZlKGNtKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbS5zYXZlKSB7XG4gICAgICAgICAgLy8gU2F2ZXMgdG8gdGV4dCBhcmVhIGlmIG5vIHNhdmUgY29tbWFuZCBpcyBkZWZpbmVkIGFuZCBjbS5zYXZlKCkgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgIGNtLnNhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vaGxzZWFyY2g6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIGNsZWFyU2VhcmNoSGlnaGxpZ2h0KGNtKTtcbiAgICAgIH0sXG4gICAgICB5YW5rOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgdmFyIGN1ciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgICB2YXIgbGluZSA9IGN1ci5saW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBjbS5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgJzAnLCAneWFuaycsIGxpbmVUZXh0LCB0cnVlLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBkZWxtYXJrczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5hcmdTdHJpbmcgfHwgIXRyaW0ocGFyYW1zLmFyZ1N0cmluZykpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0FyZ3VtZW50IHJlcXVpcmVkJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gY20uc3RhdGUudmltO1xuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKHRyaW0ocGFyYW1zLmFyZ1N0cmluZykpO1xuICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gICAgICAgICAgLy8gUmVjb3JkIHRoZSBzdHJlYW1zIHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxvb3AgZm9yIHVzZVxuICAgICAgICAgIC8vIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgIHZhciBjb3VudCA9IHN0cmVhbS5wb3M7XG5cbiAgICAgICAgICBpZiAoIXN0cmVhbS5tYXRjaCgvW2EtekEtWl0vLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBhcmd1bWVudDogJyArIHBhcmFtcy5hcmdTdHJpbmcuc3Vic3RyaW5nKGNvdW50KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN5bSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzeW1ib2wgaXMgcGFydCBvZiBhIHJhbmdlXG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnLScsIHRydWUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN5bWJvbCBpcyBwYXJ0IG9mIGEgcmFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRoZSByYW5nZSBtdXN0IHRlcm1pbmF0ZSBhdCBhbiBhbHBoYWJldGljIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9bYS16QS1aXS8sIGZhbHNlKSkge1xuICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBwYXJhbXMuYXJnU3RyaW5nLnN1YnN0cmluZyhjb3VudCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydE1hcmsgPSBzeW07XG4gICAgICAgICAgICB2YXIgZmluaXNoTWFyayA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICAvLyBUaGUgcmFuZ2UgbXVzdCB0ZXJtaW5hdGUgYXQgYW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXIgd2hpY2hcbiAgICAgICAgICAgIC8vIHNoYXJlcyB0aGUgc2FtZSBjYXNlIGFzIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgICBpZiAoaXNMb3dlckNhc2Uoc3RhcnRNYXJrKSAmJiBpc0xvd2VyQ2FzZShmaW5pc2hNYXJrKSB8fFxuICAgICAgICAgICAgICAgIGlzVXBwZXJDYXNlKHN0YXJ0TWFyaykgJiYgaXNVcHBlckNhc2UoZmluaXNoTWFyaykpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRNYXJrLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIHZhciBmaW5pc2ggPSBmaW5pc2hNYXJrLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSBmaW5pc2gpIHtcbiAgICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBwYXJhbXMuYXJnU3RyaW5nLnN1YnN0cmluZyhjb3VudCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgbWFya3MgYXJlIGFsd2F5cyBBU0NJSSB2YWx1ZXMsIGFuZCB3ZSBoYXZlXG4gICAgICAgICAgICAgIC8vIGRldGVybWluZWQgdGhhdCB0aGV5IGFyZSB0aGUgc2FtZSBjYXNlLCB3ZSBjYW4gdXNlXG4gICAgICAgICAgICAgIC8vIHRoZWlyIGNoYXIgY29kZXMgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBkZWZpbmVkIHJhbmdlLlxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBmaW5pc2ggLSBzdGFydDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0ICsgaik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLm1hcmtzW21hcmtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBzdGFydE1hcmsgKyAnLScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc3ltYm9sIGlzIGEgdmFsaWQgbWFyaywgYW5kIGlzIG5vdCBwYXJ0IG9mIGEgcmFuZ2UuXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubWFya3Nbc3ltXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGV4Q29tbWFuZERpc3BhdGNoZXIgPSBuZXcgRXhDb21tYW5kRGlzcGF0Y2hlcigpO1xuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0NvZGVNaXJyb3J9IGNtIENvZGVNaXJyb3IgaW5zdGFuY2Ugd2UgYXJlIGluLlxuICAgICogQHBhcmFtIHtib29sZWFufSBjb25maXJtIFdoZXRoZXIgdG8gY29uZmlybSBlYWNoIHJlcGxhY2UuXG4gICAgKiBAcGFyYW0ge0N1cnNvcn0gbGluZVN0YXJ0IExpbmUgdG8gc3RhcnQgcmVwbGFjaW5nIGZyb20uXG4gICAgKiBAcGFyYW0ge0N1cnNvcn0gbGluZUVuZCBMaW5lIHRvIHN0b3AgcmVwbGFjaW5nIGF0LlxuICAgICogQHBhcmFtIHtSZWdFeHB9IHF1ZXJ5IFF1ZXJ5IGZvciBwZXJmb3JtaW5nIG1hdGNoZXMgd2l0aC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNlV2l0aCBUZXh0IHRvIHJlcGxhY2UgbWF0Y2hlcyB3aXRoLiBNYXkgY29udGFpbiAkMSxcbiAgICAqICAgICAkMiwgZXRjIGZvciByZXBsYWNpbmcgY2FwdHVyZWQgZ3JvdXBzIHVzaW5nIEphdmFTY3JpcHQgcmVwbGFjZS5cbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgcmVwbGFjZSBpcyBkb25lLlxuICAgICovXG4gICAgZnVuY3Rpb24gZG9SZXBsYWNlKGNtLCBjb25maXJtLCBnbG9iYWwsIGxpbmVTdGFydCwgbGluZUVuZCwgc2VhcmNoQ3Vyc29yLCBxdWVyeSxcbiAgICAgICAgcmVwbGFjZVdpdGgsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBTZXQgdXAgYWxsIHRoZSBmdW5jdGlvbnMuXG4gICAgICBjbS5zdGF0ZS52aW0uZXhNb2RlID0gdHJ1ZTtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdFBvcywgbW9kaWZpZWRMaW5lTnVtYmVyLCBqb2luZWQ7XG4gICAgICBmdW5jdGlvbiByZXBsYWNlQWxsKCkge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICByZXBsYWNlKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKHNlYXJjaEN1cnNvci5mcm9tKCksIHNlYXJjaEN1cnNvci50bygpKTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0LnJlcGxhY2UocXVlcnksIHJlcGxhY2VXaXRoKTtcbiAgICAgICAgdmFyIHVubW9kaWZpZWRMaW5lTnVtYmVyID0gc2VhcmNoQ3Vyc29yLnRvKCkubGluZTtcbiAgICAgICAgc2VhcmNoQ3Vyc29yLnJlcGxhY2UobmV3VGV4dCk7XG4gICAgICAgIG1vZGlmaWVkTGluZU51bWJlciA9IHNlYXJjaEN1cnNvci50bygpLmxpbmU7XG4gICAgICAgIGxpbmVFbmQgKz0gbW9kaWZpZWRMaW5lTnVtYmVyIC0gdW5tb2RpZmllZExpbmVOdW1iZXI7XG4gICAgICAgIGpvaW5lZCA9IG1vZGlmaWVkTGluZU51bWJlciA8IHVubW9kaWZpZWRMaW5lTnVtYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZmluZE5leHRWYWxpZE1hdGNoKCkge1xuICAgICAgICB2YXIgbGFzdE1hdGNoVG8gPSBsYXN0UG9zICYmIGNvcHlDdXJzb3Ioc2VhcmNoQ3Vyc29yLnRvKCkpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWFyY2hDdXJzb3IuZmluZE5leHQoKTtcbiAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBsYXN0TWF0Y2hUbyAmJiBjdXJzb3JFcXVhbChzZWFyY2hDdXJzb3IuZnJvbSgpLCBsYXN0TWF0Y2hUbykpIHtcbiAgICAgICAgICBtYXRjaCA9IHNlYXJjaEN1cnNvci5maW5kTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIC8vIFRoZSBiZWxvdyBvbmx5IGxvb3BzIHRvIHNraXAgb3ZlciBtdWx0aXBsZSBvY2N1cnJlbmNlcyBvbiB0aGUgc2FtZVxuICAgICAgICAvLyBsaW5lIHdoZW4gJ2dsb2JhbCcgaXMgbm90IHRydWUuXG4gICAgICAgIHdoaWxlKGZpbmROZXh0VmFsaWRNYXRjaCgpICYmXG4gICAgICAgICAgICAgIGlzSW5SYW5nZShzZWFyY2hDdXJzb3IuZnJvbSgpLCBsaW5lU3RhcnQsIGxpbmVFbmQpKSB7XG4gICAgICAgICAgaWYgKCFnbG9iYWwgJiYgc2VhcmNoQ3Vyc29yLmZyb20oKS5saW5lID09IG1vZGlmaWVkTGluZU51bWJlciAmJiAham9pbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcoc2VhcmNoQ3Vyc29yLmZyb20oKSwgMzApO1xuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbihzZWFyY2hDdXJzb3IuZnJvbSgpLCBzZWFyY2hDdXJzb3IudG8oKSk7XG4gICAgICAgICAgbGFzdFBvcyA9IHNlYXJjaEN1cnNvci5mcm9tKCk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0b3AoY2xvc2UpIHtcbiAgICAgICAgaWYgKGNsb3NlKSB7IGNsb3NlKCk7IH1cbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgaWYgKGxhc3RQb3MpIHtcbiAgICAgICAgICBjbS5zZXRDdXJzb3IobGFzdFBvcyk7XG4gICAgICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgICAgICB2aW0uZXhNb2RlID0gZmFsc2U7XG4gICAgICAgICAgdmltLmxhc3RIUG9zID0gdmltLmxhc3RIU1BvcyA9IGxhc3RQb3MuY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKCk7IH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uUHJvbXB0S2V5RG93bihlLCBfdmFsdWUsIGNsb3NlKSB7XG4gICAgICAgIC8vIFN3YWxsb3cgYWxsIGtleXMuXG4gICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICB2YXIga2V5TmFtZSA9IENvZGVNaXJyb3Iua2V5TmFtZShlKTtcbiAgICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXBsYWNlKCk7IG5leHQoKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICBuZXh0KCk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gcmVwbGFjZUFsbCBjb250YWlucyBhIGNhbGwgdG8gY2xvc2Ugb2YgaXRzIG93bi4gV2UgZG9uJ3Qgd2FudCBpdFxuICAgICAgICAgICAgLy8gdG8gZmlyZSB0b28gZWFybHkgb3IgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICB2YXIgc2F2ZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjbS5vcGVyYXRpb24ocmVwbGFjZUFsbCk7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNhdmVkQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIHJlcGxhY2UoKTtcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCBhbmQgZXhpdC5cbiAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBjYXNlICdFc2MnOlxuICAgICAgICAgIGNhc2UgJ0N0cmwtQyc6XG4gICAgICAgICAgY2FzZSAnQ3RybC1bJzpcbiAgICAgICAgICAgIHN0b3AoY2xvc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIHsgc3RvcChjbG9zZSk7IH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFjdHVhbGx5IGRvIHJlcGxhY2UuXG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBzaG93Q29uZmlybShjbSwgJ05vIG1hdGNoZXMgZm9yICcgKyBxdWVyeS5zb3VyY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpcm0pIHtcbiAgICAgICAgcmVwbGFjZUFsbCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soKTsgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaG93UHJvbXB0KGNtLCB7XG4gICAgICAgIHByZWZpeDogZG9tKCdzcGFuJywgJ3JlcGxhY2Ugd2l0aCAnLCBkb20oJ3N0cm9uZycsIHJlcGxhY2VXaXRoKSwgJyAoeS9uL2EvcS9sKScpLFxuICAgICAgICBvbktleURvd246IG9uUHJvbXB0S2V5RG93blxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQ29kZU1pcnJvci5rZXlNYXAudmltID0ge1xuICAgICAgYXR0YWNoOiBhdHRhY2hWaW1NYXAsXG4gICAgICBkZXRhY2g6IGRldGFjaFZpbU1hcCxcbiAgICAgIGNhbGw6IGNtS2V5XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4aXRJbnNlcnRNb2RlKGNtKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICB2YXIgaW5zZXJ0TW9kZUNoYW5nZVJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKCcuJyk7XG4gICAgICB2YXIgaXNQbGF5aW5nID0gbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nO1xuICAgICAgdmFyIGxhc3RDaGFuZ2UgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgICBpZiAoIWlzUGxheWluZykge1xuICAgICAgICBjbS5vZmYoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgQ29kZU1pcnJvci5vZmYoY20uZ2V0SW5wdXRGaWVsZCgpLCAna2V5ZG93bicsIG9uS2V5RXZlbnRUYXJnZXRLZXlEb3duKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQbGF5aW5nICYmIHZpbS5pbnNlcnRNb2RlUmVwZWF0ID4gMSkge1xuICAgICAgICAvLyBQZXJmb3JtIGluc2VydCBtb2RlIHJlcGVhdCBmb3IgY29tbWFuZHMgbGlrZSAzLGEgYW5kIDMsby5cbiAgICAgICAgcmVwZWF0TGFzdEVkaXQoY20sIHZpbSwgdmltLmluc2VydE1vZGVSZXBlYXQgLSAxLFxuICAgICAgICAgICAgdHJ1ZSAvKiogcmVwZWF0Rm9ySW5zZXJ0ICovKTtcbiAgICAgICAgdmltLmxhc3RFZGl0SW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSA9IHZpbS5pbnNlcnRNb2RlUmVwZWF0O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHZpbS5pbnNlcnRNb2RlUmVwZWF0O1xuICAgICAgdmltLmluc2VydE1vZGUgPSBmYWxzZTtcbiAgICAgIGNtLnNldEN1cnNvcihjbS5nZXRDdXJzb3IoKS5saW5lLCBjbS5nZXRDdXJzb3IoKS5jaC0xKTtcbiAgICAgIGNtLnNldE9wdGlvbigna2V5TWFwJywgJ3ZpbScpO1xuICAgICAgY20uc2V0T3B0aW9uKCdkaXNhYmxlSW5wdXQnLCB0cnVlKTtcbiAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZShmYWxzZSk7IC8vIGV4aXQgcmVwbGFjZSBtb2RlIGlmIHdlIHdlcmUgaW4gaXQuXG4gICAgICAvLyB1cGRhdGUgdGhlIFwiLiByZWdpc3RlciBiZWZvcmUgZXhpdGluZyBpbnNlcnQgbW9kZVxuICAgICAgaW5zZXJ0TW9kZUNoYW5nZVJlZ2lzdGVyLnNldFRleHQobGFzdENoYW5nZS5jaGFuZ2VzLmpvaW4oJycpKTtcbiAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJub3JtYWxcIn0pO1xuICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nKSB7XG4gICAgICAgIGxvZ0luc2VydE1vZGVDaGFuZ2UobWFjcm9Nb2RlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYXBDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgIGRlZmF1bHRLZXltYXAudW5zaGlmdChjb21tYW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBDb21tYW5kKGtleXMsIHR5cGUsIG5hbWUsIGFyZ3MsIGV4dHJhKSB7XG4gICAgICB2YXIgY29tbWFuZCA9IHtrZXlzOiBrZXlzLCB0eXBlOiB0eXBlfTtcbiAgICAgIGNvbW1hbmRbdHlwZV0gPSBuYW1lO1xuICAgICAgY29tbWFuZFt0eXBlICsgXCJBcmdzXCJdID0gYXJncztcbiAgICAgIGZvciAodmFyIGtleSBpbiBleHRyYSlcbiAgICAgICAgY29tbWFuZFtrZXldID0gZXh0cmFba2V5XTtcbiAgICAgIF9tYXBDb21tYW5kKGNvbW1hbmQpO1xuICAgIH1cblxuICAgIC8vIFRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHR3by1jaGFyYWN0ZXIgRVNDIGtleW1hcCBzaG91bGQgYmVcbiAgICAvLyBhZGp1c3RlZCBhY2NvcmRpbmcgdG8geW91ciB0eXBpbmcgc3BlZWQgdG8gcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgZGVmaW5lT3B0aW9uKCdpbnNlcnRNb2RlRXNjS2V5c1RpbWVvdXQnLCAyMDAsICdudW1iZXInKTtcblxuICAgIENvZGVNaXJyb3Iua2V5TWFwWyd2aW0taW5zZXJ0J10gPSB7XG4gICAgICAvLyBUT0RPOiBvdmVycmlkZSBuYXZpZ2F0aW9uIGtleXMgc28gdGhhdCBFc2Mgd2lsbCBjYW5jZWwgYXV0b21hdGljXG4gICAgICAvLyBpbmRlbnRhdGlvbiBmcm9tIG8sIE8sIGlfPENSPlxuICAgICAgZmFsbHRocm91Z2g6IFsnZGVmYXVsdCddLFxuICAgICAgYXR0YWNoOiBhdHRhY2hWaW1NYXAsXG4gICAgICBkZXRhY2g6IGRldGFjaFZpbU1hcCxcbiAgICAgIGNhbGw6IGNtS2V5XG4gICAgfTtcblxuICAgIENvZGVNaXJyb3Iua2V5TWFwWyd2aW0tcmVwbGFjZSddID0ge1xuICAgICAgJ0JhY2tzcGFjZSc6ICdnb0NoYXJMZWZ0JyxcbiAgICAgIGZhbGx0aHJvdWdoOiBbJ3ZpbS1pbnNlcnQnXSxcbiAgICAgIGF0dGFjaDogYXR0YWNoVmltTWFwLFxuICAgICAgZGV0YWNoOiBkZXRhY2hWaW1NYXAsXG4gICAgICBjYWxsOiBjbUtleVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleGVjdXRlTWFjcm9SZWdpc3RlcihjbSwgdmltLCBtYWNyb01vZGVTdGF0ZSwgcmVnaXN0ZXJOYW1lKSB7XG4gICAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICAgIGlmIChyZWdpc3Rlck5hbWUgPT0gJzonKSB7XG4gICAgICAgIC8vIFJlYWQtb25seSByZWdpc3RlciBjb250YWluaW5nIGxhc3QgRXggY29tbWFuZC5cbiAgICAgICAgaWYgKHJlZ2lzdGVyLmtleUJ1ZmZlclswXSkge1xuICAgICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIHJlZ2lzdGVyLmtleUJ1ZmZlclswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlCdWZmZXIgPSByZWdpc3Rlci5rZXlCdWZmZXI7XG4gICAgICB2YXIgaW1jID0gMDtcbiAgICAgIG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZyA9IHRydWU7XG4gICAgICBtYWNyb01vZGVTdGF0ZS5yZXBsYXlTZWFyY2hRdWVyaWVzID0gcmVnaXN0ZXIuc2VhcmNoUXVlcmllcy5zbGljZSgwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZXh0ID0ga2V5QnVmZmVyW2ldO1xuICAgICAgICB2YXIgbWF0Y2gsIGtleTtcbiAgICAgICAgd2hpbGUgKHRleHQpIHtcbiAgICAgICAgICAvLyBQdWxsIG9mZiBvbmUgY29tbWFuZCBrZXksIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAvLyBvciBhIHNwZWNpYWwgc2VxdWVuY2Ugd3JhcHBlZCBpbiAnPCcgYW5kICc+JywgZS5nLiAnPFNwYWNlPicuXG4gICAgICAgICAgbWF0Y2ggPSAoLzxcXHcrLS4rPz58PFxcdys+fC4vKS5leGVjKHRleHQpO1xuICAgICAgICAgIGtleSA9IG1hdGNoWzBdO1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhtYXRjaC5pbmRleCArIGtleS5sZW5ndGgpO1xuICAgICAgICAgIHZpbUFwaS5oYW5kbGVLZXkoY20sIGtleSwgJ21hY3JvJyk7XG4gICAgICAgICAgaWYgKHZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHJlZ2lzdGVyLmluc2VydE1vZGVDaGFuZ2VzW2ltYysrXS5jaGFuZ2VzO1xuICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMgPVxuICAgICAgICAgICAgICAgIGNoYW5nZXM7XG4gICAgICAgICAgICByZXBlYXRJbnNlcnRNb2RlQ2hhbmdlcyhjbSwgY2hhbmdlcywgMSk7XG4gICAgICAgICAgICBleGl0SW5zZXJ0TW9kZShjbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2dLZXkobWFjcm9Nb2RlU3RhdGUsIGtleSkge1xuICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlcjtcbiAgICAgIHZhciByZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpO1xuICAgICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICAgIHJlZ2lzdGVyLnB1c2hUZXh0KGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nSW5zZXJ0TW9kZUNoYW5nZShtYWNyb01vZGVTdGF0ZSkge1xuICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlcjtcbiAgICAgIHZhciByZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpO1xuICAgICAgaWYgKHJlZ2lzdGVyICYmIHJlZ2lzdGVyLnB1c2hJbnNlcnRNb2RlQ2hhbmdlcykge1xuICAgICAgICByZWdpc3Rlci5wdXNoSW5zZXJ0TW9kZUNoYW5nZXMobWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2dTZWFyY2hRdWVyeShtYWNyb01vZGVTdGF0ZSwgcXVlcnkpIHtcbiAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gbWFjcm9Nb2RlU3RhdGUubGF0ZXN0UmVnaXN0ZXI7XG4gICAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICAgIGlmIChyZWdpc3RlciAmJiByZWdpc3Rlci5wdXNoU2VhcmNoUXVlcnkpIHtcbiAgICAgICAgcmVnaXN0ZXIucHVzaFNlYXJjaFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIGZvciBjaGFuZ2VzIG1hZGUgaW4gaW5zZXJ0IG1vZGUuXG4gICAgICogU2hvdWxkIG9ubHkgYmUgYWN0aXZlIGluIGluc2VydCBtb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGNtLCBjaGFuZ2VPYmopIHtcbiAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgdmFyIGxhc3RDaGFuZ2UgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgICBpZiAoIW1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykge1xuICAgICAgICB3aGlsZShjaGFuZ2VPYmopIHtcbiAgICAgICAgICBsYXN0Q2hhbmdlLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAobGFzdENoYW5nZS5pZ25vcmVDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGxhc3RDaGFuZ2UuaWdub3JlQ291bnQtLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZU9iai5vcmlnaW4gPT0gJytpbnB1dCcgfHwgY2hhbmdlT2JqLm9yaWdpbiA9PSAncGFzdGUnXG4gICAgICAgICAgICAgIHx8IGNoYW5nZU9iai5vcmlnaW4gPT09IHVuZGVmaW5lZCAvKiBvbmx5IGluIHRlc3RpbmcgKi8pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25Db3VudCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvdW50ID4gMSlcbiAgICAgICAgICAgICAgbGFzdENoYW5nZS5pZ25vcmVDb3VudCA9IHNlbGVjdGlvbkNvdW50O1xuICAgICAgICAgICAgdmFyIHRleHQgPSBjaGFuZ2VPYmoudGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hhbmdlLm1heWJlUmVzZXQpIHtcbiAgICAgICAgICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzID0gW107XG4gICAgICAgICAgICAgIGxhc3RDaGFuZ2UubWF5YmVSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiAhL1xcbi8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcy5wdXNoKFt0ZXh0XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzLnB1c2godGV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2hhbmdlIG9iamVjdHMgbWF5IGJlIGNoYWluZWQgd2l0aCBuZXh0LlxuICAgICAgICAgIGNoYW5nZU9iaiA9IGNoYW5nZU9iai5uZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBMaXN0ZW5zIGZvciBhbnkga2luZCBvZiBjdXJzb3IgYWN0aXZpdHkgb24gQ29kZU1pcnJvci5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICBpZiAodmltLmluc2VydE1vZGUpIHtcbiAgICAgICAgLy8gVHJhY2tpbmcgY3Vyc29yIGFjdGl2aXR5IGluIGluc2VydCBtb2RlIChmb3IgbWFjcm8gc3VwcG9ydCkuXG4gICAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgICBpZiAobWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgbGFzdENoYW5nZSA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICAgICAgaWYgKGxhc3RDaGFuZ2UuZXhwZWN0Q3Vyc29yQWN0aXZpdHlGb3JDaGFuZ2UpIHtcbiAgICAgICAgICBsYXN0Q2hhbmdlLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3Vyc29yIG1vdmVkIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgYW4gZWRpdC4gUmVzZXQgdGhlIGNoYW5nZS5cbiAgICAgICAgICBsYXN0Q2hhbmdlLm1heWJlUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFjbS5jdXJPcC5pc1ZpbU9wKSB7XG4gICAgICAgIGhhbmRsZUV4dGVybmFsU2VsZWN0aW9uKGNtLCB2aW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbFNlbGVjdGlvbihjbSwgdmltKSB7XG4gICAgICB2YXIgYW5jaG9yID0gY20uZ2V0Q3Vyc29yKCdhbmNob3InKTtcbiAgICAgIHZhciBoZWFkID0gY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICAvLyBFbnRlciBvciBleGl0IHZpc3VhbCBtb2RlIHRvIG1hdGNoIG1vdXNlIHNlbGVjdGlvbi5cbiAgICAgIGlmICh2aW0udmlzdWFsTW9kZSAmJiAhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICBleGl0VmlzdWFsTW9kZShjbSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICghdmltLnZpc3VhbE1vZGUgJiYgIXZpbS5pbnNlcnRNb2RlICYmIGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgdmltLnZpc3VhbE1vZGUgPSB0cnVlO1xuICAgICAgICB2aW0udmlzdWFsTGluZSA9IGZhbHNlO1xuICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwidmlzdWFsXCJ9KTtcbiAgICAgIH1cbiAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAvLyBCaW5kIENvZGVNaXJyb3Igc2VsZWN0aW9uIG1vZGVsIHRvIHZpbSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIC8vIE1vdXNlIHNlbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgdmlzdWFsIGNoYXJhY3Rlcndpc2UuXG4gICAgICAgIHZhciBoZWFkT2Zmc2V0ID0gIWN1cnNvcklzQmVmb3JlKGhlYWQsIGFuY2hvcikgPyAtMSA6IDA7XG4gICAgICAgIHZhciBhbmNob3JPZmZzZXQgPSBjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpID8gLTEgOiAwO1xuICAgICAgICBoZWFkID0gb2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIGhlYWRPZmZzZXQpO1xuICAgICAgICBhbmNob3IgPSBvZmZzZXRDdXJzb3IoYW5jaG9yLCAwLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICB2aW0uc2VsID0ge1xuICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgIGhlYWQ6IGhlYWRcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPCcsIGN1cnNvck1pbihoZWFkLCBhbmNob3IpKTtcbiAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChoZWFkLCBhbmNob3IpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgIC8vIFJlc2V0IGxhc3RIUG9zIGlmIHNlbGVjdGlvbiB3YXMgbW9kaWZpZWQgYnkgc29tZXRoaW5nIG91dHNpZGUgb2YgdmltIG1vZGUgZS5nLiBieSBtb3VzZS5cbiAgICAgICAgdmltLmxhc3RIUG9zID0gY20uZ2V0Q3Vyc29yKCkuY2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFdyYXBwZXIgZm9yIHNwZWNpYWwga2V5cyBwcmVzc2VkIGluIGluc2VydCBtb2RlICovXG4gICAgZnVuY3Rpb24gSW5zZXJ0TW9kZUtleShrZXlOYW1lKSB7XG4gICAgICB0aGlzLmtleU5hbWUgPSBrZXlOYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogSGFuZGxlcyByYXcga2V5IGRvd24gZXZlbnRzIGZyb20gdGhlIHRleHQgYXJlYS5cbiAgICAqIC0gU2hvdWxkIG9ubHkgYmUgYWN0aXZlIGluIGluc2VydCBtb2RlLlxuICAgICogLSBGb3IgcmVjb3JkaW5nIGRlbGV0ZXMgaW4gaW5zZXJ0IG1vZGUuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBvbktleUV2ZW50VGFyZ2V0S2V5RG93bihlKSB7XG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIHZhciBsYXN0Q2hhbmdlID0gbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzO1xuICAgICAgdmFyIGtleU5hbWUgPSBDb2RlTWlycm9yLmtleU5hbWUoZSk7XG4gICAgICBpZiAoIWtleU5hbWUpIHsgcmV0dXJuOyB9XG4gICAgICBmdW5jdGlvbiBvbktleUZvdW5kKCkge1xuICAgICAgICBpZiAobGFzdENoYW5nZS5tYXliZVJlc2V0KSB7XG4gICAgICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzID0gW107XG4gICAgICAgICAgbGFzdENoYW5nZS5tYXliZVJlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzLnB1c2gobmV3IEluc2VydE1vZGVLZXkoa2V5TmFtZSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlOYW1lLmluZGV4T2YoJ0RlbGV0ZScpICE9IC0xIHx8IGtleU5hbWUuaW5kZXhPZignQmFja3NwYWNlJykgIT0gLTEpIHtcbiAgICAgICAgQ29kZU1pcnJvci5sb29rdXBLZXkoa2V5TmFtZSwgJ3ZpbS1pbnNlcnQnLCBvbktleUZvdW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBsYXN0IGVkaXQsIHdoaWNoIGluY2x1ZGVzIGV4YWN0bHkgMSBjb21tYW5kIGFuZCBhdCBtb3N0IDFcbiAgICAgKiBpbnNlcnQuIE9wZXJhdG9yIGFuZCBtb3Rpb24gY29tbWFuZHMgYXJlIHJlYWQgZnJvbSBsYXN0RWRpdElucHV0U3RhdGUsXG4gICAgICogd2hpbGUgYWN0aW9uIGNvbW1hbmRzIGFyZSByZWFkIGZyb20gbGFzdEVkaXRBY3Rpb25Db21tYW5kLlxuICAgICAqXG4gICAgICogSWYgcmVwZWF0Rm9ySW5zZXJ0IGlzIHRydWUsIHRoZW4gdGhlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnlcbiAgICAgKiBleGl0SW5zZXJ0TW9kZSB0byByZXBlYXQgdGhlIGluc2VydCBtb2RlIGNoYW5nZXMgdGhlIHVzZXIganVzdCBtYWRlLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGVudGVySW5zZXJ0TW9kZSBjYWxsIHdhcyBtYWRlIHdpdGggYSBjb3VudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXRMYXN0RWRpdChjbSwgdmltLCByZXBlYXQsIHJlcGVhdEZvckluc2VydCkge1xuICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgdmFyIGlzQWN0aW9uID0gISF2aW0ubGFzdEVkaXRBY3Rpb25Db21tYW5kO1xuICAgICAgdmFyIGNhY2hlZElucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgIGZ1bmN0aW9uIHJlcGVhdENvbW1hbmQoKSB7XG4gICAgICAgIGlmIChpc0FjdGlvbikge1xuICAgICAgICAgIGNvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NBY3Rpb24oY20sIHZpbSwgdmltLmxhc3RFZGl0QWN0aW9uQ29tbWFuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWFuZERpc3BhdGNoZXIuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZXBlYXRJbnNlcnQocmVwZWF0KSB7XG4gICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXMuY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCByZXBlYXQgY3cgaW4gZGVza3RvcCBWSU0gZG9lcyBub3QgcmVwZWF0XG4gICAgICAgICAgLy8gaW5zZXJ0IG1vZGUgY2hhbmdlcy4gV2lsbCBjb25mb3JtIHRvIHRoYXQgYmVoYXZpb3IuXG4gICAgICAgICAgcmVwZWF0ID0gIXZpbS5sYXN0RWRpdEFjdGlvbkNvbW1hbmQgPyAxIDogcmVwZWF0O1xuICAgICAgICAgIHZhciBjaGFuZ2VPYmplY3QgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgICAgICAgcmVwZWF0SW5zZXJ0TW9kZUNoYW5nZXMoY20sIGNoYW5nZU9iamVjdC5jaGFuZ2VzLCByZXBlYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aW0uaW5wdXRTdGF0ZSA9IHZpbS5sYXN0RWRpdElucHV0U3RhdGU7XG4gICAgICBpZiAoaXNBY3Rpb24gJiYgdmltLmxhc3RFZGl0QWN0aW9uQ29tbWFuZC5pbnRlcmxhY2VJbnNlcnRSZXBlYXQpIHtcbiAgICAgICAgLy8gbyBhbmQgTyByZXBlYXQgaGF2ZSB0byBiZSBpbnRlcmxhY2VkIHdpdGggaW5zZXJ0IHJlcGVhdHMgc28gdGhhdCB0aGVcbiAgICAgICAgLy8gaW5zZXJ0aW9ucyBhcHBlYXIgb24gc2VwYXJhdGUgbGluZXMgaW5zdGVhZCBvZiB0aGUgbGFzdCBsaW5lLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgcmVwZWF0Q29tbWFuZCgpO1xuICAgICAgICAgIHJlcGVhdEluc2VydCgxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFyZXBlYXRGb3JJbnNlcnQpIHtcbiAgICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgY3Vyc29yIHRvIGVuZCB1cCBhdCB0aGUgcmlnaHQgcGxhY2UuIElmIEkgaXNcbiAgICAgICAgICAvLyByZXBlYXRlZCBpbiBpbnNlcnQgbW9kZSByZXBlYXQsIGN1cnNvciB3aWxsIGJlIDEgaW5zZXJ0XG4gICAgICAgICAgLy8gY2hhbmdlIHNldCBsZWZ0IG9mIHdoZXJlIGl0IHNob3VsZCBiZS5cbiAgICAgICAgICByZXBlYXRDb21tYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwZWF0SW5zZXJ0KHJlcGVhdCk7XG4gICAgICB9XG4gICAgICB2aW0uaW5wdXRTdGF0ZSA9IGNhY2hlZElucHV0U3RhdGU7XG4gICAgICBpZiAodmltLmluc2VydE1vZGUgJiYgIXJlcGVhdEZvckluc2VydCkge1xuICAgICAgICAvLyBEb24ndCBleGl0IGluc2VydCBtb2RlIHR3aWNlLiBJZiByZXBlYXRGb3JJbnNlcnQgaXMgc2V0LCB0aGVuIHdlXG4gICAgICAgIC8vIHdlcmUgY2FsbGVkIGJ5IGFuIGV4aXRJbnNlcnRNb2RlIGNhbGwgbG93ZXIgb24gdGhlIHN0YWNrLlxuICAgICAgICBleGl0SW5zZXJ0TW9kZShjbSk7XG4gICAgICB9XG4gICAgICBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBlYXRJbnNlcnRNb2RlQ2hhbmdlcyhjbSwgY2hhbmdlcywgcmVwZWF0KSB7XG4gICAgICBmdW5jdGlvbiBrZXlIYW5kbGVyKGJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5nID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kc1tiaW5kaW5nXShjbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmluZGluZyhjbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgICAgdmFyIHZpc3VhbEJsb2NrID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLnZpc3VhbEJsb2NrO1xuICAgICAgaWYgKHZpc3VhbEJsb2NrKSB7XG4gICAgICAgIC8vIFNldCB1cCBibG9jayBzZWxlY3Rpb24gYWdhaW4gZm9yIHJlcGVhdGluZyB0aGUgY2hhbmdlcy5cbiAgICAgICAgc2VsZWN0Rm9ySW5zZXJ0KGNtLCBoZWFkLCB2aXN1YWxCbG9jayArIDEpO1xuICAgICAgICByZXBlYXQgPSBjbS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aDtcbiAgICAgICAgY20uc2V0Q3Vyc29yKGhlYWQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICBpZiAodmlzdWFsQmxvY2spIHtcbiAgICAgICAgICBjbS5zZXRDdXJzb3Iob2Zmc2V0Q3Vyc29yKGhlYWQsIGksIDApKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tqXTtcbiAgICAgICAgICBpZiAoY2hhbmdlIGluc3RhbmNlb2YgSW5zZXJ0TW9kZUtleSkge1xuICAgICAgICAgICAgQ29kZU1pcnJvci5sb29rdXBLZXkoY2hhbmdlLmtleU5hbWUsICd2aW0taW5zZXJ0Jywga2V5SGFuZGxlcik7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hhbmdlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oY2hhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gb2Zmc2V0Q3Vyc29yKHN0YXJ0LCAwLCBjaGFuZ2VbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShjaGFuZ2VbMF0sIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmlzdWFsQmxvY2spIHtcbiAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihoZWFkLCAwLCAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRWaW1HbG9iYWxTdGF0ZSgpO1xuICAgIHJldHVybiB2aW1BcGk7XG4gIH07XG4gIC8vIEluaXRpYWxpemUgVmltIGFuZCBtYWtlIGl0IGF2YWlsYWJsZSBhcyBhbiBBUEkuXG4gIENvZGVNaXJyb3IuVmltID0gVmltKCk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2QiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIkNvZGVNaXJyb3IiLCJQb3MiLCJ0cmFuc2Zvcm1DdXJzb3IiLCJjbSIsInJhbmdlIiwidmltIiwic3RhdGUiLCJpbnNlcnRNb2RlIiwiaGVhZCIsInNlbCIsInZpc3VhbEJsb2NrIiwibGluZSIsImZyb20iLCJhbmNob3IiLCJlbXB0eSIsImNoIiwiZGVmYXVsdEtleW1hcCIsImtleXMiLCJ0eXBlIiwidG9LZXlzIiwiY29udGV4dCIsImFjdGlvbiIsIm1vdGlvbiIsIm1vdGlvbkFyZ3MiLCJsaW5ld2lzZSIsInRvSnVtcGxpc3QiLCJmb3J3YXJkIiwid29yZEVuZCIsImJpZ1dvcmQiLCJpbmNsdXNpdmUiLCJleHBsaWNpdFJlcGVhdCIsInRvRmlyc3RDaGFyIiwicmVwZWF0T2Zmc2V0IiwiaXNFZGl0IiwiYWN0aW9uQXJncyIsImFmdGVyIiwibWF0Y2hJbmRlbnQiLCJzYW1lTGluZSIsIm9wZXJhdG9yIiwib3BlcmF0b3JBcmdzIiwiaW5kZW50UmlnaHQiLCJ0b0xvd2VyIiwib3BlcmF0b3JNb3Rpb25BcmdzIiwidmlzdWFsTGluZSIsInNob3VsZE1vdmVDdXJzb3IiLCJpbnNlcnRBdCIsImludGVybGFjZUluc2VydFJlcGVhdCIsImJsb2Nrd2lzZSIsImtlZXBTcGFjZXMiLCJyZXBsYWNlIiwiZnVsbExpbmUiLCJleGl0VmlzdWFsQmxvY2siLCJwb3NpdGlvbiIsImluY3JlYXNlIiwiYmFja3RyYWNrIiwidGV4dE9iamVjdElubmVyIiwic2VhcmNoQXJncyIsInF1ZXJ5U3JjIiwid2hvbGVXb3JkT25seSIsImRlZmF1bHRLZXltYXBMZW5ndGgiLCJsZW5ndGgiLCJkZWZhdWx0RXhDb21tYW5kTWFwIiwibmFtZSIsInNob3J0TmFtZSIsInBvc3NpYmx5QXN5bmMiLCJleGNsdWRlRnJvbUNvbW1hbmRIaXN0b3J5IiwiVmltIiwiZW50ZXJWaW1Nb2RlIiwic2V0T3B0aW9uIiwic2lnbmFsIiwibW9kZSIsIm9uIiwib25DdXJzb3JBY3Rpdml0eSIsIm1heWJlSW5pdFZpbVN0YXRlIiwiZ2V0SW5wdXRGaWVsZCIsImdldE9uUGFzdGVGbiIsImxlYXZlVmltTW9kZSIsIm9mZiIsImhpZ2hsaWdodFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJkZXRhY2hWaW1NYXAiLCJuZXh0Iiwia2V5TWFwIiwib3B0aW9ucyIsIiRjdXN0b21DdXJzb3IiLCJybUNsYXNzIiwiZ2V0V3JhcHBlckVsZW1lbnQiLCJhdHRhY2giLCJhdHRhY2hWaW1NYXAiLCJwcmV2IiwiY3VyT3AiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiYWRkQ2xhc3MiLCJkZWZpbmVPcHRpb24iLCJ2YWwiLCJnZXRPcHRpb24iLCJJbml0IiwidGVzdCIsImNtS2V5Iiwia2V5IiwidW5kZWZpbmVkIiwidmltS2V5IiwiY21LZXlUb1ZpbUtleSIsImNtZCIsInZpbUFwaSIsImZpbmRLZXkiLCJtb2RpZmllcnMiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJDbWQiLCJNb2QiLCJDYXBzTG9jayIsInNwZWNpYWxLZXlzIiwiRW50ZXIiLCJCYWNrc3BhY2UiLCJEZWxldGUiLCJJbnNlcnQiLCJjaGFyQXQiLCJwaWVjZXMiLCJzcGxpdCIsImxhc3RQaWVjZSIsImhhc0NoYXJhY3RlciIsImkiLCJwaWVjZSIsImlzVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJqb2luIiwib25QYXN0ZUZuIiwic2V0Q3Vyc29yIiwib2Zmc2V0Q3Vyc29yIiwiZ2V0Q3Vyc29yIiwiYWN0aW9ucyIsImVudGVySW5zZXJ0TW9kZSIsIm51bWJlclJlZ2V4Iiwid29yZENoYXJUZXN0IiwiaXNXb3JkQ2hhciIsImJpZ1dvcmRDaGFyVGVzdCIsIm1ha2VLZXlSYW5nZSIsInN0YXJ0Iiwic2l6ZSIsInB1c2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1cHBlckNhc2VBbHBoYWJldCIsImxvd2VyQ2FzZUFscGhhYmV0IiwibnVtYmVycyIsInZhbGlkTWFya3MiLCJjb25jYXQiLCJ2YWxpZFJlZ2lzdGVycyIsInVwcGVyQ2FzZUNoYXJzIiwiUmVnRXhwIiwiXyIsImlzTGluZSIsImZpcnN0TGluZSIsImxhc3RMaW5lIiwiaXNMb3dlckNhc2UiLCJrIiwiaXNNYXRjaGFibGVTeW1ib2wiLCJpbmRleE9mIiwiaXNOdW1iZXIiLCJpc1doaXRlU3BhY2VTdHJpbmciLCJpc0VuZE9mU2VudGVuY2VTeW1ib2wiLCJpbkFycmF5IiwiYXJyIiwiZGVmYXVsdFZhbHVlIiwiYWxpYXNlcyIsImNhbGxiYWNrIiwiRXJyb3IiLCJ2YWx1ZSIsImNmZyIsIm9wdGlvbiIsInNjb3BlIiwibG9jYWwiLCJjcmVhdGVDaXJjdWxhckp1bXBMaXN0IiwicG9pbnRlciIsInRhaWwiLCJidWZmZXIiLCJBcnJheSIsImFkZCIsIm9sZEN1ciIsIm5ld0N1ciIsImN1cnJlbnQiLCJjdXJNYXJrIiwidXNlTmV4dFNsb3QiLCJjdXJzb3IiLCJ0cmFzaE1hcmsiLCJjbGVhciIsInNldEJvb2ttYXJrIiwibWFya1BvcyIsImZpbmQiLCJjdXJzb3JFcXVhbCIsIm1vdmUiLCJvZmZzZXQiLCJtYXJrIiwiaW5jIiwib2xkUG9pbnRlciIsImNhY2hlZEN1cnNvciIsImNyZWF0ZUluc2VydE1vZGVDaGFuZ2VzIiwiYyIsImNoYW5nZXMiLCJleHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZSIsIk1hY3JvTW9kZVN0YXRlIiwibGF0ZXN0UmVnaXN0ZXIiLCJpc1BsYXlpbmciLCJpc1JlY29yZGluZyIsInJlcGxheVNlYXJjaFF1ZXJpZXMiLCJvblJlY29yZGluZ0RvbmUiLCJsYXN0SW5zZXJ0TW9kZUNoYW5nZXMiLCJwcm90b3R5cGUiLCJleGl0TWFjcm9SZWNvcmRNb2RlIiwibWFjcm9Nb2RlU3RhdGUiLCJ2aW1HbG9iYWxTdGF0ZSIsImVudGVyTWFjcm9SZWNvcmRNb2RlIiwicmVnaXN0ZXJOYW1lIiwicmVnaXN0ZXIiLCJyZWdpc3RlckNvbnRyb2xsZXIiLCJnZXRSZWdpc3RlciIsIm9wZW5EaWFsb2ciLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiYm90dG9tIiwiaW5wdXRTdGF0ZSIsIklucHV0U3RhdGUiLCJsYXN0RWRpdElucHV0U3RhdGUiLCJsYXN0RWRpdEFjdGlvbkNvbW1hbmQiLCJsYXN0SFBvcyIsImxhc3RIU1BvcyIsImxhc3RNb3Rpb24iLCJtYXJrcyIsImluc2VydE1vZGVSZXBlYXQiLCJ2aXN1YWxNb2RlIiwibGFzdFNlbGVjdGlvbiIsImxhc3RQYXN0ZWRUZXh0IiwicmVzZXRWaW1HbG9iYWxTdGF0ZSIsInNlYXJjaFF1ZXJ5Iiwic2VhcmNoSXNSZXZlcnNlZCIsImxhc3RTdWJzdGl0dXRlUmVwbGFjZVBhcnQiLCJqdW1wTGlzdCIsImxhc3RDaGFyYWN0ZXJTZWFyY2giLCJpbmNyZW1lbnQiLCJzZWxlY3RlZENoYXJhY3RlciIsIlJlZ2lzdGVyQ29udHJvbGxlciIsInNlYXJjaEhpc3RvcnlDb250cm9sbGVyIiwiSGlzdG9yeUNvbnRyb2xsZXIiLCJleENvbW1hbmRIaXN0b3J5Q29udHJvbGxlciIsIm9wdGlvbk5hbWUiLCJsYXN0SW5zZXJ0TW9kZUtleVRpbWVyIiwiYnVpbGRLZXlNYXAiLCJnZXRSZWdpc3RlckNvbnRyb2xsZXIiLCJyZXNldFZpbUdsb2JhbFN0YXRlXyIsImdldFZpbUdsb2JhbFN0YXRlXyIsIm1heWJlSW5pdFZpbVN0YXRlXyIsInN1cHByZXNzRXJyb3JMb2dnaW5nIiwiSW5zZXJ0TW9kZUtleSIsIm1hcCIsImxocyIsInJocyIsImN0eCIsImV4Q29tbWFuZERpc3BhdGNoZXIiLCJ1bm1hcCIsIm5vcmVtYXAiLCJ0b0N0eEFycmF5IiwiY3R4c1RvTWFwIiwiYWN0dWFsTGVuZ3RoIiwib3JpZ0xlbmd0aCIsIm1hcHBpbmciLCJzdWJzdHIiLCJuZXdNYXBwaW5nIiwiX21hcENvbW1hbmQiLCJtYXBwZWRDdHhzIiwiZmlsdGVyIiwiZWwiLCJtYXBjbGVhciIsInVzZXJLZXltYXAiLCJzbGljZSIsImNvbnRleHRzIiwiaiIsImRlZmluZUV4IiwicHJlZml4IiwiZnVuYyIsImV4Q29tbWFuZHMiLCJjb21tYW5kTWFwXyIsImhhbmRsZUtleSIsIm9yaWdpbiIsImNvbW1hbmQiLCJoYW5kbGVNYWNyb1JlY29yZGluZyIsImNsZWFySW5wdXRTdGF0ZSIsImxvZ0tleSIsImhhbmRsZUVzYyIsImV4aXRWaXN1YWxNb2RlIiwiZXhpdEluc2VydE1vZGUiLCJkb0tleVRvS2V5IiwibWF0Y2giLCJleGVjIiwic3Vic3RyaW5nIiwiaW5kZXgiLCJoYW5kbGVLZXlJbnNlcnRNb2RlIiwia2V5QnVmZmVyIiwia2V5c0FyZUNoYXJzIiwiY29tbWFuZERpc3BhdGNoZXIiLCJtYXRjaENvbW1hbmQiLCJ0aGlzTWF0Y2giLCJ3aW5kb3ciLCJzZXRUaW1lb3V0Iiwic2VsZWN0aW9ucyIsImxpc3RTZWxlY3Rpb25zIiwiaGVyZSIsInJlcGxhY2VSYW5nZSIsInBvcCIsImhhbmRsZUtleU5vbkluc2VydE1vZGUiLCJrZXlzTWF0Y2hlciIsIm1haW5LZXkiLCJvcGVyYXRvclNob3J0Y3V0IiwicHVzaFJlcGVhdERpZ2l0Iiwib3BlcmF0aW9uIiwiaXNWaW1PcCIsInByb2Nlc3NDb21tYW5kIiwiZSIsImNvbnNvbGUiLCJoYW5kbGVFeCIsImlucHV0IiwiZGVmaW5lTW90aW9uIiwiZGVmaW5lQWN0aW9uIiwiZGVmaW5lT3BlcmF0b3IiLCJtYXBDb21tYW5kIiwiZGVmaW5lUmVnaXN0ZXIiLCJwcmVmaXhSZXBlYXQiLCJtb3Rpb25SZXBlYXQiLCJuIiwiZ2V0UmVwZWF0IiwicmVwZWF0IiwicGFyc2VJbnQiLCJyZWFzb24iLCJSZWdpc3RlciIsInRleHQiLCJpbnNlcnRNb2RlQ2hhbmdlcyIsInNlYXJjaFF1ZXJpZXMiLCJzZXRUZXh0IiwicHVzaFRleHQiLCJwdXNoSW5zZXJ0TW9kZUNoYW5nZXMiLCJwdXNoU2VhcmNoUXVlcnkiLCJxdWVyeSIsInRvU3RyaW5nIiwicmVnaXN0ZXJzIiwidW5uYW1lZFJlZ2lzdGVyIiwiaXNWYWxpZFJlZ2lzdGVyIiwic2hpZnROdW1lcmljUmVnaXN0ZXJzXyIsImFwcGVuZCIsImhpc3RvcnlCdWZmZXIiLCJpdGVyYXRvciIsImluaXRpYWxQcmVmaXgiLCJuZXh0TWF0Y2giLCJ1cCIsImRpciIsImVsZW1lbnQiLCJwdXNoSW5wdXQiLCJzcGxpY2UiLCJyZXNldCIsIm1hdGNoZXMiLCJjb21tYW5kTWF0Y2hlcyIsImZ1bGwiLCJwYXJ0aWFsIiwiYmVzdE1hdGNoIiwiY2hhcmFjdGVyIiwibGFzdENoYXIiLCJyZXBlYXRPdmVycmlkZSIsInByb2Nlc3NNb3Rpb24iLCJwcm9jZXNzT3BlcmF0b3IiLCJwcm9jZXNzT3BlcmF0b3JNb3Rpb24iLCJwcm9jZXNzQWN0aW9uIiwicHJvY2Vzc1NlYXJjaCIsInByb2Nlc3NFeCIsImNvcHlBcmdzIiwiZXZhbElucHV0IiwidXBkYXRlQ21TZWxlY3Rpb24iLCJyZXBlYXRJc0V4cGxpY2l0IiwicmVjb3JkTGFzdEVkaXQiLCJnZXRTZWFyY2hDdXJzb3IiLCJnZXRTZWFyY2hTdGF0ZSIsInNldFJldmVyc2VkIiwicHJvbXB0UHJlZml4Iiwib3JpZ2luYWxRdWVyeSIsImdldFF1ZXJ5Iiwib3JpZ2luYWxTY3JvbGxQb3MiLCJnZXRTY3JvbGxJbmZvIiwiaGFuZGxlUXVlcnkiLCJpZ25vcmVDYXNlIiwic21hcnRDYXNlIiwidXBkYXRlU2VhcmNoUXVlcnkiLCJzaG93Q29uZmlybSIsIm9uUHJvbXB0Q2xvc2UiLCJzY3JvbGxUbyIsImxlZnQiLCJ0b3AiLCJsb2dTZWFyY2hRdWVyeSIsIm9uUHJvbXB0S2V5VXAiLCJjbG9zZSIsImtleU5hbWUiLCJ0YXJnZXQiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsIk1hdGgiLCJtaW4iLCJwYXJzZWRRdWVyeSIsInNjcm9sbEludG9WaWV3IiwiZmluZE5leHQiLCJjbGVhclNlYXJjaEhpZ2hsaWdodCIsIm9uUHJvbXB0S2V5RG93biIsImVfc3RvcCIsImZvY3VzIiwic2hpZnQiLCJzaG93UHJvbXB0Iiwib25DbG9zZSIsImRlc2MiLCJvbktleVVwIiwib25LZXlEb3duIiwid29yZCIsImV4cGFuZFdvcmRVbmRlckN1cnNvciIsImlzS2V5d29yZCIsImdldExpbmUiLCJlbmQiLCJlc2NhcGVSZWdleCIsImV4QXJncyIsInNlbGVjdFZhbHVlT25PcGVuIiwib3JpZ0hlYWQiLCJjb3B5Q3Vyc29yIiwiY2xpcEN1cnNvclRvQ29udGVudCIsIm9yaWdBbmNob3IiLCJvbGRIZWFkIiwib2xkQW5jaG9yIiwibmV3SGVhZCIsIm5ld0FuY2hvciIsIm5vUmVwZWF0IiwibW90aW9uUmVzdWx0IiwibW90aW9ucyIsInJlY29yZEp1bXBQb3NpdGlvbiIsIkluZmluaXR5IiwidXBkYXRlTWFyayIsImN1cnNvcklzQmVmb3JlIiwibGFzdFNlbCIsImxpbmVPZmZzZXQiLCJhYnMiLCJjaE9mZnNldCIsImN1clN0YXJ0IiwiY3VyRW5kIiwiY21TZWwiLCJjdXJzb3JNaW4iLCJjdXJzb3JNYXgiLCJtYWtlQ21TZWxlY3Rpb24iLCJyYW5nZXMiLCJsaW5lTGVuZ3RoIiwidG1wIiwiZXhwYW5kU2VsZWN0aW9uVG9MaW5lIiwiY2xpcFRvTGluZSIsImV4Y2x1c2l2ZSIsInNldFNlbGVjdGlvbnMiLCJwcmltYXJ5Iiwib3BlcmF0b3JNb3ZlVG8iLCJvcGVyYXRvcnMiLCJhY3Rpb25Db21tYW5kIiwibW92ZVRvVG9wTGluZSIsIl9oZWFkIiwiZ2V0VXNlclZpc2libGVMaW5lcyIsImZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIiLCJtb3ZlVG9NaWRkbGVMaW5lIiwiZmxvb3IiLCJtb3ZlVG9Cb3R0b21MaW5lIiwiZXhwYW5kVG9MaW5lIiwiX2NtIiwiY3VyIiwiaXNSZXZlcnNlZCIsImhpZ2hsaWdodFNlYXJjaE1hdGNoZXMiLCJmaW5kQW5kU2VsZWN0TmV4dEluY2x1c2l2ZSIsInByZXZJbnB1dFN0YXRlIiwiZmluZE5leHRGcm9tQW5kVG9JbmNsdXNpdmUiLCJ0byIsInN1Yk1vZGUiLCJnb1RvTWFyayIsInBvcyIsImdldE1hcmtQb3MiLCJtb3ZlVG9PdGhlckhpZ2hsaWdodGVkRW5kIiwianVtcFRvTWFyayIsImJlc3QiLCJpc1dyb25nRGlyZWN0aW9uIiwiZXF1YWwiLCJiZXR3ZWVuIiwiY3Vyc29ySXNCZXR3ZWVuIiwibW92ZUJ5Q2hhcmFjdGVycyIsIm1vdmVCeUxpbmVzIiwiZW5kQ2giLCJtb3ZlQnlEaXNwbGF5TGluZXMiLCJtb3ZlQnlTY3JvbGwiLCJtb3ZlVG9Db2x1bW4iLCJtb3ZlVG9Fb2wiLCJmaXJzdCIsImxhc3QiLCJwb3NWIiwiZmluZFBvc1YiLCJoYXNNYXJrZWRUZXh0IiwibW92ZVRvU3RhcnRPZkxpbmUiLCJjaGFyQ29vcmRzIiwicmVzIiwiaGl0U2lkZSIsImxhc3RDaGFyQ29vcmRzIiwiZ29hbENvb3JkcyIsImNvb3Jkc0NoYXIiLCJyZXNDb29yZHMiLCJtb3ZlQnlQYWdlIiwibW92ZUJ5UGFyYWdyYXBoIiwiZmluZFBhcmFncmFwaCIsIm1vdmVCeVNlbnRlbmNlIiwiZmluZFNlbnRlbmNlIiwic2Nyb2xsYm94IiwiY2xpZW50SGVpZ2h0IiwiZGVmYXVsdFRleHRIZWlnaHQiLCJvcmlnIiwiZGVzdCIsIm1vdmVCeVdvcmRzIiwibW92ZVRvV29yZCIsIm1vdmVUaWxsQ2hhcmFjdGVyIiwibW92ZVRvQ2hhcmFjdGVyIiwicmVjb3JkTGFzdENoYXJhY3RlclNlYXJjaCIsIm1vdmVUb1N5bWJvbCIsImZpbmRTeW1ib2wiLCJtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIiLCJtb3ZlVG9NYXRjaGVkU3ltYm9sIiwibGluZVRleHQiLCJzeW1ib2wiLCJzdHlsZSIsImdldFRva2VuVHlwZUF0IiwicmUiLCJtYXRjaGVkIiwiZmluZE1hdGNoaW5nQnJhY2tldCIsImJyYWNrZXRSZWdleCIsIm1vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50IiwibGluZU51bSIsIm1vdmVUb1N0YXJ0T2ZEaXNwbGF5TGluZSIsImV4ZWNDb21tYW5kIiwibW92ZVRvRW5kT2ZEaXNwbGF5TGluZSIsInN0aWNreSIsInRleHRPYmplY3RNYW5pcHVsYXRpb24iLCJtaXJyb3JlZFBhaXJzIiwic2VsZlBhaXJlZCIsInNlbGVjdENvbXBhbmlvbk9iamVjdCIsImZpbmRCZWdpbm5pbmdBbmRFbmQiLCJleHBhbmRUYWdVbmRlckN1cnNvciIsImV4cGFuZFNlbGVjdGlvbiIsInJlcGVhdExhc3RDaGFyYWN0ZXJTZWFyY2giLCJsYXN0U2VhcmNoIiwibW92ZUgiLCJmbiIsImZpbGxBcnJheSIsInRpbWVzIiwiY2hhbmdlIiwiYXJncyIsImZpbmFsSGVhZCIsImdldFJhbmdlIiwibGFzdFN0YXRlIiwicHJldkxpbmVFbmQiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJ3YXNMYXN0TGluZSIsImNvbW1hbmRzIiwibmV3bGluZUFuZEluZGVudCIsInNldFNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsInJlcGxhY2VTZWxlY3Rpb24iLCJyZXBsYWNlbWVudCIsInJlcGxhY2VTZWxlY3Rpb25zIiwiaW5kZW50Iiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImluZGVudExpbmUiLCJpbmRlbnRBdXRvIiwiX2FyZ3MiLCJjaGFuZ2VDYXNlIiwiZ2V0U2VsZWN0aW9ucyIsInN3YXBwZWQiLCJ0b1N3YXAiLCJ0b1VwcGVyQ2FzZSIsInlhbmsiLCJlbmRQb3MiLCJqdW1wTGlzdFdhbGsiLCJzY3JvbGwiLCJsaW5lSGVpZ2h0IiwiZGVsdGEiLCJuZXdQb3MiLCJjdXJzb3JDb29yZHMiLCJjZWlsIiwibmV3Qm90dG9tIiwic2Nyb2xsVG9DdXJzb3IiLCJoZWlnaHQiLCJ5IiwicmVwbGF5TWFjcm8iLCJleGVjdXRlTWFjcm9SZWdpc3RlciIsInRvZ2dsZU92ZXJ3cml0ZSIsIm92ZXJ3cml0ZSIsIm1heCIsImdldExhc3RFZGl0UG9zIiwib25DaGFuZ2UiLCJvbktleUV2ZW50VGFyZ2V0S2V5RG93biIsInNlbGVjdEZvckluc2VydCIsInRvZ2dsZVZpc3VhbE1vZGUiLCJyZXNlbGVjdExhc3RTZWxlY3Rpb24iLCJfYWN0aW9uQXJncyIsInVwZGF0ZUxhc3RTZWxlY3Rpb24iLCJhbmNob3JNYXJrIiwiaGVhZE1hcmsiLCJqb2luTGluZXMiLCJmaW5hbENoIiwiY3VyRmluYWxQb3MiLCJuZXdMaW5lQW5kRW50ZXJJbnNlcnRNb2RlIiwibmV3bGluZUZuIiwibmV3bGluZUFuZEluZGVudENvbnRpbnVlQ29tbWVudCIsInBhc3RlIiwidGFiU2l6ZSIsIndoaXRlc3BhY2VMZW5ndGgiLCJzdHIiLCJ0YWJzIiwic3BhY2VzIiwiY3VycmVudExpbmUiLCJjaG9tcGVkVGV4dCIsIndhc0Nob21wZWQiLCJmaXJzdEluZGVudCIsIndzcGFjZSIsIm5ld0luZGVudCIsInF1b3RpZW50IiwiY3VyUG9zRmluYWwiLCJpZHgiLCJsYXN0U2VsZWN0aW9uQ3VyRW5kIiwic2VsZWN0ZWRBcmVhIiwiZ2V0U2VsZWN0ZWRBcmVhUmFuZ2UiLCJzZWxlY3RlZFRleHQiLCJlbXB0eVN0cmluZ3MiLCJzZWxlY3RCbG9jayIsInBvc0Zyb21JbmRleCIsImluZGV4RnJvbVBvcyIsImxhc3RDaCIsImV4dGVuZExpbmVUb0NvbHVtbiIsInVuZG8iLCJyZXBlYXRGbiIsInJlZG8iLCJzZXRSZWdpc3RlciIsInNldE1hcmsiLCJtYXJrTmFtZSIsInJlcGxhY2VXaXRoIiwicmVwbGFjZVRvIiwicmVwbGFjZVdpdGhTdHIiLCJpbmNyZW1lbnROdW1iZXJUb2tlbiIsImxpbmVTdHIiLCJudW1iZXJTdHIiLCJiYXNlU3RyIiwiZGlnaXRzIiwiYmFzZSIsIm51bWJlciIsInplcm9QYWRkaW5nIiwicmVwZWF0TGFzdEVkaXQiLCJpbmNsdWRlTGluZUJyZWFrIiwibWF4Q2giLCJyZXQiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJvZmZzZXRMaW5lIiwib2Zmc2V0Q2giLCJjb21tYW5kTWF0Y2giLCJwcmVzc2VkIiwibWFwcGVkIiwicHJlZml4TGVuIiwicHJlc3NlZFByZWZpeCIsIm1hcHBlZFByZWZpeCIsImN1cjEiLCJjdXIyIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJjYWxsIiwiY3VyMyIsImN1cjFiZWZvcmUyIiwiY3VyMmJlZm9yZTMiLCJ0cmltIiwicyIsImNvbHVtbiIsImNsaXBQb3MiLCJpc0NsaXBwZWQiLCJjdXJIZWFkIiwicHJpbUluZGV4IiwiZ2V0SW5kZXgiLCJ3YXNDbGlwcGVkIiwiYmFzZUNoIiwiaGVhZENoIiwibmV3RGlyIiwibGluZUhlYWQiLCJhdEFuY2hvciIsImF0SGVhZCIsImdldEN1cnJlbnRTZWxlY3RlZEFyZWFSYW5nZSIsImdldExhc3RTZWxlY3RlZEFyZWFSYW5nZSIsImJsb2NrIiwid2lkdGgiLCJoZWFkT2Zmc2V0IiwiYW5jaG9yT2Zmc2V0IiwiZnJvbUNoIiwidG9DaCIsImdldEhlYWQiLCJtb3ZlSGVhZCIsInNlbGVjdGlvbiIsImxpbmVzIiwiZmlyc3ROb25XUyIsInNlYXJjaCIsIl9mb3J3YXJkIiwibm9TeW1ib2wiLCJ3b3JkU3RhcnQiLCJmaW5kTWF0Y2hpbmdUYWciLCJmaW5kRW5jbG9zaW5nVGFnIiwidGFncyIsIm9wZW4iLCJzeW1ib2xUb01vZGUiLCJmaW5kU3ltYm9sTW9kZXMiLCJicmFja2V0IiwiaXNDb21wbGV0ZSIsIm5leHRDaCIsInN5bWIiLCJkZXB0aCIsInJldmVyc2VTeW1iIiwic2VjdGlvbiIsImluaXQiLCJjdXJNb3ZlVGhyb3VnaCIsImNvbW1lbnQiLCJmb3VuZCIsIm1ldGhvZCIsInByZXByb2Nlc3MiLCJ0b2tlbiIsImxpbmVDb3VudCIsImN1ckNoIiwibGluZUxlbiIsImZpbmRXb3JkIiwiZW1wdHlMaW5lSXNXb3JkIiwiY2hhclRlc3RzIiwic3RvcCIsImZvdW5kV29yZCIsIndvcmRzIiwiZW9kQ2giLCJzaG9ydENpcmN1aXQiLCJmaXJzdFdvcmQiLCJsYXN0V29yZCIsImtlZXBIUG9zIiwicmV0dmFsIiwiY2hhcklkeEluTGluZSIsImluY2x1ZGVDaGFyIiwibGFzdEluZGV4T2YiLCJpc0VtcHR5IiwiaXNCb3VuZGFyeSIsImFueSIsInN0YXJ0U3RhdGUiLCJuZXh0Q2hhciIsImxuIiwiY3VyciIsImxhc3RfdmFsaWQiLCJza2lwX2VtcHR5X2xpbmVzIiwicmV2ZXJzZSIsImN1cnJfaW5kZXgiLCJicmFja2V0UmVnZXhwIiwib3BlblN5bSIsImN1ckNoYXIiLCJzY2FuRm9yQnJhY2tldCIsImNoYXJzIiwibGVuIiwiZmlyc3RJbmRleCIsIlNlYXJjaFN0YXRlIiwic2V0UXVlcnkiLCJnZXRPdmVybGF5Iiwic2VhcmNoT3ZlcmxheSIsInNldE92ZXJsYXkiLCJvdmVybGF5IiwicmV2ZXJzZWQiLCJnZXRTY3JvbGxiYXJBbm5vdGF0ZSIsImFubm90YXRlIiwic2V0U2Nyb2xsYmFyQW5ub3RhdGUiLCJzZWFyY2hTdGF0ZV8iLCJzcGxpdEJ5U2xhc2giLCJhcmdTdHJpbmciLCJzcGxpdEJ5U2VwYXJhdG9yIiwiZmluZFVuZXNjYXBlZFNsYXNoZXMiLCJmaW5kVW5lc2NhcGVkU2VwYXJhdG9ycyIsInNlcGFyYXRvciIsInNsYXNoZXMiLCJ0b2tlbnMiLCJlc2NhcGVOZXh0Q2hhciIsInRyYW5zbGF0ZVJlZ2V4Iiwic3BlY2lhbHMiLCJ1bmVzY2FwZSIsIm91dCIsInNwZWNpYWxDb21lc05leHQiLCJjaGFyVW5lc2NhcGVzIiwidHJhbnNsYXRlUmVnZXhSZXBsYWNlIiwidW5lc2NhcGVzIiwidW5lc2NhcGVSZWdleFJlcGxhY2UiLCJzdHJlYW0iLCJTdHJpbmdTdHJlYW0iLCJvdXRwdXQiLCJlb2wiLCJwZWVrIiwibWF0Y2hlciIsInBhcnNlUXVlcnkiLCJsYXN0U2VhcmNoUmVnaXN0ZXIiLCJyZWdleFBhcnQiLCJmb3JjZUlnbm9yZUNhc2UiLCJmbGFnc1BhcnQiLCJyZWdleHAiLCJkb20iLCJjcmVhdGVFbGVtZW50IiwiYSIsIm5vZGVUeXBlIiwiYXBwZW5kQ2hpbGQiLCJPYmplY3QiLCJzZXRBdHRyaWJ1dGUiLCJ0ZW1wbGF0ZSIsInByZSIsIiRjb2xvciIsIm9wZW5Ob3RpZmljYXRpb24iLCJkdXJhdGlvbiIsImFsZXJ0IiwiaW5uZXJUZXh0IiwibWFrZVByb21wdCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCIkZm9udEZhbWlseSIsIiR3aGl0ZVNwYWNlIiwiYXV0b2NvcnJlY3QiLCJhdXRvY2FwaXRhbGl6ZSIsInNwZWxsY2hlY2siLCJzaG9ydFRleHQiLCJ0ZXh0Q29udGVudCIsInByb21wdCIsInJlZ2V4RXF1YWwiLCJyMSIsInIyIiwicHJvcHMiLCJyYXdRdWVyeSIsInNvdXJjZSIsIm1hdGNoU29sIiwic29sIiwic2tpcFRvRW5kIiwiYmFja1VwIiwic2VhcmNoU3RhdGUiLCJyZW1vdmVPdmVybGF5IiwiYWRkT3ZlcmxheSIsInNob3dNYXRjaGVzT25TY3JvbGxiYXIiLCJsYXN0RW5kUG9zIiwiaXNJblJhbmdlIiwic2Nyb2xsSW5mbyIsIm9jY2x1ZGVUb2xlcmFuY2VUb3AiLCJvY2NsdWRlVG9sZXJhbmNlQm90dG9tIiwiYm90dG9tWSIsImRvbmUiLCJkb2MiLCJoaXN0b3J5IiwiRXhDb21tYW5kRGlzcGF0Y2hlciIsImJ1aWxkQ29tbWFuZE1hcF8iLCJvcHRfcGFyYW1zIiwidGhhdCIsIl9wcm9jZXNzQ29tbWFuZCIsImNvbW1hbmRIaXN0b3J5UmVnaXN0ZXIiLCJwcmV2aW91c0NvbW1hbmQiLCJpbnB1dFN0cmVhbSIsInBhcmFtcyIsInBhcnNlSW5wdXRfIiwiY29tbWFuZE5hbWUiLCJtYXRjaENvbW1hbmRfIiwicGFyc2VDb21tYW5kQXJnc18iLCJ0b0lucHV0IiwicmVzdWx0IiwiZWF0V2hpbGUiLCJlYXQiLCJsaW5lRW5kIiwicGFyc2VMaW5lU3BlY18iLCJudW1iZXJNYXRjaCIsInBhcnNlTGluZVNwZWNPZmZzZXRfIiwib2Zmc2V0TWF0Y2giLCJkZWxpbSIsImFyZ0RlbGltaXRlciIsInVzZXIiLCJ1bnNoaWZ0IiwiY29sb3JzY2hlbWUiLCJtYXBBcmdzIiwiaW1hcCIsIm5tYXAiLCJ2bWFwIiwic2V0Iiwic2V0QXJncyIsInNldENmZyIsImV4cHIiLCJmb3JjZUdldCIsIm9wdGlvbklzQm9vbGVhbiIsIm9sZFZhbHVlIiwibWVzc2FnZSIsInNldE9wdGlvblJldHVybiIsInNldGxvY2FsIiwic2V0Z2xvYmFsIiwicmVnQXJncyIsInJlZ0luZm8iLCJzb3J0IiwidW5pcXVlIiwicGF0dGVybiIsInBhcnNlQXJncyIsImVhdFNwYWNlIiwib3B0cyIsImRlY2ltYWwiLCJoZXgiLCJvY3RhbCIsImVyciIsImxpbmVTdGFydCIsInJhZGl4IiwibnVtUGFydCIsInRleHRQYXJ0IiwibWF0Y2hQYXJ0IiwiY29tcGFyZUZuIiwiYiIsImFudW0iLCJibnVtIiwiY29tcGFyZVBhdHRlcm5GbiIsInRleHRPbGQiLCJ2Z2xvYmFsIiwiZ2xvYmFsIiwiaW52ZXJ0ZWQiLCJtYXRjaGVkTGluZXMiLCJnZXRMaW5lSGFuZGxlIiwibmV4dENvbW1hbmQiLCJnZXRMaW5lTnVtYmVyIiwic3Vic3RpdHV0ZSIsInJlcGxhY2VQYXJ0IiwidHJhaWxpbmciLCJjb3VudCIsImNvbmZpcm0iLCJzdGFydFBvcyIsImRvUmVwbGFjZSIsIndyaXRlIiwic2F2ZSIsIm5vaGxzZWFyY2giLCJkZWxtYXJrcyIsInN5bSIsInN0YXJ0TWFyayIsImZpbmlzaE1hcmsiLCJjaGFyQ29kZUF0IiwiZmluaXNoIiwic2VhcmNoQ3Vyc29yIiwiZXhNb2RlIiwibGFzdFBvcyIsIm1vZGlmaWVkTGluZU51bWJlciIsImpvaW5lZCIsInJlcGxhY2VBbGwiLCJuZXdUZXh0IiwidW5tb2RpZmllZExpbmVOdW1iZXIiLCJmaW5kTmV4dFZhbGlkTWF0Y2giLCJsYXN0TWF0Y2hUbyIsIl92YWx1ZSIsInNhdmVkQ2FsbGJhY2siLCJkZXRhY2giLCJpbnNlcnRNb2RlQ2hhbmdlUmVnaXN0ZXIiLCJsYXN0Q2hhbmdlIiwibG9nSW5zZXJ0TW9kZUNoYW5nZSIsImV4dHJhIiwiZmFsbHRocm91Z2giLCJpbWMiLCJyZXBlYXRJbnNlcnRNb2RlQ2hhbmdlcyIsImNoYW5nZU9iaiIsImlnbm9yZUNvdW50Iiwic2VsZWN0aW9uQ291bnQiLCJtYXliZVJlc2V0IiwiaGFuZGxlRXh0ZXJuYWxTZWxlY3Rpb24iLCJzb21ldGhpbmdTZWxlY3RlZCIsIm9uS2V5Rm91bmQiLCJsb29rdXBLZXkiLCJyZXBlYXRGb3JJbnNlcnQiLCJpc0FjdGlvbiIsImNhY2hlZElucHV0U3RhdGUiLCJyZXBlYXRDb21tYW5kIiwicmVwZWF0SW5zZXJ0IiwiY2hhbmdlT2JqZWN0Iiwia2V5SGFuZGxlciIsImJpbmRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/codemirror/keymap/vim.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/codemirror/keymap/vim.js");
/******/ 	
/******/ })()
;