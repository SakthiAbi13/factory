/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/raphael/raphael.js":
/*!*********************************************************!*\
  !*** ./resources/assets/vendor/libs/raphael/raphael.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// ┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐ \\\\\n// │ Raphaël 2.3.0 - JavaScript Vector Library                                                             │ \\\\\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\n// │ Copyright © 2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                       │ \\\\\n// │ Copyright © 2008-2016 Sencha Labs (http://sencha.com)                                                 │ \\\\\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\n// │ Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license.│ \\\\\n// └───────────────────────────────────────────────────────────────────────────────────────────────────────┘ \\\\\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(window, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __nested_webpack_require_1989__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1989__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __nested_webpack_require_1989__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __nested_webpack_require_1989__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __nested_webpack_require_1989__.d = function (exports, name, getter) {\n        /******/\n        if (!__nested_webpack_require_1989__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __nested_webpack_require_1989__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __nested_webpack_require_1989__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __nested_webpack_require_1989__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __nested_webpack_require_1989__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __nested_webpack_require_1989__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __nested_webpack_require_1989__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __nested_webpack_require_1989__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __nested_webpack_require_1989__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __nested_webpack_require_1989__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __nested_webpack_require_1989__(__nested_webpack_require_1989__.s = \"./dev/raphael.amd.js\");\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ({\n      /***/\n      \"./dev/raphael.amd.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.amd.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelAmdJs(module, exports, __nested_webpack_require_6928__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_6928__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\"), __nested_webpack_require_6928__(\n        /*! ./raphael.svg */\n        \"./dev/raphael.svg.js\"), __nested_webpack_require_6928__(\n        /*! ./raphael.vml */\n        \"./dev/raphael.vml.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          return R;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.core.js\":\n      /*!*****************************!*\\\n        !*** ./dev/raphael.core.js ***!\n        \\*****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelCoreJs(module, exports, __nested_webpack_require_7829__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_7829__(\n        /*! eve */\n        \"./node_modules/eve-raphael/eve.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {\n          /*\\\n           * Raphael\n           [ method ]\n           **\n           * Creates a canvas object on which to draw.\n           * You must do this first, as all future calls to drawing methods\n           * from this instance will be bound to this canvas.\n           > Parameters\n           **\n           - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n           - width (number)\n           - height (number)\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - x (number)\n           - y (number)\n           - width (number)\n           - height (number)\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.\n           = (object) @Paper\n           > Usage\n           | // Each of the following examples create a canvas\n           | // that is 320px wide by 200px high.\n           | // Canvas is created at the viewport’s 10,50 coordinate.\n           | var paper = Raphael(10, 50, 320, 200);\n           | // Canvas is created at the top left corner of the #notepad element\n           | // (or its top right corner in dir=\"rtl\" elements)\n           | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n           | // Same as above\n           | var paper = Raphael(\"notepad\", 320, 200);\n           | // Image dump\n           | var set = Raphael([\"notepad\", 320, 200, {\n           |     type: \"rect\",\n           |     x: 10,\n           |     y: 10,\n           |     width: 25,\n           |     height: 25,\n           |     stroke: \"#f00\"\n           | }, {\n           |     type: \"text\",\n           |     x: 30,\n           |     y: 40,\n           |     text: \"Dump\"\n           | }]);\n          \\*/\n          function R(first) {\n            if (R.is(first, \"function\")) {\n              return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n            } else if (R.is(first, array)) {\n              return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n            } else {\n              var args = Array.prototype.slice.call(arguments, 0);\n\n              if (R.is(args[args.length - 1], \"function\")) {\n                var f = args.pop();\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n                  f.call(R._engine.create[apply](R, args));\n                });\n              } else {\n                return R._engine.create[apply](R, arguments);\n              }\n            }\n          }\n\n          R.version = \"2.3.0\";\n          R.eve = eve;\n\n          var loaded,\n              separator = /[, ]+/,\n              elements = {\n            circle: 1,\n            rect: 1,\n            path: 1,\n            ellipse: 1,\n            text: 1,\n            image: 1\n          },\n              formatrg = /\\{(\\d+)\\}/g,\n              proto = \"prototype\",\n              has = \"hasOwnProperty\",\n              g = {\n            doc: document,\n            win: window\n          },\n              oldRaphael = {\n            was: Object.prototype[has].call(g.win, \"Raphael\"),\n            is: g.win.Raphael\n          },\n              Paper = function Paper() {\n            /*\\\n             * Paper.ca\n             [ property (object) ]\n             **\n             * Shortcut for @Paper.customAttributes\n            \\*/\n\n            /*\\\n             * Paper.customAttributes\n             [ property (object) ]\n             **\n             * If you have a set of attributes that you would like to represent\n             * as a function of some number you can do it easily with custom attributes:\n             > Usage\n             | paper.customAttributes.hue = function (num) {\n             |     num = num % 1;\n             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\n             | };\n             | // Custom attribute “hue” will change fill\n             | // to be given hue with fixed saturation and brightness.\n             | // Now you can use it like this:\n             | var c = paper.circle(10, 10, 10).attr({hue: .45});\n             | // or even like this:\n             | c.animate({hue: 1}, 1e3);\n             |\n             | // You could also create custom attribute\n             | // with multiple parameters:\n             | paper.customAttributes.hsb = function (h, s, b) {\n             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\n             | };\n             | c.attr({hsb: \"0.5 .8 1\"});\n             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\n            \\*/\n            this.ca = this.customAttributes = {};\n          },\n              paperproto,\n              appendChild = \"appendChild\",\n              apply = \"apply\",\n              concat = \"concat\",\n              //taken from Modernizr touch test: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js#L40\n          supportsTouch = 'ontouchstart' in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,\n              E = \"\",\n              S = \" \",\n              Str = String,\n              split = \"split\",\n              events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\n              touchMap = {\n            mousedown: \"touchstart\",\n            mousemove: \"touchmove\",\n            mouseup: \"touchend\"\n          },\n              lowerCase = Str.prototype.toLowerCase,\n              math = Math,\n              mmax = math.max,\n              mmin = math.min,\n              abs = math.abs,\n              pow = math.pow,\n              PI = math.PI,\n              nu = \"number\",\n              string = \"string\",\n              array = \"array\",\n              toString = \"toString\",\n              fillString = \"fill\",\n              objectToString = Object.prototype.toString,\n              paper = {},\n              push = \"push\",\n              ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\n              colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n              isnan = {\n            \"NaN\": 1,\n            \"Infinity\": 1,\n            \"-Infinity\": 1\n          },\n              bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n              round = math.round,\n              setAttribute = \"setAttribute\",\n              toFloat = parseFloat,\n              toInt = parseInt,\n              upperCase = Str.prototype.toUpperCase,\n              availableAttrs = R._availableAttrs = {\n            \"arrow-end\": \"none\",\n            \"arrow-start\": \"none\",\n            blur: 0,\n            \"clip-rect\": \"0 0 1e9 1e9\",\n            cursor: \"default\",\n            cx: 0,\n            cy: 0,\n            fill: \"#fff\",\n            \"fill-opacity\": 1,\n            font: '10px \"Arial\"',\n            \"font-family\": '\"Arial\"',\n            \"font-size\": \"10\",\n            \"font-style\": \"normal\",\n            \"font-weight\": 400,\n            gradient: 0,\n            height: 0,\n            href: \"http://raphaeljs.com/\",\n            \"letter-spacing\": 0,\n            opacity: 1,\n            path: \"M0,0\",\n            r: 0,\n            rx: 0,\n            ry: 0,\n            src: \"\",\n            stroke: \"#000\",\n            \"stroke-dasharray\": \"\",\n            \"stroke-linecap\": \"butt\",\n            \"stroke-linejoin\": \"butt\",\n            \"stroke-miterlimit\": 0,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            target: \"_blank\",\n            \"text-anchor\": \"middle\",\n            title: \"Raphael\",\n            transform: \"\",\n            width: 0,\n            x: 0,\n            y: 0,\n            \"class\": \"\"\n          },\n              availableAnimAttrs = R._availableAnimAttrs = {\n            blur: nu,\n            \"clip-rect\": \"csv\",\n            cx: nu,\n            cy: nu,\n            fill: \"colour\",\n            \"fill-opacity\": nu,\n            \"font-size\": nu,\n            height: nu,\n            opacity: nu,\n            path: \"path\",\n            r: nu,\n            rx: nu,\n            ry: nu,\n            stroke: \"colour\",\n            \"stroke-opacity\": nu,\n            \"stroke-width\": nu,\n            transform: \"transform\",\n            width: nu,\n            x: nu,\n            y: nu\n          },\n              whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\n              commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n              hsrg = {\n            hs: 1,\n            rg: 1\n          },\n              p2s = /,?([achlmqrstvxz]),?/gi,\n              pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n              tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n              pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n              radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\n              eldata = {},\n              sortByKey = function sortByKey(a, b) {\n            return a.key - b.key;\n          },\n              sortByNumber = function sortByNumber(a, b) {\n            return toFloat(a) - toFloat(b);\n          },\n              fun = function fun() {},\n              pipe = function pipe(x) {\n            return x;\n          },\n              rectPath = R._rectPath = function (x, y, w, h, r) {\n            if (r) {\n              return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\n            }\n\n            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n          },\n              ellipsePath = function ellipsePath(x, y, rx, ry) {\n            if (ry == null) {\n              ry = rx;\n            }\n\n            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n          },\n              getPath = R._getPath = {\n            path: function path(el) {\n              return el.attr(\"path\");\n            },\n            circle: function circle(el) {\n              var a = el.attrs;\n              return ellipsePath(a.cx, a.cy, a.r);\n            },\n            ellipse: function ellipse(el) {\n              var a = el.attrs;\n              return ellipsePath(a.cx, a.cy, a.rx, a.ry);\n            },\n            rect: function rect(el) {\n              var a = el.attrs;\n              return rectPath(a.x, a.y, a.width, a.height, a.r);\n            },\n            image: function image(el) {\n              var a = el.attrs;\n              return rectPath(a.x, a.y, a.width, a.height);\n            },\n            text: function text(el) {\n              var bbox = el._getBBox();\n\n              return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            },\n            set: function set(el) {\n              var bbox = el._getBBox();\n\n              return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            }\n          },\n\n          /*\\\n           * Raphael.mapPath\n           [ method ]\n           **\n           * Transform the path string with given matrix.\n           > Parameters\n           - path (string) path string\n           - matrix (object) see @Matrix\n           = (string) transformed path string\n          \\*/\n          mapPath = R.mapPath = function (path, matrix) {\n            if (!matrix) {\n              return path;\n            }\n\n            var x, y, i, j, ii, jj, pathi;\n            path = path2curve(path);\n\n            for (i = 0, ii = path.length; i < ii; i++) {\n              pathi = path[i];\n\n              for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n              }\n            }\n\n            return path;\n          };\n\n          R._g = g;\n          /*\\\n           * Raphael.type\n           [ property (string) ]\n           **\n           * Can be “SVG”, “VML” or empty, depending on browser support.\n          \\*/\n\n          R.type = g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\";\n\n          if (R.type == \"VML\") {\n            var d = g.doc.createElement(\"div\"),\n                b;\n            d.innerHTML = '<v:shape adj=\"1\"/>';\n            b = d.firstChild;\n            b.style.behavior = \"url(#default#VML)\";\n\n            if (!(b && _typeof(b.adj) == \"object\")) {\n              return R.type = E;\n            }\n\n            d = null;\n          }\n          /*\\\n           * Raphael.svg\n           [ property (boolean) ]\n           **\n           * `true` if browser supports SVG.\n          \\*/\n\n          /*\\\n           * Raphael.vml\n           [ property (boolean) ]\n           **\n           * `true` if browser supports VML.\n          \\*/\n\n\n          R.svg = !(R.vml = R.type == \"VML\");\n          R._Paper = Paper;\n          /*\\\n           * Raphael.fn\n           [ property (object) ]\n           **\n           * You can add your own method to the canvas. For example if you want to draw a pie chart,\n           * you can create your own pie chart function and ship it as a Raphaël plugin. To do this\n           * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\n           * Raphaël instance is created, otherwise it will take no effect. Please note that the\n           * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\n           * ensure any namespacing ensures proper context.\n           > Usage\n           | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\n           |     return this.path( ... );\n           | };\n           | // or create namespace\n           | Raphael.fn.mystuff = {\n           |     arrow: function () {…},\n           |     star: function () {…},\n           |     // etc…\n           | };\n           | var paper = Raphael(10, 10, 630, 480);\n           | // then use it\n           | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\n           | paper.mystuff.arrow();\n           | paper.mystuff.star();\n          \\*/\n\n          R.fn = paperproto = Paper.prototype = R.prototype;\n          R._id = 0;\n          /*\\\n           * Raphael.is\n           [ method ]\n           **\n           * Handful of replacements for `typeof` operator.\n           > Parameters\n           - o (…) any object or primitive\n           - type (string) name of the type, i.e. “string”, “function”, “number”, etc.\n           = (boolean) is given value is of given type\n          \\*/\n\n          R.is = function (o, type) {\n            type = lowerCase.call(type);\n\n            if (type == \"finite\") {\n              return !isnan[has](+o);\n            }\n\n            if (type == \"array\") {\n              return o instanceof Array;\n            }\n\n            return type == \"null\" && o === null || type == _typeof(o) && o !== null || type == \"object\" && o === Object(o) || type == \"array\" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;\n          };\n\n          function clone(obj) {\n            if (typeof obj == \"function\" || Object(obj) !== obj) {\n              return obj;\n            }\n\n            var res = new obj.constructor();\n\n            for (var key in obj) {\n              if (obj[has](key)) {\n                res[key] = clone(obj[key]);\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.angle\n           [ method ]\n           **\n           * Returns angle between two or three points\n           > Parameters\n           - x1 (number) x coord of first point\n           - y1 (number) y coord of first point\n           - x2 (number) x coord of second point\n           - y2 (number) y coord of second point\n           - x3 (number) #optional x coord of third point\n           - y3 (number) #optional y coord of third point\n           = (number) angle in degrees.\n          \\*/\n\n\n          R.angle = function (x1, y1, x2, y2, x3, y3) {\n            if (x3 == null) {\n              var x = x1 - x2,\n                  y = y1 - y2;\n\n              if (!x && !y) {\n                return 0;\n              }\n\n              return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n            } else {\n              return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\n            }\n          };\n          /*\\\n           * Raphael.rad\n           [ method ]\n           **\n           * Transform angle to radians\n           > Parameters\n           - deg (number) angle in degrees\n           = (number) angle in radians.\n          \\*/\n\n\n          R.rad = function (deg) {\n            return deg % 360 * PI / 180;\n          };\n          /*\\\n           * Raphael.deg\n           [ method ]\n           **\n           * Transform angle to degrees\n           > Parameters\n           - rad (number) angle in radians\n           = (number) angle in degrees.\n          \\*/\n\n\n          R.deg = function (rad) {\n            return Math.round(rad * 180 / PI % 360 * 1000) / 1000;\n          };\n          /*\\\n           * Raphael.snapTo\n           [ method ]\n           **\n           * Snaps given value to given grid.\n           > Parameters\n           - values (array|number) given array of values or step of the grid\n           - value (number) value to adjust\n           - tolerance (number) #optional tolerance for snapping. Default is `10`.\n           = (number) adjusted value.\n          \\*/\n\n\n          R.snapTo = function (values, value, tolerance) {\n            tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\n\n            if (R.is(values, array)) {\n              var i = values.length;\n\n              while (i--) {\n                if (abs(values[i] - value) <= tolerance) {\n                  return values[i];\n                }\n              }\n            } else {\n              values = +values;\n              var rem = value % values;\n\n              if (rem < tolerance) {\n                return value - rem;\n              }\n\n              if (rem > values - tolerance) {\n                return value - rem + values;\n              }\n            }\n\n            return value;\n          };\n          /*\\\n           * Raphael.createUUID\n           [ method ]\n           **\n           * Returns RFC4122, version 4 ID\n          \\*/\n\n\n          var createUUID = R.createUUID = function (uuidRegEx, uuidReplacer) {\n            return function () {\n              return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\n            };\n          }(/[xy]/g, function (c) {\n            var r = math.random() * 16 | 0,\n                v = c == \"x\" ? r : r & 3 | 8;\n            return v.toString(16);\n          });\n          /*\\\n           * Raphael.setWindow\n           [ method ]\n           **\n           * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\n           > Parameters\n           - newwin (window) new window object\n          \\*/\n\n\n          R.setWindow = function (newwin) {\n            eve(\"raphael.setWindow\", R, g.win, newwin);\n            g.win = newwin;\n            g.doc = g.win.document;\n\n            if (R._engine.initWin) {\n              R._engine.initWin(g.win);\n            }\n          };\n\n          var _toHex = function toHex(color) {\n            if (R.vml) {\n              // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\n              var trim = /^\\s+|\\s+$/g;\n              var bod;\n\n              try {\n                var docum = new ActiveXObject(\"htmlfile\");\n                docum.write(\"<body>\");\n                docum.close();\n                bod = docum.body;\n              } catch (e) {\n                bod = createPopup().document.body;\n              }\n\n              var range = bod.createTextRange();\n              _toHex = cacher(function (color) {\n                try {\n                  bod.style.color = Str(color).replace(trim, E);\n                  var value = range.queryCommandValue(\"ForeColor\");\n                  value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;\n                  return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\n                } catch (e) {\n                  return \"none\";\n                }\n              });\n            } else {\n              var i = g.doc.createElement(\"i\");\n              i.title = \"Rapha\\xebl Colour Picker\";\n              i.style.display = \"none\";\n              g.doc.body.appendChild(i);\n              _toHex = cacher(function (color) {\n                i.style.color = color;\n                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n              });\n            }\n\n            return _toHex(color);\n          },\n              hsbtoString = function hsbtoString() {\n            return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n          },\n              hsltoString = function hsltoString() {\n            return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n          },\n              rgbtoString = function rgbtoString() {\n            return this.hex;\n          },\n              prepareRGB = function prepareRGB(r, g, b) {\n            if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n              b = r.b;\n              g = r.g;\n              r = r.r;\n            }\n\n            if (g == null && R.is(r, string)) {\n              var clr = R.getRGB(r);\n              r = clr.r;\n              g = clr.g;\n              b = clr.b;\n            }\n\n            if (r > 1 || g > 1 || b > 1) {\n              r /= 255;\n              g /= 255;\n              b /= 255;\n            }\n\n            return [r, g, b];\n          },\n              packageRGB = function packageRGB(r, g, b, o) {\n            r *= 255;\n            g *= 255;\n            b *= 255;\n            var rgb = {\n              r: r,\n              g: g,\n              b: b,\n              hex: R.rgb(r, g, b),\n              toString: rgbtoString\n            };\n            R.is(o, \"finite\") && (rgb.opacity = o);\n            return rgb;\n          };\n          /*\\\n           * Raphael.color\n           [ method ]\n           **\n           * Parses the color string and returns object with all values for the given color.\n           > Parameters\n           - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\n           = (object) Combined RGB & HSB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••,\n           o     error (boolean) `true` if string can’t be parsed,\n           o     h (number) hue,\n           o     s (number) saturation,\n           o     v (number) value (brightness),\n           o     l (number) lightness\n           o }\n          \\*/\n\n\n          R.color = function (clr) {\n            var rgb;\n\n            if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n              rgb = R.hsb2rgb(clr);\n              clr.r = rgb.r;\n              clr.g = rgb.g;\n              clr.b = rgb.b;\n              clr.hex = rgb.hex;\n            } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n              rgb = R.hsl2rgb(clr);\n              clr.r = rgb.r;\n              clr.g = rgb.g;\n              clr.b = rgb.b;\n              clr.hex = rgb.hex;\n            } else {\n              if (R.is(clr, \"string\")) {\n                clr = R.getRGB(clr);\n              }\n\n              if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\n                rgb = R.rgb2hsl(clr);\n                clr.h = rgb.h;\n                clr.s = rgb.s;\n                clr.l = rgb.l;\n                rgb = R.rgb2hsb(clr);\n                clr.v = rgb.b;\n              } else {\n                clr = {\n                  hex: \"none\"\n                };\n                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n              }\n            }\n\n            clr.toString = rgbtoString;\n            return clr;\n          };\n          /*\\\n           * Raphael.hsb2rgb\n           [ method ]\n           **\n           * Converts HSB values to RGB object.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - v (number) value or brightness\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••\n           o }\n          \\*/\n\n\n          R.hsb2rgb = function (h, s, v, o) {\n            if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n              v = h.b;\n              s = h.s;\n              o = h.o;\n              h = h.h;\n            }\n\n            h *= 360;\n            var R, G, B, X, C;\n            h = h % 360 / 60;\n            C = v * s;\n            X = C * (1 - abs(h % 2 - 1));\n            R = G = B = v - C;\n            h = ~~h;\n            R += [C, X, 0, 0, X, C][h];\n            G += [X, C, C, X, 0, 0][h];\n            B += [0, 0, X, C, C, X][h];\n            return packageRGB(R, G, B, o);\n          };\n          /*\\\n           * Raphael.hsl2rgb\n           [ method ]\n           **\n           * Converts HSL values to RGB object.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - l (number) luminosity\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••\n           o }\n          \\*/\n\n\n          R.hsl2rgb = function (h, s, l, o) {\n            if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n              l = h.l;\n              s = h.s;\n              h = h.h;\n            }\n\n            if (h > 1 || s > 1 || l > 1) {\n              h /= 360;\n              s /= 100;\n              l /= 100;\n            }\n\n            h *= 360;\n            var R, G, B, X, C;\n            h = h % 360 / 60;\n            C = 2 * s * (l < .5 ? l : 1 - l);\n            X = C * (1 - abs(h % 2 - 1));\n            R = G = B = l - C / 2;\n            h = ~~h;\n            R += [C, X, 0, 0, X, C][h];\n            G += [X, C, C, X, 0, 0][h];\n            B += [0, 0, X, C, C, X][h];\n            return packageRGB(R, G, B, o);\n          };\n          /*\\\n           * Raphael.rgb2hsb\n           [ method ]\n           **\n           * Converts RGB values to HSB object.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (object) HSB object in format:\n           o {\n           o     h (number) hue\n           o     s (number) saturation\n           o     b (number) brightness\n           o }\n          \\*/\n\n\n          R.rgb2hsb = function (r, g, b) {\n            b = prepareRGB(r, g, b);\n            r = b[0];\n            g = b[1];\n            b = b[2];\n            var H, S, V, C;\n            V = mmax(r, g, b);\n            C = V - mmin(r, g, b);\n            H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;\n            H = (H + 360) % 6 * 60 / 360;\n            S = C == 0 ? 0 : C / V;\n            return {\n              h: H,\n              s: S,\n              b: V,\n              toString: hsbtoString\n            };\n          };\n          /*\\\n           * Raphael.rgb2hsl\n           [ method ]\n           **\n           * Converts RGB values to HSL object.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (object) HSL object in format:\n           o {\n           o     h (number) hue\n           o     s (number) saturation\n           o     l (number) luminosity\n           o }\n          \\*/\n\n\n          R.rgb2hsl = function (r, g, b) {\n            b = prepareRGB(r, g, b);\n            r = b[0];\n            g = b[1];\n            b = b[2];\n            var H, S, L, M, m, C;\n            M = mmax(r, g, b);\n            m = mmin(r, g, b);\n            C = M - m;\n            H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;\n            H = (H + 360) % 6 * 60 / 360;\n            L = (M + m) / 2;\n            S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);\n            return {\n              h: H,\n              s: S,\n              l: L,\n              toString: hsltoString\n            };\n          };\n\n          R._path2string = function () {\n            return this.join(\",\").replace(p2s, \"$1\");\n          };\n\n          function repush(array, item) {\n            for (var i = 0, ii = array.length; i < ii; i++) {\n              if (array[i] === item) {\n                return array.push(array.splice(i, 1)[0]);\n              }\n            }\n          }\n\n          function cacher(f, scope, postprocessor) {\n            function newf() {\n              var arg = Array.prototype.slice.call(arguments, 0),\n                  args = arg.join(\"\\u2400\"),\n                  cache = newf.cache = newf.cache || {},\n                  count = newf.count = newf.count || [];\n\n              if (cache[has](args)) {\n                repush(count, args);\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\n              }\n\n              count.length >= 1e3 && delete cache[count.shift()];\n              count.push(args);\n              cache[args] = f[apply](scope, arg);\n              return postprocessor ? postprocessor(cache[args]) : cache[args];\n            }\n\n            return newf;\n          }\n\n          var preload = R._preload = function (src, f) {\n            var img = g.doc.createElement(\"img\");\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\n            img.onload = function () {\n              f.call(this);\n              this.onload = null;\n              g.doc.body.removeChild(this);\n            };\n\n            img.onerror = function () {\n              g.doc.body.removeChild(this);\n            };\n\n            g.doc.body.appendChild(img);\n            img.src = src;\n          };\n\n          function clrToString() {\n            return this.hex;\n          }\n          /*\\\n           * Raphael.getRGB\n           [ method ]\n           **\n           * Parses colour string as RGB object\n           > Parameters\n           - colour (string) colour string in one of formats:\n           # <ul>\n           #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\n           #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\n           #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\n           #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\n           #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\n           #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\n           #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsl(•••, •••, •••) — same as hsb</li>\n           #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>\n           # </ul>\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue\n           o     hex (string) color in HTML/CSS format: #••••••,\n           o     error (boolean) true if string can’t be parsed\n           o }\n          \\*/\n\n\n          R.getRGB = cacher(function (colour) {\n            if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n              return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                error: 1,\n                toString: clrToString\n              };\n            }\n\n            if (colour == \"none\") {\n              return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                toString: clrToString\n              };\n            }\n\n            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = _toHex(colour));\n            var res,\n                red,\n                green,\n                blue,\n                opacity,\n                t,\n                values,\n                rgb = colour.match(colourRegExp);\n\n            if (rgb) {\n              if (rgb[2]) {\n                blue = toInt(rgb[2].substring(5), 16);\n                green = toInt(rgb[2].substring(3, 5), 16);\n                red = toInt(rgb[2].substring(1, 3), 16);\n              }\n\n              if (rgb[3]) {\n                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n              }\n\n              if (rgb[4]) {\n                values = rgb[4][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n              }\n\n              if (rgb[5]) {\n                values = rgb[5][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsb2rgb(red, green, blue, opacity);\n              }\n\n              if (rgb[6]) {\n                values = rgb[6][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsl2rgb(red, green, blue, opacity);\n              }\n\n              rgb = {\n                r: red,\n                g: green,\n                b: blue,\n                toString: clrToString\n              };\n              rgb.hex = \"#\" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);\n              R.is(opacity, \"finite\") && (rgb.opacity = opacity);\n              return rgb;\n            }\n\n            return {\n              r: -1,\n              g: -1,\n              b: -1,\n              hex: \"none\",\n              error: 1,\n              toString: clrToString\n            };\n          }, R);\n          /*\\\n           * Raphael.hsb\n           [ method ]\n           **\n           * Converts HSB values to hex representation of the colour.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - b (number) value or brightness\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.hsb = cacher(function (h, s, b) {\n            return R.hsb2rgb(h, s, b).hex;\n          });\n          /*\\\n           * Raphael.hsl\n           [ method ]\n           **\n           * Converts HSL values to hex representation of the colour.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - l (number) luminosity\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.hsl = cacher(function (h, s, l) {\n            return R.hsl2rgb(h, s, l).hex;\n          });\n          /*\\\n           * Raphael.rgb\n           [ method ]\n           **\n           * Converts RGB values to hex representation of the colour.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.rgb = cacher(function (r, g, b) {\n            function round(x) {\n              return x + 0.5 | 0;\n            }\n\n            return \"#\" + (16777216 | round(b) | round(g) << 8 | round(r) << 16).toString(16).slice(1);\n          });\n          /*\\\n           * Raphael.getColor\n           [ method ]\n           **\n           * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\n           > Parameters\n           - value (number) #optional brightness, default is `0.75`\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.getColor = function (value) {\n            var start = this.getColor.start = this.getColor.start || {\n              h: 0,\n              s: 1,\n              b: value || .75\n            },\n                rgb = this.hsb2rgb(start.h, start.s, start.b);\n            start.h += .075;\n\n            if (start.h > 1) {\n              start.h = 0;\n              start.s -= .2;\n              start.s <= 0 && (this.getColor.start = {\n                h: 0,\n                s: 1,\n                b: start.b\n              });\n            }\n\n            return rgb.hex;\n          };\n          /*\\\n           * Raphael.getColor.reset\n           [ method ]\n           **\n           * Resets spectrum position for @Raphael.getColor back to red.\n          \\*/\n\n\n          R.getColor.reset = function () {\n            delete this.start;\n          }; // http://schepers.cc/getting-to-the-point\n\n\n          function catmullRom2bezier(crp, z) {\n            var d = [];\n\n            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n              var p = [{\n                x: +crp[i - 2],\n                y: +crp[i - 1]\n              }, {\n                x: +crp[i],\n                y: +crp[i + 1]\n              }, {\n                x: +crp[i + 2],\n                y: +crp[i + 3]\n              }, {\n                x: +crp[i + 4],\n                y: +crp[i + 5]\n              }];\n\n              if (z) {\n                if (!i) {\n                  p[0] = {\n                    x: +crp[iLen - 2],\n                    y: +crp[iLen - 1]\n                  };\n                } else if (iLen - 4 == i) {\n                  p[3] = {\n                    x: +crp[0],\n                    y: +crp[1]\n                  };\n                } else if (iLen - 2 == i) {\n                  p[2] = {\n                    x: +crp[0],\n                    y: +crp[1]\n                  };\n                  p[3] = {\n                    x: +crp[2],\n                    y: +crp[3]\n                  };\n                }\n              } else {\n                if (iLen - 4 == i) {\n                  p[3] = p[2];\n                } else if (!i) {\n                  p[0] = {\n                    x: +crp[i],\n                    y: +crp[i + 1]\n                  };\n                }\n              }\n\n              d.push([\"C\", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);\n            }\n\n            return d;\n          }\n          /*\\\n           * Raphael.parsePathString\n           [ method ]\n           **\n           * Utility method\n           **\n           * Parses given path string into an array of arrays of path segments.\n           > Parameters\n           - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\n           = (array) array of segments.\n          \\*/\n\n\n          R.parsePathString = function (pathString) {\n            if (!pathString) {\n              return null;\n            }\n\n            var pth = paths(pathString);\n\n            if (pth.arr) {\n              return pathClone(pth.arr);\n            }\n\n            var paramCounts = {\n              a: 7,\n              c: 6,\n              h: 1,\n              l: 2,\n              m: 2,\n              r: 4,\n              q: 4,\n              s: 4,\n              t: 2,\n              v: 1,\n              z: 0\n            },\n                data = [];\n\n            if (R.is(pathString, array) && R.is(pathString[0], array)) {\n              // rough assumption\n              data = pathClone(pathString);\n            }\n\n            if (!data.length) {\n              Str(pathString).replace(pathCommand, function (a, b, c) {\n                var params = [],\n                    name = b.toLowerCase();\n                c.replace(pathValues, function (a, b) {\n                  b && params.push(+b);\n                });\n\n                if (name == \"m\" && params.length > 2) {\n                  data.push([b][concat](params.splice(0, 2)));\n                  name = \"l\";\n                  b = b == \"m\" ? \"l\" : \"L\";\n                }\n\n                if (name == \"r\") {\n                  data.push([b][concat](params));\n                } else while (params.length >= paramCounts[name]) {\n                  data.push([b][concat](params.splice(0, paramCounts[name])));\n\n                  if (!paramCounts[name]) {\n                    break;\n                  }\n                }\n              });\n            }\n\n            data.toString = R._path2string;\n            pth.arr = pathClone(data);\n            return data;\n          };\n          /*\\\n           * Raphael.parseTransformString\n           [ method ]\n           **\n           * Utility method\n           **\n           * Parses given path string into an array of transformations.\n           > Parameters\n           - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\n           = (array) array of transformations.\n          \\*/\n\n\n          R.parseTransformString = cacher(function (TString) {\n            if (!TString) {\n              return null;\n            }\n\n            var paramCounts = {\n              r: 3,\n              s: 4,\n              t: 2,\n              m: 6\n            },\n                data = [];\n\n            if (R.is(TString, array) && R.is(TString[0], array)) {\n              // rough assumption\n              data = pathClone(TString);\n            }\n\n            if (!data.length) {\n              Str(TString).replace(tCommand, function (a, b, c) {\n                var params = [],\n                    name = lowerCase.call(b);\n                c.replace(pathValues, function (a, b) {\n                  b && params.push(+b);\n                });\n                data.push([b][concat](params));\n              });\n            }\n\n            data.toString = R._path2string;\n            return data;\n          }, this, function (elem) {\n            if (!elem) return elem;\n            var newData = [];\n\n            for (var i = 0; i < elem.length; i++) {\n              var newLevel = [];\n\n              for (var j = 0; j < elem[i].length; j++) {\n                newLevel.push(elem[i][j]);\n              }\n\n              newData.push(newLevel);\n            }\n\n            return newData;\n          }); // PATHS\n\n          var paths = function paths(ps) {\n            var p = paths.ps = paths.ps || {};\n\n            if (p[ps]) {\n              p[ps].sleep = 100;\n            } else {\n              p[ps] = {\n                sleep: 100\n              };\n            }\n\n            setTimeout(function () {\n              for (var key in p) {\n                if (p[has](key) && key != ps) {\n                  p[key].sleep--;\n                  !p[key].sleep && delete p[key];\n                }\n              }\n            });\n            return p[ps];\n          };\n          /*\\\n           * Raphael.findDotsAtSegment\n           [ method ]\n           **\n           * Utility method\n           **\n           * Find dot coordinates on the given cubic bezier curve at the given t.\n           > Parameters\n           - p1x (number) x of the first point of the curve\n           - p1y (number) y of the first point of the curve\n           - c1x (number) x of the first anchor of the curve\n           - c1y (number) y of the first anchor of the curve\n           - c2x (number) x of the second anchor of the curve\n           - c2y (number) y of the second anchor of the curve\n           - p2x (number) x of the second point of the curve\n           - p2y (number) y of the second point of the curve\n           - t (number) position on the curve (0..1)\n           = (object) point information in format:\n           o {\n           o     x: (number) x coordinate of the point\n           o     y: (number) y coordinate of the point\n           o     m: {\n           o         x: (number) x coordinate of the left anchor\n           o         y: (number) y coordinate of the left anchor\n           o     }\n           o     n: {\n           o         x: (number) x coordinate of the right anchor\n           o         y: (number) y coordinate of the right anchor\n           o     }\n           o     start: {\n           o         x: (number) x coordinate of the start of the curve\n           o         y: (number) y coordinate of the start of the curve\n           o     }\n           o     end: {\n           o         x: (number) x coordinate of the end of the curve\n           o         y: (number) y coordinate of the end of the curve\n           o     }\n           o     alpha: (number) angle of the curve derivative at the point\n           o }\n          \\*/\n\n\n          R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n            var t1 = 1 - t,\n                t13 = pow(t1, 3),\n                t12 = pow(t1, 2),\n                t2 = t * t,\n                t3 = t2 * t,\n                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n                ax = t1 * p1x + t * c1x,\n                ay = t1 * p1y + t * c1y,\n                cx = t1 * c2x + t * p2x,\n                cy = t1 * c2y + t * p2y,\n                alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;\n            (mx > nx || my < ny) && (alpha += 180);\n            return {\n              x: x,\n              y: y,\n              m: {\n                x: mx,\n                y: my\n              },\n              n: {\n                x: nx,\n                y: ny\n              },\n              start: {\n                x: ax,\n                y: ay\n              },\n              end: {\n                x: cx,\n                y: cy\n              },\n              alpha: alpha\n            };\n          };\n          /*\\\n           * Raphael.bezierBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Return bounding box of a given cubic bezier curve\n           > Parameters\n           - p1x (number) x of the first point of the curve\n           - p1y (number) y of the first point of the curve\n           - c1x (number) x of the first anchor of the curve\n           - c1y (number) y of the first anchor of the curve\n           - c2x (number) x of the second anchor of the curve\n           - c2y (number) y of the second anchor of the curve\n           - p2x (number) x of the second point of the curve\n           - p2y (number) y of the second point of the curve\n           * or\n           - bez (array) array of six points for bezier curve\n           = (object) point information in format:\n           o {\n           o     min: {\n           o         x: (number) x coordinate of the left point\n           o         y: (number) y coordinate of the top point\n           o     }\n           o     max: {\n           o         x: (number) x coordinate of the right point\n           o         y: (number) y coordinate of the bottom point\n           o     }\n           o }\n          \\*/\n\n\n          R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n            if (!R.is(p1x, \"array\")) {\n              p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n            }\n\n            var bbox = curveDim.apply(null, p1x);\n            return {\n              x: bbox.min.x,\n              y: bbox.min.y,\n              x2: bbox.max.x,\n              y2: bbox.max.y,\n              width: bbox.max.x - bbox.min.x,\n              height: bbox.max.y - bbox.min.y\n            };\n          };\n          /*\\\n           * Raphael.isPointInsideBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if given point is inside bounding boxes.\n           > Parameters\n           - bbox (string) bounding box\n           - x (string) x coordinate of the point\n           - y (string) y coordinate of the point\n           = (boolean) `true` if point inside\n          \\*/\n\n\n          R.isPointInsideBBox = function (bbox, x, y) {\n            return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\n          };\n          /*\\\n           * Raphael.isBBoxIntersect\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if two bounding boxes intersect\n           > Parameters\n           - bbox1 (string) first bounding box\n           - bbox2 (string) second bounding box\n           = (boolean) `true` if they intersect\n          \\*/\n\n\n          R.isBBoxIntersect = function (bbox1, bbox2) {\n            var i = R.isPointInsideBBox;\n            return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n          };\n\n          function base3(t, p1, p2, p3, p4) {\n            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n            return t * t2 - 3 * p1 + 3 * p2;\n          }\n\n          function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n            if (z == null) {\n              z = 1;\n            }\n\n            z = z > 1 ? 1 : z < 0 ? 0 : z;\n            var z2 = z / 2,\n                n = 12,\n                Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],\n                Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],\n                sum = 0;\n\n            for (var i = 0; i < n; i++) {\n              var ct = z2 * Tvalues[i] + z2,\n                  xbase = base3(ct, x1, x2, x3, x4),\n                  ybase = base3(ct, y1, y2, y3, y4),\n                  comb = xbase * xbase + ybase * ybase;\n              sum += Cvalues[i] * math.sqrt(comb);\n            }\n\n            return z2 * sum;\n          }\n\n          function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n              return;\n            }\n\n            var t = 1,\n                step = t / 2,\n                t2 = t - step,\n                l,\n                e = .01;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\n            while (abs(l - ll) > e) {\n              step /= 2;\n              t2 += (l < ll ? 1 : -1) * step;\n              l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n            }\n\n            return t2;\n          }\n\n          function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n            if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {\n              return;\n            }\n\n            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n            if (!denominator) {\n              return;\n            }\n\n            var px = nx / denominator,\n                py = ny / denominator,\n                px2 = +px.toFixed(2),\n                py2 = +py.toFixed(2);\n\n            if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {\n              return;\n            }\n\n            return {\n              x: px,\n              y: py\n            };\n          }\n\n          function inter(bez1, bez2) {\n            return interHelper(bez1, bez2);\n          }\n\n          function interCount(bez1, bez2) {\n            return interHelper(bez1, bez2, 1);\n          }\n\n          function interHelper(bez1, bez2, justCount) {\n            var bbox1 = R.bezierBBox(bez1),\n                bbox2 = R.bezierBBox(bez2);\n\n            if (!R.isBBoxIntersect(bbox1, bbox2)) {\n              return justCount ? 0 : [];\n            }\n\n            var l1 = bezlen.apply(0, bez1),\n                l2 = bezlen.apply(0, bez2),\n                n1 = mmax(~~(l1 / 5), 1),\n                n2 = mmax(~~(l2 / 5), 1),\n                dots1 = [],\n                dots2 = [],\n                xy = {},\n                res = justCount ? 0 : [];\n\n            for (var i = 0; i < n1 + 1; i++) {\n              var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\n              dots1.push({\n                x: p.x,\n                y: p.y,\n                t: i / n1\n              });\n            }\n\n            for (i = 0; i < n2 + 1; i++) {\n              p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\n              dots2.push({\n                x: p.x,\n                y: p.y,\n                t: i / n2\n              });\n            }\n\n            for (i = 0; i < n1; i++) {\n              for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\n                if (is) {\n                  if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                    continue;\n                  }\n\n                  xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                  var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                      t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\n                  if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\n                    if (justCount) {\n                      res++;\n                    } else {\n                      res.push({\n                        x: is.x,\n                        y: is.y,\n                        t1: mmin(t1, 1),\n                        t2: mmin(t2, 1)\n                      });\n                    }\n                  }\n                }\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.pathIntersection\n           [ method ]\n           **\n           * Utility method\n           **\n           * Finds intersections of two paths\n           > Parameters\n           - path1 (string) path string\n           - path2 (string) path string\n           = (array) dots of intersection\n           o [\n           o     {\n           o         x: (number) x coordinate of the point\n           o         y: (number) y coordinate of the point\n           o         t1: (number) t value for segment of path1\n           o         t2: (number) t value for segment of path2\n           o         segment1: (number) order number for segment of path1\n           o         segment2: (number) order number for segment of path2\n           o         bez1: (array) eight coordinates representing beziér curve for the segment of path1\n           o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n           o     }\n           o ]\n          \\*/\n\n\n          R.pathIntersection = function (path1, path2) {\n            return interPathHelper(path1, path2);\n          };\n\n          R.pathIntersectionNumber = function (path1, path2) {\n            return interPathHelper(path1, path2, 1);\n          };\n\n          function interPathHelper(path1, path2, justCount) {\n            path1 = R._path2curve(path1);\n            path2 = R._path2curve(path2);\n            var x1,\n                y1,\n                x2,\n                y2,\n                x1m,\n                y1m,\n                x2m,\n                y2m,\n                bez1,\n                bez2,\n                res = justCount ? 0 : [];\n\n            for (var i = 0, ii = path1.length; i < ii; i++) {\n              var pi = path1[i];\n\n              if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n              } else {\n                if (pi[0] == \"C\") {\n                  bez1 = [x1, y1].concat(pi.slice(1));\n                  x1 = bez1[6];\n                  y1 = bez1[7];\n                } else {\n                  bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                  x1 = x1m;\n                  y1 = y1m;\n                }\n\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                  var pj = path2[j];\n\n                  if (pj[0] == \"M\") {\n                    x2 = x2m = pj[1];\n                    y2 = y2m = pj[2];\n                  } else {\n                    if (pj[0] == \"C\") {\n                      bez2 = [x2, y2].concat(pj.slice(1));\n                      x2 = bez2[6];\n                      y2 = bez2[7];\n                    } else {\n                      bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                      x2 = x2m;\n                      y2 = y2m;\n                    }\n\n                    var intr = interHelper(bez1, bez2, justCount);\n\n                    if (justCount) {\n                      res += intr;\n                    } else {\n                      for (var k = 0, kk = intr.length; k < kk; k++) {\n                        intr[k].segment1 = i;\n                        intr[k].segment2 = j;\n                        intr[k].bez1 = bez1;\n                        intr[k].bez2 = bez2;\n                      }\n\n                      res = res.concat(intr);\n                    }\n                  }\n                }\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.isPointInsidePath\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if given point is inside a given closed path.\n           > Parameters\n           - path (string) path string\n           - x (number) x of the point\n           - y (number) y of the point\n           = (boolean) true, if point is inside the path\n          \\*/\n\n\n          R.isPointInsidePath = function (path, x, y) {\n            var bbox = R.pathBBox(path);\n            return R.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n          };\n\n          R._removedFactory = function (methodname) {\n            return function () {\n              eve(\"raphael.log\", null, \"Rapha\\xEBl: you are calling to method \\u201C\" + methodname + \"\\u201D of removed object\", methodname);\n            };\n          };\n          /*\\\n           * Raphael.pathBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Return bounding box of a given path\n           > Parameters\n           - path (string) path string\n           = (object) bounding box\n           o {\n           o     x: (number) x coordinate of the left top point of the box\n           o     y: (number) y coordinate of the left top point of the box\n           o     x2: (number) x coordinate of the right bottom point of the box\n           o     y2: (number) y coordinate of the right bottom point of the box\n           o     width: (number) width of the box\n           o     height: (number) height of the box\n           o     cx: (number) x coordinate of the center of the box\n           o     cy: (number) y coordinate of the center of the box\n           o }\n          \\*/\n\n\n          var pathDimensions = R.pathBBox = function (path) {\n            var pth = paths(path);\n\n            if (pth.bbox) {\n              return clone(pth.bbox);\n            }\n\n            if (!path) {\n              return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n                x2: 0,\n                y2: 0\n              };\n            }\n\n            path = path2curve(path);\n            var x = 0,\n                y = 0,\n                X = [],\n                Y = [],\n                p;\n\n            for (var i = 0, ii = path.length; i < ii; i++) {\n              p = path[i];\n\n              if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n              } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X[concat](dim.min.x, dim.max.x);\n                Y = Y[concat](dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n              }\n            }\n\n            var xmin = mmin[apply](0, X),\n                ymin = mmin[apply](0, Y),\n                xmax = mmax[apply](0, X),\n                ymax = mmax[apply](0, Y),\n                width = xmax - xmin,\n                height = ymax - ymin,\n                bb = {\n              x: xmin,\n              y: ymin,\n              x2: xmax,\n              y2: ymax,\n              width: width,\n              height: height,\n              cx: xmin + width / 2,\n              cy: ymin + height / 2\n            };\n            pth.bbox = clone(bb);\n            return bb;\n          },\n              pathClone = function pathClone(pathArray) {\n            var res = clone(pathArray);\n            res.toString = R._path2string;\n            return res;\n          },\n              pathToRelative = R._pathToRelative = function (pathArray) {\n            var pth = paths(pathArray);\n\n            if (pth.rel) {\n              return pathClone(pth.rel);\n            }\n\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {\n              // rough assumption\n              pathArray = R.parsePathString(pathArray);\n            }\n\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n\n            if (pathArray[0][0] == \"M\") {\n              x = pathArray[0][1];\n              y = pathArray[0][2];\n              mx = x;\n              my = y;\n              start++;\n              res.push([\"M\", x, y]);\n            }\n\n            for (var i = start, ii = pathArray.length; i < ii; i++) {\n              var r = res[i] = [],\n                  pa = pathArray[i];\n\n              if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n\n                switch (r[0]) {\n                  case \"a\":\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +(pa[6] - x).toFixed(3);\n                    r[7] = +(pa[7] - y).toFixed(3);\n                    break;\n\n                  case \"v\":\n                    r[1] = +(pa[1] - y).toFixed(3);\n                    break;\n\n                  case \"m\":\n                    mx = pa[1];\n                    my = pa[2];\n\n                  default:\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\n                      r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);\n                    }\n\n                }\n              } else {\n                r = res[i] = [];\n\n                if (pa[0] == \"m\") {\n                  mx = pa[1] + x;\n                  my = pa[2] + y;\n                }\n\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                  res[i][k] = pa[k];\n                }\n              }\n\n              var len = res[i].length;\n\n              switch (res[i][0]) {\n                case \"z\":\n                  x = mx;\n                  y = my;\n                  break;\n\n                case \"h\":\n                  x += +res[i][len - 1];\n                  break;\n\n                case \"v\":\n                  y += +res[i][len - 1];\n                  break;\n\n                default:\n                  x += +res[i][len - 2];\n                  y += +res[i][len - 1];\n              }\n            }\n\n            res.toString = R._path2string;\n            pth.rel = pathClone(res);\n            return res;\n          },\n              pathToAbsolute = R._pathToAbsolute = function (pathArray) {\n            var pth = paths(pathArray);\n\n            if (pth.abs) {\n              return pathClone(pth.abs);\n            }\n\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {\n              // rough assumption\n              pathArray = R.parsePathString(pathArray);\n            }\n\n            if (!pathArray || !pathArray.length) {\n              return [[\"M\", 0, 0]];\n            }\n\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n\n            if (pathArray[0][0] == \"M\") {\n              x = +pathArray[0][1];\n              y = +pathArray[0][2];\n              mx = x;\n              my = y;\n              start++;\n              res[0] = [\"M\", x, y];\n            }\n\n            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n\n            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n              res.push(r = []);\n              pa = pathArray[i];\n\n              if (pa[0] != upperCase.call(pa[0])) {\n                r[0] = upperCase.call(pa[0]);\n\n                switch (r[0]) {\n                  case \"A\":\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +(pa[6] + x);\n                    r[7] = +(pa[7] + y);\n                    break;\n\n                  case \"V\":\n                    r[1] = +pa[1] + y;\n                    break;\n\n                  case \"H\":\n                    r[1] = +pa[1] + x;\n                    break;\n\n                  case \"R\":\n                    var dots = [x, y][concat](pa.slice(1));\n\n                    for (var j = 2, jj = dots.length; j < jj; j++) {\n                      dots[j] = +dots[j] + x;\n                      dots[++j] = +dots[j] + y;\n                    }\n\n                    res.pop();\n                    res = res[concat](catmullRom2bezier(dots, crz));\n                    break;\n\n                  case \"M\":\n                    mx = +pa[1] + x;\n                    my = +pa[2] + y;\n\n                  default:\n                    for (j = 1, jj = pa.length; j < jj; j++) {\n                      r[j] = +pa[j] + (j % 2 ? x : y);\n                    }\n\n                }\n              } else if (pa[0] == \"R\") {\n                dots = [x, y][concat](pa.slice(1));\n                res.pop();\n                res = res[concat](catmullRom2bezier(dots, crz));\n                r = [\"R\"][concat](pa.slice(-2));\n              } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                  r[k] = pa[k];\n                }\n              }\n\n              switch (r[0]) {\n                case \"Z\":\n                  x = mx;\n                  y = my;\n                  break;\n\n                case \"H\":\n                  x = r[1];\n                  break;\n\n                case \"V\":\n                  y = r[1];\n                  break;\n\n                case \"M\":\n                  mx = r[r.length - 2];\n                  my = r[r.length - 1];\n\n                default:\n                  x = r[r.length - 2];\n                  y = r[r.length - 1];\n              }\n            }\n\n            res.toString = R._path2string;\n            pth.abs = pathClone(res);\n            return res;\n          },\n              l2c = function l2c(x1, y1, x2, y2) {\n            return [x1, y1, x2, y2, x2, y2];\n          },\n              q2c = function q2c(x1, y1, ax, ay, x2, y2) {\n            var _13 = 1 / 3,\n                _23 = 2 / 3;\n\n            return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n          },\n              a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = PI * 120 / 180,\n                rad = PI / 180 * (+angle || 0),\n                res = [],\n                xy,\n                rotate = cacher(function (x, y, rad) {\n              var X = x * math.cos(rad) - y * math.sin(rad),\n                  Y = x * math.sin(rad) + y * math.cos(rad);\n              return {\n                x: X,\n                y: Y\n              };\n            });\n\n            if (!recursive) {\n              xy = rotate(x1, y1, -rad);\n              x1 = xy.x;\n              y1 = xy.y;\n              xy = rotate(x2, y2, -rad);\n              x2 = xy.x;\n              y2 = xy.y;\n              var cos = math.cos(PI / 180 * angle),\n                  sin = math.sin(PI / 180 * angle),\n                  x = (x1 - x2) / 2,\n                  y = (y1 - y2) / 2;\n              var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n              if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n              }\n\n              var rx2 = rx * rx,\n                  ry2 = ry * ry,\n                  k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                  cx = k * rx * y / ry + (x1 + x2) / 2,\n                  cy = k * -ry * x / rx + (y1 + y2) / 2,\n                  f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                  f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n              f1 = x1 < cx ? PI - f1 : f1;\n              f2 = x2 < cx ? PI - f2 : f2;\n              f1 < 0 && (f1 = PI * 2 + f1);\n              f2 < 0 && (f2 = PI * 2 + f2);\n\n              if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n              }\n\n              if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n              }\n            } else {\n              f1 = recursive[0];\n              f2 = recursive[1];\n              cx = recursive[2];\n              cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n\n            if (abs(df) > _120) {\n              var f2old = f2,\n                  x2old = x2,\n                  y2old = y2;\n              f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n              x2 = cx + rx * math.cos(f2);\n              y2 = cy + ry * math.sin(f2);\n              res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n            var c1 = math.cos(f1),\n                s1 = math.sin(f1),\n                c2 = math.cos(f2),\n                s2 = math.sin(f2),\n                t = math.tan(df / 4),\n                hx = 4 / 3 * rx * t,\n                hy = 4 / 3 * ry * t,\n                m1 = [x1, y1],\n                m2 = [x1 + hx * s1, y1 - hy * c1],\n                m3 = [x2 + hx * s2, y2 - hy * c2],\n                m4 = [x2, y2];\n            m2[0] = 2 * m1[0] - m2[0];\n            m2[1] = 2 * m1[1] - m2[1];\n\n            if (recursive) {\n              return [m2, m3, m4][concat](res);\n            } else {\n              res = [m2, m3, m4][concat](res).join()[split](\",\");\n              var newres = [];\n\n              for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n              }\n\n              return newres;\n            }\n          },\n              findDotAtSegment = function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n            var t1 = 1 - t;\n            return {\n              x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n              y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n            };\n          },\n              curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n            var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),\n                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\n                c = p1x - c1x,\n                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                y = [p1y, p2y],\n                x = [p1x, p2x],\n                dot;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n\n            if (t1 > 0 && t1 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            if (t2 > 0 && t2 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);\n            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\n            c = p1y - c1y;\n            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n\n            if (t1 > 0 && t1 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            if (t2 > 0 && t2 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            return {\n              min: {\n                x: mmin[apply](0, x),\n                y: mmin[apply](0, y)\n              },\n              max: {\n                x: mmax[apply](0, x),\n                y: mmax[apply](0, y)\n              }\n            };\n          }),\n              path2curve = R._path2curve = cacher(function (path, path2) {\n            var pth = !path2 && paths(path);\n\n            if (!path2 && pth.curve) {\n              return pathClone(pth.curve);\n            }\n\n            var p = pathToAbsolute(path),\n                p2 = path2 && pathToAbsolute(path2),\n                attrs = {\n              x: 0,\n              y: 0,\n              bx: 0,\n              by: 0,\n              X: 0,\n              Y: 0,\n              qx: null,\n              qy: null\n            },\n                attrs2 = {\n              x: 0,\n              y: 0,\n              bx: 0,\n              by: 0,\n              X: 0,\n              Y: 0,\n              qx: null,\n              qy: null\n            },\n                processPath = function processPath(path, d, pcom) {\n              var nx,\n                  ny,\n                  tq = {\n                T: 1,\n                Q: 1\n              };\n\n              if (!path) {\n                return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n              }\n\n              !(path[0] in tq) && (d.qx = d.qy = null);\n\n              switch (path[0]) {\n                case \"M\":\n                  d.X = path[1];\n                  d.Y = path[2];\n                  break;\n\n                case \"A\":\n                  path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\n                  break;\n\n                case \"S\":\n                  if (pcom == \"C\" || pcom == \"S\") {\n                    // In \"S\" case we have to take into account, if the previous command is C/S.\n                    nx = d.x * 2 - d.bx; // And reflect the previous\n\n                    ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                  } else {\n                    // or some else or nothing\n                    nx = d.x;\n                    ny = d.y;\n                  }\n\n                  path = [\"C\", nx, ny][concat](path.slice(1));\n                  break;\n\n                case \"T\":\n                  if (pcom == \"Q\" || pcom == \"T\") {\n                    // In \"T\" case we have to take into account, if the previous command is Q/T.\n                    d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n                    d.qy = d.y * 2 - d.qy; // to case \"S\".\n                  } else {\n                    // or something else or nothing\n                    d.qx = d.x;\n                    d.qy = d.y;\n                  }\n\n                  path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                  break;\n\n                case \"Q\":\n                  d.qx = path[1];\n                  d.qy = path[2];\n                  path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                  break;\n\n                case \"L\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\n                  break;\n\n                case \"H\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\n                  break;\n\n                case \"V\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\n                  break;\n\n                case \"Z\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\n                  break;\n              }\n\n              return path;\n            },\n                fixArc = function fixArc(pp, i) {\n              if (pp[i].length > 7) {\n                pp[i].shift();\n                var pi = pp[i];\n\n                while (pi.length) {\n                  pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n\n                  p2 && (pcoms2[i] = \"A\"); // the same as above\n\n                  pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\n                }\n\n                pp.splice(i, 1);\n                ii = mmax(p.length, p2 && p2.length || 0);\n              }\n            },\n                fixM = function fixM(path1, path2, a1, a2, i) {\n              if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                a1.bx = 0;\n                a1.by = 0;\n                a1.x = path1[i][1];\n                a1.y = path1[i][2];\n                ii = mmax(p.length, p2 && p2.length || 0);\n              }\n            },\n                pcoms1 = [],\n                // path commands of original path p\n            pcoms2 = [],\n                // path commands of original path p2\n            pfirst = \"\",\n                // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n\n\n            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n              p[i] && (pfirst = p[i][0]); // save current path command\n\n              if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n                {\n                  pcoms1[i] = pfirst; // Save current path command\n\n                  i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n                }\n\n              p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n              if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n              // which may produce multiple C:s\n              // so we have to make sure that C is also C in original path\n\n              fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n              if (p2) {\n                // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n\n                if (pfirst != \"C\") {\n                  pcoms2[i] = pfirst;\n                  i && (pcom = pcoms2[i - 1]);\n                }\n\n                p2[i] = processPath(p2[i], attrs2, pcom);\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") pcoms2[i] = \"C\";\n                fixArc(p2, i);\n              }\n\n              fixM(p, p2, attrs, attrs2, i);\n              fixM(p2, p, attrs2, attrs, i);\n              var seg = p[i],\n                  seg2 = p2 && p2[i],\n                  seglen = seg.length,\n                  seg2len = p2 && seg2.length;\n              attrs.x = seg[seglen - 2];\n              attrs.y = seg[seglen - 1];\n              attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n              attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n              attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n              attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n              attrs2.x = p2 && seg2[seg2len - 2];\n              attrs2.y = p2 && seg2[seg2len - 1];\n            }\n\n            if (!p2) {\n              pth.curve = pathClone(p);\n            }\n\n            return p2 ? [p, p2] : p;\n          }, null, pathClone),\n              parseDots = R._parseDots = cacher(function (gradient) {\n            var dots = [];\n\n            for (var i = 0, ii = gradient.length; i < ii; i++) {\n              var dot = {},\n                  par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\n              dot.color = R.getRGB(par[1]);\n\n              if (dot.color.error) {\n                return null;\n              }\n\n              dot.opacity = dot.color.opacity;\n              dot.color = dot.color.hex;\n              par[2] && (dot.offset = par[2] + \"%\");\n              dots.push(dot);\n            }\n\n            for (i = 1, ii = dots.length - 1; i < ii; i++) {\n              if (!dots[i].offset) {\n                var start = toFloat(dots[i - 1].offset || 0),\n                    end = 0;\n\n                for (var j = i + 1; j < ii; j++) {\n                  if (dots[j].offset) {\n                    end = dots[j].offset;\n                    break;\n                  }\n                }\n\n                if (!end) {\n                  end = 100;\n                  j = ii;\n                }\n\n                end = toFloat(end);\n                var d = (end - start) / (j - i + 1);\n\n                for (; i < j; i++) {\n                  start += d;\n                  dots[i].offset = start + \"%\";\n                }\n              }\n            }\n\n            return dots;\n          }),\n              tear = R._tear = function (el, paper) {\n            el == paper.top && (paper.top = el.prev);\n            el == paper.bottom && (paper.bottom = el.next);\n            el.next && (el.next.prev = el.prev);\n            el.prev && (el.prev.next = el.next);\n          },\n              tofront = R._tofront = function (el, paper) {\n            if (paper.top === el) {\n              return;\n            }\n\n            tear(el, paper);\n            el.next = null;\n            el.prev = paper.top;\n            paper.top.next = el;\n            paper.top = el;\n          },\n              toback = R._toback = function (el, paper) {\n            if (paper.bottom === el) {\n              return;\n            }\n\n            tear(el, paper);\n            el.next = paper.bottom;\n            el.prev = null;\n            paper.bottom.prev = el;\n            paper.bottom = el;\n          },\n              insertafter = R._insertafter = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.top && (paper.top = el);\n            el2.next && (el2.next.prev = el);\n            el.next = el2.next;\n            el.prev = el2;\n            el2.next = el;\n          },\n              insertbefore = R._insertbefore = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.bottom && (paper.bottom = el);\n            el2.prev && (el2.prev.next = el);\n            el.prev = el2.prev;\n            el2.prev = el;\n            el.next = el2;\n          },\n\n          /*\\\n           * Raphael.toMatrix\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns matrix of transformations applied to a given path\n           > Parameters\n           - path (string) path string\n           - transform (string|array) transformation string\n           = (object) @Matrix\n          \\*/\n          toMatrix = R.toMatrix = function (path, transform) {\n            var bb = pathDimensions(path),\n                el = {\n              _: {\n                transform: E\n              },\n              getBBox: function getBBox() {\n                return bb;\n              }\n            };\n            extractTransform(el, transform);\n            return el.matrix;\n          },\n\n          /*\\\n           * Raphael.transformPath\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns path transformed by a given transformation\n           > Parameters\n           - path (string) path string\n           - transform (string|array) transformation string\n           = (string) path\n          \\*/\n          transformPath = R.transformPath = function (path, transform) {\n            return mapPath(path, toMatrix(path, transform));\n          },\n              extractTransform = R._extractTransform = function (el, tstr) {\n            if (tstr == null) {\n              return el._.transform;\n            }\n\n            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            var tdata = R.parseTransformString(tstr),\n                deg = 0,\n                dx = 0,\n                dy = 0,\n                sx = 1,\n                sy = 1,\n                _ = el._,\n                m = new Matrix();\n            _.transform = tdata || [];\n\n            if (tdata) {\n              for (var i = 0, ii = tdata.length; i < ii; i++) {\n                var t = tdata[i],\n                    tlen = t.length,\n                    command = Str(t[0]).toLowerCase(),\n                    absolute = t[0] != command,\n                    inver = absolute ? m.invert() : 0,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    bb;\n\n                if (command == \"t\" && tlen == 3) {\n                  if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                  } else {\n                    m.translate(t[1], t[2]);\n                  }\n                } else if (command == \"r\") {\n                  if (tlen == 2) {\n                    bb = bb || el.getBBox(1);\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    deg += t[1];\n                  } else if (tlen == 4) {\n                    if (absolute) {\n                      x2 = inver.x(t[2], t[3]);\n                      y2 = inver.y(t[2], t[3]);\n                      m.rotate(t[1], x2, y2);\n                    } else {\n                      m.rotate(t[1], t[2], t[3]);\n                    }\n\n                    deg += t[1];\n                  }\n                } else if (command == \"s\") {\n                  if (tlen == 2 || tlen == 3) {\n                    bb = bb || el.getBBox(1);\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    sx *= t[1];\n                    sy *= t[tlen - 1];\n                  } else if (tlen == 5) {\n                    if (absolute) {\n                      x2 = inver.x(t[3], t[4]);\n                      y2 = inver.y(t[3], t[4]);\n                      m.scale(t[1], t[2], x2, y2);\n                    } else {\n                      m.scale(t[1], t[2], t[3], t[4]);\n                    }\n\n                    sx *= t[1];\n                    sy *= t[2];\n                  }\n                } else if (command == \"m\" && tlen == 7) {\n                  m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n                }\n\n                _.dirtyT = 1;\n                el.matrix = m;\n              }\n            }\n            /*\\\n             * Element.matrix\n             [ property (object) ]\n             **\n             * Keeps @Matrix object, which represents element transformation\n            \\*/\n\n\n            el.matrix = m;\n            _.sx = sx;\n            _.sy = sy;\n            _.deg = deg;\n            _.dx = dx = m.e;\n            _.dy = dy = m.f;\n\n            if (sx == 1 && sy == 1 && !deg && _.bbox) {\n              _.bbox.x += +dx;\n              _.bbox.y += +dy;\n            } else {\n              _.dirtyT = 1;\n            }\n          },\n              getEmpty = function getEmpty(item) {\n            var l = item[0];\n\n            switch (l.toLowerCase()) {\n              case \"t\":\n                return [l, 0, 0];\n\n              case \"m\":\n                return [l, 1, 0, 0, 1, 0, 0];\n\n              case \"r\":\n                if (item.length == 4) {\n                  return [l, 0, item[2], item[3]];\n                } else {\n                  return [l, 0];\n                }\n\n              case \"s\":\n                if (item.length == 5) {\n                  return [l, 1, 1, item[3], item[4]];\n                } else if (item.length == 3) {\n                  return [l, 1, 1];\n                } else {\n                  return [l, 1];\n                }\n\n            }\n          },\n              equaliseTransform = R._equaliseTransform = function (t1, t2) {\n            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n            t1 = R.parseTransformString(t1) || [];\n            t2 = R.parseTransformString(t2) || [];\n            var maxlength = mmax(t1.length, t2.length),\n                from = [],\n                to = [],\n                i = 0,\n                j,\n                jj,\n                tt1,\n                tt2;\n\n            for (; i < maxlength; i++) {\n              tt1 = t1[i] || getEmpty(t2[i]);\n              tt2 = t2[i] || getEmpty(tt1);\n\n              if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {\n                return;\n              }\n\n              from[i] = [];\n              to[i] = [];\n\n              for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n              }\n            }\n\n            return {\n              from: from,\n              to: to\n            };\n          };\n\n          R._getContainer = function (x, y, w, h) {\n            var container;\n            container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\n\n            if (container == null) {\n              return;\n            }\n\n            if (container.tagName) {\n              if (y == null) {\n                return {\n                  container: container,\n                  width: container.style.pixelWidth || container.offsetWidth,\n                  height: container.style.pixelHeight || container.offsetHeight\n                };\n              } else {\n                return {\n                  container: container,\n                  width: y,\n                  height: w\n                };\n              }\n            }\n\n            return {\n              container: 1,\n              x: x,\n              y: y,\n              width: w,\n              height: h\n            };\n          };\n          /*\\\n           * Raphael.pathToRelative\n           [ method ]\n           **\n           * Utility method\n           **\n           * Converts path to relative form\n           > Parameters\n           - pathString (string|array) path string or array of segments\n           = (array) array of segments.\n          \\*/\n\n\n          R.pathToRelative = pathToRelative;\n          R._engine = {};\n          /*\\\n           * Raphael.path2curve\n           [ method ]\n           **\n           * Utility method\n           **\n           * Converts path to a new path where all segments are cubic bezier curves.\n           > Parameters\n           - pathString (string|array) path string or array of segments\n           = (array) array of segments.\n          \\*/\n\n          R.path2curve = path2curve;\n          /*\\\n           * Raphael.matrix\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns matrix based on given parameters.\n           > Parameters\n           - a (number)\n           - b (number)\n           - c (number)\n           - d (number)\n           - e (number)\n           - f (number)\n           = (object) @Matrix\n          \\*/\n\n          R.matrix = function (a, b, c, d, e, f) {\n            return new Matrix(a, b, c, d, e, f);\n          };\n\n          function Matrix(a, b, c, d, e, f) {\n            if (a != null) {\n              this.a = +a;\n              this.b = +b;\n              this.c = +c;\n              this.d = +d;\n              this.e = +e;\n              this.f = +f;\n            } else {\n              this.a = 1;\n              this.b = 0;\n              this.c = 0;\n              this.d = 1;\n              this.e = 0;\n              this.f = 0;\n            }\n          }\n\n          (function (matrixproto) {\n            /*\\\n             * Matrix.add\n             [ method ]\n             **\n             * Adds given matrix to existing one.\n             > Parameters\n             - a (number)\n             - b (number)\n             - c (number)\n             - d (number)\n             - e (number)\n             - f (number)\n             or\n             - matrix (object) @Matrix\n            \\*/\n            matrixproto.add = function (a, b, c, d, e, f) {\n              var out = [[], [], []],\n                  m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                  matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                  x,\n                  y,\n                  z,\n                  res;\n\n              if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n              }\n\n              for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                  res = 0;\n\n                  for (z = 0; z < 3; z++) {\n                    res += m[x][z] * matrix[z][y];\n                  }\n\n                  out[x][y] = res;\n                }\n              }\n\n              this.a = out[0][0];\n              this.b = out[1][0];\n              this.c = out[0][1];\n              this.d = out[1][1];\n              this.e = out[0][2];\n              this.f = out[1][2];\n            };\n            /*\\\n             * Matrix.invert\n             [ method ]\n             **\n             * Returns inverted version of the matrix\n             = (object) @Matrix\n            \\*/\n\n\n            matrixproto.invert = function () {\n              var me = this,\n                  x = me.a * me.d - me.b * me.c;\n              return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n            };\n            /*\\\n             * Matrix.clone\n             [ method ]\n             **\n             * Returns copy of the matrix\n             = (object) @Matrix\n            \\*/\n\n\n            matrixproto.clone = function () {\n              return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n            };\n            /*\\\n             * Matrix.translate\n             [ method ]\n             **\n             * Translate the matrix\n             > Parameters\n             - x (number)\n             - y (number)\n            \\*/\n\n\n            matrixproto.translate = function (x, y) {\n              this.add(1, 0, 0, 1, x, y);\n            };\n            /*\\\n             * Matrix.scale\n             [ method ]\n             **\n             * Scales the matrix\n             > Parameters\n             - x (number)\n             - y (number) #optional\n             - cx (number) #optional\n             - cy (number) #optional\n            \\*/\n\n\n            matrixproto.scale = function (x, y, cx, cy) {\n              y == null && (y = x);\n              (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n              this.add(x, 0, 0, y, 0, 0);\n              (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            };\n            /*\\\n             * Matrix.rotate\n             [ method ]\n             **\n             * Rotates the matrix\n             > Parameters\n             - a (number)\n             - x (number)\n             - y (number)\n            \\*/\n\n\n            matrixproto.rotate = function (a, x, y) {\n              a = R.rad(a);\n              x = x || 0;\n              y = y || 0;\n              var cos = +math.cos(a).toFixed(9),\n                  sin = +math.sin(a).toFixed(9);\n              this.add(cos, sin, -sin, cos, x, y);\n              this.add(1, 0, 0, 1, -x, -y);\n            };\n            /*\\\n             * Matrix.x\n             [ method ]\n             **\n             * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n             > Parameters\n             - x (number)\n             - y (number)\n             = (number) x\n            \\*/\n\n\n            matrixproto.x = function (x, y) {\n              return x * this.a + y * this.c + this.e;\n            };\n            /*\\\n             * Matrix.y\n             [ method ]\n             **\n             * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n             > Parameters\n             - x (number)\n             - y (number)\n             = (number) y\n            \\*/\n\n\n            matrixproto.y = function (x, y) {\n              return x * this.b + y * this.d + this.f;\n            };\n\n            matrixproto.get = function (i) {\n              return +this[Str.fromCharCode(97 + i)].toFixed(4);\n            };\n\n            matrixproto.toString = function () {\n              return R.svg ? \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n            };\n\n            matrixproto.toFilter = function () {\n              return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) + \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) + \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\n            };\n\n            matrixproto.offset = function () {\n              return [this.e.toFixed(4), this.f.toFixed(4)];\n            };\n\n            function norm(a) {\n              return a[0] * a[0] + a[1] * a[1];\n            }\n\n            function normalize(a) {\n              var mag = math.sqrt(norm(a));\n              a[0] && (a[0] /= mag);\n              a[1] && (a[1] /= mag);\n            }\n            /*\\\n             * Matrix.split\n             [ method ]\n             **\n             * Splits matrix into primitive transformations\n             = (object) in format:\n             o dx (number) translation by x\n             o dy (number) translation by y\n             o scalex (number) scale by x\n             o scaley (number) scale by y\n             o shear (number) shear\n             o rotate (number) rotation in deg\n             o isSimple (boolean) could it be represented via simple transformations\n            \\*/\n\n\n            matrixproto.split = function () {\n              var out = {}; // translation\n\n              out.dx = this.e;\n              out.dy = this.f; // scale and shear\n\n              var row = [[this.a, this.c], [this.b, this.d]];\n              out.scalex = math.sqrt(norm(row[0]));\n              normalize(row[0]);\n              out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n              row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n              out.scaley = math.sqrt(norm(row[1]));\n              normalize(row[1]);\n              out.shear /= out.scaley; // rotation\n\n              var sin = -row[0][1],\n                  cos = row[1][1];\n\n              if (cos < 0) {\n                out.rotate = R.deg(math.acos(cos));\n\n                if (sin < 0) {\n                  out.rotate = 360 - out.rotate;\n                }\n              } else {\n                out.rotate = R.deg(math.asin(sin));\n              }\n\n              out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n              out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n              out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n              return out;\n            };\n            /*\\\n             * Matrix.toTransformString\n             [ method ]\n             **\n             * Return transform string that represents given matrix\n             = (string) transform string\n            \\*/\n\n\n            matrixproto.toTransformString = function (shorter) {\n              var s = shorter || this[split]();\n\n              if (s.isSimple) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) + (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\n              } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n              }\n            };\n          })(Matrix.prototype);\n\n          var preventDefault = function preventDefault() {\n            this.returnValue = false;\n          },\n              preventTouch = function preventTouch() {\n            return this.originalEvent.preventDefault();\n          },\n              stopPropagation = function stopPropagation() {\n            this.cancelBubble = true;\n          },\n              stopTouch = function stopTouch() {\n            return this.originalEvent.stopPropagation();\n          },\n              getEventPosition = function getEventPosition(e) {\n            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n            return {\n              x: e.clientX + scrollX,\n              y: e.clientY + scrollY\n            };\n          },\n              addEvent = function () {\n            if (g.doc.addEventListener) {\n              return function (obj, type, fn, element) {\n                var f = function f(e) {\n                  var pos = getEventPosition(e);\n                  return fn.call(element, e, pos.x, pos.y);\n                };\n\n                obj.addEventListener(type, f, false);\n\n                if (supportsTouch && touchMap[type]) {\n                  var _f = function _f(e) {\n                    var pos = getEventPosition(e),\n                        olde = e;\n\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                      if (e.targetTouches[i].target == obj) {\n                        e = e.targetTouches[i];\n                        e.originalEvent = olde;\n                        e.preventDefault = preventTouch;\n                        e.stopPropagation = stopTouch;\n                        break;\n                      }\n                    }\n\n                    return fn.call(element, e, pos.x, pos.y);\n                  };\n\n                  obj.addEventListener(touchMap[type], _f, false);\n                }\n\n                return function () {\n                  obj.removeEventListener(type, f, false);\n                  if (supportsTouch && touchMap[type]) obj.removeEventListener(touchMap[type], _f, false);\n                  return true;\n                };\n              };\n            } else if (g.doc.attachEvent) {\n              return function (obj, type, fn, element) {\n                var f = function f(e) {\n                  e = e || g.win.event;\n                  var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                      scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                      x = e.clientX + scrollX,\n                      y = e.clientY + scrollY;\n                  e.preventDefault = e.preventDefault || preventDefault;\n                  e.stopPropagation = e.stopPropagation || stopPropagation;\n                  return fn.call(element, e, x, y);\n                };\n\n                obj.attachEvent(\"on\" + type, f);\n\n                var detacher = function detacher() {\n                  obj.detachEvent(\"on\" + type, f);\n                  return true;\n                };\n\n                return detacher;\n              };\n            }\n          }(),\n              drag = [],\n              dragMove = function dragMove(e) {\n            var x = e.clientX,\n                y = e.clientY,\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                dragi,\n                j = drag.length;\n\n            while (j--) {\n              dragi = drag[j];\n\n              if (supportsTouch && e.touches) {\n                var i = e.touches.length,\n                    touch;\n\n                while (i--) {\n                  touch = e.touches[i];\n\n                  if (touch.identifier == dragi.el._drag.id) {\n                    x = touch.clientX;\n                    y = touch.clientY;\n                    (e.originalEvent ? e.originalEvent : e).preventDefault();\n                    break;\n                  }\n                }\n              } else {\n                e.preventDefault();\n              }\n\n              var node = dragi.el.node,\n                  o,\n                  next = node.nextSibling,\n                  parent = node.parentNode,\n                  display = node.style.display;\n              g.win.opera && parent.removeChild(node);\n              node.style.display = \"none\";\n              o = dragi.el.paper.getElementByPoint(x, y);\n              node.style.display = display;\n              g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n              o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\n              x += scrollX;\n              y += scrollY;\n              eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n            }\n          },\n              dragUp = function dragUp(e) {\n            R.unmousemove(dragMove).unmouseup(dragUp);\n            var i = drag.length,\n                dragi;\n\n            while (i--) {\n              dragi = drag[i];\n              dragi.el._drag = {};\n              eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            }\n\n            drag = [];\n          },\n\n          /*\\\n           * Raphael.el\n           [ property (object) ]\n           **\n           * You can add your own method to elements. This is useful when you want to hack default functionality or\n           * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\n           * you can redefine element method at any time. Expending element methods wouldn’t affect set.\n           > Usage\n           | Raphael.el.red = function () {\n           |     this.attr({fill: \"#f00\"});\n           | };\n           | // then use it\n           | paper.circle(100, 100, 20).red();\n          \\*/\n          elproto = R.el = {};\n          /*\\\n           * Element.click\n           [ method ]\n           **\n           * Adds event handler for click for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unclick\n           [ method ]\n           **\n           * Removes event handler for click for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.dblclick\n           [ method ]\n           **\n           * Adds event handler for double click for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.undblclick\n           [ method ]\n           **\n           * Removes event handler for double click for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mousedown\n           [ method ]\n           **\n           * Adds event handler for mousedown for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmousedown\n           [ method ]\n           **\n           * Removes event handler for mousedown for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mousemove\n           [ method ]\n           **\n           * Adds event handler for mousemove for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmousemove\n           [ method ]\n           **\n           * Removes event handler for mousemove for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseout\n           [ method ]\n           **\n           * Adds event handler for mouseout for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseout\n           [ method ]\n           **\n           * Removes event handler for mouseout for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseover\n           [ method ]\n           **\n           * Adds event handler for mouseover for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseover\n           [ method ]\n           **\n           * Removes event handler for mouseover for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseup\n           [ method ]\n           **\n           * Adds event handler for mouseup for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseup\n           [ method ]\n           **\n           * Removes event handler for mouseup for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchstart\n           [ method ]\n           **\n           * Adds event handler for touchstart for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchstart\n           [ method ]\n           **\n           * Removes event handler for touchstart for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchmove\n           [ method ]\n           **\n           * Adds event handler for touchmove for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchmove\n           [ method ]\n           **\n           * Removes event handler for touchmove for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchend\n           [ method ]\n           **\n           * Adds event handler for touchend for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchend\n           [ method ]\n           **\n           * Removes event handler for touchend for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchcancel\n           [ method ]\n           **\n           * Adds event handler for touchcancel for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchcancel\n           [ method ]\n           **\n           * Removes event handler for touchcancel for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n\n          for (var i = events.length; i--;) {\n            (function (eventName) {\n              R[eventName] = elproto[eventName] = function (fn, scope) {\n                if (R.is(fn, \"function\")) {\n                  this.events = this.events || [];\n                  this.events.push({\n                    name: eventName,\n                    f: fn,\n                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)\n                  });\n                }\n\n                return this;\n              };\n\n              R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n\n                while (l--) {\n                  if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                  }\n                }\n\n                return this;\n              };\n            })(events[i]);\n          }\n          /*\\\n           * Element.data\n           [ method ]\n           **\n           * Adds or retrieves given value associated with given key.\n           **\n           * See also @Element.removeData\n           > Parameters\n           - key (string) key to store data\n           - value (any) #optional value to store\n           = (object) @Element\n           * or, if value is not specified:\n           = (any) value\n           * or, if key and value are not specified:\n           = (object) Key/value pairs for all the data associated with the element.\n           > Usage\n           | for (var i = 0, i < 5, i++) {\n           |     paper.circle(10 + 15 * i, 10, 10)\n           |          .attr({fill: \"#000\"})\n           |          .data(\"i\", i)\n           |          .click(function () {\n           |             alert(this.data(\"i\"));\n           |          });\n           | }\n          \\*/\n\n\n          elproto.data = function (key, value) {\n            var data = eldata[this.id] = eldata[this.id] || {};\n\n            if (arguments.length == 0) {\n              return data;\n            }\n\n            if (arguments.length == 1) {\n              if (R.is(key, \"object\")) {\n                for (var i in key) {\n                  if (key[has](i)) {\n                    this.data(i, key[i]);\n                  }\n                }\n\n                return this;\n              }\n\n              eve(\"raphael.data.get.\" + this.id, this, data[key], key);\n              return data[key];\n            }\n\n            data[key] = value;\n            eve(\"raphael.data.set.\" + this.id, this, value, key);\n            return this;\n          };\n          /*\\\n           * Element.removeData\n           [ method ]\n           **\n           * Removes value associated with an element by given key.\n           * If key is not provided, removes all the data of the element.\n           > Parameters\n           - key (string) #optional key\n           = (object) @Element\n          \\*/\n\n\n          elproto.removeData = function (key) {\n            if (key == null) {\n              delete eldata[this.id];\n            } else {\n              eldata[this.id] && delete eldata[this.id][key];\n            }\n\n            return this;\n          };\n          /*\\\n          * Element.getData\n          [ method ]\n          **\n          * Retrieves the element data\n          = (object) data\n          \\*/\n\n\n          elproto.getData = function () {\n            return clone(eldata[this.id] || {});\n          };\n          /*\\\n           * Element.hover\n           [ method ]\n           **\n           * Adds event handlers for hover for the element.\n           > Parameters\n           - f_in (function) handler for hover in\n           - f_out (function) handler for hover out\n           - icontext (object) #optional context for hover in handler\n           - ocontext (object) #optional context for hover out handler\n           = (object) @Element\n          \\*/\n\n\n          elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n          };\n          /*\\\n           * Element.unhover\n           [ method ]\n           **\n           * Removes event handlers for hover for the element.\n           > Parameters\n           - f_in (function) handler for hover in\n           - f_out (function) handler for hover out\n           = (object) @Element\n          \\*/\n\n\n          elproto.unhover = function (f_in, f_out) {\n            return this.unmouseover(f_in).unmouseout(f_out);\n          };\n\n          var draggable = [];\n          /*\\\n           * Element.drag\n           [ method ]\n           **\n           * Adds event handlers for drag of the element.\n           > Parameters\n           - onmove (function) handler for moving\n           - onstart (function) handler for drag start\n           - onend (function) handler for drag end\n           - mcontext (object) #optional context for moving handler\n           - scontext (object) #optional context for drag start handler\n           - econtext (object) #optional context for drag end handler\n           * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,\n           * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\n           * `drag.over.<id>` will be fired as well.\n           *\n           * Start event and start handler will be called in specified context or in context of the element with following parameters:\n           o x (number) x position of the mouse\n           o y (number) y position of the mouse\n           o event (object) DOM event object\n           * Move event and move handler will be called in specified context or in context of the element with following parameters:\n           o dx (number) shift by x from the start point\n           o dy (number) shift by y from the start point\n           o x (number) x position of the mouse\n           o y (number) y position of the mouse\n           o event (object) DOM event object\n           * End event and end handler will be called in specified context or in context of the element with following parameters:\n           o event (object) DOM event object\n           = (object) @Element\n          \\*/\n\n          elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n            function start(e) {\n              (e.originalEvent || e).preventDefault();\n              var x = e.clientX,\n                  y = e.clientY,\n                  scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                  scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n              this._drag.id = e.identifier;\n\n              if (supportsTouch && e.touches) {\n                var i = e.touches.length,\n                    touch;\n\n                while (i--) {\n                  touch = e.touches[i];\n                  this._drag.id = touch.identifier;\n\n                  if (touch.identifier == this._drag.id) {\n                    x = touch.clientX;\n                    y = touch.clientY;\n                    break;\n                  }\n                }\n              }\n\n              this._drag.x = x + scrollX;\n              this._drag.y = y + scrollY;\n              !drag.length && R.mousemove(dragMove).mouseup(dragUp);\n              drag.push({\n                el: this,\n                move_scope: move_scope,\n                start_scope: start_scope,\n                end_scope: end_scope\n              });\n              onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\n              onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\n              onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\n              eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, this._drag.x, this._drag.y, e);\n            }\n\n            this._drag = {};\n            draggable.push({\n              el: this,\n              start: start\n            });\n            this.mousedown(start);\n            return this;\n          };\n          /*\\\n           * Element.onDragOver\n           [ method ]\n           **\n           * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\n           > Parameters\n           - f (function) handler for event, first argument would be the element you are dragging over\n          \\*/\n\n\n          elproto.onDragOver = function (f) {\n            f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\n          };\n          /*\\\n           * Element.undrag\n           [ method ]\n           **\n           * Removes all drag event handlers from given element.\n          \\*/\n\n\n          elproto.undrag = function () {\n            var i = draggable.length;\n\n            while (i--) {\n              if (draggable[i].el == this) {\n                this.unmousedown(draggable[i].start);\n                draggable.splice(i, 1);\n                eve.unbind(\"raphael.drag.*.\" + this.id);\n              }\n            }\n\n            !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\n            drag = [];\n          };\n          /*\\\n           * Paper.circle\n           [ method ]\n           **\n           * Draws a circle.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the centre\n           - y (number) y coordinate of the centre\n           - r (number) radius\n           = (object) Raphaël element object with type “circle”\n           **\n           > Usage\n           | var c = paper.circle(50, 50, 40);\n          \\*/\n\n\n          paperproto.circle = function (x, y, r) {\n            var out = R._engine.circle(this, x || 0, y || 0, r || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.rect\n           [ method ]\n           *\n           * Draws a rectangle.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the top left corner\n           - y (number) y coordinate of the top left corner\n           - width (number) width\n           - height (number) height\n           - r (number) #optional radius for rounded corners, default is 0\n           = (object) Raphaël element object with type “rect”\n           **\n           > Usage\n           | // regular rectangle\n           | var c = paper.rect(10, 10, 50, 50);\n           | // rectangle with rounded corners\n           | var c = paper.rect(40, 40, 50, 50, 10);\n          \\*/\n\n\n          paperproto.rect = function (x, y, w, h, r) {\n            var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.ellipse\n           [ method ]\n           **\n           * Draws an ellipse.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the centre\n           - y (number) y coordinate of the centre\n           - rx (number) horizontal radius\n           - ry (number) vertical radius\n           = (object) Raphaël element object with type “ellipse”\n           **\n           > Usage\n           | var c = paper.ellipse(50, 50, 40, 20);\n          \\*/\n\n\n          paperproto.ellipse = function (x, y, rx, ry) {\n            var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.path\n           [ method ]\n           **\n           * Creates a path element by given path data string.\n           > Parameters\n           - pathString (string) #optional path string in SVG format.\n           * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\n           | \"M10,20L30,40\"\n           * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.\n           *\n           # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\n           # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n           # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n           # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n           # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n           # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n           # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n           # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n           # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n           # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n           # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n           # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n           # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n           * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.\n           * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.\n           > Usage\n           | var c = paper.path(\"M10 10L90 90\");\n           | // draw a diagonal line:\n           | // move to 10,10, line to 90,90\n           * For example of path strings, check out these icons: http://raphaeljs.com/icons/\n          \\*/\n\n\n          paperproto.path = function (pathString) {\n            pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\n\n            var out = R._engine.path(R.format[apply](R, arguments), this);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.image\n           [ method ]\n           **\n           * Embeds an image into the surface.\n           **\n           > Parameters\n           **\n           - src (string) URI of the source image\n           - x (number) x coordinate position\n           - y (number) y coordinate position\n           - width (number) width of the image\n           - height (number) height of the image\n           = (object) Raphaël element object with type “image”\n           **\n           > Usage\n           | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n          \\*/\n\n\n          paperproto.image = function (src, x, y, w, h) {\n            var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.text\n           [ method ]\n           **\n           * Draws a text string. If you need line breaks, put “\\n” in the string.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate position\n           - y (number) y coordinate position\n           - text (string) The text string to draw\n           = (object) Raphaël element object with type “text”\n           **\n           > Usage\n           | var t = paper.text(50, 50, \"Raphaël\\nkicks\\nbutt!\");\n          \\*/\n\n\n          paperproto.text = function (x, y, text) {\n            var out = R._engine.text(this, x || 0, y || 0, Str(text));\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.set\n           [ method ]\n           **\n           * Creates array-like object to keep and operate several elements at once.\n           * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.\n           * Sets act as pseudo elements — all methods available to an element can be used on a set.\n           = (object) array-like object that represents set of elements\n           **\n           > Usage\n           | var st = paper.set();\n           | st.push(\n           |     paper.circle(10, 10, 5),\n           |     paper.circle(30, 10, 5)\n           | );\n           | st.attr({fill: \"red\"}); // changes the fill of both circles\n          \\*/\n\n\n          paperproto.set = function (itemsArray) {\n            !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\n            var out = new Set(itemsArray);\n            this.__set__ && this.__set__.push(out);\n            out[\"paper\"] = this;\n            out[\"type\"] = \"set\";\n            return out;\n          };\n          /*\\\n           * Paper.setStart\n           [ method ]\n           **\n           * Creates @Paper.set. All elements that will be created after calling this method and before calling\n           * @Paper.setFinish will be added to the set.\n           **\n           > Usage\n           | paper.setStart();\n           | paper.circle(10, 10, 5),\n           | paper.circle(30, 10, 5)\n           | var st = paper.setFinish();\n           | st.attr({fill: \"red\"}); // changes the fill of both circles\n          \\*/\n\n\n          paperproto.setStart = function (set) {\n            this.__set__ = set || this.set();\n          };\n          /*\\\n           * Paper.setFinish\n           [ method ]\n           **\n           * See @Paper.setStart. This method finishes catching and returns resulting set.\n           **\n           = (object) set\n          \\*/\n\n\n          paperproto.setFinish = function (set) {\n            var out = this.__set__;\n            delete this.__set__;\n            return out;\n          };\n          /*\\\n           * Paper.getSize\n           [ method ]\n           **\n           * Obtains current paper actual size.\n           **\n           = (object)\n           \\*/\n\n\n          paperproto.getSize = function () {\n            var container = this.canvas.parentNode;\n            return {\n              width: container.offsetWidth,\n              height: container.offsetHeight\n            };\n          };\n          /*\\\n           * Paper.setSize\n           [ method ]\n           **\n           * If you need to change dimensions of the canvas call this method\n           **\n           > Parameters\n           **\n           - width (number) new width of the canvas\n           - height (number) new height of the canvas\n          \\*/\n\n\n          paperproto.setSize = function (width, height) {\n            return R._engine.setSize.call(this, width, height);\n          };\n          /*\\\n           * Paper.setViewBox\n           [ method ]\n           **\n           * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\n           * specifying new boundaries.\n           **\n           > Parameters\n           **\n           - x (number) new x position, default is `0`\n           - y (number) new y position, default is `0`\n           - w (number) new width of the canvas\n           - h (number) new height of the canvas\n           - fit (boolean) `true` if you want graphics to fit into new boundary box\n          \\*/\n\n\n          paperproto.setViewBox = function (x, y, w, h, fit) {\n            return R._engine.setViewBox.call(this, x, y, w, h, fit);\n          };\n          /*\\\n           * Paper.top\n           [ property ]\n           **\n           * Points to the topmost element on the paper\n          \\*/\n\n          /*\\\n           * Paper.bottom\n           [ property ]\n           **\n           * Points to the bottom element on the paper\n          \\*/\n\n\n          paperproto.top = paperproto.bottom = null;\n          /*\\\n           * Paper.raphael\n           [ property ]\n           **\n           * Points to the @Raphael object/function\n          \\*/\n\n          paperproto.raphael = R;\n\n          var getOffset = function getOffset(elem) {\n            var box = elem.getBoundingClientRect(),\n                doc = elem.ownerDocument,\n                body = doc.body,\n                docElem = doc.documentElement,\n                clientTop = docElem.clientTop || body.clientTop || 0,\n                clientLeft = docElem.clientLeft || body.clientLeft || 0,\n                top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,\n                left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n            return {\n              y: top,\n              x: left\n            };\n          };\n          /*\\\n           * Paper.getElementByPoint\n           [ method ]\n           **\n           * Returns you topmost element under given point.\n           **\n           = (object) Raphaël element object\n           > Parameters\n           **\n           - x (number) x coordinate from the top left corner of the window\n           - y (number) y coordinate from the top left corner of the window\n           > Usage\n           | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n          \\*/\n\n\n          paperproto.getElementByPoint = function (x, y) {\n            var paper = this,\n                svg = paper.canvas,\n                target = g.doc.elementFromPoint(x, y);\n\n            if (g.win.opera && target.tagName == \"svg\") {\n              var so = getOffset(svg),\n                  sr = svg.createSVGRect();\n              sr.x = x - so.x;\n              sr.y = y - so.y;\n              sr.width = sr.height = 1;\n              var hits = svg.getIntersectionList(sr, null);\n\n              if (hits.length) {\n                target = hits[hits.length - 1];\n              }\n            }\n\n            if (!target) {\n              return null;\n            }\n\n            while (target.parentNode && target != svg.parentNode && !target.raphael) {\n              target = target.parentNode;\n            }\n\n            target == paper.canvas.parentNode && (target = svg);\n            target = target && target.raphael ? paper.getById(target.raphaelid) : null;\n            return target;\n          };\n          /*\\\n           * Paper.getElementsByBBox\n           [ method ]\n           **\n           * Returns set of elements that have an intersecting bounding box\n           **\n           > Parameters\n           **\n           - bbox (object) bbox to check with\n           = (object) @Set\n           \\*/\n\n\n          paperproto.getElementsByBBox = function (bbox) {\n            var set = this.set();\n            this.forEach(function (el) {\n              if (R.isBBoxIntersect(el.getBBox(), bbox)) {\n                set.push(el);\n              }\n            });\n            return set;\n          };\n          /*\\\n           * Paper.getById\n           [ method ]\n           **\n           * Returns you element by its internal ID.\n           **\n           > Parameters\n           **\n           - id (number) id\n           = (object) Raphaël element object\n          \\*/\n\n\n          paperproto.getById = function (id) {\n            var bot = this.bottom;\n\n            while (bot) {\n              if (bot.id == id) {\n                return bot;\n              }\n\n              bot = bot.next;\n            }\n\n            return null;\n          };\n          /*\\\n           * Paper.forEach\n           [ method ]\n           **\n           * Executes given function for each element on the paper\n           *\n           * If callback function returns `false` it will stop loop running.\n           **\n           > Parameters\n           **\n           - callback (function) function to run\n           - thisArg (object) context object for the callback\n           = (object) Paper object\n           > Usage\n           | paper.forEach(function (el) {\n           |     el.attr({ stroke: \"blue\" });\n           | });\n          \\*/\n\n\n          paperproto.forEach = function (callback, thisArg) {\n            var bot = this.bottom;\n\n            while (bot) {\n              if (callback.call(thisArg, bot) === false) {\n                return this;\n              }\n\n              bot = bot.next;\n            }\n\n            return this;\n          };\n          /*\\\n           * Paper.getElementsByPoint\n           [ method ]\n           **\n           * Returns set of elements that have common point inside\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (object) @Set\n          \\*/\n\n\n          paperproto.getElementsByPoint = function (x, y) {\n            var set = this.set();\n            this.forEach(function (el) {\n              if (el.isPointInside(x, y)) {\n                set.push(el);\n              }\n            });\n            return set;\n          };\n\n          function x_y() {\n            return this.x + S + this.y;\n          }\n\n          function x_y_w_h() {\n            return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n          }\n          /*\\\n           * Element.isPointInside\n           [ method ]\n           **\n           * Determine if given point is inside this element’s shape\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (boolean) `true` if point inside the shape\n          \\*/\n\n\n          elproto.isPointInside = function (x, y) {\n            var rp = this.realPath = getPath[this.type](this);\n\n            if (this.attr('transform') && this.attr('transform').length) {\n              rp = R.transformPath(rp, this.attr('transform'));\n            }\n\n            return R.isPointInsidePath(rp, x, y);\n          };\n          /*\\\n           * Element.getBBox\n           [ method ]\n           **\n           * Return bounding box for a given element\n           **\n           > Parameters\n           **\n           - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\n           = (object) Bounding box object:\n           o {\n           o     x: (number) top left corner x\n           o     y: (number) top left corner y\n           o     x2: (number) bottom right corner x\n           o     y2: (number) bottom right corner y\n           o     width: (number) width\n           o     height: (number) height\n           o }\n          \\*/\n\n\n          elproto.getBBox = function (isWithoutTransform) {\n            if (this.removed) {\n              return {};\n            }\n\n            var _ = this._;\n\n            if (isWithoutTransform) {\n              if (_.dirty || !_.bboxwt) {\n                this.realPath = getPath[this.type](this);\n                _.bboxwt = pathDimensions(this.realPath);\n                _.bboxwt.toString = x_y_w_h;\n                _.dirty = 0;\n              }\n\n              return _.bboxwt;\n            }\n\n            if (_.dirty || _.dirtyT || !_.bbox) {\n              if (_.dirty || !this.realPath) {\n                _.bboxwt = 0;\n                this.realPath = getPath[this.type](this);\n              }\n\n              _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\n              _.bbox.toString = x_y_w_h;\n              _.dirty = _.dirtyT = 0;\n            }\n\n            return _.bbox;\n          };\n          /*\\\n           * Element.clone\n           [ method ]\n           **\n           = (object) clone of a given element\n           **\n          \\*/\n\n\n          elproto.clone = function () {\n            if (this.removed) {\n              return null;\n            }\n\n            var out = this.paper[this.type]().attr(this.attr());\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Element.glow\n           [ method ]\n           **\n           * Return set of elements that create glow-like effect around given element. See @Paper.set.\n           *\n           * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.\n           **\n           > Parameters\n           **\n           - glow (object) #optional parameters object with all properties optional:\n           o {\n           o     width (number) size of the glow, default is `10`\n           o     fill (boolean) will it be filled, default is `false`\n           o     opacity (number) opacity, default is `0.5`\n           o     offsetx (number) horizontal offset, default is `0`\n           o     offsety (number) vertical offset, default is `0`\n           o     color (string) glow colour, default is `black`\n           o }\n           = (object) @Paper.set of elements that represents glow\n          \\*/\n\n\n          elproto.glow = function (glow) {\n            if (this.type == \"text\") {\n              return null;\n            }\n\n            glow = glow || {};\n            var s = {\n              width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\n              fill: glow.fill || false,\n              opacity: glow.opacity == null ? .5 : glow.opacity,\n              offsetx: glow.offsetx || 0,\n              offsety: glow.offsety || 0,\n              color: glow.color || \"#000\"\n            },\n                c = s.width / 2,\n                r = this.paper,\n                out = r.set(),\n                path = this.realPath || getPath[this.type](this);\n            path = this.matrix ? mapPath(path, this.matrix) : path;\n\n            for (var i = 1; i < c + 1; i++) {\n              out.push(r.path(path).attr({\n                stroke: s.color,\n                fill: s.fill ? s.color : \"none\",\n                \"stroke-linejoin\": \"round\",\n                \"stroke-linecap\": \"round\",\n                \"stroke-width\": +(s.width / c * i).toFixed(3),\n                opacity: +(s.opacity / c).toFixed(3)\n              }));\n            }\n\n            return out.insertBefore(this).translate(s.offsetx, s.offsety);\n          };\n\n          var curveslengths = {},\n              getPointAtSegmentLength = function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n            if (length == null) {\n              return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n            } else {\n              return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n            }\n          },\n              getLengthFactory = function getLengthFactory(istotal, subpath) {\n            return function (path, length, onlystart) {\n              path = path2curve(path);\n              var x,\n                  y,\n                  p,\n                  l,\n                  sp = \"\",\n                  subpaths = {},\n                  point,\n                  len = 0;\n\n              for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n\n                if (p[0] == \"M\") {\n                  x = +p[1];\n                  y = +p[2];\n                } else {\n                  l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\n                  if (len + l > length) {\n                    if (subpath && !subpaths.start) {\n                      point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                      sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\n\n                      if (onlystart) {\n                        return sp;\n                      }\n\n                      subpaths.start = sp;\n                      sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\n                      len += l;\n                      x = +p[5];\n                      y = +p[6];\n                      continue;\n                    }\n\n                    if (!istotal && !subpath) {\n                      point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                      return {\n                        x: point.x,\n                        y: point.y,\n                        alpha: point.alpha\n                      };\n                    }\n                  }\n\n                  len += l;\n                  x = +p[5];\n                  y = +p[6];\n                }\n\n                sp += p.shift() + p;\n              }\n\n              subpaths.end = sp;\n              point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n              point.alpha && (point = {\n                x: point.x,\n                y: point.y,\n                alpha: point.alpha\n              });\n              return point;\n            };\n          };\n\n          var getTotalLength = getLengthFactory(1),\n              getPointAtLength = getLengthFactory(),\n              getSubpathsAtLength = getLengthFactory(0, 1);\n          /*\\\n           * Raphael.getTotalLength\n           [ method ]\n           **\n           * Returns length of the given path in pixels.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string.\n           **\n           = (number) length.\n          \\*/\n\n          R.getTotalLength = getTotalLength;\n          /*\\\n           * Raphael.getPointAtLength\n           [ method ]\n           **\n           * Return coordinates of the point located at the given length on the given path.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string\n           - length (number)\n           **\n           = (object) representation of the point:\n           o {\n           o     x: (number) x coordinate\n           o     y: (number) y coordinate\n           o     alpha: (number) angle of derivative\n           o }\n          \\*/\n\n          R.getPointAtLength = getPointAtLength;\n          /*\\\n           * Raphael.getSubpath\n           [ method ]\n           **\n           * Return subpath of a given path from given length to given length.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string\n           - from (number) position of the start of the segment\n           - to (number) position of the end of the segment\n           **\n           = (string) pathstring for the segment\n          \\*/\n\n          R.getSubpath = function (path, from, to) {\n            if (this.getTotalLength(path) - to < 1e-6) {\n              return getSubpathsAtLength(path, from).end;\n            }\n\n            var a = getSubpathsAtLength(path, to, 1);\n            return from ? getSubpathsAtLength(a, from).end : a;\n          };\n          /*\\\n           * Element.getTotalLength\n           [ method ]\n           **\n           * Returns length of the path in pixels. Only works for element of “path” type.\n           = (number) length.\n          \\*/\n\n\n          elproto.getTotalLength = function () {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            if (this.node.getTotalLength) {\n              return this.node.getTotalLength();\n            }\n\n            return getTotalLength(path);\n          };\n          /*\\\n           * Element.getPointAtLength\n           [ method ]\n           **\n           * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.\n           **\n           > Parameters\n           **\n           - length (number)\n           **\n           = (object) representation of the point:\n           o {\n           o     x: (number) x coordinate\n           o     y: (number) y coordinate\n           o     alpha: (number) angle of derivative\n           o }\n          \\*/\n\n\n          elproto.getPointAtLength = function (length) {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            return getPointAtLength(path, length);\n          };\n          /*\\\n           * Element.getPath\n           [ method ]\n           **\n           * Returns path of the element. Only works for elements of “path” type and simple elements like circle.\n           = (object) path\n           **\n          \\*/\n\n\n          elproto.getPath = function () {\n            var path,\n                getPath = R._getPath[this.type];\n\n            if (this.type == \"text\" || this.type == \"set\") {\n              return;\n            }\n\n            if (getPath) {\n              path = getPath(this);\n            }\n\n            return path;\n          };\n          /*\\\n           * Element.getSubpath\n           [ method ]\n           **\n           * Return subpath of a given element from given length to given length. Only works for element of “path” type.\n           **\n           > Parameters\n           **\n           - from (number) position of the start of the segment\n           - to (number) position of the end of the segment\n           **\n           = (string) pathstring for the segment\n          \\*/\n\n\n          elproto.getSubpath = function (from, to) {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            return R.getSubpath(path, from, to);\n          };\n          /*\\\n           * Raphael.easing_formulas\n           [ property ]\n           **\n           * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\n           # <ul>\n           #     <li>“linear”</li>\n           #     <li>“&lt;” or “easeIn” or “ease-in”</li>\n           #     <li>“>” or “easeOut” or “ease-out”</li>\n           #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>\n           #     <li>“backIn” or “back-in”</li>\n           #     <li>“backOut” or “back-out”</li>\n           #     <li>“elastic”</li>\n           #     <li>“bounce”</li>\n           # </ul>\n           # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\n          \\*/\n\n\n          var ef = R.easing_formulas = {\n            linear: function linear(n) {\n              return n;\n            },\n            \"<\": function _(n) {\n              return pow(n, 1.7);\n            },\n            \">\": function _(n) {\n              return pow(n, .48);\n            },\n            \"<>\": function _(n) {\n              var q = .48 - n / 1.04,\n                  Q = math.sqrt(.1734 + q * q),\n                  x = Q - q,\n                  X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n                  y = -Q - q,\n                  Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n                  t = X + Y + .5;\n              return (1 - t) * 3 * t * t + t * t * t;\n            },\n            backIn: function backIn(n) {\n              var s = 1.70158;\n              return n * n * ((s + 1) * n - s);\n            },\n            backOut: function backOut(n) {\n              n = n - 1;\n              var s = 1.70158;\n              return n * n * ((s + 1) * n + s) + 1;\n            },\n            elastic: function elastic(n) {\n              if (n == !!n) {\n                return n;\n              }\n\n              return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\n            },\n            bounce: function bounce(n) {\n              var s = 7.5625,\n                  p = 2.75,\n                  l;\n\n              if (n < 1 / p) {\n                l = s * n * n;\n              } else {\n                if (n < 2 / p) {\n                  n -= 1.5 / p;\n                  l = s * n * n + .75;\n                } else {\n                  if (n < 2.5 / p) {\n                    n -= 2.25 / p;\n                    l = s * n * n + .9375;\n                  } else {\n                    n -= 2.625 / p;\n                    l = s * n * n + .984375;\n                  }\n                }\n              }\n\n              return l;\n            }\n          };\n          ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\n          ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\n          ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\n          ef[\"back-in\"] = ef.backIn;\n          ef[\"back-out\"] = ef.backOut;\n\n          var animationElements = [],\n              requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n            setTimeout(callback, 16);\n          },\n              animation = function animation() {\n            var Now = +new Date(),\n                l = 0;\n\n            for (; l < animationElements.length; l++) {\n              var e = animationElements[l];\n\n              if (e.el.removed || e.paused) {\n                continue;\n              }\n\n              var time = Now - e.start,\n                  ms = e.ms,\n                  easing = e.easing,\n                  from = e.from,\n                  diff = e.diff,\n                  to = e.to,\n                  t = e.t,\n                  that = e.el,\n                  set = {},\n                  now,\n                  init = {},\n                  key;\n\n              if (e.initstatus) {\n                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\n                e.status = e.initstatus;\n                delete e.initstatus;\n                e.stop && animationElements.splice(l--, 1);\n              } else {\n                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\n              }\n\n              if (time < 0) {\n                continue;\n              }\n\n              if (time < ms) {\n                var pos = easing(time / ms);\n\n                for (var attr in from) {\n                  if (from[has](attr)) {\n                    switch (availableAnimAttrs[attr]) {\n                      case nu:\n                        now = +from[attr] + pos * ms * diff[attr];\n                        break;\n\n                      case \"colour\":\n                        now = \"rgb(\" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b))].join(\",\") + \")\";\n                        break;\n\n                      case \"path\":\n                        now = [];\n\n                        for (var i = 0, ii = from[attr].length; i < ii; i++) {\n                          now[i] = [from[attr][i][0]];\n\n                          for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                            now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\n                          }\n\n                          now[i] = now[i].join(S);\n                        }\n\n                        now = now.join(S);\n                        break;\n\n                      case \"transform\":\n                        if (diff[attr].real) {\n                          now = [];\n\n                          for (i = 0, ii = from[attr].length; i < ii; i++) {\n                            now[i] = [from[attr][i][0]];\n\n                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                              now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\n                            }\n                          }\n                        } else {\n                          var get = function get(i) {\n                            return +from[attr][i] + pos * ms * diff[attr][i];\n                          }; // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\n\n\n                          now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\n                        }\n\n                        break;\n\n                      case \"csv\":\n                        if (attr == \"clip-rect\") {\n                          now = [];\n                          i = 4;\n\n                          while (i--) {\n                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];\n                          }\n                        }\n\n                        break;\n\n                      default:\n                        var from2 = [][concat](from[attr]);\n                        now = [];\n                        i = that.paper.customAttributes[attr].length;\n\n                        while (i--) {\n                          now[i] = +from2[i] + pos * ms * diff[attr][i];\n                        }\n\n                        break;\n                    }\n\n                    set[attr] = now;\n                  }\n                }\n\n                that.attr(set);\n\n                (function (id, that, anim) {\n                  setTimeout(function () {\n                    eve(\"raphael.anim.frame.\" + id, that, anim);\n                  });\n                })(that.id, that, e.anim);\n              } else {\n                (function (f, el, a) {\n                  setTimeout(function () {\n                    eve(\"raphael.anim.frame.\" + el.id, el, a);\n                    eve(\"raphael.anim.finish.\" + el.id, el, a);\n                    R.is(f, \"function\") && f.call(el);\n                  });\n                })(e.callback, that, e.anim);\n\n                that.attr(to);\n                animationElements.splice(l--, 1);\n\n                if (e.repeat > 1 && !e.next) {\n                  for (key in to) {\n                    if (to[has](key)) {\n                      init[key] = e.totalOrigin[key];\n                    }\n                  }\n\n                  e.el.attr(init);\n                  runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\n                }\n\n                if (e.next && !e.stop) {\n                  runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\n                }\n              }\n            }\n\n            animationElements.length && requestAnimFrame(animation);\n          },\n              upto255 = function upto255(color) {\n            return color > 255 ? 255 : color < 0 ? 0 : color;\n          };\n          /*\\\n           * Element.animateWith\n           [ method ]\n           **\n           * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\n           **\n           > Parameters\n           **\n           - el (object) element to sync with\n           - anim (object) animation to sync with\n           - params (object) #optional final attributes for the element, see also @Element.attr\n           - ms (number) #optional number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           * or\n           - element (object) element to sync with\n           - anim (object) animation to sync with\n           - animation (object) #optional animation object, see @Raphael.animation\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.animateWith = function (el, anim, params, ms, easing, callback) {\n            var element = this;\n\n            if (element.removed) {\n              callback && callback.call(element);\n              return element;\n            }\n\n            var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\n                x,\n                y;\n            runAnimation(a, element, a.percents[0], null, element.attr());\n\n            for (var i = 0, ii = animationElements.length; i < ii; i++) {\n              if (animationElements[i].anim == anim && animationElements[i].el == el) {\n                animationElements[ii - 1].start = animationElements[i].start;\n                break;\n              }\n            }\n\n            return element; //\n            //\n            // var a = params ? R.animation(params, ms, easing, callback) : anim,\n            //     status = element.status(anim);\n            // return this.animate(a).status(a, status * anim.ms / a.ms);\n          };\n\n          function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\n            var cx = 3 * p1x,\n                bx = 3 * (p2x - p1x) - cx,\n                ax = 1 - cx - bx,\n                cy = 3 * p1y,\n                by = 3 * (p2y - p1y) - cy,\n                ay = 1 - cy - by;\n\n            function sampleCurveX(t) {\n              return ((ax * t + bx) * t + cx) * t;\n            }\n\n            function solve(x, epsilon) {\n              var t = solveCurveX(x, epsilon);\n              return ((ay * t + by) * t + cy) * t;\n            }\n\n            function solveCurveX(x, epsilon) {\n              var t0, t1, t2, x2, d2, i;\n\n              for (t2 = x, i = 0; i < 8; i++) {\n                x2 = sampleCurveX(t2) - x;\n\n                if (abs(x2) < epsilon) {\n                  return t2;\n                }\n\n                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\n\n                if (abs(d2) < 1e-6) {\n                  break;\n                }\n\n                t2 = t2 - x2 / d2;\n              }\n\n              t0 = 0;\n              t1 = 1;\n              t2 = x;\n\n              if (t2 < t0) {\n                return t0;\n              }\n\n              if (t2 > t1) {\n                return t1;\n              }\n\n              while (t0 < t1) {\n                x2 = sampleCurveX(t2);\n\n                if (abs(x2 - x) < epsilon) {\n                  return t2;\n                }\n\n                if (x > x2) {\n                  t0 = t2;\n                } else {\n                  t1 = t2;\n                }\n\n                t2 = (t1 - t0) / 2 + t0;\n              }\n\n              return t2;\n            }\n\n            return solve(t, 1 / (200 * duration));\n          }\n\n          elproto.onAnimation = function (f) {\n            f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\n            return this;\n          };\n\n          function Animation(anim, ms) {\n            var percents = [],\n                newAnim = {};\n            this.ms = ms;\n            this.times = 1;\n\n            if (anim) {\n              for (var attr in anim) {\n                if (anim[has](attr)) {\n                  newAnim[toFloat(attr)] = anim[attr];\n                  percents.push(toFloat(attr));\n                }\n              }\n\n              percents.sort(sortByNumber);\n            }\n\n            this.anim = newAnim;\n            this.top = percents[percents.length - 1];\n            this.percents = percents;\n          }\n          /*\\\n           * Animation.delay\n           [ method ]\n           **\n           * Creates a copy of existing animation object with given delay.\n           **\n           > Parameters\n           **\n           - delay (number) number of ms to pass between animation start and actual animation\n           **\n           = (object) new altered Animation object\n           | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\n           | circle1.animate(anim); // run the given animation immediately\n           | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\n          \\*/\n\n\n          Animation.prototype.delay = function (delay) {\n            var a = new Animation(this.anim, this.ms);\n            a.times = this.times;\n            a.del = +delay || 0;\n            return a;\n          };\n          /*\\\n           * Animation.repeat\n           [ method ]\n           **\n           * Creates a copy of existing animation object with given repetition.\n           **\n           > Parameters\n           **\n           - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\n           **\n           = (object) new altered Animation object\n          \\*/\n\n\n          Animation.prototype.repeat = function (times) {\n            var a = new Animation(this.anim, this.ms);\n            a.del = this.del;\n            a.times = math.floor(mmax(times, 0)) || 1;\n            return a;\n          };\n\n          function runAnimation(anim, element, percent, status, totalOrigin, times) {\n            percent = toFloat(percent);\n            var params,\n                isInAnim,\n                isInAnimSet,\n                percents = [],\n                next,\n                prev,\n                timestamp,\n                ms = anim.ms,\n                from = {},\n                to = {},\n                diff = {};\n\n            if (status) {\n              for (i = 0, ii = animationElements.length; i < ii; i++) {\n                var e = animationElements[i];\n\n                if (e.el.id == element.id && e.anim == anim) {\n                  if (e.percent != percent) {\n                    animationElements.splice(i, 1);\n                    isInAnimSet = 1;\n                  } else {\n                    isInAnim = e;\n                  }\n\n                  element.attr(e.totalOrigin);\n                  break;\n                }\n              }\n            } else {\n              status = +to; // NaN\n            }\n\n            for (var i = 0, ii = anim.percents.length; i < ii; i++) {\n              if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\n                percent = anim.percents[i];\n                prev = anim.percents[i - 1] || 0;\n                ms = ms / anim.top * (percent - prev);\n                next = anim.percents[i + 1];\n                params = anim.anim[percent];\n                break;\n              } else if (status) {\n                element.attr(anim.anim[anim.percents[i]]);\n              }\n            }\n\n            if (!params) {\n              return;\n            }\n\n            if (!isInAnim) {\n              for (var attr in params) {\n                if (params[has](attr)) {\n                  if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\n                    from[attr] = element.attr(attr);\n                    from[attr] == null && (from[attr] = availableAttrs[attr]);\n                    to[attr] = params[attr];\n\n                    switch (availableAnimAttrs[attr]) {\n                      case nu:\n                        diff[attr] = (to[attr] - from[attr]) / ms;\n                        break;\n\n                      case \"colour\":\n                        from[attr] = R.getRGB(from[attr]);\n                        var toColour = R.getRGB(to[attr]);\n                        diff[attr] = {\n                          r: (toColour.r - from[attr].r) / ms,\n                          g: (toColour.g - from[attr].g) / ms,\n                          b: (toColour.b - from[attr].b) / ms\n                        };\n                        break;\n\n                      case \"path\":\n                        var pathes = path2curve(from[attr], to[attr]),\n                            toPath = pathes[1];\n                        from[attr] = pathes[0];\n                        diff[attr] = [];\n\n                        for (i = 0, ii = from[attr].length; i < ii; i++) {\n                          diff[attr][i] = [0];\n\n                          for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                            diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\n                          }\n                        }\n\n                        break;\n\n                      case \"transform\":\n                        var _ = element._,\n                            eq = equaliseTransform(_[attr], to[attr]);\n\n                        if (eq) {\n                          from[attr] = eq.from;\n                          to[attr] = eq.to;\n                          diff[attr] = [];\n                          diff[attr].real = true;\n\n                          for (i = 0, ii = from[attr].length; i < ii; i++) {\n                            diff[attr][i] = [from[attr][i][0]];\n\n                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                              diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\n                            }\n                          }\n                        } else {\n                          var m = element.matrix || new Matrix(),\n                              to2 = {\n                            _: {\n                              transform: _.transform\n                            },\n                            getBBox: function getBBox() {\n                              return element.getBBox(1);\n                            }\n                          };\n                          from[attr] = [m.a, m.b, m.c, m.d, m.e, m.f];\n                          extractTransform(to2, to[attr]);\n                          to[attr] = to2._.transform;\n                          diff[attr] = [(to2.matrix.a - m.a) / ms, (to2.matrix.b - m.b) / ms, (to2.matrix.c - m.c) / ms, (to2.matrix.d - m.d) / ms, (to2.matrix.e - m.e) / ms, (to2.matrix.f - m.f) / ms]; // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\n                          // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\n                          // extractTransform(to2, to[attr]);\n                          // diff[attr] = [\n                          //     (to2._.sx - _.sx) / ms,\n                          //     (to2._.sy - _.sy) / ms,\n                          //     (to2._.deg - _.deg) / ms,\n                          //     (to2._.dx - _.dx) / ms,\n                          //     (to2._.dy - _.dy) / ms\n                          // ];\n                        }\n\n                        break;\n\n                      case \"csv\":\n                        var values = Str(params[attr])[split](separator),\n                            from2 = Str(from[attr])[split](separator);\n\n                        if (attr == \"clip-rect\") {\n                          from[attr] = from2;\n                          diff[attr] = [];\n                          i = from2.length;\n\n                          while (i--) {\n                            diff[attr][i] = (values[i] - from[attr][i]) / ms;\n                          }\n                        }\n\n                        to[attr] = values;\n                        break;\n\n                      default:\n                        values = [][concat](params[attr]);\n                        from2 = [][concat](from[attr]);\n                        diff[attr] = [];\n                        i = element.paper.customAttributes[attr].length;\n\n                        while (i--) {\n                          diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\n                        }\n\n                        break;\n                    }\n                  }\n                }\n              }\n\n              var easing = params.easing,\n                  easyeasy = R.easing_formulas[easing];\n\n              if (!easyeasy) {\n                easyeasy = Str(easing).match(bezierrg);\n\n                if (easyeasy && easyeasy.length == 5) {\n                  var curve = easyeasy;\n\n                  easyeasy = function easyeasy(t) {\n                    return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\n                  };\n                } else {\n                  easyeasy = pipe;\n                }\n              }\n\n              timestamp = params.start || anim.start || +new Date();\n              e = {\n                anim: anim,\n                percent: percent,\n                timestamp: timestamp,\n                start: timestamp + (anim.del || 0),\n                status: 0,\n                initstatus: status || 0,\n                stop: false,\n                ms: ms,\n                easing: easyeasy,\n                from: from,\n                diff: diff,\n                to: to,\n                el: element,\n                callback: params.callback,\n                prev: prev,\n                next: next,\n                repeat: times || anim.times,\n                origin: element.attr(),\n                totalOrigin: totalOrigin\n              };\n              animationElements.push(e);\n\n              if (status && !isInAnim && !isInAnimSet) {\n                e.stop = true;\n                e.start = new Date() - ms * status;\n\n                if (animationElements.length == 1) {\n                  return animation();\n                }\n              }\n\n              if (isInAnimSet) {\n                e.start = new Date() - e.ms * status;\n              }\n\n              animationElements.length == 1 && requestAnimFrame(animation);\n            } else {\n              isInAnim.initstatus = status;\n              isInAnim.start = new Date() - isInAnim.ms * status;\n            }\n\n            eve(\"raphael.anim.start.\" + element.id, element, anim);\n          }\n          /*\\\n           * Raphael.animation\n           [ method ]\n           **\n           * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\n           * See also @Animation.delay and @Animation.repeat methods.\n           **\n           > Parameters\n           **\n           - params (object) final attributes for the element, see also @Element.attr\n           - ms (number) number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           **\n           = (object) @Animation\n          \\*/\n\n\n          R.animation = function (params, ms, easing, callback) {\n            if (params instanceof Animation) {\n              return params;\n            }\n\n            if (R.is(easing, \"function\") || !easing) {\n              callback = callback || easing || null;\n              easing = null;\n            }\n\n            params = Object(params);\n            ms = +ms || 0;\n            var p = {},\n                json,\n                attr;\n\n            for (attr in params) {\n              if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\n                json = true;\n                p[attr] = params[attr];\n              }\n            }\n\n            if (!json) {\n              // if percent-like syntax is used and end-of-all animation callback used\n              if (callback) {\n                // find the last one\n                var lastKey = 0;\n\n                for (var i in params) {\n                  var percent = toInt(i);\n\n                  if (params[has](i) && percent > lastKey) {\n                    lastKey = percent;\n                  }\n                }\n\n                lastKey += '%'; // if already defined callback in the last keyframe, skip\n\n                !params[lastKey].callback && (params[lastKey].callback = callback);\n              }\n\n              return new Animation(params, ms);\n            } else {\n              easing && (p.easing = easing);\n              callback && (p.callback = callback);\n              return new Animation({\n                100: p\n              }, ms);\n            }\n          };\n          /*\\\n           * Element.animate\n           [ method ]\n           **\n           * Creates and starts animation for given element.\n           **\n           > Parameters\n           **\n           - params (object) final attributes for the element, see also @Element.attr\n           - ms (number) number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           * or\n           - animation (object) animation object, see @Raphael.animation\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.animate = function (params, ms, easing, callback) {\n            var element = this;\n\n            if (element.removed) {\n              callback && callback.call(element);\n              return element;\n            }\n\n            var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\n            runAnimation(anim, element, anim.percents[0], null, element.attr());\n            return element;\n          };\n          /*\\\n           * Element.setTime\n           [ method ]\n           **\n           * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\n           **\n           > Parameters\n           **\n           - anim (object) animation object\n           - value (number) number of milliseconds from the beginning of the animation\n           **\n           = (object) original element if `value` is specified\n           * Note, that during animation following events are triggered:\n           *\n           * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\n          \\*/\n\n\n          elproto.setTime = function (anim, value) {\n            if (anim && value != null) {\n              this.status(anim, mmin(value, anim.ms) / anim.ms);\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.status\n           [ method ]\n           **\n           * Gets or sets the status of animation of the element.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\n           **\n           = (number) status\n           * or\n           = (array) status if `anim` is not specified. Array of objects in format:\n           o {\n           o     anim: (object) animation object\n           o     status: (number) status\n           o }\n           * or\n           = (object) original element if `value` is specified\n          \\*/\n\n\n          elproto.status = function (anim, value) {\n            var out = [],\n                i = 0,\n                len,\n                e;\n\n            if (value != null) {\n              runAnimation(anim, this, -1, mmin(value, 1));\n              return this;\n            } else {\n              len = animationElements.length;\n\n              for (; i < len; i++) {\n                e = animationElements[i];\n\n                if (e.el.id == this.id && (!anim || e.anim == anim)) {\n                  if (anim) {\n                    return e.status;\n                  }\n\n                  out.push({\n                    anim: e.anim,\n                    status: e.status\n                  });\n                }\n              }\n\n              if (anim) {\n                return 0;\n              }\n\n              return out;\n            }\n          };\n          /*\\\n           * Element.pause\n           [ method ]\n           **\n           * Stops animation of the element with ability to resume it later on.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.pause = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\n                  animationElements[i].paused = true;\n                }\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.resume\n           [ method ]\n           **\n           * Resumes animation if it was paused with @Element.pause method.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.resume = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                var e = animationElements[i];\n\n                if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\n                  delete e.paused;\n                  this.status(e.anim, e.status);\n                }\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.stop\n           [ method ]\n           **\n           * Stops animation of the element.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.stop = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\n                  animationElements.splice(i--, 1);\n                }\n              }\n            }\n\n            return this;\n          };\n\n          function stopAnimation(paper) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.paper == paper) {\n                animationElements.splice(i--, 1);\n              }\n            }\n          }\n\n          eve.on(\"raphael.remove\", stopAnimation);\n          eve.on(\"raphael.clear\", stopAnimation);\n\n          elproto.toString = function () {\n            return \"Rapha\\xEBl\\u2019s object\";\n          }; // Set\n\n\n          var Set = function Set(items) {\n            this.items = [];\n            this.length = 0;\n            this.type = \"set\";\n\n            if (items) {\n              for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\n                  this[this.items.length] = this.items[this.items.length] = items[i];\n                  this.length++;\n                }\n              }\n            }\n          },\n              setproto = Set.prototype;\n          /*\\\n           * Set.push\n           [ method ]\n           **\n           * Adds each argument to the current set.\n           = (object) original element\n          \\*/\n\n\n          setproto.push = function () {\n            var item, len;\n\n            for (var i = 0, ii = arguments.length; i < ii; i++) {\n              item = arguments[i];\n\n              if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Set.pop\n           [ method ]\n           **\n           * Removes last element and returns it.\n           = (object) element\n          \\*/\n\n\n          setproto.pop = function () {\n            this.length && delete this[this.length--];\n            return this.items.pop();\n          };\n          /*\\\n           * Set.forEach\n           [ method ]\n           **\n           * Executes given function for each element in the set.\n           *\n           * If function returns `false` it will stop loop running.\n           **\n           > Parameters\n           **\n           - callback (function) function to run\n           - thisArg (object) context object for the callback\n           = (object) Set object\n          \\*/\n\n\n          setproto.forEach = function (callback, thisArg) {\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\n              if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n              }\n            }\n\n            return this;\n          };\n\n          for (var method in elproto) {\n            if (elproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname][apply](el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n\n          setproto.attr = function (name, value) {\n            if (name && R.is(name, array) && R.is(name[0], \"object\")) {\n              for (var j = 0, jj = name.length; j < jj; j++) {\n                this.items[j].attr(name[j]);\n              }\n            } else {\n              for (var i = 0, ii = this.items.length; i < ii; i++) {\n                this.items[i].attr(name, value);\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Set.clear\n           [ method ]\n           **\n           * Removes all elements from the set\n          \\*/\n\n\n          setproto.clear = function () {\n            while (this.length) {\n              this.pop();\n            }\n          };\n          /*\\\n           * Set.splice\n           [ method ]\n           **\n           * Removes given element from the set\n           **\n           > Parameters\n           **\n           - index (number) position of the deletion\n           - count (number) number of element to remove\n           - insertion… (object) #optional elements to insert\n           = (object) set elements that were deleted\n          \\*/\n\n\n          setproto.splice = function (index, count, insertion) {\n            index = index < 0 ? mmax(this.length + index, 0) : index;\n            count = mmax(0, mmin(this.length - index, count));\n            var tail = [],\n                todel = [],\n                args = [],\n                i;\n\n            for (i = 2; i < arguments.length; i++) {\n              args.push(arguments[i]);\n            }\n\n            for (i = 0; i < count; i++) {\n              todel.push(this[index + i]);\n            }\n\n            for (; i < this.length - index; i++) {\n              tail.push(this[index + i]);\n            }\n\n            var arglen = args.length;\n\n            for (i = 0; i < arglen + tail.length; i++) {\n              this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n            }\n\n            i = this.items.length = this.length -= count - arglen;\n\n            while (this[i]) {\n              delete this[i++];\n            }\n\n            return new Set(todel);\n          };\n          /*\\\n           * Set.exclude\n           [ method ]\n           **\n           * Removes given element from the set\n           **\n           > Parameters\n           **\n           - element (object) element to remove\n           = (boolean) `true` if object was found & removed from the set\n          \\*/\n\n\n          setproto.exclude = function (el) {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n              if (this[i] == el) {\n                this.splice(i, 1);\n                return true;\n              }\n            }\n          };\n\n          setproto.animate = function (params, ms, easing, callback) {\n            (R.is(easing, \"function\") || !easing) && (callback = easing || null);\n            var len = this.items.length,\n                i = len,\n                item,\n                set = this,\n                collector;\n\n            if (!len) {\n              return this;\n            }\n\n            callback && (collector = function collector() {\n              ! --len && callback.call(set);\n            });\n            easing = R.is(easing, string) ? easing : collector;\n            var anim = R.animation(params, ms, easing, collector);\n            item = this.items[--i].animate(anim);\n\n            while (i--) {\n              this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\n              this.items[i] && !this.items[i].removed || len--;\n            }\n\n            return this;\n          };\n\n          setproto.insertAfter = function (el) {\n            var i = this.items.length;\n\n            while (i--) {\n              this.items[i].insertAfter(el);\n            }\n\n            return this;\n          };\n\n          setproto.getBBox = function () {\n            var x = [],\n                y = [],\n                x2 = [],\n                y2 = [];\n\n            for (var i = this.items.length; i--;) {\n              if (!this.items[i].removed) {\n                var box = this.items[i].getBBox();\n                x.push(box.x);\n                y.push(box.y);\n                x2.push(box.x + box.width);\n                y2.push(box.y + box.height);\n              }\n            }\n\n            x = mmin[apply](0, x);\n            y = mmin[apply](0, y);\n            x2 = mmax[apply](0, x2);\n            y2 = mmax[apply](0, y2);\n            return {\n              x: x,\n              y: y,\n              x2: x2,\n              y2: y2,\n              width: x2 - x,\n              height: y2 - y\n            };\n          };\n\n          setproto.clone = function (s) {\n            s = this.paper.set();\n\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\n              s.push(this.items[i].clone());\n            }\n\n            return s;\n          };\n\n          setproto.toString = function () {\n            return \"Rapha\\xEBl\\u2018s set\";\n          };\n\n          setproto.glow = function (glowConfig) {\n            var ret = this.paper.set();\n            this.forEach(function (shape, index) {\n              var g = shape.glow(glowConfig);\n\n              if (g != null) {\n                g.forEach(function (shape2, index2) {\n                  ret.push(shape2);\n                });\n              }\n            });\n            return ret;\n          };\n          /*\\\n           * Set.isPointInside\n           [ method ]\n           **\n           * Determine if given point is inside this set’s elements\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (boolean) `true` if point is inside any of the set's elements\n           \\*/\n\n\n          setproto.isPointInside = function (x, y) {\n            var isPointInside = false;\n            this.forEach(function (el) {\n              if (el.isPointInside(x, y)) {\n                isPointInside = true;\n                return false; // stop loop\n              }\n            });\n            return isPointInside;\n          };\n          /*\\\n           * Raphael.registerFont\n           [ method ]\n           **\n           * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.\n           * Returns original parameter, so it could be used with chaining.\n           # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\n           **\n           > Parameters\n           **\n           - font (object) the font to register\n           = (object) the font you passed in\n           > Usage\n           | Cufon.registerFont(Raphael.registerFont({…}));\n          \\*/\n\n\n          R.registerFont = function (font) {\n            if (!font.face) {\n              return font;\n            }\n\n            this.fonts = this.fonts || {};\n            var fontcopy = {\n              w: font.w,\n              face: {},\n              glyphs: {}\n            },\n                family = font.face[\"font-family\"];\n\n            for (var prop in font.face) {\n              if (font.face[has](prop)) {\n                fontcopy.face[prop] = font.face[prop];\n              }\n            }\n\n            if (this.fonts[family]) {\n              this.fonts[family].push(fontcopy);\n            } else {\n              this.fonts[family] = [fontcopy];\n            }\n\n            if (!font.svg) {\n              fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\n\n              for (var glyph in font.glyphs) {\n                if (font.glyphs[has](glyph)) {\n                  var path = font.glyphs[glyph];\n                  fontcopy.glyphs[glyph] = {\n                    w: path.w,\n                    k: {},\n                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\n                      return {\n                        l: \"L\",\n                        c: \"C\",\n                        x: \"z\",\n                        t: \"m\",\n                        r: \"l\",\n                        v: \"c\"\n                      }[command] || \"M\";\n                    }) + \"z\"\n                  };\n\n                  if (path.k) {\n                    for (var k in path.k) {\n                      if (path[has](k)) {\n                        fontcopy.glyphs[glyph].k[k] = path.k[k];\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            return font;\n          };\n          /*\\\n           * Paper.getFont\n           [ method ]\n           **\n           * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.\n           **\n           > Parameters\n           **\n           - family (string) font family name or any word from it\n           - weight (string) #optional font weight\n           - style (string) #optional font style\n           - stretch (string) #optional font stretch\n           = (object) the font object\n           > Usage\n           | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\n          \\*/\n\n\n          paperproto.getFont = function (family, weight, style, stretch) {\n            stretch = stretch || \"normal\";\n            style = style || \"normal\";\n            weight = +weight || {\n              normal: 400,\n              bold: 700,\n              lighter: 300,\n              bolder: 800\n            }[weight] || 400;\n\n            if (!R.fonts) {\n              return;\n            }\n\n            var font = R.fonts[family];\n\n            if (!font) {\n              var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\n\n              for (var fontName in R.fonts) {\n                if (R.fonts[has](fontName)) {\n                  if (name.test(fontName)) {\n                    font = R.fonts[fontName];\n                    break;\n                  }\n                }\n              }\n            }\n\n            var thefont;\n\n            if (font) {\n              for (var i = 0, ii = font.length; i < ii; i++) {\n                thefont = font[i];\n\n                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\n                  break;\n                }\n              }\n            }\n\n            return thefont;\n          };\n          /*\\\n           * Paper.print\n           [ method ]\n           **\n           * Creates path that represent given text written using given font at given position with given size.\n           * Result of the method is path element that contains whole text as a separate path.\n           **\n           > Parameters\n           **\n           - x (number) x position of the text\n           - y (number) y position of the text\n           - string (string) text to print\n           - font (object) font object, see @Paper.getFont\n           - size (number) #optional size of the font, default is `16`\n           - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\n           - letter_spacing (number) #optional number in range `-1..1`, default is `0`\n           - line_spacing (number) #optional number in range `1..3`, default is `1`\n           = (object) resulting path element, which consist of all letters\n           > Usage\n           | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\n          \\*/\n\n\n          paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\n            origin = origin || \"middle\"; // baseline|middle\n\n            letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\n            line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\n            var letters = Str(string)[split](E),\n                shift = 0,\n                notfirst = 0,\n                path = E,\n                scale;\n            R.is(font, \"string\") && (font = this.getFont(font));\n\n            if (font) {\n              scale = (size || 16) / font.face[\"units-per-em\"];\n              var bb = font.face.bbox[split](separator),\n                  top = +bb[0],\n                  lineHeight = bb[3] - bb[1],\n                  shifty = 0,\n                  height = +bb[1] + (origin == \"baseline\" ? lineHeight + +font.face.descent : lineHeight / 2);\n\n              for (var i = 0, ii = letters.length; i < ii; i++) {\n                if (letters[i] == \"\\n\") {\n                  shift = 0;\n                  curr = 0;\n                  notfirst = 0;\n                  shifty += lineHeight * line_spacing;\n                } else {\n                  var prev = notfirst && font.glyphs[letters[i - 1]] || {},\n                      curr = font.glyphs[letters[i]];\n                  shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;\n                  notfirst = 1;\n                }\n\n                if (curr && curr.d) {\n                  path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\n                }\n              }\n            }\n\n            return this.path(path).attr({\n              fill: \"#000\",\n              stroke: \"none\"\n            });\n          };\n          /*\\\n           * Paper.add\n           [ method ]\n           **\n           * Imports elements in JSON array in format `{type: type, <attributes>}`\n           **\n           > Parameters\n           **\n           - json (array)\n           = (object) resulting set of imported elements\n           > Usage\n           | paper.add([\n           |     {\n           |         type: \"circle\",\n           |         cx: 10,\n           |         cy: 10,\n           |         r: 5\n           |     },\n           |     {\n           |         type: \"rect\",\n           |         x: 10,\n           |         y: 10,\n           |         width: 10,\n           |         height: 10,\n           |         fill: \"#fc0\"\n           |     }\n           | ]);\n          \\*/\n\n\n          paperproto.add = function (json) {\n            if (R.is(json, \"array\")) {\n              var res = this.set(),\n                  i = 0,\n                  ii = json.length,\n                  j;\n\n              for (; i < ii; i++) {\n                j = json[i] || {};\n                elements[has](j.type) && res.push(this[j.type]().attr(j));\n              }\n            }\n\n            return res;\n          };\n          /*\\\n           * Raphael.format\n           [ method ]\n           **\n           * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.\n           **\n           > Parameters\n           **\n           - token (string) string to format\n           - … (string) rest of arguments will be treated as parameters for replacement\n           = (string) formated string\n           > Usage\n           | var x = 10,\n           |     y = 20,\n           |     width = 40,\n           |     height = 50;\n           | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n           | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\n          \\*/\n\n\n          R.format = function (token, params) {\n            var args = R.is(params, array) ? [0][concat](params) : arguments;\n            token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\n              return args[++i] == null ? E : args[i];\n            }));\n            return token || E;\n          };\n          /*\\\n           * Raphael.fullfill\n           [ method ]\n           **\n           * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.\n           **\n           > Parameters\n           **\n           - token (string) string to format\n           - json (object) object which properties will be used as a replacement\n           = (string) formated string\n           > Usage\n           | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n           | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n           |     x: 10,\n           |     y: 20,\n           |     dim: {\n           |         width: 40,\n           |         height: 50,\n           |         \"negative width\": -40\n           |     }\n           | }));\n          \\*/\n\n\n          R.fullfill = function () {\n            var tokenRegex = /\\{([^\\}]+)\\}/g,\n                objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g,\n                // matches .xxxxx or [\"xxxxx\"] to run over object properties\n            replacer = function replacer(all, key, obj) {\n              var res = obj;\n              key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n\n                if (res) {\n                  if (name in res) {\n                    res = res[name];\n                  }\n\n                  typeof res == \"function\" && isFunc && (res = res());\n                }\n              });\n              res = (res == null || res == obj ? all : res) + \"\";\n              return res;\n            };\n\n            return function (str, obj) {\n              return String(str).replace(tokenRegex, function (all, key) {\n                return replacer(all, key, obj);\n              });\n            };\n          }();\n          /*\\\n           * Raphael.ninja\n           [ method ]\n           **\n           * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\n           * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\n           **\n           = (object) Raphael object\n           > Usage\n           | (function (local_raphael) {\n           |     var paper = local_raphael(10, 10, 320, 200);\n           |     …\n           | })(Raphael.ninja());\n          \\*/\n\n\n          R.ninja = function () {\n            if (oldRaphael.was) {\n              g.win.Raphael = oldRaphael.is;\n            } else {\n              // IE8 raises an error when deleting window property\n              window.Raphael = undefined;\n\n              try {\n                delete window.Raphael;\n              } catch (e) {}\n            }\n\n            return R;\n          };\n          /*\\\n           * Raphael.st\n           [ property (object) ]\n           **\n           * You can add your own method to elements and sets. It is wise to add a set method for each element method\n           * you added, so you will be able to call the same method on sets too.\n           **\n           * See also @Raphael.el.\n           > Usage\n           | Raphael.el.red = function () {\n           |     this.attr({fill: \"#f00\"});\n           | };\n           | Raphael.st.red = function () {\n           |     this.forEach(function (el) {\n           |         el.red();\n           |     });\n           | };\n           | // then use it\n           | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\n          \\*/\n\n\n          R.st = setproto;\n          eve.on(\"raphael.DOMload\", function () {\n            loaded = true;\n          }); // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\n          (function (doc, loaded, _f2) {\n            if (doc.readyState == null && doc.addEventListener) {\n              doc.addEventListener(loaded, _f2 = function f() {\n                doc.removeEventListener(loaded, _f2, false);\n                doc.readyState = \"complete\";\n              }, false);\n              doc.readyState = \"loading\";\n            }\n\n            function isLoaded() {\n              /in/.test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\n            }\n\n            isLoaded();\n          })(document, \"DOMContentLoaded\");\n\n          return R;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.svg.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.svg.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelSvgJs(module, exports, __nested_webpack_require_218764__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_218764__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          if (R && !R.svg) {\n            return;\n          }\n\n          var has = \"hasOwnProperty\",\n              Str = String,\n              toFloat = parseFloat,\n              toInt = parseInt,\n              math = Math,\n              mmax = math.max,\n              abs = math.abs,\n              pow = math.pow,\n              separator = /[, ]+/,\n              eve = R.eve,\n              E = \"\",\n              S = \" \";\n          var xlink = \"http://www.w3.org/1999/xlink\",\n              markers = {\n            block: \"M5,0 0,2.5 5,5z\",\n            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\n            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\n            open: \"M6,1 1,3.5 6,6\",\n            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\n          },\n              markerCounter = {};\n\n          R.toString = function () {\n            return \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\n          };\n\n          var $ = function $(el, attr) {\n            if (attr) {\n              if (typeof el == \"string\") {\n                el = $(el);\n              }\n\n              for (var key in attr) {\n                if (attr[has](key)) {\n                  if (key.substring(0, 6) == \"xlink:\") {\n                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\n                  } else {\n                    el.setAttribute(key, Str(attr[key]));\n                  }\n                }\n              }\n            } else {\n              el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\n              el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\n            }\n\n            return el;\n          },\n              addGradientFill = function addGradientFill(element, gradient) {\n            var type = \"linear\",\n                id = element.id + gradient,\n                fx = .5,\n                fy = .5,\n                o = element.node,\n                SVG = element.paper,\n                s = o.style,\n                el = R._g.doc.getElementById(id);\n\n            if (!el) {\n              gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\n                type = \"radial\";\n\n                if (_fx && _fy) {\n                  fx = toFloat(_fx);\n                  fy = toFloat(_fy);\n                  var dir = (fy > .5) * 2 - 1;\n                  pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) && fy != .5 && (fy = fy.toFixed(5) - 1e-5 * dir);\n                }\n\n                return E;\n              });\n              gradient = gradient.split(/\\s*\\-\\s*/);\n\n              if (type == \"linear\") {\n                var angle = gradient.shift();\n                angle = -toFloat(angle);\n\n                if (isNaN(angle)) {\n                  return null;\n                }\n\n                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\n                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\n                vector[2] *= max;\n                vector[3] *= max;\n\n                if (vector[2] < 0) {\n                  vector[0] = -vector[2];\n                  vector[2] = 0;\n                }\n\n                if (vector[3] < 0) {\n                  vector[1] = -vector[3];\n                  vector[3] = 0;\n                }\n              }\n\n              var dots = R._parseDots(gradient);\n\n              if (!dots) {\n                return null;\n              }\n\n              id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\n\n              if (element.gradient && id != element.gradient.id) {\n                SVG.defs.removeChild(element.gradient);\n                delete element.gradient;\n              }\n\n              if (!element.gradient) {\n                el = $(type + \"Gradient\", {\n                  id: id\n                });\n                element.gradient = el;\n                $(el, type == \"radial\" ? {\n                  fx: fx,\n                  fy: fy\n                } : {\n                  x1: vector[0],\n                  y1: vector[1],\n                  x2: vector[2],\n                  y2: vector[3],\n                  gradientTransform: element.matrix.invert()\n                });\n                SVG.defs.appendChild(el);\n\n                for (var i = 0, ii = dots.length; i < ii; i++) {\n                  el.appendChild($(\"stop\", {\n                    offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\n                    \"stop-color\": dots[i].color || \"#fff\",\n                    \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\n                  }));\n                }\n              }\n            }\n\n            $(o, {\n              fill: fillurl(id),\n              opacity: 1,\n              \"fill-opacity\": 1\n            });\n            s.fill = E;\n            s.opacity = 1;\n            s.fillOpacity = 1;\n            return 1;\n          },\n              isIE9or10 = function isIE9or10() {\n            var mode = document.documentMode;\n            return mode && (mode === 9 || mode === 10);\n          },\n              fillurl = function fillurl(id) {\n            if (isIE9or10()) {\n              return \"url('#\" + id + \"')\";\n            }\n\n            var location = document.location;\n            var locationString = location.protocol + '//' + location.host + location.pathname + location.search;\n            return \"url('\" + locationString + \"#\" + id + \"')\";\n          },\n              updatePosition = function updatePosition(o) {\n            var bbox = o.getBBox(1);\n            $(o.pattern, {\n              patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"\n            });\n          },\n              addArrow = function addArrow(o, value, isEnd) {\n            if (o.type == \"path\") {\n              var values = Str(value).toLowerCase().split(\"-\"),\n                  p = o.paper,\n                  se = isEnd ? \"end\" : \"start\",\n                  node = o.node,\n                  attrs = o.attrs,\n                  stroke = attrs[\"stroke-width\"],\n                  i = values.length,\n                  type = \"classic\",\n                  from,\n                  to,\n                  dx,\n                  refX,\n                  attr,\n                  w = 3,\n                  h = 3,\n                  t = 5;\n\n              while (i--) {\n                switch (values[i]) {\n                  case \"block\":\n                  case \"classic\":\n                  case \"oval\":\n                  case \"diamond\":\n                  case \"open\":\n                  case \"none\":\n                    type = values[i];\n                    break;\n\n                  case \"wide\":\n                    h = 5;\n                    break;\n\n                  case \"narrow\":\n                    h = 2;\n                    break;\n\n                  case \"long\":\n                    w = 5;\n                    break;\n\n                  case \"short\":\n                    w = 2;\n                    break;\n                }\n              }\n\n              if (type == \"open\") {\n                w += 2;\n                h += 2;\n                t += 2;\n                dx = 1;\n                refX = isEnd ? 4 : 1;\n                attr = {\n                  fill: \"none\",\n                  stroke: attrs.stroke\n                };\n              } else {\n                refX = dx = w / 2;\n                attr = {\n                  fill: attrs.stroke,\n                  stroke: \"none\"\n                };\n              }\n\n              if (o._.arrows) {\n                if (isEnd) {\n                  o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\n                  o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\n                } else {\n                  o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\n                  o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\n                }\n              } else {\n                o._.arrows = {};\n              }\n\n              if (type != \"none\") {\n                var pathId = \"raphael-marker-\" + type,\n                    markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\n\n                if (!R._g.doc.getElementById(pathId)) {\n                  p.defs.appendChild($($(\"path\"), {\n                    \"stroke-linecap\": \"round\",\n                    d: markers[type],\n                    id: pathId\n                  }));\n                  markerCounter[pathId] = 1;\n                } else {\n                  markerCounter[pathId]++;\n                }\n\n                var marker = R._g.doc.getElementById(markerId),\n                    use;\n\n                if (!marker) {\n                  marker = $($(\"marker\"), {\n                    id: markerId,\n                    markerHeight: h,\n                    markerWidth: w,\n                    orient: \"auto\",\n                    refX: refX,\n                    refY: h / 2\n                  });\n                  use = $($(\"use\"), {\n                    \"xlink:href\": \"#\" + pathId,\n                    transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\n                    \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\n                  });\n                  marker.appendChild(use);\n                  p.defs.appendChild(marker);\n                  markerCounter[markerId] = 1;\n                } else {\n                  markerCounter[markerId]++;\n                  use = marker.getElementsByTagName(\"use\")[0];\n                }\n\n                $(use, attr);\n                var delta = dx * (type != \"diamond\" && type != \"oval\");\n\n                if (isEnd) {\n                  from = o._.arrows.startdx * stroke || 0;\n                  to = R.getTotalLength(attrs.path) - delta * stroke;\n                } else {\n                  from = delta * stroke;\n                  to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                }\n\n                attr = {};\n                attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\n\n                if (to || from) {\n                  attr.d = R.getSubpath(attrs.path, from, to);\n                }\n\n                $(node, attr);\n                o._.arrows[se + \"Path\"] = pathId;\n                o._.arrows[se + \"Marker\"] = markerId;\n                o._.arrows[se + \"dx\"] = delta;\n                o._.arrows[se + \"Type\"] = type;\n                o._.arrows[se + \"String\"] = value;\n              } else {\n                if (isEnd) {\n                  from = o._.arrows.startdx * stroke || 0;\n                  to = R.getTotalLength(attrs.path) - from;\n                } else {\n                  from = 0;\n                  to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                }\n\n                o._.arrows[se + \"Path\"] && $(node, {\n                  d: R.getSubpath(attrs.path, from, to)\n                });\n                delete o._.arrows[se + \"Path\"];\n                delete o._.arrows[se + \"Marker\"];\n                delete o._.arrows[se + \"dx\"];\n                delete o._.arrows[se + \"Type\"];\n                delete o._.arrows[se + \"String\"];\n              }\n\n              for (attr in markerCounter) {\n                if (markerCounter[has](attr) && !markerCounter[attr]) {\n                  var item = R._g.doc.getElementById(attr);\n\n                  item && item.parentNode.removeChild(item);\n                }\n              }\n            }\n          },\n              dasharray = {\n            \"-\": [3, 1],\n            \".\": [1, 1],\n            \"-.\": [3, 1, 1, 1],\n            \"-..\": [3, 1, 1, 1, 1, 1],\n            \". \": [1, 3],\n            \"- \": [4, 3],\n            \"--\": [8, 3],\n            \"- .\": [4, 3, 1, 3],\n            \"--.\": [8, 3, 1, 3],\n            \"--..\": [8, 3, 1, 3, 1, 3]\n          },\n              addDashes = function addDashes(o, value, params) {\n            value = dasharray[Str(value).toLowerCase()];\n\n            if (value) {\n              var width = o.attrs[\"stroke-width\"] || \"1\",\n                  butt = {\n                round: width,\n                square: width,\n                butt: 0\n              }[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\n                  dashes = [],\n                  i = value.length;\n\n              while (i--) {\n                dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;\n              }\n\n              $(o.node, {\n                \"stroke-dasharray\": dashes.join(\",\")\n              });\n            } else {\n              $(o.node, {\n                \"stroke-dasharray\": \"none\"\n              });\n            }\n          },\n              setFillAndStroke = function setFillAndStroke(o, params) {\n            var node = o.node,\n                attrs = o.attrs,\n                vis = node.style.visibility;\n            node.style.visibility = \"hidden\";\n\n            for (var att in params) {\n              if (params[has](att)) {\n                if (!R._availableAttrs[has](att)) {\n                  continue;\n                }\n\n                var value = params[att];\n                attrs[att] = value;\n\n                switch (att) {\n                  case \"blur\":\n                    o.blur(value);\n                    break;\n\n                  case \"title\":\n                    var title = node.getElementsByTagName(\"title\"); // Use the existing <title>.\n\n                    if (title.length && (title = title[0])) {\n                      title.firstChild.nodeValue = value;\n                    } else {\n                      title = $(\"title\");\n\n                      var val = R._g.doc.createTextNode(value);\n\n                      title.appendChild(val);\n                      node.appendChild(title);\n                    }\n\n                    break;\n\n                  case \"href\":\n                  case \"target\":\n                    var pn = node.parentNode;\n\n                    if (pn.tagName.toLowerCase() != \"a\") {\n                      var hl = $(\"a\");\n                      pn.insertBefore(hl, node);\n                      hl.appendChild(node);\n                      pn = hl;\n                    }\n\n                    if (att == \"target\") {\n                      pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\n                    } else {\n                      pn.setAttributeNS(xlink, att, value);\n                    }\n\n                    break;\n\n                  case \"cursor\":\n                    node.style.cursor = value;\n                    break;\n\n                  case \"transform\":\n                    o.transform(value);\n                    break;\n\n                  case \"arrow-start\":\n                    addArrow(o, value);\n                    break;\n\n                  case \"arrow-end\":\n                    addArrow(o, value, 1);\n                    break;\n\n                  case \"clip-rect\":\n                    var rect = Str(value).split(separator);\n\n                    if (rect.length == 4) {\n                      o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\n                      var el = $(\"clipPath\"),\n                          rc = $(\"rect\");\n                      el.id = R.createUUID();\n                      $(rc, {\n                        x: rect[0],\n                        y: rect[1],\n                        width: rect[2],\n                        height: rect[3]\n                      });\n                      el.appendChild(rc);\n                      o.paper.defs.appendChild(el);\n                      $(node, {\n                        \"clip-path\": \"url(#\" + el.id + \")\"\n                      });\n                      o.clip = rc;\n                    }\n\n                    if (!value) {\n                      var path = node.getAttribute(\"clip-path\");\n\n                      if (path) {\n                        var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\n\n                        clip && clip.parentNode.removeChild(clip);\n                        $(node, {\n                          \"clip-path\": E\n                        });\n                        delete o.clip;\n                      }\n                    }\n\n                    break;\n\n                  case \"path\":\n                    if (o.type == \"path\") {\n                      $(node, {\n                        d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"\n                      });\n                      o._.dirty = 1;\n\n                      if (o._.arrows) {\n                        \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                        \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                      }\n                    }\n\n                    break;\n\n                  case \"width\":\n                    node.setAttribute(att, value);\n                    o._.dirty = 1;\n\n                    if (attrs.fx) {\n                      att = \"x\";\n                      value = attrs.x;\n                    } else {\n                      break;\n                    }\n\n                  case \"x\":\n                    if (attrs.fx) {\n                      value = -attrs.x - (attrs.width || 0);\n                    }\n\n                  case \"rx\":\n                    if (att == \"rx\" && o.type == \"rect\") {\n                      break;\n                    }\n\n                  case \"cx\":\n                    node.setAttribute(att, value);\n                    o.pattern && updatePosition(o);\n                    o._.dirty = 1;\n                    break;\n\n                  case \"height\":\n                    node.setAttribute(att, value);\n                    o._.dirty = 1;\n\n                    if (attrs.fy) {\n                      att = \"y\";\n                      value = attrs.y;\n                    } else {\n                      break;\n                    }\n\n                  case \"y\":\n                    if (attrs.fy) {\n                      value = -attrs.y - (attrs.height || 0);\n                    }\n\n                  case \"ry\":\n                    if (att == \"ry\" && o.type == \"rect\") {\n                      break;\n                    }\n\n                  case \"cy\":\n                    node.setAttribute(att, value);\n                    o.pattern && updatePosition(o);\n                    o._.dirty = 1;\n                    break;\n\n                  case \"r\":\n                    if (o.type == \"rect\") {\n                      $(node, {\n                        rx: value,\n                        ry: value\n                      });\n                    } else {\n                      node.setAttribute(att, value);\n                    }\n\n                    o._.dirty = 1;\n                    break;\n\n                  case \"src\":\n                    if (o.type == \"image\") {\n                      node.setAttributeNS(xlink, \"href\", value);\n                    }\n\n                    break;\n\n                  case \"stroke-width\":\n                    if (o._.sx != 1 || o._.sy != 1) {\n                      value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\n                    }\n\n                    node.setAttribute(att, value);\n\n                    if (attrs[\"stroke-dasharray\"]) {\n                      addDashes(o, attrs[\"stroke-dasharray\"], params);\n                    }\n\n                    if (o._.arrows) {\n                      \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                      \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                    }\n\n                    break;\n\n                  case \"stroke-dasharray\":\n                    addDashes(o, value, params);\n                    break;\n\n                  case \"fill\":\n                    var isURL = Str(value).match(R._ISURL);\n\n                    if (isURL) {\n                      el = $(\"pattern\");\n                      var ig = $(\"image\");\n                      el.id = R.createUUID();\n                      $(el, {\n                        x: 0,\n                        y: 0,\n                        patternUnits: \"userSpaceOnUse\",\n                        height: 1,\n                        width: 1\n                      });\n                      $(ig, {\n                        x: 0,\n                        y: 0,\n                        \"xlink:href\": isURL[1]\n                      });\n                      el.appendChild(ig);\n\n                      (function (el) {\n                        R._preload(isURL[1], function () {\n                          var w = this.offsetWidth,\n                              h = this.offsetHeight;\n                          $(el, {\n                            width: w,\n                            height: h\n                          });\n                          $(ig, {\n                            width: w,\n                            height: h\n                          });\n                        });\n                      })(el);\n\n                      o.paper.defs.appendChild(el);\n                      $(node, {\n                        fill: \"url(#\" + el.id + \")\"\n                      });\n                      o.pattern = el;\n                      o.pattern && updatePosition(o);\n                      break;\n                    }\n\n                    var clr = R.getRGB(value);\n\n                    if (!clr.error) {\n                      delete params.gradient;\n                      delete attrs.gradient;\n                      !R.is(attrs.opacity, \"undefined\") && R.is(params.opacity, \"undefined\") && $(node, {\n                        opacity: attrs.opacity\n                      });\n                      !R.is(attrs[\"fill-opacity\"], \"undefined\") && R.is(params[\"fill-opacity\"], \"undefined\") && $(node, {\n                        \"fill-opacity\": attrs[\"fill-opacity\"]\n                      });\n                    } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\n                      if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\n                        var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\n                        if (gradient) {\n                          var stops = gradient.getElementsByTagName(\"stop\");\n                          $(stops[stops.length - 1], {\n                            \"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)\n                          });\n                        }\n                      }\n\n                      attrs.gradient = value;\n                      attrs.fill = \"none\";\n                      break;\n                    }\n\n                    clr[has](\"opacity\") && $(node, {\n                      \"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity\n                    });\n\n                  case \"stroke\":\n                    clr = R.getRGB(value);\n                    node.setAttribute(att, clr.hex);\n                    att == \"stroke\" && clr[has](\"opacity\") && $(node, {\n                      \"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity\n                    });\n\n                    if (att == \"stroke\" && o._.arrows) {\n                      \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                      \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                    }\n\n                    break;\n\n                  case \"gradient\":\n                    (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\n                    break;\n\n                  case \"opacity\":\n                    if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\n                      $(node, {\n                        \"stroke-opacity\": value > 1 ? value / 100 : value\n                      });\n                    }\n\n                  // fall\n\n                  case \"fill-opacity\":\n                    if (attrs.gradient) {\n                      gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\n                      if (gradient) {\n                        stops = gradient.getElementsByTagName(\"stop\");\n                        $(stops[stops.length - 1], {\n                          \"stop-opacity\": value\n                        });\n                      }\n\n                      break;\n                    }\n\n                  default:\n                    att == \"font-size\" && (value = toInt(value, 10) + \"px\");\n                    var cssrule = att.replace(/(\\-.)/g, function (w) {\n                      return w.substring(1).toUpperCase();\n                    });\n                    node.style[cssrule] = value;\n                    o._.dirty = 1;\n                    node.setAttribute(att, value);\n                    break;\n                }\n              }\n            }\n\n            tuneText(o, params);\n            node.style.visibility = vis;\n          },\n              leading = 1.2,\n              tuneText = function tuneText(el, params) {\n            if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\n              return;\n            }\n\n            var a = el.attrs,\n                node = el.node,\n                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\n\n            if (params[has](\"text\")) {\n              a.text = params.text;\n\n              while (node.firstChild) {\n                node.removeChild(node.firstChild);\n              }\n\n              var texts = Str(params.text).split(\"\\n\"),\n                  tspans = [],\n                  tspan;\n\n              for (var i = 0, ii = texts.length; i < ii; i++) {\n                tspan = $(\"tspan\");\n                i && $(tspan, {\n                  dy: fontSize * leading,\n                  x: a.x\n                });\n                tspan.appendChild(R._g.doc.createTextNode(texts[i]));\n                node.appendChild(tspan);\n                tspans[i] = tspan;\n              }\n            } else {\n              tspans = node.getElementsByTagName(\"tspan\");\n\n              for (i = 0, ii = tspans.length; i < ii; i++) {\n                if (i) {\n                  $(tspans[i], {\n                    dy: fontSize * leading,\n                    x: a.x\n                  });\n                } else {\n                  $(tspans[0], {\n                    dy: 0\n                  });\n                }\n              }\n            }\n\n            $(node, {\n              x: a.x,\n              y: a.y\n            });\n            el._.dirty = 1;\n\n            var bb = el._getBBox(),\n                dif = a.y - (bb.y + bb.height / 2);\n\n            dif && R.is(dif, \"finite\") && $(tspans[0], {\n              dy: dif\n            });\n          },\n              getRealNode = function getRealNode(node) {\n            if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\n              return node.parentNode;\n            } else {\n              return node;\n            }\n          },\n              Element = function Element(node, svg) {\n            var X = 0,\n                Y = 0;\n            /*\\\n             * Element.node\n             [ property (object) ]\n             **\n             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n             **\n             * Note: Don’t mess with it.\n             > Usage\n             | // draw a circle at coordinate 10,10 with radius of 10\n             | var c = paper.circle(10, 10, 10);\n             | c.node.onclick = function () {\n             |     c.attr(\"fill\", \"red\");\n             | };\n            \\*/\n\n            this[0] = this.node = node;\n            /*\\\n             * Element.raphael\n             [ property (object) ]\n             **\n             * Internal reference to @Raphael object. In case it is not available.\n             > Usage\n             | Raphael.el.red = function () {\n             |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\n             |     hsb.h = 1;\n             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\n             | }\n            \\*/\n\n            node.raphael = true;\n            /*\\\n             * Element.id\n             [ property (number) ]\n             **\n             * Unique id of the element. Especially useful when you want to listen to events of the element,\n             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\n            \\*/\n\n            this.id = guid();\n            node.raphaelid = this.id;\n            /**\n            * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements\n            * @returns {string} id\n            */\n\n            function guid() {\n              return (\"0000\" + (Math.random() * Math.pow(36, 5) << 0).toString(36)).slice(-5);\n            }\n\n            this.matrix = R.matrix();\n            this.realPath = null;\n            /*\\\n             * Element.paper\n             [ property (object) ]\n             **\n             * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.\n             > Usage\n             | Raphael.el.cross = function () {\n             |     this.attr({fill: \"red\"});\n             |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\n             |         .attr({stroke: \"red\"});\n             | }\n            \\*/\n\n            this.paper = svg;\n            this.attrs = this.attrs || {};\n            this._ = {\n              transform: [],\n              sx: 1,\n              sy: 1,\n              deg: 0,\n              dx: 0,\n              dy: 0,\n              dirty: 1\n            };\n            !svg.bottom && (svg.bottom = this);\n            /*\\\n             * Element.prev\n             [ property (object) ]\n             **\n             * Reference to the previous element in the hierarchy.\n            \\*/\n\n            this.prev = svg.top;\n            svg.top && (svg.top.next = this);\n            svg.top = this;\n            /*\\\n             * Element.next\n             [ property (object) ]\n             **\n             * Reference to the next element in the hierarchy.\n            \\*/\n\n            this.next = null;\n          },\n              elproto = R.el;\n\n          Element.prototype = elproto;\n          elproto.constructor = Element;\n\n          R._engine.path = function (pathString, SVG) {\n            var el = $(\"path\");\n            SVG.canvas && SVG.canvas.appendChild(el);\n            var p = new Element(el, SVG);\n            p.type = \"path\";\n            setFillAndStroke(p, {\n              fill: \"none\",\n              stroke: \"#000\",\n              path: pathString\n            });\n            return p;\n          };\n          /*\\\n           * Element.rotate\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds rotation by given angle around given point to the list of\n           * transformations of the element.\n           > Parameters\n           - deg (number) angle in degrees\n           - cx (number) #optional x coordinate of the centre of rotation\n           - cy (number) #optional y coordinate of the centre of rotation\n           * If cx & cy aren’t specified centre of the shape is used as a point of rotation.\n           = (object) @Element\n          \\*/\n\n\n          elproto.rotate = function (deg, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            deg = Str(deg).split(separator);\n\n            if (deg.length - 1) {\n              cx = toFloat(deg[1]);\n              cy = toFloat(deg[2]);\n            }\n\n            deg = toFloat(deg[0]);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n              cx = bbox.x + bbox.width / 2;\n              cy = bbox.y + bbox.height / 2;\n            }\n\n            this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n            return this;\n          };\n          /*\\\n           * Element.scale\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds scale by given amount relative to given point to the list of\n           * transformations of the element.\n           > Parameters\n           - sx (number) horisontal scale amount\n           - sy (number) vertical scale amount\n           - cx (number) #optional x coordinate of the centre of scale\n           - cy (number) #optional y coordinate of the centre of scale\n           * If cx & cy aren’t specified centre of the shape is used instead.\n           = (object) @Element\n          \\*/\n\n\n          elproto.scale = function (sx, sy, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            sx = Str(sx).split(separator);\n\n            if (sx.length - 1) {\n              sy = toFloat(sx[1]);\n              cx = toFloat(sx[2]);\n              cy = toFloat(sx[3]);\n            }\n\n            sx = toFloat(sx[0]);\n            sy == null && (sy = sx);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n            }\n\n            cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n            cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n            this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n            return this;\n          };\n          /*\\\n           * Element.translate\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds translation by given amount to the list of transformations of the element.\n           > Parameters\n           - dx (number) horisontal shift\n           - dy (number) vertical shift\n           = (object) @Element\n          \\*/\n\n\n          elproto.translate = function (dx, dy) {\n            if (this.removed) {\n              return this;\n            }\n\n            dx = Str(dx).split(separator);\n\n            if (dx.length - 1) {\n              dy = toFloat(dx[1]);\n            }\n\n            dx = toFloat(dx[0]) || 0;\n            dy = +dy || 0;\n            this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n            return this;\n          };\n          /*\\\n           * Element.transform\n           [ method ]\n           **\n           * Adds transformation to the element which is separate to other attributes,\n           * i.e. translation doesn’t change `x` or `y` of the rectange. The format\n           * of transformation string is similar to the path string syntax:\n           | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\n           * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\n           * scale and `m` is for matrix.\n           *\n           * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\n           *\n           * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;\n           * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin\n           * coordinates as optional parameters, the default is the centre point of the element.\n           * Matrix accepts six parameters.\n           > Usage\n           | var el = paper.rect(10, 20, 300, 200);\n           | // translate 100, 100, rotate 45°, translate -100, 0\n           | el.transform(\"t100,100r45t-100,0\");\n           | // if you want you can append or prepend transformations\n           | el.transform(\"...t50,50\");\n           | el.transform(\"s2...\");\n           | // or even wrap\n           | el.transform(\"t50,50...t-50-50\");\n           | // to reset transformation call method with empty string\n           | el.transform(\"\");\n           | // to get current value call it without parameters\n           | console.log(el.transform());\n           > Parameters\n           - tstr (string) #optional transformation string\n           * If tstr isn’t specified\n           = (string) current transformation string\n           * else\n           = (object) @Element\n          \\*/\n\n\n          elproto.transform = function (tstr) {\n            var _ = this._;\n\n            if (tstr == null) {\n              return _.transform;\n            }\n\n            R._extractTransform(this, tstr);\n\n            this.clip && $(this.clip, {\n              transform: this.matrix.invert()\n            });\n            this.pattern && updatePosition(this);\n            this.node && $(this.node, {\n              transform: this.matrix\n            });\n\n            if (_.sx != 1 || _.sy != 1) {\n              var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\n              this.attr({\n                \"stroke-width\": sw\n              });\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.hide\n           [ method ]\n           **\n           * Makes element invisible. See @Element.show.\n           = (object) @Element\n          \\*/\n\n\n          elproto.hide = function () {\n            if (!this.removed) this.node.style.display = \"none\";\n            return this;\n          };\n          /*\\\n           * Element.show\n           [ method ]\n           **\n           * Makes element visible. See @Element.hide.\n           = (object) @Element\n          \\*/\n\n\n          elproto.show = function () {\n            if (!this.removed) this.node.style.display = \"\";\n            return this;\n          };\n          /*\\\n           * Element.remove\n           [ method ]\n           **\n           * Removes element from the paper.\n          \\*/\n\n\n          elproto.remove = function () {\n            var node = getRealNode(this.node);\n\n            if (this.removed || !node.parentNode) {\n              return;\n            }\n\n            var paper = this.paper;\n            paper.__set__ && paper.__set__.exclude(this);\n            eve.unbind(\"raphael.*.*.\" + this.id);\n\n            if (this.gradient) {\n              paper.defs.removeChild(this.gradient);\n            }\n\n            R._tear(this, paper);\n\n            node.parentNode.removeChild(node); // Remove custom data for element\n\n            this.removeData();\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            this.removed = true;\n          };\n\n          elproto._getBBox = function () {\n            if (this.node.style.display == \"none\") {\n              this.show();\n              var hide = true;\n            }\n\n            var canvasHidden = false,\n                containerStyle;\n\n            if (this.paper.canvas.parentElement) {\n              containerStyle = this.paper.canvas.parentElement.style;\n            } //IE10+ can't find parentElement\n            else if (this.paper.canvas.parentNode) {\n              containerStyle = this.paper.canvas.parentNode.style;\n            }\n\n            if (containerStyle && containerStyle.display == \"none\") {\n              canvasHidden = true;\n              containerStyle.display = \"\";\n            }\n\n            var bbox = {};\n\n            try {\n              bbox = this.node.getBBox();\n            } catch (e) {\n              // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\n              bbox = {\n                x: this.node.clientLeft,\n                y: this.node.clientTop,\n                width: this.node.clientWidth,\n                height: this.node.clientHeight\n              };\n            } finally {\n              bbox = bbox || {};\n\n              if (canvasHidden) {\n                containerStyle.display = \"none\";\n              }\n            }\n\n            hide && this.hide();\n            return bbox;\n          };\n          /*\\\n           * Element.attr\n           [ method ]\n           **\n           * Sets the attributes of the element.\n           > Parameters\n           - attrName (string) attribute’s name\n           - value (string) value\n           * or\n           - params (object) object of name/value pairs\n           * or\n           - attrName (string) attribute’s name\n           * or\n           - attrNames (array) in this case method returns array of current values for given attribute names\n           = (object) @Element if attrsName & value or params are passed in.\n           = (...) value of the attribute if only attrsName is passed in.\n           = (array) array of values of the attribute if attrsNames is passed in.\n           = (object) object of attributes if nothing is passed in.\n           > Possible parameters\n           # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\n           o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\n           o clip-rect (string) comma or space separated values: x, y, width and height\n           o cursor (string) CSS type of the cursor\n           o cx (number) the x-axis coordinate of the center of the circle, or ellipse\n           o cy (number) the y-axis coordinate of the center of the circle, or ellipse\n           o fill (string) colour, gradient or image\n           o fill-opacity (number)\n           o font (string)\n           o font-family (string)\n           o font-size (number) font size in pixels\n           o font-weight (string)\n           o height (number)\n           o href (string) URL, if specified element behaves as hyperlink\n           o opacity (number)\n           o path (string) SVG path string format\n           o r (number) radius of the circle, ellipse or rounded corner on the rect\n           o rx (number) horisontal radius of the ellipse\n           o ry (number) vertical radius of the ellipse\n           o src (string) image URL, only works for @Element.image element\n           o stroke (string) stroke colour\n           o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]\n           o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]\n           o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]\n           o stroke-miterlimit (number)\n           o stroke-opacity (number)\n           o stroke-width (number) stroke width in pixels, default is '1'\n           o target (string) used with href\n           o text (string) contents of the text element. Use `\\n` for multiline text\n           o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”\n           o title (string) will create tooltip with a given text\n           o transform (string) see @Element.transform\n           o width (number)\n           o x (number)\n           o y (number)\n           > Gradients\n           * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°\n           * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.\n           *\n           * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –\n           * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point\n           * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\n           > Path String\n           # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path’s data attribute’s format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>\n           > Colour Parsing\n           # <ul>\n           #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\n           #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\n           #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\n           #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\n           #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\n           #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>\n           #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>\n           #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\n           #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>\n           #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\n           #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>\n           #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>\n           # </ul>\n          \\*/\n\n\n          elproto.attr = function (name, value) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (name == null) {\n              var res = {};\n\n              for (var a in this.attrs) {\n                if (this.attrs[has](a)) {\n                  res[a] = this.attrs[a];\n                }\n              }\n\n              res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n              res.transform = this._.transform;\n              return res;\n            }\n\n            if (value == null && R.is(name, \"string\")) {\n              if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n              }\n\n              if (name == \"transform\") {\n                return this._.transform;\n              }\n\n              var names = name.split(separator),\n                  out = {};\n\n              for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n\n                if (name in this.attrs) {\n                  out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                  out[name] = this.paper.customAttributes[name].def;\n                } else {\n                  out[name] = R._availableAttrs[name];\n                }\n              }\n\n              return ii - 1 ? out : out[names[0]];\n            }\n\n            if (value == null && R.is(name, \"array\")) {\n              out = {};\n\n              for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n              }\n\n              return out;\n            }\n\n            if (value != null) {\n              var params = {};\n              params[name] = value;\n            } else if (name != null && R.is(name, \"object\")) {\n              params = name;\n            }\n\n            for (var key in params) {\n              eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n            }\n\n            for (key in this.paper.customAttributes) {\n              if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n                this.attrs[key] = params[key];\n\n                for (var subkey in par) {\n                  if (par[has](subkey)) {\n                    params[subkey] = par[subkey];\n                  }\n                }\n              }\n            }\n\n            setFillAndStroke(this, params);\n            return this;\n          };\n          /*\\\n           * Element.toFront\n           [ method ]\n           **\n           * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.\n           = (object) @Element\n          \\*/\n\n\n          elproto.toFront = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            node.parentNode.appendChild(node);\n            var svg = this.paper;\n            svg.top != this && R._tofront(this, svg);\n            return this;\n          };\n          /*\\\n           * Element.toBack\n           [ method ]\n           **\n           * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.\n           = (object) @Element\n          \\*/\n\n\n          elproto.toBack = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var parentNode = node.parentNode;\n            parentNode.insertBefore(node, parentNode.firstChild);\n\n            R._toback(this, this.paper);\n\n            var svg = this.paper;\n            return this;\n          };\n          /*\\\n           * Element.insertAfter\n           [ method ]\n           **\n           * Inserts current object after the given one.\n           = (object) @Element\n          \\*/\n\n\n          elproto.insertAfter = function (element) {\n            if (this.removed || !element) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var afterNode = getRealNode(element.node || element[element.length - 1].node);\n\n            if (afterNode.nextSibling) {\n              afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\n            } else {\n              afterNode.parentNode.appendChild(node);\n            }\n\n            R._insertafter(this, element, this.paper);\n\n            return this;\n          };\n          /*\\\n           * Element.insertBefore\n           [ method ]\n           **\n           * Inserts current object before the given one.\n           = (object) @Element\n          \\*/\n\n\n          elproto.insertBefore = function (element) {\n            if (this.removed || !element) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var beforeNode = getRealNode(element.node || element[0].node);\n            beforeNode.parentNode.insertBefore(node, beforeNode);\n\n            R._insertbefore(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.blur = function (size) {\n            // Experimental. No Safari support. Use it on your own risk.\n            var t = this;\n\n            if (+size !== 0) {\n              var fltr = $(\"filter\"),\n                  blur = $(\"feGaussianBlur\");\n              t.attrs.blur = size;\n              fltr.id = R.createUUID();\n              $(blur, {\n                stdDeviation: +size || 1.5\n              });\n              fltr.appendChild(blur);\n              t.paper.defs.appendChild(fltr);\n              t._blur = fltr;\n              $(t.node, {\n                filter: \"url(#\" + fltr.id + \")\"\n              });\n            } else {\n              if (t._blur) {\n                t._blur.parentNode.removeChild(t._blur);\n\n                delete t._blur;\n                delete t.attrs.blur;\n              }\n\n              t.node.removeAttribute(\"filter\");\n            }\n\n            return t;\n          };\n\n          R._engine.circle = function (svg, x, y, r) {\n            var el = $(\"circle\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              cx: x,\n              cy: y,\n              r: r,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"circle\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.rect = function (svg, x, y, w, h, r) {\n            var el = $(\"rect\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              rx: r || 0,\n              ry: r || 0,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"rect\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.ellipse = function (svg, x, y, rx, ry) {\n            var el = $(\"ellipse\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              cx: x,\n              cy: y,\n              rx: rx,\n              ry: ry,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"ellipse\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.image = function (svg, src, x, y, w, h) {\n            var el = $(\"image\");\n            $(el, {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              preserveAspectRatio: \"none\"\n            });\n            el.setAttributeNS(xlink, \"href\", src);\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              src: src\n            };\n            res.type = \"image\";\n            return res;\n          };\n\n          R._engine.text = function (svg, x, y, text) {\n            var el = $(\"text\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              \"text-anchor\": \"middle\",\n              text: text,\n              \"font-family\": R._availableAttrs[\"font-family\"],\n              \"font-size\": R._availableAttrs[\"font-size\"],\n              stroke: \"none\",\n              fill: \"#000\"\n            };\n            res.type = \"text\";\n            setFillAndStroke(res, res.attrs);\n            return res;\n          };\n\n          R._engine.setSize = function (width, height) {\n            this.width = width || this.width;\n            this.height = height || this.height;\n            this.canvas.setAttribute(\"width\", this.width);\n            this.canvas.setAttribute(\"height\", this.height);\n\n            if (this._viewBox) {\n              this.setViewBox.apply(this, this._viewBox);\n            }\n\n            return this;\n          };\n\n          R._engine.create = function () {\n            var con = R._getContainer.apply(0, arguments),\n                container = con && con.container;\n\n            if (!container) {\n              throw new Error(\"SVG container not found.\");\n            }\n\n            var x = con.x,\n                y = con.y,\n                width = con.width,\n                height = con.height,\n                cnvs = $(\"svg\"),\n                css = \"overflow:hidden;\",\n                isFloating;\n            x = x || 0;\n            y = y || 0;\n            width = width || 512;\n            height = height || 342;\n            $(cnvs, {\n              height: height,\n              version: 1.1,\n              width: width,\n              xmlns: \"http://www.w3.org/2000/svg\",\n              \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n            });\n\n            if (container == 1) {\n              cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\n\n              R._g.doc.body.appendChild(cnvs);\n\n              isFloating = 1;\n            } else {\n              cnvs.style.cssText = css + \"position:relative\";\n\n              if (container.firstChild) {\n                container.insertBefore(cnvs, container.firstChild);\n              } else {\n                container.appendChild(cnvs);\n              }\n            }\n\n            container = new R._Paper();\n            container.width = width;\n            container.height = height;\n            container.canvas = cnvs;\n            container.clear();\n            container._left = container._top = 0;\n            isFloating && (container.renderfix = function () {});\n            container.renderfix();\n            return container;\n          };\n\n          R._engine.setViewBox = function (x, y, w, h, fit) {\n            eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n            var paperSize = this.getSize(),\n                size = mmax(w / paperSize.width, h / paperSize.height),\n                top = this.top,\n                aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\n                vb,\n                sw;\n\n            if (x == null) {\n              if (this._vbSize) {\n                size = 1;\n              }\n\n              delete this._vbSize;\n              vb = \"0 0 \" + this.width + S + this.height;\n            } else {\n              this._vbSize = size;\n              vb = x + S + y + S + w + S + h;\n            }\n\n            $(this.canvas, {\n              viewBox: vb,\n              preserveAspectRatio: aspectRatio\n            });\n\n            while (size && top) {\n              sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\n              top.attr({\n                \"stroke-width\": sw\n              });\n              top._.dirty = 1;\n              top._.dirtyT = 1;\n              top = top.prev;\n            }\n\n            this._viewBox = [x, y, w, h, !!fit];\n            return this;\n          };\n          /*\\\n           * Paper.renderfix\n           [ method ]\n           **\n           * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent\n           * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\n           * This method fixes the issue.\n           **\n             Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\n          \\*/\n\n\n          R.prototype.renderfix = function () {\n            var cnvs = this.canvas,\n                s = cnvs.style,\n                pos;\n\n            try {\n              pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\n            } catch (e) {\n              pos = cnvs.createSVGMatrix();\n            }\n\n            var left = -pos.e % 1,\n                top = -pos.f % 1;\n\n            if (left || top) {\n              if (left) {\n                this._left = (this._left + left) % 1;\n                s.left = this._left + \"px\";\n              }\n\n              if (top) {\n                this._top = (this._top + top) % 1;\n                s.top = this._top + \"px\";\n              }\n            }\n          };\n          /*\\\n           * Paper.clear\n           [ method ]\n           **\n           * Clears the paper, i.e. removes all the elements.\n          \\*/\n\n\n          R.prototype.clear = function () {\n            R.eve(\"raphael.clear\", this);\n            var c = this.canvas;\n\n            while (c.firstChild) {\n              c.removeChild(c.firstChild);\n            }\n\n            this.bottom = this.top = null;\n            (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\n            c.appendChild(this.desc);\n            c.appendChild(this.defs = $(\"defs\"));\n          };\n          /*\\\n           * Paper.remove\n           [ method ]\n           **\n           * Removes the paper from the DOM.\n          \\*/\n\n\n          R.prototype.remove = function () {\n            eve(\"raphael.remove\", this);\n            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n          };\n\n          var setproto = R.st;\n\n          for (var method in elproto) {\n            if (elproto[has](method) && !setproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.vml.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.vml.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelVmlJs(module, exports, __nested_webpack_require_280447__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_280447__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          if (R && !R.vml) {\n            return;\n          }\n\n          var has = \"hasOwnProperty\",\n              Str = String,\n              toFloat = parseFloat,\n              math = Math,\n              round = math.round,\n              mmax = math.max,\n              mmin = math.min,\n              abs = math.abs,\n              fillString = \"fill\",\n              separator = /[, ]+/,\n              eve = R.eve,\n              ms = \" progid:DXImageTransform.Microsoft\",\n              S = \" \",\n              E = \"\",\n              map = {\n            M: \"m\",\n            L: \"l\",\n            C: \"c\",\n            Z: \"x\",\n            m: \"t\",\n            l: \"r\",\n            c: \"v\",\n            z: \"x\"\n          },\n              bites = /([clmz]),?([^clmz]*)/gi,\n              blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\n              val = /-?[^,\\s-]+/g,\n              cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\n              zoom = 21600,\n              pathTypes = {\n            path: 1,\n            rect: 1,\n            image: 1\n          },\n              ovalTypes = {\n            circle: 1,\n            ellipse: 1\n          },\n              path2vml = function path2vml(path) {\n            var total = /[ahqstv]/ig,\n                command = R._pathToAbsolute;\n            Str(path).match(total) && (command = R._path2curve);\n            total = /[clmz]/g;\n\n            if (command == R._pathToAbsolute && !Str(path).match(total)) {\n              var res = Str(path).replace(bites, function (all, command, args) {\n                var vals = [],\n                    isMove = command.toLowerCase() == \"m\",\n                    res = map[command];\n                args.replace(val, function (value) {\n                  if (isMove && vals.length == 2) {\n                    res += vals + map[command == \"m\" ? \"l\" : \"L\"];\n                    vals = [];\n                  }\n\n                  vals.push(round(value * zoom));\n                });\n                return res + vals;\n              });\n              return res;\n            }\n\n            var pa = command(path),\n                p,\n                r;\n            res = [];\n\n            for (var i = 0, ii = pa.length; i < ii; i++) {\n              p = pa[i];\n              r = pa[i][0].toLowerCase();\n              r == \"z\" && (r = \"x\");\n\n              for (var j = 1, jj = p.length; j < jj; j++) {\n                r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\n              }\n\n              res.push(r);\n            }\n\n            return res.join(S);\n          },\n              compensation = function compensation(deg, dx, dy) {\n            var m = R.matrix();\n            m.rotate(-deg, .5, .5);\n            return {\n              dx: m.x(dx, dy),\n              dy: m.y(dx, dy)\n            };\n          },\n              setCoords = function setCoords(p, sx, sy, dx, dy, deg) {\n            var _ = p._,\n                m = p.matrix,\n                fillpos = _.fillpos,\n                o = p.node,\n                s = o.style,\n                y = 1,\n                flip = \"\",\n                dxdy,\n                kx = zoom / sx,\n                ky = zoom / sy;\n            s.visibility = \"hidden\";\n\n            if (!sx || !sy) {\n              return;\n            }\n\n            o.coordsize = abs(kx) + S + abs(ky);\n            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\n\n            if (deg) {\n              var c = compensation(deg, dx, dy);\n              dx = c.dx;\n              dy = c.dy;\n            }\n\n            sx < 0 && (flip += \"x\");\n            sy < 0 && (flip += \" y\") && (y = -1);\n            s.flip = flip;\n            o.coordorigin = dx * -kx + S + dy * -ky;\n\n            if (fillpos || _.fillsize) {\n              var fill = o.getElementsByTagName(fillString);\n              fill = fill && fill[0];\n              o.removeChild(fill);\n\n              if (fillpos) {\n                c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\n                fill.position = c.dx * y + S + c.dy * y;\n              }\n\n              if (_.fillsize) {\n                fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\n              }\n\n              o.appendChild(fill);\n            }\n\n            s.visibility = \"visible\";\n          };\n\n          R.toString = function () {\n            return \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xEBl \" + this.version;\n          };\n\n          var addArrow = function addArrow(o, value, isEnd) {\n            var values = Str(value).toLowerCase().split(\"-\"),\n                se = isEnd ? \"end\" : \"start\",\n                i = values.length,\n                type = \"classic\",\n                w = \"medium\",\n                h = \"medium\";\n\n            while (i--) {\n              switch (values[i]) {\n                case \"block\":\n                case \"classic\":\n                case \"oval\":\n                case \"diamond\":\n                case \"open\":\n                case \"none\":\n                  type = values[i];\n                  break;\n\n                case \"wide\":\n                case \"narrow\":\n                  h = values[i];\n                  break;\n\n                case \"long\":\n                case \"short\":\n                  w = values[i];\n                  break;\n              }\n            }\n\n            var stroke = o.node.getElementsByTagName(\"stroke\")[0];\n            stroke[se + \"arrow\"] = type;\n            stroke[se + \"arrowlength\"] = w;\n            stroke[se + \"arrowwidth\"] = h;\n          },\n              setFillAndStroke = function setFillAndStroke(o, params) {\n            // o.paper.canvas.style.display = \"none\";\n            o.attrs = o.attrs || {};\n            var node = o.node,\n                a = o.attrs,\n                s = node.style,\n                xy,\n                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\n                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\n                res = o;\n\n            for (var par in params) {\n              if (params[has](par)) {\n                a[par] = params[par];\n              }\n            }\n\n            if (newpath) {\n              a.path = R._getPath[o.type](o);\n              o._.dirty = 1;\n            }\n\n            params.href && (node.href = params.href);\n            params.title && (node.title = params.title);\n            params.target && (node.target = params.target);\n            params.cursor && (s.cursor = params.cursor);\n            \"blur\" in params && o.blur(params.blur);\n\n            if (params.path && o.type == \"path\" || newpath) {\n              node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\n              o._.dirty = 1;\n\n              if (o.type == \"image\") {\n                o._.fillpos = [a.x, a.y];\n                o._.fillsize = [a.width, a.height];\n                setCoords(o, 1, 1, 0, 0, 0);\n              }\n            }\n\n            \"transform\" in params && o.transform(params.transform);\n\n            if (isOval) {\n              var cx = +a.cx,\n                  cy = +a.cy,\n                  rx = +a.rx || +a.r || 0,\n                  ry = +a.ry || +a.r || 0;\n              node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\n              o._.dirty = 1;\n            }\n\n            if (\"clip-rect\" in params) {\n              var rect = Str(params[\"clip-rect\"]).split(separator);\n\n              if (rect.length == 4) {\n                rect[2] = +rect[2] + +rect[0];\n                rect[3] = +rect[3] + +rect[1];\n\n                var div = node.clipRect || R._g.doc.createElement(\"div\"),\n                    dstyle = div.style;\n\n                dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\n\n                if (!node.clipRect) {\n                  dstyle.position = \"absolute\";\n                  dstyle.top = 0;\n                  dstyle.left = 0;\n                  dstyle.width = o.paper.width + \"px\";\n                  dstyle.height = o.paper.height + \"px\";\n                  node.parentNode.insertBefore(div, node);\n                  div.appendChild(node);\n                  node.clipRect = div;\n                }\n              }\n\n              if (!params[\"clip-rect\"]) {\n                node.clipRect && (node.clipRect.style.clip = \"auto\");\n              }\n            }\n\n            if (o.textpath) {\n              var textpathStyle = o.textpath.style;\n              params.font && (textpathStyle.font = params.font);\n              params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\n              params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\n              params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\n              params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\n            }\n\n            if (\"arrow-start\" in params) {\n              addArrow(res, params[\"arrow-start\"]);\n            }\n\n            if (\"arrow-end\" in params) {\n              addArrow(res, params[\"arrow-end\"], 1);\n            }\n\n            if (params.opacity != null || params.fill != null || params.src != null || params.stroke != null || params[\"stroke-width\"] != null || params[\"stroke-opacity\"] != null || params[\"fill-opacity\"] != null || params[\"stroke-dasharray\"] != null || params[\"stroke-miterlimit\"] != null || params[\"stroke-linejoin\"] != null || params[\"stroke-linecap\"] != null) {\n              var fill = node.getElementsByTagName(fillString),\n                  newfill = false;\n              fill = fill && fill[0];\n              !fill && (newfill = fill = createNode(fillString));\n\n              if (o.type == \"image\" && params.src) {\n                fill.src = params.src;\n              }\n\n              params.fill && (fill.on = true);\n\n              if (fill.on == null || params.fill == \"none\" || params.fill === null) {\n                fill.on = false;\n              }\n\n              if (fill.on && params.fill) {\n                var isURL = Str(params.fill).match(R._ISURL);\n\n                if (isURL) {\n                  fill.parentNode == node && node.removeChild(fill);\n                  fill.rotate = true;\n                  fill.src = isURL[1];\n                  fill.type = \"tile\";\n                  var bbox = o.getBBox(1);\n                  fill.position = bbox.x + S + bbox.y;\n                  o._.fillpos = [bbox.x, bbox.y];\n\n                  R._preload(isURL[1], function () {\n                    o._.fillsize = [this.offsetWidth, this.offsetHeight];\n                  });\n                } else {\n                  fill.color = R.getRGB(params.fill).hex;\n                  fill.src = E;\n                  fill.type = \"solid\";\n\n                  if (R.getRGB(params.fill).error && (res.type in {\n                    circle: 1,\n                    ellipse: 1\n                  } || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\n                    a.fill = \"none\";\n                    a.gradient = params.fill;\n                    fill.rotate = false;\n                  }\n                }\n              }\n\n              if (\"fill-opacity\" in params || \"opacity\" in params) {\n                var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\n                opacity = mmin(mmax(opacity, 0), 1);\n                fill.opacity = opacity;\n\n                if (fill.src) {\n                  fill.color = \"none\";\n                }\n              }\n\n              node.appendChild(fill);\n              var stroke = node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0],\n                  newstroke = false;\n              !stroke && (newstroke = stroke = createNode(\"stroke\"));\n\n              if (params.stroke && params.stroke != \"none\" || params[\"stroke-width\"] || params[\"stroke-opacity\"] != null || params[\"stroke-dasharray\"] || params[\"stroke-miterlimit\"] || params[\"stroke-linejoin\"] || params[\"stroke-linecap\"]) {\n                stroke.on = true;\n              }\n\n              (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\n              var strokeColor = R.getRGB(params.stroke);\n              stroke.on && params.stroke && (stroke.color = strokeColor.hex);\n              opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\n              var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\n              opacity = mmin(mmax(opacity, 0), 1);\n              params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\n              params[\"stroke-width\"] && (stroke.weight = width);\n              width && width < 1 && (opacity *= width) && (stroke.weight = 1);\n              stroke.opacity = opacity;\n              params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\n              stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\n              params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\n\n              if (\"stroke-dasharray\" in params) {\n                var dasharray = {\n                  \"-\": \"shortdash\",\n                  \".\": \"shortdot\",\n                  \"-.\": \"shortdashdot\",\n                  \"-..\": \"shortdashdotdot\",\n                  \". \": \"dot\",\n                  \"- \": \"dash\",\n                  \"--\": \"longdash\",\n                  \"- .\": \"dashdot\",\n                  \"--.\": \"longdashdot\",\n                  \"--..\": \"longdashdotdot\"\n                };\n                stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\n              }\n\n              newstroke && node.appendChild(stroke);\n            }\n\n            if (res.type == \"text\") {\n              res.paper.canvas.style.display = E;\n              var span = res.paper.span,\n                  m = 100,\n                  fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\n              s = span.style;\n              a.font && (s.font = a.font);\n              a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\n              a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\n              a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\n              fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\n              s.fontSize = fontSize * m + \"px\";\n              res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\n              var brect = span.getBoundingClientRect();\n              res.W = a.w = (brect.right - brect.left) / m;\n              res.H = a.h = (brect.bottom - brect.top) / m; // res.paper.canvas.style.display = \"none\";\n\n              res.X = a.x;\n              res.Y = a.y + res.H / 2;\n              (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\n              var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\n\n              for (var d = 0, dd = dirtyattrs.length; d < dd; d++) {\n                if (dirtyattrs[d] in params) {\n                  res._.dirty = 1;\n                  break;\n                }\n              } // text-anchor emulation\n\n\n              switch (a[\"text-anchor\"]) {\n                case \"start\":\n                  res.textpath.style[\"v-text-align\"] = \"left\";\n                  res.bbx = res.W / 2;\n                  break;\n\n                case \"end\":\n                  res.textpath.style[\"v-text-align\"] = \"right\";\n                  res.bbx = -res.W / 2;\n                  break;\n\n                default:\n                  res.textpath.style[\"v-text-align\"] = \"center\";\n                  res.bbx = 0;\n                  break;\n              }\n\n              res.textpath.style[\"v-text-kern\"] = true;\n            } // res.paper.canvas.style.display = E;\n\n          },\n              addGradientFill = function addGradientFill(o, gradient, fill) {\n            o.attrs = o.attrs || {};\n            var attrs = o.attrs,\n                pow = Math.pow,\n                opacity,\n                oindex,\n                type = \"linear\",\n                fxfy = \".5 .5\";\n            o.attrs.gradient = gradient;\n            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\n              type = \"radial\";\n\n              if (fx && fy) {\n                fx = toFloat(fx);\n                fy = toFloat(fy);\n                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\n                fxfy = fx + S + fy;\n              }\n\n              return E;\n            });\n            gradient = gradient.split(/\\s*\\-\\s*/);\n\n            if (type == \"linear\") {\n              var angle = gradient.shift();\n              angle = -toFloat(angle);\n\n              if (isNaN(angle)) {\n                return null;\n              }\n            }\n\n            var dots = R._parseDots(gradient);\n\n            if (!dots) {\n              return null;\n            }\n\n            o = o.shape || o.node;\n\n            if (dots.length) {\n              o.removeChild(fill);\n              fill.on = true;\n              fill.method = \"none\";\n              fill.color = dots[0].color;\n              fill.color2 = dots[dots.length - 1].color;\n              var clrs = [];\n\n              for (var i = 0, ii = dots.length; i < ii; i++) {\n                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\n              }\n\n              fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\n\n              if (type == \"radial\") {\n                fill.type = \"gradientTitle\";\n                fill.focus = \"100%\";\n                fill.focussize = \"0 0\";\n                fill.focusposition = fxfy;\n                fill.angle = 0;\n              } else {\n                // fill.rotate= true;\n                fill.type = \"gradient\";\n                fill.angle = (270 - angle) % 360;\n              }\n\n              o.appendChild(fill);\n            }\n\n            return 1;\n          },\n              Element = function Element(node, vml) {\n            this[0] = this.node = node;\n            node.raphael = true;\n            this.id = R._oid++;\n            node.raphaelid = this.id;\n            this.X = 0;\n            this.Y = 0;\n            this.attrs = {};\n            this.paper = vml;\n            this.matrix = R.matrix();\n            this._ = {\n              transform: [],\n              sx: 1,\n              sy: 1,\n              dx: 0,\n              dy: 0,\n              deg: 0,\n              dirty: 1,\n              dirtyT: 1\n            };\n            !vml.bottom && (vml.bottom = this);\n            this.prev = vml.top;\n            vml.top && (vml.top.next = this);\n            vml.top = this;\n            this.next = null;\n          };\n\n          var elproto = R.el;\n          Element.prototype = elproto;\n          elproto.constructor = Element;\n\n          elproto.transform = function (tstr) {\n            if (tstr == null) {\n              return this._.transform;\n            }\n\n            var vbs = this.paper._viewBoxShift,\n                vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\n                oldt;\n\n            if (vbs) {\n              oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\n            }\n\n            R._extractTransform(this, vbt + tstr);\n\n            var matrix = this.matrix.clone(),\n                skew = this.skew,\n                o = this.node,\n                split,\n                isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\n                isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\n            matrix.translate(1, 1);\n\n            if (isPatt || isGrad || this.type == \"image\") {\n              skew.matrix = \"1 0 0 1\";\n              skew.offset = \"0 0\";\n              split = matrix.split();\n\n              if (isGrad && split.noRotation || !split.isSimple) {\n                o.style.filter = matrix.toFilter();\n                var bb = this.getBBox(),\n                    bbt = this.getBBox(1),\n                    dx = bb.x - bbt.x,\n                    dy = bb.y - bbt.y;\n                o.coordorigin = dx * -zoom + S + dy * -zoom;\n                setCoords(this, 1, 1, dx, dy, 0);\n              } else {\n                o.style.filter = E;\n                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\n              }\n            } else {\n              o.style.filter = E;\n              skew.matrix = Str(matrix);\n              skew.offset = matrix.offset();\n            }\n\n            if (oldt !== null) {\n              // empty string value is true as well\n              this._.transform = oldt;\n\n              R._extractTransform(this, oldt);\n            }\n\n            return this;\n          };\n\n          elproto.rotate = function (deg, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (deg == null) {\n              return;\n            }\n\n            deg = Str(deg).split(separator);\n\n            if (deg.length - 1) {\n              cx = toFloat(deg[1]);\n              cy = toFloat(deg[2]);\n            }\n\n            deg = toFloat(deg[0]);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n              cx = bbox.x + bbox.width / 2;\n              cy = bbox.y + bbox.height / 2;\n            }\n\n            this._.dirtyT = 1;\n            this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n            return this;\n          };\n\n          elproto.translate = function (dx, dy) {\n            if (this.removed) {\n              return this;\n            }\n\n            dx = Str(dx).split(separator);\n\n            if (dx.length - 1) {\n              dy = toFloat(dx[1]);\n            }\n\n            dx = toFloat(dx[0]) || 0;\n            dy = +dy || 0;\n\n            if (this._.bbox) {\n              this._.bbox.x += dx;\n              this._.bbox.y += dy;\n            }\n\n            this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n            return this;\n          };\n\n          elproto.scale = function (sx, sy, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            sx = Str(sx).split(separator);\n\n            if (sx.length - 1) {\n              sy = toFloat(sx[1]);\n              cx = toFloat(sx[2]);\n              cy = toFloat(sx[3]);\n              isNaN(cx) && (cx = null);\n              isNaN(cy) && (cy = null);\n            }\n\n            sx = toFloat(sx[0]);\n            sy == null && (sy = sx);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n            }\n\n            cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n            cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n            this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n            this._.dirtyT = 1;\n            return this;\n          };\n\n          elproto.hide = function () {\n            !this.removed && (this.node.style.display = \"none\");\n            return this;\n          };\n\n          elproto.show = function () {\n            !this.removed && (this.node.style.display = E);\n            return this;\n          }; // Needed to fix the vml setViewBox issues\n\n\n          elproto.auxGetBBox = R.el.getBBox;\n\n          elproto.getBBox = function () {\n            var b = this.auxGetBBox();\n\n            if (this.paper && this.paper._viewBoxShift) {\n              var c = {};\n              var z = 1 / this.paper._viewBoxShift.scale;\n              c.x = b.x - this.paper._viewBoxShift.dx;\n              c.x *= z;\n              c.y = b.y - this.paper._viewBoxShift.dy;\n              c.y *= z;\n              c.width = b.width * z;\n              c.height = b.height * z;\n              c.x2 = c.x + c.width;\n              c.y2 = c.y + c.height;\n              return c;\n            }\n\n            return b;\n          };\n\n          elproto._getBBox = function () {\n            if (this.removed) {\n              return {};\n            }\n\n            return {\n              x: this.X + (this.bbx || 0) - this.W / 2,\n              y: this.Y - this.H,\n              width: this.W,\n              height: this.H\n            };\n          };\n\n          elproto.remove = function () {\n            if (this.removed || !this.node.parentNode) {\n              return;\n            }\n\n            this.paper.__set__ && this.paper.__set__.exclude(this);\n            R.eve.unbind(\"raphael.*.*.\" + this.id);\n\n            R._tear(this, this.paper);\n\n            this.node.parentNode.removeChild(this.node);\n            this.shape && this.shape.parentNode.removeChild(this.shape);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            this.removed = true;\n          };\n\n          elproto.attr = function (name, value) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (name == null) {\n              var res = {};\n\n              for (var a in this.attrs) {\n                if (this.attrs[has](a)) {\n                  res[a] = this.attrs[a];\n                }\n              }\n\n              res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n              res.transform = this._.transform;\n              return res;\n            }\n\n            if (value == null && R.is(name, \"string\")) {\n              if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n              }\n\n              var names = name.split(separator),\n                  out = {};\n\n              for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n\n                if (name in this.attrs) {\n                  out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                  out[name] = this.paper.customAttributes[name].def;\n                } else {\n                  out[name] = R._availableAttrs[name];\n                }\n              }\n\n              return ii - 1 ? out : out[names[0]];\n            }\n\n            if (this.attrs && value == null && R.is(name, \"array\")) {\n              out = {};\n\n              for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n              }\n\n              return out;\n            }\n\n            var params;\n\n            if (value != null) {\n              params = {};\n              params[name] = value;\n            }\n\n            value == null && R.is(name, \"object\") && (params = name);\n\n            for (var key in params) {\n              eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n            }\n\n            if (params) {\n              for (key in this.paper.customAttributes) {\n                if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n                  var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n                  this.attrs[key] = params[key];\n\n                  for (var subkey in par) {\n                    if (par[has](subkey)) {\n                      params[subkey] = par[subkey];\n                    }\n                  }\n                }\n              } // this.paper.canvas.style.display = \"none\";\n\n\n              if (params.text && this.type == \"text\") {\n                this.textpath.string = params.text;\n              }\n\n              setFillAndStroke(this, params); // this.paper.canvas.style.display = E;\n            }\n\n            return this;\n          };\n\n          elproto.toFront = function () {\n            !this.removed && this.node.parentNode.appendChild(this.node);\n            this.paper && this.paper.top != this && R._tofront(this, this.paper);\n            return this;\n          };\n\n          elproto.toBack = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            if (this.node.parentNode.firstChild != this.node) {\n              this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\n\n              R._toback(this, this.paper);\n            }\n\n            return this;\n          };\n\n          elproto.insertAfter = function (element) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (element.constructor == R.st.constructor) {\n              element = element[element.length - 1];\n            }\n\n            if (element.node.nextSibling) {\n              element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\n            } else {\n              element.node.parentNode.appendChild(this.node);\n            }\n\n            R._insertafter(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.insertBefore = function (element) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (element.constructor == R.st.constructor) {\n              element = element[0];\n            }\n\n            element.node.parentNode.insertBefore(this.node, element.node);\n\n            R._insertbefore(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.blur = function (size) {\n            var s = this.node.runtimeStyle,\n                f = s.filter;\n            f = f.replace(blurregexp, E);\n\n            if (+size !== 0) {\n              this.attrs.blur = size;\n              s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\n              s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\n            } else {\n              s.filter = f;\n              s.margin = 0;\n              delete this.attrs.blur;\n            }\n\n            return this;\n          };\n\n          R._engine.path = function (pathString, vml) {\n            var el = createNode(\"shape\");\n            el.style.cssText = cssDot;\n            el.coordsize = zoom + S + zoom;\n            el.coordorigin = vml.coordorigin;\n            var p = new Element(el, vml),\n                attr = {\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            pathString && (attr.path = pathString);\n            p.type = \"path\";\n            p.path = [];\n            p.Path = E;\n            setFillAndStroke(p, attr);\n            vml.canvas && vml.canvas.appendChild(el);\n            var skew = createNode(\"skew\");\n            skew.on = true;\n            el.appendChild(skew);\n            p.skew = skew;\n            p.transform(E);\n            return p;\n          };\n\n          R._engine.rect = function (vml, x, y, w, h, r) {\n            var path = R._rectPath(x, y, w, h, r),\n                res = vml.path(path),\n                a = res.attrs;\n\n            res.X = a.x = x;\n            res.Y = a.y = y;\n            res.W = a.width = w;\n            res.H = a.height = h;\n            a.r = r;\n            a.path = path;\n            res.type = \"rect\";\n            return res;\n          };\n\n          R._engine.ellipse = function (vml, x, y, rx, ry) {\n            var res = vml.path(),\n                a = res.attrs;\n            res.X = x - rx;\n            res.Y = y - ry;\n            res.W = rx * 2;\n            res.H = ry * 2;\n            res.type = \"ellipse\";\n            setFillAndStroke(res, {\n              cx: x,\n              cy: y,\n              rx: rx,\n              ry: ry\n            });\n            return res;\n          };\n\n          R._engine.circle = function (vml, x, y, r) {\n            var res = vml.path(),\n                a = res.attrs;\n            res.X = x - r;\n            res.Y = y - r;\n            res.W = res.H = r * 2;\n            res.type = \"circle\";\n            setFillAndStroke(res, {\n              cx: x,\n              cy: y,\n              r: r\n            });\n            return res;\n          };\n\n          R._engine.image = function (vml, src, x, y, w, h) {\n            var path = R._rectPath(x, y, w, h),\n                res = vml.path(path).attr({\n              stroke: \"none\"\n            }),\n                a = res.attrs,\n                node = res.node,\n                fill = node.getElementsByTagName(fillString)[0];\n\n            a.src = src;\n            res.X = a.x = x;\n            res.Y = a.y = y;\n            res.W = a.width = w;\n            res.H = a.height = h;\n            a.path = path;\n            res.type = \"image\";\n            fill.parentNode == node && node.removeChild(fill);\n            fill.rotate = true;\n            fill.src = src;\n            fill.type = \"tile\";\n            res._.fillpos = [x, y];\n            res._.fillsize = [w, h];\n            node.appendChild(fill);\n            setCoords(res, 1, 1, 0, 0, 0);\n            return res;\n          };\n\n          R._engine.text = function (vml, x, y, text) {\n            var el = createNode(\"shape\"),\n                path = createNode(\"path\"),\n                o = createNode(\"textpath\");\n            x = x || 0;\n            y = y || 0;\n            text = text || \"\";\n            path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\n            path.textpathok = true;\n            o.string = Str(text);\n            o.on = true;\n            el.style.cssText = cssDot;\n            el.coordsize = zoom + S + zoom;\n            el.coordorigin = \"0 0\";\n            var p = new Element(el, vml),\n                attr = {\n              fill: \"#000\",\n              stroke: \"none\",\n              font: R._availableAttrs.font,\n              text: text\n            };\n            p.shape = el;\n            p.path = path;\n            p.textpath = o;\n            p.type = \"text\";\n            p.attrs.text = Str(text);\n            p.attrs.x = x;\n            p.attrs.y = y;\n            p.attrs.w = 1;\n            p.attrs.h = 1;\n            setFillAndStroke(p, attr);\n            el.appendChild(o);\n            el.appendChild(path);\n            vml.canvas.appendChild(el);\n            var skew = createNode(\"skew\");\n            skew.on = true;\n            el.appendChild(skew);\n            p.skew = skew;\n            p.transform(E);\n            return p;\n          };\n\n          R._engine.setSize = function (width, height) {\n            var cs = this.canvas.style;\n            this.width = width;\n            this.height = height;\n            width == +width && (width += \"px\");\n            height == +height && (height += \"px\");\n            cs.width = width;\n            cs.height = height;\n            cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\n\n            if (this._viewBox) {\n              R._engine.setViewBox.apply(this, this._viewBox);\n            }\n\n            return this;\n          };\n\n          R._engine.setViewBox = function (x, y, w, h, fit) {\n            R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n            var paperSize = this.getSize(),\n                width = paperSize.width,\n                height = paperSize.height,\n                H,\n                W;\n\n            if (fit) {\n              H = height / h;\n              W = width / w;\n\n              if (w * H < width) {\n                x -= (width - w * H) / 2 / H;\n              }\n\n              if (h * W < height) {\n                y -= (height - h * W) / 2 / W;\n              }\n            }\n\n            this._viewBox = [x, y, w, h, !!fit];\n            this._viewBoxShift = {\n              dx: -x,\n              dy: -y,\n              scale: paperSize\n            };\n            this.forEach(function (el) {\n              el.transform(\"...\");\n            });\n            return this;\n          };\n\n          var createNode;\n\n          R._engine.initWin = function (win) {\n            var doc = win.document;\n\n            if (doc.styleSheets.length < 31) {\n              doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\n            } else {\n              // no more room, add to the existing one\n              // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n              doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\n            }\n\n            try {\n              !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\n\n              createNode = function createNode(tagName) {\n                return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\n              };\n            } catch (e) {\n              createNode = function createNode(tagName) {\n                return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\n              };\n            }\n          };\n\n          R._engine.initWin(R._g.win);\n\n          R._engine.create = function () {\n            var con = R._getContainer.apply(0, arguments),\n                container = con.container,\n                height = con.height,\n                s,\n                width = con.width,\n                x = con.x,\n                y = con.y;\n\n            if (!container) {\n              throw new Error(\"VML container not found.\");\n            }\n\n            var res = new R._Paper(),\n                c = res.canvas = R._g.doc.createElement(\"div\"),\n                cs = c.style;\n\n            x = x || 0;\n            y = y || 0;\n            width = width || 512;\n            height = height || 342;\n            res.width = width;\n            res.height = height;\n            width == +width && (width += \"px\");\n            height == +height && (height += \"px\");\n            res.coordsize = zoom * 1e3 + S + zoom * 1e3;\n            res.coordorigin = \"0 0\";\n            res.span = R._g.doc.createElement(\"span\");\n            res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\n            c.appendChild(res.span);\n            cs.cssText = R.format(\"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden\", width, height);\n\n            if (container == 1) {\n              R._g.doc.body.appendChild(c);\n\n              cs.left = x + \"px\";\n              cs.top = y + \"px\";\n              cs.position = \"absolute\";\n            } else {\n              if (container.firstChild) {\n                container.insertBefore(c, container.firstChild);\n              } else {\n                container.appendChild(c);\n              }\n            }\n\n            res.renderfix = function () {};\n\n            return res;\n          };\n\n          R.prototype.clear = function () {\n            R.eve(\"raphael.clear\", this);\n            this.canvas.innerHTML = E;\n            this.span = R._g.doc.createElement(\"span\");\n            this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\n            this.canvas.appendChild(this.span);\n            this.bottom = this.top = null;\n          };\n\n          R.prototype.remove = function () {\n            R.eve(\"raphael.remove\", this);\n            this.canvas.parentNode.removeChild(this.canvas);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            return true;\n          };\n\n          var setproto = R.st;\n\n          for (var method in elproto) {\n            if (elproto[has](method) && !setproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./node_modules/eve-raphael/eve.js\":\n      /*!*****************************************!*\\\n        !*** ./node_modules/eve-raphael/eve.js ***!\n        \\*****************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function node_modulesEveRaphaelEveJs(module, exports, __webpack_require__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n        // \n        // Licensed under the Apache License, Version 2.0 (the \"License\");\n        // you may not use this file except in compliance with the License.\n        // You may obtain a copy of the License at\n        // \n        // http://www.apache.org/licenses/LICENSE-2.0\n        // \n        // Unless required by applicable law or agreed to in writing, software\n        // distributed under the License is distributed on an \"AS IS\" BASIS,\n        // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n        // See the License for the specific language governing permissions and\n        // limitations under the License.\n        // ┌────────────────────────────────────────────────────────────┐ \\\\\n        // │ Eve 0.5.0 - JavaScript Events Library                      │ \\\\\n        // ├────────────────────────────────────────────────────────────┤ \\\\\n        // │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n        // └────────────────────────────────────────────────────────────┘ \\\\\n\n\n        (function (glob) {\n          var version = \"0.5.0\",\n              has = \"hasOwnProperty\",\n              separator = /[\\.\\/]/,\n              comaseparator = /\\s*,\\s*/,\n              wildcard = \"*\",\n              fun = function fun() {},\n              numsort = function numsort(a, b) {\n            return a - b;\n          },\n              current_event,\n              stop,\n              events = {\n            n: {}\n          },\n              firstDefined = function firstDefined() {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n              if (typeof this[i] != \"undefined\") {\n                return this[i];\n              }\n            }\n          },\n              lastDefined = function lastDefined() {\n            var i = this.length;\n\n            while (--i) {\n              if (typeof this[i] != \"undefined\") {\n                return this[i];\n              }\n            }\n          },\n              objtos = Object.prototype.toString,\n              Str = String,\n              isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n          };\n          /*\\\n           * eve\n           [ method ]\n            * Fires event with given `name`, given scope and other parameters.\n            > Arguments\n            - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n           - scope (object) context for the event handlers\n           - varargs (...) the rest of arguments will be sent to event handlers\n            = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n          \\*/\n\n\n          var eve = function eve(name, scope) {\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n\n            for (var i = 0, ii = listeners.length; i < ii; i++) {\n              if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n\n                if (listeners[i].zIndex < 0) {\n                  queue[listeners[i].zIndex] = listeners[i];\n                }\n              }\n            }\n\n            indexed.sort(numsort);\n\n            while (indexed[z] < 0) {\n              l = queue[indexed[z++]];\n              out.push(l.apply(scope, args));\n\n              if (stop) {\n                stop = oldstop;\n                return out;\n              }\n            }\n\n            for (i = 0; i < ii; i++) {\n              l = listeners[i];\n\n              if (\"zIndex\" in l) {\n                if (l.zIndex == indexed[z]) {\n                  out.push(l.apply(scope, args));\n\n                  if (stop) {\n                    break;\n                  }\n\n                  do {\n                    z++;\n                    l = queue[indexed[z]];\n                    l && out.push(l.apply(scope, args));\n\n                    if (stop) {\n                      break;\n                    }\n                  } while (l);\n                } else {\n                  queue[l.zIndex] = l;\n                }\n              } else {\n                out.push(l.apply(scope, args));\n\n                if (stop) {\n                  break;\n                }\n              }\n            }\n\n            stop = oldstop;\n            current_event = ce;\n            return out;\n          }; // Undocumented. Debug only.\n\n\n          eve._events = events;\n          /*\\\n           * eve.listeners\n           [ method ]\n            * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n            > Arguments\n            - name (string) name of the event, dot (`.`) or slash (`/`) separated\n            = (array) array of event handlers\n          \\*/\n\n          eve.listeners = function (name) {\n            var names = isArray(name) ? name : name.split(separator),\n                e = events,\n                item,\n                items,\n                k,\n                i,\n                ii,\n                j,\n                jj,\n                nes,\n                es = [e],\n                out = [];\n\n            for (i = 0, ii = names.length; i < ii; i++) {\n              nes = [];\n\n              for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n\n                while (k--) {\n                  item = items[k];\n\n                  if (item) {\n                    nes.push(item);\n                    out = out.concat(item.f || []);\n                  }\n                }\n              }\n\n              es = nes;\n            }\n\n            return out;\n          };\n          /*\\\n           * eve.separator\n           [ method ]\n            * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n           * here. Be aware that if you pass a string longer than one character it will be treated as\n           * a list of characters.\n            - separator (string) new separator. Empty string resets to default: `.` or `/`.\n          \\*/\n\n\n          eve.separator = function (sep) {\n            if (sep) {\n              sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n              sep = \"[\" + sep + \"]\";\n              separator = new RegExp(sep);\n            } else {\n              separator = /[\\.\\/]/;\n            }\n          };\n          /*\\\n           * eve.on\n           [ method ]\n           **\n           * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n           | eve.on(\"*.under.*\", f);\n           | eve(\"mouse.under.floor\"); // triggers f\n           * Use @eve to trigger the listener.\n           **\n           - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n           - f (function) event handler function\n           **\n           - name (array) if you don’t want to use separators, you can use array of strings\n           - f (function) event handler function\n           **\n           = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n           > Example:\n           | eve.on(\"mouse\", eatIt)(2);\n           | eve.on(\"mouse\", scream);\n           | eve.on(\"mouse\", catchIt)(1);\n           * This will ensure that `catchIt` function will be called before `eatIt`.\n           *\n           * If you want to put your handler before non-indexed handlers, specify a negative value.\n           * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n          \\*/\n\n\n          eve.on = function (name, f) {\n            if (typeof f != \"function\") {\n              return function () {};\n            }\n\n            var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n            for (var i = 0, ii = names.length; i < ii; i++) {\n              (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                  e = e.n;\n                  e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n                    n: {}\n                  });\n                }\n\n                e.f = e.f || [];\n\n                for (i = 0, ii = e.f.length; i < ii; i++) {\n                  if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                  }\n                }\n\n                !exist && e.f.push(f);\n              })(names[i]);\n            }\n\n            return function (zIndex) {\n              if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n              }\n            };\n          };\n          /*\\\n           * eve.f\n           [ method ]\n           **\n           * Returns function that will fire given event with optional arguments.\n           * Arguments that will be passed to the result function will be also\n           * concated to the list of final arguments.\n           | el.onclick = eve.f(\"click\", 1, 2);\n           | eve.on(\"click\", function (a, b, c) {\n           |     console.log(a, b, c); // 1, 2, [event object]\n           | });\n           > Arguments\n           - event (string) event name\n           - varargs (…) and any other arguments\n           = (function) possible event handler function\n          \\*/\n\n\n          eve.f = function (event) {\n            var attrs = [].slice.call(arguments, 1);\n            return function () {\n              eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n            };\n          };\n          /*\\\n           * eve.stop\n           [ method ]\n           **\n           * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n          \\*/\n\n\n          eve.stop = function () {\n            stop = 1;\n          };\n          /*\\\n           * eve.nt\n           [ method ]\n           **\n           * Could be used inside event handler to figure out actual name of the event.\n           **\n           > Arguments\n           **\n           - subname (string) #optional subname of the event\n           **\n           = (string) name of the event, if `subname` is not specified\n           * or\n           = (boolean) `true`, if current event’s name contains `subname`\n          \\*/\n\n\n          eve.nt = function (subname) {\n            var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\n            if (subname) {\n              return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n            }\n\n            return cur;\n          };\n          /*\\\n           * eve.nts\n           [ method ]\n           **\n           * Could be used inside event handler to figure out actual name of the event.\n           **\n           **\n           = (array) names of the event\n          \\*/\n\n\n          eve.nts = function () {\n            return isArray(current_event) ? current_event : current_event.split(separator);\n          };\n          /*\\\n           * eve.off\n           [ method ]\n           **\n           * Removes given function from the list of event listeners assigned to given name.\n           * If no arguments specified all the events will be cleared.\n           **\n           > Arguments\n           **\n           - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n           - f (function) event handler function\n          \\*/\n\n          /*\\\n           * eve.unbind\n           [ method ]\n           **\n           * See @eve.off\n          \\*/\n\n\n          eve.off = eve.unbind = function (name, f) {\n            if (!name) {\n              eve._events = events = {\n                n: {}\n              };\n              return;\n            }\n\n            var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n            if (names.length > 1) {\n              for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n              }\n\n              return;\n            }\n\n            names = isArray(name) ? name : Str(name).split(separator);\n            var e,\n                key,\n                splice,\n                i,\n                ii,\n                j,\n                jj,\n                cur = [events];\n\n            for (i = 0, ii = names.length; i < ii; i++) {\n              for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n\n                if (names[i] != wildcard) {\n                  if (e[names[i]]) {\n                    splice.push(e[names[i]]);\n                  }\n                } else {\n                  for (key in e) {\n                    if (e[has](key)) {\n                      splice.push(e[key]);\n                    }\n                  }\n                }\n\n                cur.splice.apply(cur, splice);\n              }\n            }\n\n            for (i = 0, ii = cur.length; i < ii; i++) {\n              e = cur[i];\n\n              while (e.n) {\n                if (f) {\n                  if (e.f) {\n                    for (j = 0, jj = e.f.length; j < jj; j++) {\n                      if (e.f[j] == f) {\n                        e.f.splice(j, 1);\n                        break;\n                      }\n                    }\n\n                    !e.f.length && delete e.f;\n                  }\n\n                  for (key in e.n) {\n                    if (e.n[has](key) && e.n[key].f) {\n                      var funcs = e.n[key].f;\n\n                      for (j = 0, jj = funcs.length; j < jj; j++) {\n                        if (funcs[j] == f) {\n                          funcs.splice(j, 1);\n                          break;\n                        }\n                      }\n\n                      !funcs.length && delete e.n[key].f;\n                    }\n                  }\n                } else {\n                  delete e.f;\n\n                  for (key in e.n) {\n                    if (e.n[has](key) && e.n[key].f) {\n                      delete e.n[key].f;\n                    }\n                  }\n                }\n\n                e = e.n;\n              }\n            }\n          };\n          /*\\\n           * eve.once\n           [ method ]\n           **\n           * Binds given event handler with a given name to only run once then unbind itself.\n           | eve.once(\"login\", f);\n           | eve(\"login\"); // triggers f\n           | eve(\"login\"); // no listeners\n           * Use @eve to trigger the listener.\n           **\n           > Arguments\n           **\n           - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n           - f (function) event handler function\n           **\n           = (function) same return function as @eve.on\n          \\*/\n\n\n          eve.once = function (name, f) {\n            var f2 = function f2() {\n              eve.off(name, f2);\n              return f.apply(this, arguments);\n            };\n\n            return eve.on(name, f2);\n          };\n          /*\\\n           * eve.version\n           [ property (string) ]\n           **\n           * Current version of the library.\n          \\*/\n\n\n          eve.version = version;\n\n          eve.toString = function () {\n            return \"You are running Eve \" + version;\n          };\n\n           true && module.exports ? module.exports = eve :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return eve;\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n        })(this);\n        /***/\n\n      }\n      /******/\n\n    })\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL3JhcGhhZWwvcmFwaGFlbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxTQUFTQSxnQ0FBVCxDQUEwQ0MsSUFBMUMsRUFBZ0RDLE9BQWhELEVBQXlEO0VBQ3pELElBQUcsc0JBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0Isc0JBQU9DLE1BQVAsT0FBa0IsUUFBcEQsRUFDQ0EsTUFBTSxDQUFDRCxPQUFQLEdBQWlCRCxPQUFPLEVBQXhCLENBREQsS0FFSyxJQUFHLElBQUgsRUFDSkcsaUNBQU8sRUFBRCxvQ0FBS0gsT0FBTDtBQUFBO0FBQUE7QUFBQSxrR0FBTixDQURJLEtBRUEsRUFHSjtBQUNELENBVEQsRUFTR0ssTUFUSCxFQVNXLFlBQVc7RUFDdEI7SUFBTztJQUFVLFVBQVNDLE9BQVQsRUFBa0I7TUFBRTs7TUFDckM7TUFBVTs7TUFDVjtNQUFVLElBQUlDLGdCQUFnQixHQUFHLEVBQXZCO01BQ1Y7O01BQ0E7TUFBVTs7TUFDVjs7TUFBVSxTQUFTQywrQkFBVCxDQUE2QkMsUUFBN0IsRUFBdUM7UUFDakQ7O1FBQ0E7UUFBVzs7UUFDWDtRQUFXLElBQUdGLGdCQUFnQixDQUFDRSxRQUFELENBQW5CLEVBQStCO1VBQzFDO1VBQVksT0FBT0YsZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsQ0FBMkJSLE9BQWxDO1VBQ1o7UUFBWTtRQUNaO1FBQVc7O1FBQ1g7OztRQUFXLElBQUlDLE1BQU0sR0FBR0ssZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsR0FBNkI7VUFDckQ7VUFBWUMsQ0FBQyxFQUFFRCxRQURzQzs7VUFFckQ7VUFBWUUsQ0FBQyxFQUFFLEtBRnNDOztVQUdyRDtVQUFZVixPQUFPLEVBQUU7VUFDckI7O1FBSnFELENBQTFDO1FBS1g7O1FBQ0E7UUFBVzs7UUFDWDs7UUFBV0ssT0FBTyxDQUFDRyxRQUFELENBQVAsQ0FB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Q0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FB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QyxDQUFuRSxFQUNqRUMsNkJBQTZCLEtBQUtHLFNBQWxDLEtBQWdEN0MsTUFBTSxDQUFDRCxPQUFQLEdBQWlCMkMsNkJBQWpFLENBRCtELENBQVIsR0FDOENHLENBRHJHO1FBRUgsQ0F2WkQsRUF1WkcsSUF2Wkg7UUEwWkE7O01BQU87TUFFUDs7SUEzb1FVLENBdEZNO0VBQWhCO0FBa3VRQyxDQTV1UUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL3JhcGhhZWwvcmFwaGFlbC5qcz80YWM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCBcXFxcXG4vLyDilIIgUmFwaGHDq2wgMi4zLjAgLSBKYXZhU2NyaXB0IFZlY3RvciBMaWJyYXJ5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBcXFxcXG4vLyDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKQgXFxcXFxuLy8g4pSCIENvcHlyaWdodCDCqSAyMDA4LTIwMTYgRG1pdHJ5IEJhcmFub3Zza2l5IChodHRwOi8vcmFwaGFlbGpzLmNvbSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgXFxcXFxuLy8g4pSCIENvcHlyaWdodCDCqSAyMDA4LTIwMTYgU2VuY2hhIExhYnMgKGh0dHA6Ly9zZW5jaGEuY29tKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgXFxcXFxuLy8g4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkIFxcXFxcbi8vIOKUgiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIChodHRwczovL2dpdGh1Yi5jb20vRG1pdHJ5QmFyYW5vdnNraXkvcmFwaGFlbC9ibG9iL21hc3Rlci9saWNlbnNlLnR4dCkgbGljZW5zZS7ilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmFwaGFlbFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSYXBoYWVsXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9kZXYvcmFwaGFlbC5hbWQuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9kZXYvcmFwaGFlbC5hbWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9kZXYvcmFwaGFlbC5hbWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhcGhhZWwuY29yZSAqLyBcIi4vZGV2L3JhcGhhZWwuY29yZS5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYXBoYWVsLnN2ZyAqLyBcIi4vZGV2L3JhcGhhZWwuc3ZnLmpzXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhcGhhZWwudm1sICovIFwiLi9kZXYvcmFwaGFlbC52bWwuanNcIildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihSKSB7XG5cbiAgICByZXR1cm4gUjtcblxufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9kZXYvcmFwaGFlbC5jb3JlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2Rldi9yYXBoYWVsLmNvcmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlICovIFwiLi9ub2RlX21vZHVsZXMvZXZlLXJhcGhhZWwvZXZlLmpzXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oZXZlKSB7XG5cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBvYmplY3Qgb24gd2hpY2ggdG8gZHJhdy5cbiAgICAgKiBZb3UgbXVzdCBkbyB0aGlzIGZpcnN0LCBhcyBhbGwgZnV0dXJlIGNhbGxzIHRvIGRyYXdpbmcgbWV0aG9kc1xuICAgICAqIGZyb20gdGhpcyBpbnN0YW5jZSB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgY2FudmFzLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBjb250YWluZXIgKEhUTUxFbGVtZW50fHN0cmluZykgRE9NIGVsZW1lbnQgb3IgaXRzIElEIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGEgcGFyZW50IGZvciBkcmF3aW5nIHN1cmZhY2VcbiAgICAgLSB3aWR0aCAobnVtYmVyKVxuICAgICAtIGhlaWdodCAobnVtYmVyKVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIG5ld2x5IGNyZWF0ZWQgcGFwZXJcbiAgICAgKiBvclxuICAgICAtIHggKG51bWJlcilcbiAgICAgLSB5IChudW1iZXIpXG4gICAgIC0gd2lkdGggKG51bWJlcilcbiAgICAgLSBoZWlnaHQgKG51bWJlcilcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnb2luZyB0byBiZSBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiBuZXdseSBjcmVhdGVkIHBhcGVyXG4gICAgICogb3JcbiAgICAgLSBhbGwgKGFycmF5KSAoZmlyc3QgMyBvciA0IGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgZXF1YWwgdG8gW2NvbnRhaW5lcklELCB3aWR0aCwgaGVpZ2h0XSBvciBbeCwgeSwgd2lkdGgsIGhlaWdodF0uIFRoZSByZXN0IGFyZSBlbGVtZW50IGRlc2NyaXB0aW9ucyBpbiBmb3JtYXQge3R5cGU6IHR5cGUsIDxhdHRyaWJ1dGVzPn0pLiBTZWUgQFBhcGVyLmFkZC5cbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnb2luZyB0byBiZSBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiBuZXdseSBjcmVhdGVkIHBhcGVyXG4gICAgICogb3JcbiAgICAgLSBvblJlYWR5Q2FsbGJhY2sgKGZ1bmN0aW9uKSBmdW5jdGlvbiB0aGF0IGlzIGdvaW5nIHRvIGJlIGNhbGxlZCBvbiBET00gcmVhZHkgZXZlbnQuIFlvdSBjYW4gYWxzbyBzdWJzY3JpYmUgdG8gdGhpcyBldmVudCB2aWEgRXZl4oCZcyDigJxET01Mb2Fk4oCdIGV2ZW50LiBJbiB0aGlzIGNhc2UgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgID0gKG9iamVjdCkgQFBhcGVyXG4gICAgID4gVXNhZ2VcbiAgICAgfCAvLyBFYWNoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgY3JlYXRlIGEgY2FudmFzXG4gICAgIHwgLy8gdGhhdCBpcyAzMjBweCB3aWRlIGJ5IDIwMHB4IGhpZ2guXG4gICAgIHwgLy8gQ2FudmFzIGlzIGNyZWF0ZWQgYXQgdGhlIHZpZXdwb3J04oCZcyAxMCw1MCBjb29yZGluYXRlLlxuICAgICB8IHZhciBwYXBlciA9IFJhcGhhZWwoMTAsIDUwLCAzMjAsIDIwMCk7XG4gICAgIHwgLy8gQ2FudmFzIGlzIGNyZWF0ZWQgYXQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgI25vdGVwYWQgZWxlbWVudFxuICAgICB8IC8vIChvciBpdHMgdG9wIHJpZ2h0IGNvcm5lciBpbiBkaXI9XCJydGxcIiBlbGVtZW50cylcbiAgICAgfCB2YXIgcGFwZXIgPSBSYXBoYWVsKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm90ZXBhZFwiKSwgMzIwLCAyMDApO1xuICAgICB8IC8vIFNhbWUgYXMgYWJvdmVcbiAgICAgfCB2YXIgcGFwZXIgPSBSYXBoYWVsKFwibm90ZXBhZFwiLCAzMjAsIDIwMCk7XG4gICAgIHwgLy8gSW1hZ2UgZHVtcFxuICAgICB8IHZhciBzZXQgPSBSYXBoYWVsKFtcIm5vdGVwYWRcIiwgMzIwLCAyMDAsIHtcbiAgICAgfCAgICAgdHlwZTogXCJyZWN0XCIsXG4gICAgIHwgICAgIHg6IDEwLFxuICAgICB8ICAgICB5OiAxMCxcbiAgICAgfCAgICAgd2lkdGg6IDI1LFxuICAgICB8ICAgICBoZWlnaHQ6IDI1LFxuICAgICB8ICAgICBzdHJva2U6IFwiI2YwMFwiXG4gICAgIHwgfSwge1xuICAgICB8ICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgfCAgICAgeDogMzAsXG4gICAgIHwgICAgIHk6IDQwLFxuICAgICB8ICAgICB0ZXh0OiBcIkR1bXBcIlxuICAgICB8IH1dKTtcbiAgICBcXCovXG4gICAgZnVuY3Rpb24gUihmaXJzdCkge1xuICAgICAgICBpZiAoUi5pcyhmaXJzdCwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZCA/IGZpcnN0KCkgOiBldmUub24oXCJyYXBoYWVsLkRPTWxvYWRcIiwgZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKFIuaXMoZmlyc3QsIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFIuX2VuZ2luZS5jcmVhdGVbYXBwbHldKFIsIGZpcnN0LnNwbGljZSgwLCAzICsgUi5pcyhmaXJzdFswXSwgbnUpKSkuYWRkKGZpcnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIGlmIChSLmlzKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkID8gZi5jYWxsKFIuX2VuZ2luZS5jcmVhdGVbYXBwbHldKFIsIGFyZ3MpKSA6IGV2ZS5vbihcInJhcGhhZWwuRE9NbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuY2FsbChSLl9lbmdpbmUuY3JlYXRlW2FwcGx5XShSLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBSLl9lbmdpbmUuY3JlYXRlW2FwcGx5XShSLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFIudmVyc2lvbiA9IFwiMi4zLjBcIjtcbiAgICBSLmV2ZSA9IGV2ZTtcbiAgICB2YXIgbG9hZGVkLFxuICAgICAgICBzZXBhcmF0b3IgPSAvWywgXSsvLFxuICAgICAgICBlbGVtZW50cyA9IHtjaXJjbGU6IDEsIHJlY3Q6IDEsIHBhdGg6IDEsIGVsbGlwc2U6IDEsIHRleHQ6IDEsIGltYWdlOiAxfSxcbiAgICAgICAgZm9ybWF0cmcgPSAvXFx7KFxcZCspXFx9L2csXG4gICAgICAgIHByb3RvID0gXCJwcm90b3R5cGVcIixcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBnID0ge1xuICAgICAgICAgICAgZG9jOiBkb2N1bWVudCxcbiAgICAgICAgICAgIHdpbjogd2luZG93XG4gICAgICAgIH0sXG4gICAgICAgIG9sZFJhcGhhZWwgPSB7XG4gICAgICAgICAgICB3YXM6IE9iamVjdC5wcm90b3R5cGVbaGFzXS5jYWxsKGcud2luLCBcIlJhcGhhZWxcIiksXG4gICAgICAgICAgICBpczogZy53aW4uUmFwaGFlbFxuICAgICAgICB9LFxuICAgICAgICBQYXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qXFxcbiAgICAgICAgICAgICAqIFBhcGVyLmNhXG4gICAgICAgICAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICAgICAgICAgKipcbiAgICAgICAgICAgICAqIFNob3J0Y3V0IGZvciBAUGFwZXIuY3VzdG9tQXR0cmlidXRlc1xuICAgICAgICAgICAgXFwqL1xuICAgICAgICAgICAgLypcXFxuICAgICAgICAgICAgICogUGFwZXIuY3VzdG9tQXR0cmlidXRlc1xuICAgICAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgICAgICoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgaGF2ZSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gcmVwcmVzZW50XG4gICAgICAgICAgICAgKiBhcyBhIGZ1bmN0aW9uIG9mIHNvbWUgbnVtYmVyIHlvdSBjYW4gZG8gaXQgZWFzaWx5IHdpdGggY3VzdG9tIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgPiBVc2FnZVxuICAgICAgICAgICAgIHwgcGFwZXIuY3VzdG9tQXR0cmlidXRlcy5odWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICAgfCAgICAgbnVtID0gbnVtICUgMTtcbiAgICAgICAgICAgICB8ICAgICByZXR1cm4ge2ZpbGw6IFwiaHNiKFwiICsgbnVtICsgXCIsIDAuNzUsIDEpXCJ9O1xuICAgICAgICAgICAgIHwgfTtcbiAgICAgICAgICAgICB8IC8vIEN1c3RvbSBhdHRyaWJ1dGUg4oCcaHVl4oCdIHdpbGwgY2hhbmdlIGZpbGxcbiAgICAgICAgICAgICB8IC8vIHRvIGJlIGdpdmVuIGh1ZSB3aXRoIGZpeGVkIHNhdHVyYXRpb24gYW5kIGJyaWdodG5lc3MuXG4gICAgICAgICAgICAgfCAvLyBOb3cgeW91IGNhbiB1c2UgaXQgbGlrZSB0aGlzOlxuICAgICAgICAgICAgIHwgdmFyIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7aHVlOiAuNDV9KTtcbiAgICAgICAgICAgICB8IC8vIG9yIGV2ZW4gbGlrZSB0aGlzOlxuICAgICAgICAgICAgIHwgYy5hbmltYXRlKHtodWU6IDF9LCAxZTMpO1xuICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICB8IC8vIFlvdSBjb3VsZCBhbHNvIGNyZWF0ZSBjdXN0b20gYXR0cmlidXRlXG4gICAgICAgICAgICAgfCAvLyB3aXRoIG11bHRpcGxlIHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgfCBwYXBlci5jdXN0b21BdHRyaWJ1dGVzLmhzYiA9IGZ1bmN0aW9uIChoLCBzLCBiKSB7XG4gICAgICAgICAgICAgfCAgICAgcmV0dXJuIHtmaWxsOiBcImhzYihcIiArIFtoLCBzLCBiXS5qb2luKFwiLFwiKSArIFwiKVwifTtcbiAgICAgICAgICAgICB8IH07XG4gICAgICAgICAgICAgfCBjLmF0dHIoe2hzYjogXCIwLjUgLjggMVwifSk7XG4gICAgICAgICAgICAgfCBjLmFuaW1hdGUoe2hzYjogWzEsIDAsIDAuNV19LCAxZTMpO1xuICAgICAgICAgICAgXFwqL1xuICAgICAgICAgICAgdGhpcy5jYSA9IHRoaXMuY3VzdG9tQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBwYXBlcnByb3RvLFxuICAgICAgICBhcHBlbmRDaGlsZCA9IFwiYXBwZW5kQ2hpbGRcIixcbiAgICAgICAgYXBwbHkgPSBcImFwcGx5XCIsXG4gICAgICAgIGNvbmNhdCA9IFwiY29uY2F0XCIsXG4gICAgICAgIC8vdGFrZW4gZnJvbSBNb2Rlcm5penIgdG91Y2ggdGVzdDogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzI0w0MFxuICAgICAgICBzdXBwb3J0c1RvdWNoID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LlRvdWNoRXZlbnQgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoLFxuICAgICAgICBFID0gXCJcIixcbiAgICAgICAgUyA9IFwiIFwiLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHNwbGl0ID0gXCJzcGxpdFwiLFxuICAgICAgICBldmVudHMgPSBcImNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZW1vdmUgbW91c2VvdXQgbW91c2VvdmVyIG1vdXNldXAgdG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcIltzcGxpdF0oUyksXG4gICAgICAgIHRvdWNoTWFwID0ge1xuICAgICAgICAgICAgbW91c2Vkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgICAgIG1vdXNlbW92ZTogXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgICAgIG1vdXNldXA6IFwidG91Y2hlbmRcIlxuICAgICAgICB9LFxuICAgICAgICBsb3dlckNhc2UgPSBTdHIucHJvdG90eXBlLnRvTG93ZXJDYXNlLFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgbW1heCA9IG1hdGgubWF4LFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIGFicyA9IG1hdGguYWJzLFxuICAgICAgICBwb3cgPSBtYXRoLnBvdyxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBudSA9IFwibnVtYmVyXCIsXG4gICAgICAgIHN0cmluZyA9IFwic3RyaW5nXCIsXG4gICAgICAgIGFycmF5ID0gXCJhcnJheVwiLFxuICAgICAgICB0b1N0cmluZyA9IFwidG9TdHJpbmdcIixcbiAgICAgICAgZmlsbFN0cmluZyA9IFwiZmlsbFwiLFxuICAgICAgICBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIHBhcGVyID0ge30sXG4gICAgICAgIHB1c2ggPSBcInB1c2hcIixcbiAgICAgICAgSVNVUkwgPSBSLl9JU1VSTCA9IC9edXJsXFwoWydcIl0/KC4rPylbJ1wiXT9cXCkkL2ksXG4gICAgICAgIGNvbG91clJlZ0V4cCA9IC9eXFxzKigoI1thLWZcXGRdezZ9KXwoI1thLWZcXGRdezN9KXxyZ2JhP1xcKFxccyooW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/KD86XFxzKixcXHMqW1xcZFxcLl0rJT8pPylcXHMqXFwpfGhzYmE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/KSU/XFxzKlxcKXxoc2xhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyklP1xccypcXCkpXFxzKiQvaSxcbiAgICAgICAgaXNuYW4gPSB7XCJOYU5cIjogMSwgXCJJbmZpbml0eVwiOiAxLCBcIi1JbmZpbml0eVwiOiAxfSxcbiAgICAgICAgYmV6aWVycmcgPSAvXig/OmN1YmljLSk/YmV6aWVyXFwoKFteLF0rKSwoW14sXSspLChbXixdKyksKFteXFwpXSspXFwpLyxcbiAgICAgICAgcm91bmQgPSBtYXRoLnJvdW5kLFxuICAgICAgICBzZXRBdHRyaWJ1dGUgPSBcInNldEF0dHJpYnV0ZVwiLFxuICAgICAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgICAgdG9JbnQgPSBwYXJzZUludCxcbiAgICAgICAgdXBwZXJDYXNlID0gU3RyLnByb3RvdHlwZS50b1VwcGVyQ2FzZSxcbiAgICAgICAgYXZhaWxhYmxlQXR0cnMgPSBSLl9hdmFpbGFibGVBdHRycyA9IHtcbiAgICAgICAgICAgIFwiYXJyb3ctZW5kXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJhcnJvdy1zdGFydFwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGJsdXI6IDAsXG4gICAgICAgICAgICBcImNsaXAtcmVjdFwiOiBcIjAgMCAxZTkgMWU5XCIsXG4gICAgICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIGZpbGw6IFwiI2ZmZlwiLFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogMSxcbiAgICAgICAgICAgIGZvbnQ6ICcxMHB4IFwiQXJpYWxcIicsXG4gICAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6ICdcIkFyaWFsXCInLFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMFwiLFxuICAgICAgICAgICAgXCJmb250LXN0eWxlXCI6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IDQwMCxcbiAgICAgICAgICAgIGdyYWRpZW50OiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgaHJlZjogXCJodHRwOi8vcmFwaGFlbGpzLmNvbS9cIixcbiAgICAgICAgICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBwYXRoOiBcIk0wLDBcIixcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByeDogMCxcbiAgICAgICAgICAgIHJ5OiAwLFxuICAgICAgICAgICAgc3JjOiBcIlwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDBcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcImJ1dHRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwiYnV0dFwiLFxuICAgICAgICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiAwLFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiAxLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgIHRpdGxlOiBcIlJhcGhhZWxcIixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgYXZhaWxhYmxlQW5pbUF0dHJzID0gUi5fYXZhaWxhYmxlQW5pbUF0dHJzID0ge1xuICAgICAgICAgICAgYmx1cjogbnUsXG4gICAgICAgICAgICBcImNsaXAtcmVjdFwiOiBcImNzdlwiLFxuICAgICAgICAgICAgY3g6IG51LFxuICAgICAgICAgICAgY3k6IG51LFxuICAgICAgICAgICAgZmlsbDogXCJjb2xvdXJcIixcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IG51LFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogbnUsXG4gICAgICAgICAgICBoZWlnaHQ6IG51LFxuICAgICAgICAgICAgb3BhY2l0eTogbnUsXG4gICAgICAgICAgICBwYXRoOiBcInBhdGhcIixcbiAgICAgICAgICAgIHI6IG51LFxuICAgICAgICAgICAgcng6IG51LFxuICAgICAgICAgICAgcnk6IG51LFxuICAgICAgICAgICAgc3Ryb2tlOiBcImNvbG91clwiLFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBudSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG51LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgd2lkdGg6IG51LFxuICAgICAgICAgICAgeDogbnUsXG4gICAgICAgICAgICB5OiBudVxuICAgICAgICB9LFxuICAgICAgICB3aGl0ZXNwYWNlID0gL1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgICAgY29tbWFTcGFjZXMgPSAvW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSovLFxuICAgICAgICBoc3JnID0ge2hzOiAxLCByZzogMX0sXG4gICAgICAgIHAycyA9IC8sPyhbYWNobG1xcnN0dnh6XSksPy9naSxcbiAgICAgICAgcGF0aENvbW1hbmQgPSAvKFthY2hsbXJxc3R2el0pW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5LF0qKCgtP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosP1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qKSspL2lnLFxuICAgICAgICB0Q29tbWFuZCA9IC8oW3JzdG1dKVtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOSxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLD9bXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKikrKS9pZyxcbiAgICAgICAgcGF0aFZhbHVlcyA9IC8oLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKiw/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSovaWcsXG4gICAgICAgIHJhZGlhbF9ncmFkaWVudCA9IFIuX3JhZGlhbF9ncmFkaWVudCA9IC9ecig/OlxcKChbXixdKz8pW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSooW15cXCldKz8pXFwpKT8vLFxuICAgICAgICBlbGRhdGEgPSB7fSxcbiAgICAgICAgc29ydEJ5S2V5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmtleSAtIGIua2V5O1xuICAgICAgICB9LFxuICAgICAgICBzb3J0QnlOdW1iZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHRvRmxvYXQoYSkgLSB0b0Zsb2F0KGIpO1xuICAgICAgICB9LFxuICAgICAgICBmdW4gPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcGlwZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdFBhdGggPSBSLl9yZWN0UGF0aCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW1wiTVwiLCB4ICsgciwgeV0sIFtcImxcIiwgdyAtIHIgKiAyLCAwXSwgW1wiYVwiLCByLCByLCAwLCAwLCAxLCByLCByXSwgW1wibFwiLCAwLCBoIC0gciAqIDJdLCBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCByXSwgW1wibFwiLCByICogMiAtIHcsIDBdLCBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sIFtcImxcIiwgMCwgciAqIDIgLSBoXSwgW1wiYVwiLCByLCByLCAwLCAwLCAxLCByLCAtcl0sIFtcInpcIl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2VQYXRoID0gZnVuY3Rpb24gKHgsIHksIHJ4LCByeSkge1xuICAgICAgICAgICAgaWYgKHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIHgsIHldLCBbXCJtXCIsIDAsIC1yeV0sIFtcImFcIiwgcngsIHJ5LCAwLCAxLCAxLCAwLCAyICogcnldLCBbXCJhXCIsIHJ4LCByeSwgMCwgMSwgMSwgMCwgLTIgKiByeV0sIFtcInpcIl1dO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQYXRoID0gUi5fZ2V0UGF0aCA9IHtcbiAgICAgICAgICAgIHBhdGg6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5hdHRyKFwicGF0aFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZWwuYXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGEuY3gsIGEuY3ksIGEucik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxsaXBzZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbC5hdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxsaXBzZVBhdGgoYS5jeCwgYS5jeSwgYS5yeCwgYS5yeSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbC5hdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYS54LCBhLnksIGEud2lkdGgsIGEuaGVpZ2h0LCBhLnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGVsLmF0dHJzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhLngsIGEueSwgYS53aWR0aCwgYS5oZWlnaHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZWwuX2dldEJCb3goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZWwuX2dldEJCb3goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBSYXBoYWVsLm1hcFBhdGhcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCBnaXZlbiBtYXRyaXguXG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAgICAgLSBtYXRyaXggKG9iamVjdCkgc2VlIEBNYXRyaXhcbiAgICAgICAgID0gKHN0cmluZykgdHJhbnNmb3JtZWQgcGF0aCBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXBQYXRoID0gUi5tYXBQYXRoID0gZnVuY3Rpb24gKHBhdGgsIG1hdHJpeCkge1xuICAgICAgICAgICAgaWYgKCFtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4LCB5LCBpLCBqLCBpaSwgamosIHBhdGhpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhdGhpID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhpLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1hdHJpeC54KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB5ID0gbWF0cml4LnkocGF0aGlbal0sIHBhdGhpW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhpW2pdID0geDtcbiAgICAgICAgICAgICAgICAgICAgcGF0aGlbaiArIDFdID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgIFIuX2cgPSBnO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnR5cGVcbiAgICAgWyBwcm9wZXJ0eSAoc3RyaW5nKSBdXG4gICAgICoqXG4gICAgICogQ2FuIGJlIOKAnFNWR+KAnSwg4oCcVk1M4oCdIG9yIGVtcHR5LCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxuICAgIFxcKi9cbiAgICBSLnR5cGUgPSAoZy53aW4uU1ZHQW5nbGUgfHwgZy5kb2MuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIikgPyBcIlNWR1wiIDogXCJWTUxcIik7XG4gICAgaWYgKFIudHlwZSA9PSBcIlZNTFwiKSB7XG4gICAgICAgIHZhciBkID0gZy5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIGI7XG4gICAgICAgIGQuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcbiAgICAgICAgYiA9IGQuZmlyc3RDaGlsZDtcbiAgICAgICAgYi5zdHlsZS5iZWhhdmlvciA9IFwidXJsKCNkZWZhdWx0I1ZNTClcIjtcbiAgICAgICAgaWYgKCEoYiAmJiB0eXBlb2YgYi5hZGogPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHJldHVybiAoUi50eXBlID0gRSk7XG4gICAgICAgIH1cbiAgICAgICAgZCA9IG51bGw7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnN2Z1xuICAgICBbIHByb3BlcnR5IChib29sZWFuKSBdXG4gICAgICoqXG4gICAgICogYHRydWVgIGlmIGJyb3dzZXIgc3VwcG9ydHMgU1ZHLlxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC52bWxcbiAgICAgWyBwcm9wZXJ0eSAoYm9vbGVhbikgXVxuICAgICAqKlxuICAgICAqIGB0cnVlYCBpZiBicm93c2VyIHN1cHBvcnRzIFZNTC5cbiAgICBcXCovXG4gICAgUi5zdmcgPSAhKFIudm1sID0gUi50eXBlID09IFwiVk1MXCIpO1xuICAgIFIuX1BhcGVyID0gUGFwZXI7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZm5cbiAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICoqXG4gICAgICogWW91IGNhbiBhZGQgeW91ciBvd24gbWV0aG9kIHRvIHRoZSBjYW52YXMuIEZvciBleGFtcGxlIGlmIHlvdSB3YW50IHRvIGRyYXcgYSBwaWUgY2hhcnQsXG4gICAgICogeW91IGNhbiBjcmVhdGUgeW91ciBvd24gcGllIGNoYXJ0IGZ1bmN0aW9uIGFuZCBzaGlwIGl0IGFzIGEgUmFwaGHDq2wgcGx1Z2luLiBUbyBkbyB0aGlzXG4gICAgICogeW91IG5lZWQgdG8gZXh0ZW5kIHRoZSBgUmFwaGFlbC5mbmAgb2JqZWN0LiBZb3Ugc2hvdWxkIG1vZGlmeSB0aGUgYGZuYCBvYmplY3QgYmVmb3JlIGFcbiAgICAgKiBSYXBoYcOrbCBpbnN0YW5jZSBpcyBjcmVhdGVkLCBvdGhlcndpc2UgaXQgd2lsbCB0YWtlIG5vIGVmZmVjdC4gUGxlYXNlIG5vdGUgdGhhdCB0aGVcbiAgICAgKiBhYmlsaXR5IGZvciBuYW1lc3BhY2VkIHBsdWdpbnMgd2FzIHJlbW92ZWQgaW4gUmFwaGFlbCAyLjAuIEl0IGlzIHVwIHRvIHRoZSBwbHVnaW4gdG9cbiAgICAgKiBlbnN1cmUgYW55IG5hbWVzcGFjaW5nIGVuc3VyZXMgcHJvcGVyIGNvbnRleHQuXG4gICAgID4gVXNhZ2VcbiAgICAgfCBSYXBoYWVsLmZuLmFycm93ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCBzaXplKSB7XG4gICAgIHwgICAgIHJldHVybiB0aGlzLnBhdGgoIC4uLiApO1xuICAgICB8IH07XG4gICAgIHwgLy8gb3IgY3JlYXRlIG5hbWVzcGFjZVxuICAgICB8IFJhcGhhZWwuZm4ubXlzdHVmZiA9IHtcbiAgICAgfCAgICAgYXJyb3c6IGZ1bmN0aW9uICgpIHvigKZ9LFxuICAgICB8ICAgICBzdGFyOiBmdW5jdGlvbiAoKSB74oCmfSxcbiAgICAgfCAgICAgLy8gZXRj4oCmXG4gICAgIHwgfTtcbiAgICAgfCB2YXIgcGFwZXIgPSBSYXBoYWVsKDEwLCAxMCwgNjMwLCA0ODApO1xuICAgICB8IC8vIHRoZW4gdXNlIGl0XG4gICAgIHwgcGFwZXIuYXJyb3coMTAsIDEwLCAzMCwgMzAsIDUpLmF0dHIoe2ZpbGw6IFwiI2YwMFwifSk7XG4gICAgIHwgcGFwZXIubXlzdHVmZi5hcnJvdygpO1xuICAgICB8IHBhcGVyLm15c3R1ZmYuc3RhcigpO1xuICAgIFxcKi9cbiAgICBSLmZuID0gcGFwZXJwcm90byA9IFBhcGVyLnByb3RvdHlwZSA9IFIucHJvdG90eXBlO1xuICAgIFIuX2lkID0gMDtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5pc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSGFuZGZ1bCBvZiByZXBsYWNlbWVudHMgZm9yIGB0eXBlb2ZgIG9wZXJhdG9yLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBvICjigKYpIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlXG4gICAgIC0gdHlwZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSB0eXBlLCBpLmUuIOKAnHN0cmluZ+KAnSwg4oCcZnVuY3Rpb27igJ0sIOKAnG51bWJlcuKAnSwgZXRjLlxuICAgICA9IChib29sZWFuKSBpcyBnaXZlbiB2YWx1ZSBpcyBvZiBnaXZlbiB0eXBlXG4gICAgXFwqL1xuICAgIFIuaXMgPSBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICB0eXBlID0gbG93ZXJDYXNlLmNhbGwodHlwZSk7XG4gICAgICAgIGlmICh0eXBlID09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNuYW5baGFzXSgrbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbyBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAgKHR5cGUgPT0gXCJudWxsXCIgJiYgbyA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PSB0eXBlb2YgbyAmJiBvICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgICh0eXBlID09IFwib2JqZWN0XCIgJiYgbyA9PT0gT2JqZWN0KG8pKSB8fFxuICAgICAgICAgICAgICAgICh0eXBlID09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkobykpIHx8XG4gICAgICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gXCJmdW5jdGlvblwiIHx8IE9iamVjdChvYmopICE9PSBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IG5ldyBvYmouY29uc3RydWN0b3I7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmpbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmFuZ2xlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuZ2xlIGJldHdlZW4gdHdvIG9yIHRocmVlIHBvaW50c1xuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSB4MSAobnVtYmVyKSB4IGNvb3JkIG9mIGZpcnN0IHBvaW50XG4gICAgIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuICAgICAtIHgyIChudW1iZXIpIHggY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gICAgIC0geTIgKG51bWJlcikgeSBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAgICAgLSB4MyAobnVtYmVyKSAjb3B0aW9uYWwgeCBjb29yZCBvZiB0aGlyZCBwb2ludFxuICAgICAtIHkzIChudW1iZXIpICNvcHRpb25hbCB5IGNvb3JkIG9mIHRoaXJkIHBvaW50XG4gICAgID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlcy5cbiAgICBcXCovXG4gICAgUi5hbmdsZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIGlmICh4MyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHgxIC0geDIsXG4gICAgICAgICAgICAgICAgeSA9IHkxIC0geTI7XG4gICAgICAgICAgICBpZiAoIXggJiYgIXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMTgwICsgbWF0aC5hdGFuMigteSwgLXgpICogMTgwIC8gUEkgKyAzNjApICUgMzYwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFIuYW5nbGUoeDEsIHkxLCB4MywgeTMpIC0gUi5hbmdsZSh4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnJhZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVHJhbnNmb3JtIGFuZ2xlIHRvIHJhZGlhbnNcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gZGVnIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgPSAobnVtYmVyKSBhbmdsZSBpbiByYWRpYW5zLlxuICAgIFxcKi9cbiAgICBSLnJhZCA9IGZ1bmN0aW9uIChkZWcpIHtcbiAgICAgICAgcmV0dXJuIGRlZyAlIDM2MCAqIFBJIC8gMTgwO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZGVnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBUcmFuc2Zvcm0gYW5nbGUgdG8gZGVncmVlc1xuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSByYWQgKG51bWJlcikgYW5nbGUgaW4gcmFkaWFuc1xuICAgICA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgXFwqL1xuICAgIFIuZGVnID0gZnVuY3Rpb24gKHJhZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCAoKHJhZCAqIDE4MCAvIFBJJSAzNjApKiAxMDAwKSAvIDEwMDA7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5zbmFwVG9cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNuYXBzIGdpdmVuIHZhbHVlIHRvIGdpdmVuIGdyaWQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHZhbHVlcyAoYXJyYXl8bnVtYmVyKSBnaXZlbiBhcnJheSBvZiB2YWx1ZXMgb3Igc3RlcCBvZiB0aGUgZ3JpZFxuICAgICAtIHZhbHVlIChudW1iZXIpIHZhbHVlIHRvIGFkanVzdFxuICAgICAtIHRvbGVyYW5jZSAobnVtYmVyKSAjb3B0aW9uYWwgdG9sZXJhbmNlIGZvciBzbmFwcGluZy4gRGVmYXVsdCBpcyBgMTBgLlxuICAgICA9IChudW1iZXIpIGFkanVzdGVkIHZhbHVlLlxuICAgIFxcKi9cbiAgICBSLnNuYXBUbyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHZhbHVlLCB0b2xlcmFuY2UpIHtcbiAgICAgICAgdG9sZXJhbmNlID0gUi5pcyh0b2xlcmFuY2UsIFwiZmluaXRlXCIpID8gdG9sZXJhbmNlIDogMTA7XG4gICAgICAgIGlmIChSLmlzKHZhbHVlcywgYXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSBpZiAoYWJzKHZhbHVlc1tpXSAtIHZhbHVlKSA8PSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgICAgICAgIHZhciByZW0gPSB2YWx1ZSAlIHZhbHVlcztcbiAgICAgICAgICAgIGlmIChyZW0gPCB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtID4gdmFsdWVzIC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuY3JlYXRlVVVJRFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBSRkM0MTIyLCB2ZXJzaW9uIDQgSURcbiAgICBcXCovXG4gICAgdmFyIGNyZWF0ZVVVSUQgPSBSLmNyZWF0ZVVVSUQgPSAoZnVuY3Rpb24gKHV1aWRSZWdFeCwgdXVpZFJlcGxhY2VyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKHV1aWRSZWdFeCwgdXVpZFJlcGxhY2VyKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuICAgIH0pKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gbWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgICAgIHYgPSBjID09IFwieFwiID8gciA6IChyICYgMyB8IDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG5cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5zZXRXaW5kb3dcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFVzZWQgd2hlbiB5b3UgbmVlZCB0byBkcmF3IGluIGAmbHQ7aWZyYW1lPmAuIFN3aXRjaGVkIHdpbmRvdyB0byB0aGUgaWZyYW1lIG9uZS5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gbmV3d2luICh3aW5kb3cpIG5ldyB3aW5kb3cgb2JqZWN0XG4gICAgXFwqL1xuICAgIFIuc2V0V2luZG93ID0gZnVuY3Rpb24gKG5ld3dpbikge1xuICAgICAgICBldmUoXCJyYXBoYWVsLnNldFdpbmRvd1wiLCBSLCBnLndpbiwgbmV3d2luKTtcbiAgICAgICAgZy53aW4gPSBuZXd3aW47XG4gICAgICAgIGcuZG9jID0gZy53aW4uZG9jdW1lbnQ7XG4gICAgICAgIGlmIChSLl9lbmdpbmUuaW5pdFdpbikge1xuICAgICAgICAgICAgUi5fZW5naW5lLmluaXRXaW4oZy53aW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdG9IZXggPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgaWYgKFIudm1sKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDkvMTAvY29udmVydC1hbnktY29sb3VyLXZhbHVlLXRvLWhleC1pbi1tc2llL1xuICAgICAgICAgICAgdmFyIHRyaW0gPSAvXlxccyt8XFxzKyQvZztcbiAgICAgICAgICAgIHZhciBib2Q7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bSA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiaHRtbGZpbGVcIik7XG4gICAgICAgICAgICAgICAgZG9jdW0ud3JpdGUoXCI8Ym9keT5cIik7XG4gICAgICAgICAgICAgICAgZG9jdW0uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBib2QgPSBkb2N1bS5ib2R5O1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgYm9kID0gY3JlYXRlUG9wdXAoKS5kb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmdlID0gYm9kLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYm9kLnN0eWxlLmNvbG9yID0gU3RyKGNvbG9yKS5yZXBsYWNlKHRyaW0sIEUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByYW5nZS5xdWVyeUNvbW1hbmRWYWx1ZShcIkZvcmVDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoKHZhbHVlICYgMjU1KSA8PCAxNikgfCAodmFsdWUgJiA2NTI4MCkgfCAoKHZhbHVlICYgMTY3MTE2ODApID4+PiAxNik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiNcIiArIChcIjAwMDAwMFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKS5zbGljZSgtNik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gZy5kb2MuY3JlYXRlRWxlbWVudChcImlcIik7XG4gICAgICAgICAgICBpLnRpdGxlID0gXCJSYXBoYVxceGVibCBDb2xvdXIgUGlja2VyXCI7XG4gICAgICAgICAgICBpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGcuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoaSk7XG4gICAgICAgICAgICB0b0hleCA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBpLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGcuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoaSwgRSkuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvSGV4KGNvbG9yKTtcbiAgICB9LFxuICAgIGhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJoc2IoXCIgKyBbdGhpcy5oLCB0aGlzLnMsIHRoaXMuYl0gKyBcIilcIjtcbiAgICB9LFxuICAgIGhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJoc2woXCIgKyBbdGhpcy5oLCB0aGlzLnMsIHRoaXMubF0gKyBcIilcIjtcbiAgICB9LFxuICAgIHJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZXg7XG4gICAgfSxcbiAgICBwcmVwYXJlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgaWYgKGcgPT0gbnVsbCAmJiBSLmlzKHIsIFwib2JqZWN0XCIpICYmIFwiclwiIGluIHIgJiYgXCJnXCIgaW4gciAmJiBcImJcIiBpbiByKSB7XG4gICAgICAgICAgICBiID0gci5iO1xuICAgICAgICAgICAgZyA9IHIuZztcbiAgICAgICAgICAgIHIgPSByLnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcgPT0gbnVsbCAmJiBSLmlzKHIsIHN0cmluZykpIHtcbiAgICAgICAgICAgIHZhciBjbHIgPSBSLmdldFJHQihyKTtcbiAgICAgICAgICAgIHIgPSBjbHIucjtcbiAgICAgICAgICAgIGcgPSBjbHIuZztcbiAgICAgICAgICAgIGIgPSBjbHIuYjtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA+IDEgfHwgZyA+IDEgfHwgYiA+IDEpIHtcbiAgICAgICAgICAgIHIgLz0gMjU1O1xuICAgICAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgICAgICBiIC89IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfSxcbiAgICBwYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICAgICAgciAqPSAyNTU7XG4gICAgICAgIGcgKj0gMjU1O1xuICAgICAgICBiICo9IDI1NTtcbiAgICAgICAgdmFyIHJnYiA9IHtcbiAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgIGhleDogUi5yZ2IociwgZywgYiksXG4gICAgICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICAgICAgfTtcbiAgICAgICAgUi5pcyhvLCBcImZpbml0ZVwiKSAmJiAocmdiLm9wYWNpdHkgPSBvKTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuY29sb3JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFBhcnNlcyB0aGUgY29sb3Igc3RyaW5nIGFuZCByZXR1cm5zIG9iamVjdCB3aXRoIGFsbCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBjb2xvci5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gY2xyIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIHN1cHBvcnRlZCBmb3JtYXRzIChzZWUgQFJhcGhhZWwuZ2V0UkdCKVxuICAgICA9IChvYmplY3QpIENvbWJpbmVkIFJHQiAmIEhTQiBvYmplY3QgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgciAobnVtYmVyKSByZWQsXG4gICAgIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gICAgIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiAgICAgbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiAgICAgbyAgICAgZXJyb3IgKGJvb2xlYW4pIGB0cnVlYCBpZiBzdHJpbmcgY2Fu4oCZdCBiZSBwYXJzZWQsXG4gICAgIG8gICAgIGggKG51bWJlcikgaHVlLFxuICAgICBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gICAgIG8gICAgIHYgKG51bWJlcikgdmFsdWUgKGJyaWdodG5lc3MpLFxuICAgICBvICAgICBsIChudW1iZXIpIGxpZ2h0bmVzc1xuICAgICBvIH1cbiAgICBcXCovXG4gICAgUi5jb2xvciA9IGZ1bmN0aW9uIChjbHIpIHtcbiAgICAgICAgdmFyIHJnYjtcbiAgICAgICAgaWYgKFIuaXMoY2xyLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBjbHIgJiYgXCJzXCIgaW4gY2xyICYmIFwiYlwiIGluIGNscikge1xuICAgICAgICAgICAgcmdiID0gUi5oc2IycmdiKGNscik7XG4gICAgICAgICAgICBjbHIuciA9IHJnYi5yO1xuICAgICAgICAgICAgY2xyLmcgPSByZ2IuZztcbiAgICAgICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgICAgICBjbHIuaGV4ID0gcmdiLmhleDtcbiAgICAgICAgfSBlbHNlIGlmIChSLmlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImxcIiBpbiBjbHIpIHtcbiAgICAgICAgICAgIHJnYiA9IFIuaHNsMnJnYihjbHIpO1xuICAgICAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgICAgICBjbHIuYiA9IHJnYi5iO1xuICAgICAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoUi5pcyhjbHIsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgY2xyID0gUi5nZXRSR0IoY2xyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSLmlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gY2xyICYmIFwiZ1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIpIHtcbiAgICAgICAgICAgICAgICByZ2IgPSBSLnJnYjJoc2woY2xyKTtcbiAgICAgICAgICAgICAgICBjbHIuaCA9IHJnYi5oO1xuICAgICAgICAgICAgICAgIGNsci5zID0gcmdiLnM7XG4gICAgICAgICAgICAgICAgY2xyLmwgPSByZ2IubDtcbiAgICAgICAgICAgICAgICByZ2IgPSBSLnJnYjJoc2IoY2xyKTtcbiAgICAgICAgICAgICAgICBjbHIudiA9IHJnYi5iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbHIgPSB7aGV4OiBcIm5vbmVcIn07XG4gICAgICAgICAgICAgICAgY2xyLnIgPSBjbHIuZyA9IGNsci5iID0gY2xyLmggPSBjbHIucyA9IGNsci52ID0gY2xyLmwgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbHIudG9TdHJpbmcgPSByZ2J0b1N0cmluZztcbiAgICAgICAgcmV0dXJuIGNscjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmhzYjJyZ2JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIEhTQiB2YWx1ZXMgdG8gUkdCIG9iamVjdC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaCAobnVtYmVyKSBodWVcbiAgICAgLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAgICAgLSB2IChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiAgICAgPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHIgKG51bWJlcikgcmVkLFxuICAgICBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuICAgICBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gICAgIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKJcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuaHNiMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCB2LCBvKSB7XG4gICAgICAgIGlmICh0aGlzLmlzKGgsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImJcIiBpbiBoKSB7XG4gICAgICAgICAgICB2ID0gaC5iO1xuICAgICAgICAgICAgcyA9IGgucztcbiAgICAgICAgICAgIG8gPSBoLm87XG4gICAgICAgICAgICBoID0gaC5oO1xuICAgICAgICB9XG4gICAgICAgIGggKj0gMzYwO1xuICAgICAgICB2YXIgUiwgRywgQiwgWCwgQztcbiAgICAgICAgaCA9IChoICUgMzYwKSAvIDYwO1xuICAgICAgICBDID0gdiAqIHM7XG4gICAgICAgIFggPSBDICogKDEgLSBhYnMoaCAlIDIgLSAxKSk7XG4gICAgICAgIFIgPSBHID0gQiA9IHYgLSBDO1xuXG4gICAgICAgIGggPSB+fmg7XG4gICAgICAgIFIgKz0gW0MsIFgsIDAsIDAsIFgsIENdW2hdO1xuICAgICAgICBHICs9IFtYLCBDLCBDLCBYLCAwLCAwXVtoXTtcbiAgICAgICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgICAgIHJldHVybiBwYWNrYWdlUkdCKFIsIEcsIEIsIG8pO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaHNsMnJnYlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ29udmVydHMgSFNMIHZhbHVlcyB0byBSR0Igb2JqZWN0LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoIChudW1iZXIpIGh1ZVxuICAgICAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuICAgICAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuICAgICA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgciAobnVtYmVyKSByZWQsXG4gICAgIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gICAgIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiAgICAgbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAolxuICAgICBvIH1cbiAgICBcXCovXG4gICAgUi5oc2wycmdiID0gZnVuY3Rpb24gKGgsIHMsIGwsIG8pIHtcbiAgICAgICAgaWYgKHRoaXMuaXMoaCwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gaCAmJiBcInNcIiBpbiBoICYmIFwibFwiIGluIGgpIHtcbiAgICAgICAgICAgIGwgPSBoLmw7XG4gICAgICAgICAgICBzID0gaC5zO1xuICAgICAgICAgICAgaCA9IGguaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgICAgIGggLz0gMzYwO1xuICAgICAgICAgICAgcyAvPSAxMDA7XG4gICAgICAgICAgICBsIC89IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoICo9IDM2MDtcbiAgICAgICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgICAgIGggPSAoaCAlIDM2MCkgLyA2MDtcbiAgICAgICAgQyA9IDIgKiBzICogKGwgPCAuNSA/IGwgOiAxIC0gbCk7XG4gICAgICAgIFggPSBDICogKDEgLSBhYnMoaCAlIDIgLSAxKSk7XG4gICAgICAgIFIgPSBHID0gQiA9IGwgLSBDIC8gMjtcblxuICAgICAgICBoID0gfn5oO1xuICAgICAgICBSICs9IFtDLCBYLCAwLCAwLCBYLCBDXVtoXTtcbiAgICAgICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgICAgIEIgKz0gWzAsIDAsIFgsIEMsIEMsIFhdW2hdO1xuICAgICAgICByZXR1cm4gcGFja2FnZVJHQihSLCBHLCBCLCBvKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnJnYjJoc2JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gSFNCIG9iamVjdC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gciAobnVtYmVyKSByZWRcbiAgICAgLSBnIChudW1iZXIpIGdyZWVuXG4gICAgIC0gYiAobnVtYmVyKSBibHVlXG4gICAgID0gKG9iamVjdCkgSFNCIG9iamVjdCBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBoIChudW1iZXIpIGh1ZVxuICAgICBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAgICAgbyAgICAgYiAobnVtYmVyKSBicmlnaHRuZXNzXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLnJnYjJoc2IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICAgICAgciA9IGJbMF07XG4gICAgICAgIGcgPSBiWzFdO1xuICAgICAgICBiID0gYlsyXTtcblxuICAgICAgICB2YXIgSCwgUywgViwgQztcbiAgICAgICAgViA9IG1tYXgociwgZywgYik7XG4gICAgICAgIEMgPSBWIC0gbW1pbihyLCBnLCBiKTtcbiAgICAgICAgSCA9IChDID09IDAgPyBudWxsIDpcbiAgICAgICAgICAgICBWID09IHIgPyAoZyAtIGIpIC8gQyA6XG4gICAgICAgICAgICAgViA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgICAgICAociAtIGcpIC8gQyArIDRcbiAgICAgICAgICAgICk7XG4gICAgICAgIEggPSAoKEggKyAzNjApICUgNikgKiA2MCAvIDM2MDtcbiAgICAgICAgUyA9IEMgPT0gMCA/IDAgOiBDIC8gVjtcbiAgICAgICAgcmV0dXJuIHtoOiBILCBzOiBTLCBiOiBWLCB0b1N0cmluZzogaHNidG9TdHJpbmd9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwucmdiMmhzbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBIU0wgb2JqZWN0LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSByIChudW1iZXIpIHJlZFxuICAgICAtIGcgKG51bWJlcikgZ3JlZW5cbiAgICAgLSBiIChudW1iZXIpIGJsdWVcbiAgICAgPSAob2JqZWN0KSBIU0wgb2JqZWN0IGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIGggKG51bWJlcikgaHVlXG4gICAgIG8gICAgIHMgKG51bWJlcikgc2F0dXJhdGlvblxuICAgICBvICAgICBsIChudW1iZXIpIGx1bWlub3NpdHlcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIucmdiMmhzbCA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIGIgPSBwcmVwYXJlUkdCKHIsIGcsIGIpO1xuICAgICAgICByID0gYlswXTtcbiAgICAgICAgZyA9IGJbMV07XG4gICAgICAgIGIgPSBiWzJdO1xuXG4gICAgICAgIHZhciBILCBTLCBMLCBNLCBtLCBDO1xuICAgICAgICBNID0gbW1heChyLCBnLCBiKTtcbiAgICAgICAgbSA9IG1taW4ociwgZywgYik7XG4gICAgICAgIEMgPSBNIC0gbTtcbiAgICAgICAgSCA9IChDID09IDAgPyBudWxsIDpcbiAgICAgICAgICAgICBNID09IHIgPyAoZyAtIGIpIC8gQyA6XG4gICAgICAgICAgICAgTSA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgICAgICAociAtIGcpIC8gQyArIDQpO1xuICAgICAgICBIID0gKChIICsgMzYwKSAlIDYpICogNjAgLyAzNjA7XG4gICAgICAgIEwgPSAoTSArIG0pIC8gMjtcbiAgICAgICAgUyA9IChDID09IDAgPyAwIDpcbiAgICAgICAgICAgICBMIDwgLjUgPyBDIC8gKDIgKiBMKSA6XG4gICAgICAgICAgICAgICAgICAgICAgQyAvICgyIC0gMiAqIEwpKTtcbiAgICAgICAgcmV0dXJuIHtoOiBILCBzOiBTLCBsOiBMLCB0b1N0cmluZzogaHNsdG9TdHJpbmd9O1xuICAgIH07XG4gICAgUi5fcGF0aDJzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW4oXCIsXCIpLnJlcGxhY2UocDJzLCBcIiQxXCIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVwdXNoKGFycmF5LCBpdGVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWNoZXIoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgICAgICAgZnVuY3Rpb24gbmV3ZigpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmcuam9pbihcIlxcdTI0MDBcIiksXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBuZXdmLmNhY2hlID0gbmV3Zi5jYWNoZSB8fCB7fSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IG5ld2YuY291bnQgPSBuZXdmLmNvdW50IHx8IFtdO1xuICAgICAgICAgICAgaWYgKGNhY2hlW2hhc10oYXJncykpIHtcbiAgICAgICAgICAgICAgICByZXB1c2goY291bnQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3N0cHJvY2Vzc29yID8gcG9zdHByb2Nlc3NvcihjYWNoZVthcmdzXSkgOiBjYWNoZVthcmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50Lmxlbmd0aCA+PSAxZTMgJiYgZGVsZXRlIGNhY2hlW2NvdW50LnNoaWZ0KCldO1xuICAgICAgICAgICAgY291bnQucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGNhY2hlW2FyZ3NdID0gZlthcHBseV0oc2NvcGUsIGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld2Y7XG4gICAgfVxuXG4gICAgdmFyIHByZWxvYWQgPSBSLl9wcmVsb2FkID0gZnVuY3Rpb24gKHNyYywgZikge1xuICAgICAgICB2YXIgaW1nID0gZy5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTk5OTllbTt0b3A6LTk5OTllbVwiO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgZy5kb2MuYm9keS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnLmRvYy5ib2R5LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBnLmRvYy5ib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsclRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZXg7XG4gICAgfVxuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZ2V0UkdCXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQYXJzZXMgY29sb3VyIHN0cmluZyBhcyBSR0Igb2JqZWN0XG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGNvbG91ciAoc3RyaW5nKSBjb2xvdXIgc3RyaW5nIGluIG9uZSBvZiBmb3JtYXRzOlxuICAgICAjIDx1bD5cbiAgICAgIyAgICAgPGxpPkNvbG91ciBuYW1lICjigJw8Y29kZT5yZWQ8L2NvZGU+4oCdLCDigJw8Y29kZT5ncmVlbjwvY29kZT7igJ0sIOKAnDxjb2RlPmNvcm5mbG93ZXJibHVlPC9jb2RlPuKAnSwgZXRjKTwvbGk+XG4gICAgICMgICAgIDxsaT4j4oCi4oCi4oCiIOKAlCBzaG9ydGVuZWQgSFRNTCBjb2xvdXI6ICjigJw8Y29kZT4jMDAwPC9jb2RlPuKAnSwg4oCcPGNvZGU+I2ZjMDwvY29kZT7igJ0sIGV0Yyk8L2xpPlxuICAgICAjICAgICA8bGk+I+KAouKAouKAouKAouKAouKAoiDigJQgZnVsbCBsZW5ndGggSFRNTCBjb2xvdXI6ICjigJw8Y29kZT4jMDAwMDAwPC9jb2RlPuKAnSwg4oCcPGNvZGU+I2JkMjMwMDwvY29kZT7igJ0pPC9saT5cbiAgICAgIyAgICAgPGxpPnJnYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgcmVkLCBncmVlbiBhbmQgYmx1ZSBjaGFubmVsc+KAmSB2YWx1ZXM6ICjigJw8Y29kZT5yZ2IoMjAwLCZuYnNwOzEwMCwmbmJzcDswKTwvY29kZT7igJ0pPC9saT5cbiAgICAgIyAgICAgPGxpPnJnYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU6ICjigJw8Y29kZT5yZ2IoMTAwJSwmbmJzcDsxNzUlLCZuYnNwOzAlKTwvY29kZT7igJ0pPC9saT5cbiAgICAgIyAgICAgPGxpPmhzYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzIHZhbHVlczogKOKAnDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDsxKTwvY29kZT7igJ0pPC9saT5cbiAgICAgIyAgICAgPGxpPmhzYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICAgICAjICAgICA8bGk+aHNsKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBzYW1lIGFzIGhzYjwvbGk+XG4gICAgICMgICAgIDxsaT5oc2wo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgaHNiPC9saT5cbiAgICAgIyA8L3VsPlxuICAgICA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgciAobnVtYmVyKSByZWQsXG4gICAgIG8gICAgIGcgKG51bWJlcikgZ3JlZW4sXG4gICAgIG8gICAgIGIgKG51bWJlcikgYmx1ZVxuICAgICBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuICAgICBvICAgICBlcnJvciAoYm9vbGVhbikgdHJ1ZSBpZiBzdHJpbmcgY2Fu4oCZdCBiZSBwYXJzZWRcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuZ2V0UkdCID0gY2FjaGVyKGZ1bmN0aW9uIChjb2xvdXIpIHtcbiAgICAgICAgaWYgKCFjb2xvdXIgfHwgISEoKGNvbG91ciA9IFN0cihjb2xvdXIpKS5pbmRleE9mKFwiLVwiKSArIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIGVycm9yOiAxLCB0b1N0cmluZzogY2xyVG9TdHJpbmd9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgdG9TdHJpbmc6IGNsclRvU3RyaW5nfTtcbiAgICAgICAgfVxuICAgICAgICAhKGhzcmdbaGFzXShjb2xvdXIudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikpIHx8IGNvbG91ci5jaGFyQXQoKSA9PSBcIiNcIikgJiYgKGNvbG91ciA9IHRvSGV4KGNvbG91cikpO1xuICAgICAgICB2YXIgcmVzLFxuICAgICAgICAgICAgcmVkLFxuICAgICAgICAgICAgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLFxuICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICByZ2IgPSBjb2xvdXIubWF0Y2goY29sb3VyUmVnRXhwKTtcbiAgICAgICAgaWYgKHJnYikge1xuICAgICAgICAgICAgaWYgKHJnYlsyXSkge1xuICAgICAgICAgICAgICAgIGJsdWUgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDUpLCAxNik7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgICAgICAgICAgcmVkID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZygxLCAzKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJnYlszXSkge1xuICAgICAgICAgICAgICAgIGJsdWUgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMykpICsgdCwgMTYpO1xuICAgICAgICAgICAgICAgIGdyZWVuID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDIpKSArIHQsIDE2KTtcbiAgICAgICAgICAgICAgICByZWQgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMSkpICsgdCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJnYls0XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJnYls0XVtzcGxpdF0oY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwicmdiYVwiICYmIChvcGFjaXR5ID0gdG9GbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJnYls1XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJnYls1XVtzcGxpdF0oY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgICh2YWx1ZXNbMF0uc2xpY2UoLTMpID09IFwiZGVnXCIgfHwgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIlxceGIwXCIpICYmIChyZWQgLz0gMzYwKTtcbiAgICAgICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUi5oc2IycmdiKHJlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJnYls2XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJnYls2XVtzcGxpdF0oY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgICAgIHJlZCA9IHRvRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSB0b0Zsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gKj0gMi41NSk7XG4gICAgICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgICh2YWx1ZXNbMF0uc2xpY2UoLTMpID09IFwiZGVnXCIgfHwgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIlxceGIwXCIpICYmIChyZWQgLz0gMzYwKTtcbiAgICAgICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzbGFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUi5oc2wycmdiKHJlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiID0ge3I6IHJlZCwgZzogZ3JlZW4sIGI6IGJsdWUsIHRvU3RyaW5nOiBjbHJUb1N0cmluZ307XG4gICAgICAgICAgICByZ2IuaGV4ID0gXCIjXCIgKyAoMTY3NzcyMTYgfCBibHVlIHwgKGdyZWVuIDw8IDgpIHwgKHJlZCA8PCAxNikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgICAgIFIuaXMob3BhY2l0eSwgXCJmaW5pdGVcIikgJiYgKHJnYi5vcGFjaXR5ID0gb3BhY2l0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmdiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiBjbHJUb1N0cmluZ307XG4gICAgfSwgUik7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaHNiXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBIU0IgdmFsdWVzIHRvIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3VyLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoIChudW1iZXIpIGh1ZVxuICAgICAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuICAgICAtIGIgKG51bWJlcikgdmFsdWUgb3IgYnJpZ2h0bmVzc1xuICAgICA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3VyLlxuICAgIFxcKi9cbiAgICBSLmhzYiA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgYikge1xuICAgICAgICByZXR1cm4gUi5oc2IycmdiKGgsIHMsIGIpLmhleDtcbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5oc2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIEhTTCB2YWx1ZXMgdG8gaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvdXIuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGggKG51bWJlcikgaHVlXG4gICAgIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gICAgIC0gbCAobnVtYmVyKSBsdW1pbm9zaXR5XG4gICAgID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvdXIuXG4gICAgXFwqL1xuICAgIFIuaHNsID0gY2FjaGVyKGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICAgIHJldHVybiBSLmhzbDJyZ2IoaCwgcywgbCkuaGV4O1xuICAgIH0pO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnJnYlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ29udmVydHMgUkdCIHZhbHVlcyB0byBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG91ci5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gciAobnVtYmVyKSByZWRcbiAgICAgLSBnIChudW1iZXIpIGdyZWVuXG4gICAgIC0gYiAobnVtYmVyKSBibHVlXG4gICAgID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvdXIuXG4gICAgXFwqL1xuICAgIFIucmdiID0gY2FjaGVyKGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kKHgpIHsgcmV0dXJuICh4ICsgMC41KSB8IDA7IH1cbiAgICAgICAgcmV0dXJuIFwiI1wiICsgKDE2Nzc3MjE2IHwgcm91bmQoYikgfCAocm91bmQoZykgPDwgOCkgfCAocm91bmQocikgPDwgMTYpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfSk7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZ2V0Q29sb3JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIE9uIGVhY2ggY2FsbCByZXR1cm5zIG5leHQgY29sb3VyIGluIHRoZSBzcGVjdHJ1bS4gVG8gcmVzZXQgaXQgYmFjayB0byByZWQgY2FsbCBAUmFwaGFlbC5nZXRDb2xvci5yZXNldFxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSB2YWx1ZSAobnVtYmVyKSAjb3B0aW9uYWwgYnJpZ2h0bmVzcywgZGVmYXVsdCBpcyBgMC43NWBcbiAgICAgPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG91ci5cbiAgICBcXCovXG4gICAgUi5nZXRDb2xvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldENvbG9yLnN0YXJ0ID0gdGhpcy5nZXRDb2xvci5zdGFydCB8fCB7aDogMCwgczogMSwgYjogdmFsdWUgfHwgLjc1fSxcbiAgICAgICAgICAgIHJnYiA9IHRoaXMuaHNiMnJnYihzdGFydC5oLCBzdGFydC5zLCBzdGFydC5iKTtcbiAgICAgICAgc3RhcnQuaCArPSAuMDc1O1xuICAgICAgICBpZiAoc3RhcnQuaCA+IDEpIHtcbiAgICAgICAgICAgIHN0YXJ0LmggPSAwO1xuICAgICAgICAgICAgc3RhcnQucyAtPSAuMjtcbiAgICAgICAgICAgIHN0YXJ0LnMgPD0gMCAmJiAodGhpcy5nZXRDb2xvci5zdGFydCA9IHtoOiAwLCBzOiAxLCBiOiBzdGFydC5ifSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYi5oZXg7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5nZXRDb2xvci5yZXNldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVzZXRzIHNwZWN0cnVtIHBvc2l0aW9uIGZvciBAUmFwaGFlbC5nZXRDb2xvciBiYWNrIHRvIHJlZC5cbiAgICBcXCovXG4gICAgUi5nZXRDb2xvci5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RhcnQ7XG4gICAgfTtcblxuICAgIC8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuICAgIGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSAtIDJdLCB5OiArY3JwW2kgLSAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpXSwgICAgIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpTGVuIC0gMl0sIHk6ICtjcnBbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHt4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wdXNoKFtcIkNcIixcbiAgICAgICAgICAgICAgICAgICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICAocFsxXS54ICsgNiAqIHBbMl0ueCAtIHBbM10ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueSArIDYqcFsyXS55IC0gcFszXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICBwWzJdLngsXG4gICAgICAgICAgICAgICAgICBwWzJdLnlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnBhcnNlUGF0aFN0cmluZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50cyAoaW4gdGhlIGxhc3QgY2FzZSBpdCB3aWxsIGJlIHJldHVybmVkIHN0cmFpZ2h0IGF3YXkpXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50cy5cbiAgICBcXCovXG4gICAgUi5wYXJzZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgICAgICBpZiAoIXBhdGhTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoU3RyaW5nKTtcbiAgICAgICAgaWYgKHB0aC5hcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1Db3VudHMgPSB7YTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcjogNCwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMH0sXG4gICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgIGlmIChSLmlzKHBhdGhTdHJpbmcsIGFycmF5KSAmJiBSLmlzKHBhdGhTdHJpbmdbMF0sIGFycmF5KSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICBkYXRhID0gcGF0aENsb25lKHBhdGhTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFN0cihwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJtXCIgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXVtjb25jYXRdKHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwibFwiO1xuICAgICAgICAgICAgICAgICAgICBiID0gYiA9PSBcIm1cIiA/IFwibFwiIDogXCJMXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl1bY29uY2F0XShwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXVtjb25jYXRdKHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS50b1N0cmluZyA9IFIuX3BhdGgyc3RyaW5nO1xuICAgICAgICBwdGguYXJyID0gcGF0aENsb25lKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnBhcnNlVHJhbnNmb3JtU3RyaW5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFBhcnNlcyBnaXZlbiBwYXRoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gVFN0cmluZyAoc3RyaW5nfGFycmF5KSB0cmFuc2Zvcm0gc3RyaW5nIG9yIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9ucyAoaW4gdGhlIGxhc3QgY2FzZSBpdCB3aWxsIGJlIHJldHVybmVkIHN0cmFpZ2h0IGF3YXkpXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgXFwqL1xuICAgIFIucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBjYWNoZXIoZnVuY3Rpb24gKFRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFUU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1Db3VudHMgPSB7cjogMywgczogNCwgdDogMiwgbTogNn0sXG4gICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgIGlmIChSLmlzKFRTdHJpbmcsIGFycmF5KSAmJiBSLmlzKFRTdHJpbmdbMF0sIGFycmF5KSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICBkYXRhID0gcGF0aENsb25lKFRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFN0cihUU3RyaW5nKS5yZXBsYWNlKHRDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGxvd2VyQ2FzZS5jYWxsKGIpO1xuICAgICAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdW2NvbmNhdF0ocGFyYW1zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnRvU3RyaW5nID0gUi5fcGF0aDJzdHJpbmc7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sIHRoaXMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgaWYgKCFlbGVtKSByZXR1cm4gZWxlbTtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3TGV2ZWwgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlbVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0xldmVsLnB1c2goZWxlbVtpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEYXRhLnB1c2gobmV3TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTsgfSApO1xuICAgIC8vIFBBVEhTXG4gICAgdmFyIHBhdGhzID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmZpbmREb3RzQXRTZWdtZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIEZpbmQgZG90IGNvb3JkaW5hdGVzIG9uIHRoZSBnaXZlbiBjdWJpYyBiZXppZXIgY3VydmUgYXQgdGhlIGdpdmVuIHQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHAxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXkgKG51bWJlcikgeSBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeCAobnVtYmVyKSB4IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSB0IChudW1iZXIpIHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSAoMC4uMSlcbiAgICAgPSAob2JqZWN0KSBwb2ludCBpbmZvcm1hdGlvbiBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgbyAgICAgbToge1xuICAgICBvICAgICAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGFuY2hvclxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGFuY2hvclxuICAgICBvICAgICB9XG4gICAgIG8gICAgIG46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGFuY2hvclxuICAgICBvICAgICB9XG4gICAgIG8gICAgIHN0YXJ0OiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZVxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfVxuICAgICBvICAgICBlbmQ6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZVxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH1cbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBkZXJpdmF0aXZlIGF0IHRoZSBwb2ludFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgUi5maW5kRG90c0F0U2VnbWVudCA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdCkge1xuICAgICAgICB2YXIgdDEgPSAxIC0gdCxcbiAgICAgICAgICAgIHQxMyA9IHBvdyh0MSwgMyksXG4gICAgICAgICAgICB0MTIgPSBwb3codDEsIDIpLFxuICAgICAgICAgICAgdDIgPSB0ICogdCxcbiAgICAgICAgICAgIHQzID0gdDIgKiB0LFxuICAgICAgICAgICAgeCA9IHQxMyAqIHAxeCArIHQxMiAqIDMgKiB0ICogYzF4ICsgdDEgKiAzICogdCAqIHQgKiBjMnggKyB0MyAqIHAyeCxcbiAgICAgICAgICAgIHkgPSB0MTMgKiBwMXkgKyB0MTIgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgdDMgKiBwMnksXG4gICAgICAgICAgICBteCA9IHAxeCArIDIgKiB0ICogKGMxeCAtIHAxeCkgKyB0MiAqIChjMnggLSAyICogYzF4ICsgcDF4KSxcbiAgICAgICAgICAgIG15ID0gcDF5ICsgMiAqIHQgKiAoYzF5IC0gcDF5KSArIHQyICogKGMyeSAtIDIgKiBjMXkgKyBwMXkpLFxuICAgICAgICAgICAgbnggPSBjMXggKyAyICogdCAqIChjMnggLSBjMXgpICsgdDIgKiAocDJ4IC0gMiAqIGMyeCArIGMxeCksXG4gICAgICAgICAgICBueSA9IGMxeSArIDIgKiB0ICogKGMyeSAtIGMxeSkgKyB0MiAqIChwMnkgLSAyICogYzJ5ICsgYzF5KSxcbiAgICAgICAgICAgIGF4ID0gdDEgKiBwMXggKyB0ICogYzF4LFxuICAgICAgICAgICAgYXkgPSB0MSAqIHAxeSArIHQgKiBjMXksXG4gICAgICAgICAgICBjeCA9IHQxICogYzJ4ICsgdCAqIHAyeCxcbiAgICAgICAgICAgIGN5ID0gdDEgKiBjMnkgKyB0ICogcDJ5LFxuICAgICAgICAgICAgYWxwaGEgPSAoOTAgLSBtYXRoLmF0YW4yKG14IC0gbngsIG15IC0gbnkpICogMTgwIC8gUEkpO1xuICAgICAgICAobXggPiBueCB8fCBteSA8IG55KSAmJiAoYWxwaGEgKz0gMTgwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbToge3g6IG14LCB5OiBteX0sXG4gICAgICAgICAgICBuOiB7eDogbngsIHk6IG55fSxcbiAgICAgICAgICAgIHN0YXJ0OiB7eDogYXgsIHk6IGF5fSxcbiAgICAgICAgICAgIGVuZDoge3g6IGN4LCB5OiBjeX0sXG4gICAgICAgICAgICBhbHBoYTogYWxwaGFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmJlemllckJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJuIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIGN1YmljIGJlemllciBjdXJ2ZVxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgICogb3JcbiAgICAgLSBiZXogKGFycmF5KSBhcnJheSBvZiBzaXggcG9pbnRzIGZvciBiZXppZXIgY3VydmVcbiAgICAgPSAob2JqZWN0KSBwb2ludCBpbmZvcm1hdGlvbiBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBtaW46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwb2ludFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSB0b3AgcG9pbnRcbiAgICAgbyAgICAgfVxuICAgICBvICAgICBtYXg6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcG9pbnRcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBvaW50XG4gICAgIG8gICAgIH1cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuYmV6aWVyQkJveCA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSkge1xuICAgICAgICBpZiAoIVIuaXMocDF4LCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBwMXggPSBbcDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYm94ID0gY3VydmVEaW0uYXBwbHkobnVsbCwgcDF4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGJib3gubWluLngsXG4gICAgICAgICAgICB5OiBiYm94Lm1pbi55LFxuICAgICAgICAgICAgeDI6IGJib3gubWF4LngsXG4gICAgICAgICAgICB5MjogYmJveC5tYXgueSxcbiAgICAgICAgICAgIHdpZHRoOiBiYm94Lm1heC54IC0gYmJveC5taW4ueCxcbiAgICAgICAgICAgIGhlaWdodDogYmJveC5tYXgueSAtIGJib3gubWluLnlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmlzUG9pbnRJbnNpZGVCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBib3VuZGluZyBib3hlcy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gYmJveCAoc3RyaW5nKSBib3VuZGluZyBib3hcbiAgICAgLSB4IChzdHJpbmcpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgLSB5IChzdHJpbmcpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGluc2lkZVxuICAgIFxcKi9cbiAgICBSLmlzUG9pbnRJbnNpZGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPj0gYmJveC54ICYmIHggPD0gYmJveC54MiAmJiB5ID49IGJib3gueSAmJiB5IDw9IGJib3gueTI7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5pc0JCb3hJbnRlcnNlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdHdvIGJvdW5kaW5nIGJveGVzIGludGVyc2VjdFxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiB0aGV5IGludGVyc2VjdFxuICAgIFxcKi9cbiAgICBSLmlzQkJveEludGVyc2VjdCA9IGZ1bmN0aW9uIChiYm94MSwgYmJveDIpIHtcbiAgICAgICAgdmFyIGkgPSBSLmlzUG9pbnRJbnNpZGVCQm94O1xuICAgICAgICByZXR1cm4gaShiYm94MiwgYmJveDEueCwgYmJveDEueSlcbiAgICAgICAgICAgIHx8IGkoYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaShiYm94MiwgYmJveDEueCwgYmJveDEueTIpXG4gICAgICAgICAgICB8fCBpKGJib3gyLCBiYm94MS54MiwgYmJveDEueTIpXG4gICAgICAgICAgICB8fCBpKGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaShiYm94MSwgYmJveDIueDIsIGJib3gyLnkpXG4gICAgICAgICAgICB8fCBpKGJib3gxLCBiYm94Mi54LCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IGkoYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnggfHwgYmJveDIueCA8IGJib3gxLngyICYmIGJib3gyLnggPiBiYm94MS54KVxuICAgICAgICAgICAgJiYgKGJib3gxLnkgPCBiYm94Mi55MiAmJiBiYm94MS55ID4gYmJveDIueSB8fCBiYm94Mi55IDwgYmJveDEueTIgJiYgYmJveDIueSA+IGJib3gxLnkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgICAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgICAgICAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgICAgICAgdmFyIHoyID0geiAvIDIsXG4gICAgICAgICAgICBuID0gMTIsXG4gICAgICAgICAgICBUdmFsdWVzID0gWy0wLjEyNTIsMC4xMjUyLC0wLjM2NzgsMC4zNjc4LC0wLjU4NzMsMC41ODczLC0wLjc2OTksMC43Njk5LC0wLjkwNDEsMC45MDQxLC0wLjk4MTYsMC45ODE2XSxcbiAgICAgICAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICAgICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgICAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgICAgICAgICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoyICogc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXRMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsbCkge1xuICAgICAgICBpZiAobGwgPCAwIHx8IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIDwgbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IDEsXG4gICAgICAgICAgICBzdGVwID0gdCAvIDIsXG4gICAgICAgICAgICB0MiA9IHQgLSBzdGVwLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGUgPSAuMDE7XG4gICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIHdoaWxlIChhYnMobCAtIGxsKSA+IGUpIHtcbiAgICAgICAgICAgIHN0ZXAgLz0gMjtcbiAgICAgICAgICAgIHQyICs9IChsIDwgbGwgPyAxIDogLTEpICogc3RlcDtcbiAgICAgICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgICAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICAgICAgICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB5ID0gbnkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDogcHgsIHk6IHB5fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXIoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyQ291bnQoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICAgICAgICB2YXIgYmJveDEgPSBSLmJlemllckJCb3goYmV6MSksXG4gICAgICAgICAgICBiYm94MiA9IFIuYmV6aWVyQkJveChiZXoyKTtcbiAgICAgICAgaWYgKCFSLmlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgICAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgICAgICAgbjEgPSBtbWF4KH5+KGwxIC8gNSksIDEpLFxuICAgICAgICAgICAgbjIgPSBtbWF4KH5+KGwyIC8gNSksIDEpLFxuICAgICAgICAgICAgZG90czEgPSBbXSxcbiAgICAgICAgICAgIGRvdHMyID0gW10sXG4gICAgICAgICAgICB4eSA9IHt9LFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IFIuZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoUiwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgICAgICAgICBkb3RzMS5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4xfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4yICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gUi5maW5kRG90c0F0U2VnbWVudC5hcHBseShSLCBiZXoyLmNvbmNhdChpIC8gbjIpKTtcbiAgICAgICAgICAgIGRvdHMyLnB1c2goe3g6IHAueCwgeTogcC55LCB0OiBpIC8gbjJ9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjE7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpID0gZG90czFbaV0sXG4gICAgICAgICAgICAgICAgICAgIGRpMSA9IGRvdHMxW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZGogPSBkb3RzMltqXSxcbiAgICAgICAgICAgICAgICAgICAgZGoxID0gZG90czJbaiArIDFdLFxuICAgICAgICAgICAgICAgICAgICBjaSA9IGFicyhkaTEueCAtIGRpLngpIDwgLjAwMSA/IFwieVwiIDogXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgIGNqID0gYWJzKGRqMS54IC0gZGoueCkgPCAuMDAxID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgaXMgPSBpbnRlcnNlY3QoZGkueCwgZGkueSwgZGkxLngsIGRpMS55LCBkai54LCBkai55LCBkajEueCwgZGoxLnkpO1xuICAgICAgICAgICAgICAgIGlmIChpcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeHlbaXMueC50b0ZpeGVkKDQpXSA9PSBpcy55LnRvRml4ZWQoNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHh5W2lzLngudG9GaXhlZCg0KV0gPSBpcy55LnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MSA9IGRpLnQgKyBhYnMoKGlzW2NpXSAtIGRpW2NpXSkgLyAoZGkxW2NpXSAtIGRpW2NpXSkpICogKGRpMS50IC0gZGkudCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0MiA9IGRqLnQgKyBhYnMoKGlzW2NqXSAtIGRqW2NqXSkgLyAoZGoxW2NqXSAtIGRqW2NqXSkpICogKGRqMS50IC0gZGoudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEuMDAxICYmIHQyID49IDAgJiYgdDIgPD0gMS4wMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MTogbW1pbih0MSwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyOiBtbWluKHQyLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnBhdGhJbnRlcnNlY3Rpb25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgaW50ZXJzZWN0aW9ucyBvZiB0d28gcGF0aHNcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcGF0aDEgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgLSBwYXRoMiAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgZG90cyBvZiBpbnRlcnNlY3Rpb25cbiAgICAgbyBbXG4gICAgIG8gICAgIHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxXG4gICAgIG8gICAgICAgICB0MjogKG51bWJlcikgdCB2YWx1ZSBmb3Igc2VnbWVudCBvZiBwYXRoMlxuICAgICBvICAgICAgICAgc2VnbWVudDE6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMVxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMlxuICAgICBvICAgICAgICAgYmV6MTogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDFcbiAgICAgbyAgICAgICAgIGJlejI6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgyXG4gICAgIG8gICAgIH1cbiAgICAgbyBdXG4gICAgXFwqL1xuICAgIFIucGF0aEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIpO1xuICAgIH07XG4gICAgUi5wYXRoSW50ZXJzZWN0aW9uTnVtYmVyID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMikge1xuICAgICAgICByZXR1cm4gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwgMSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgcGF0aDEgPSBSLl9wYXRoMmN1cnZlKHBhdGgxKTtcbiAgICAgICAgcGF0aDIgPSBSLl9wYXRoMmN1cnZlKHBhdGgyKTtcbiAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgICAgICAgICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDFtO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkxbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaXNQb2ludEluc2lkZVBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGEgZ2l2ZW4gY2xvc2VkIHBhdGguXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgLSB4IChudW1iZXIpIHggb2YgdGhlIHBvaW50XG4gICAgIC0geSAobnVtYmVyKSB5IG9mIHRoZSBwb2ludFxuICAgICA9IChib29sZWFuKSB0cnVlLCBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIHBhdGhcbiAgICBcXCovXG4gICAgUi5pc1BvaW50SW5zaWRlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB4LCB5KSB7XG4gICAgICAgIHZhciBiYm94ID0gUi5wYXRoQkJveChwYXRoKTtcbiAgICAgICAgcmV0dXJuIFIuaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkgJiZcbiAgICAgICAgICAgICAgIGludGVyUGF0aEhlbHBlcihwYXRoLCBbW1wiTVwiLCB4LCB5XSwgW1wiSFwiLCBiYm94LngyICsgMTBdXSwgMSkgJSAyID09IDE7XG4gICAgfTtcbiAgICBSLl9yZW1vdmVkRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2RuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUoXCJyYXBoYWVsLmxvZ1wiLCBudWxsLCBcIlJhcGhhXFx4ZWJsOiB5b3UgYXJlIGNhbGxpbmcgdG8gbWV0aG9kIFxcdTIwMWNcIiArIG1ldGhvZG5hbWUgKyBcIlxcdTIwMWQgb2YgcmVtb3ZlZCBvYmplY3RcIiwgbWV0aG9kbmFtZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5wYXRoQkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm4gYm91bmRpbmcgYm94IG9mIGEgZ2l2ZW4gcGF0aFxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3hcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94XG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94XG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94XG4gICAgIG8gICAgIHdpZHRoOiAobnVtYmVyKSB3aWR0aCBvZiB0aGUgYm94XG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyAgICAgY3g6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBib3hcbiAgICAgbyAgICAgY3k6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIHZhciBwYXRoRGltZW5zaW9ucyA9IFIucGF0aEJCb3ggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aCk7XG4gICAgICAgIGlmIChwdGguYmJveCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHB0aC5iYm94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7eDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgeDI6IDAsIHkyOiAwfTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gcGF0aDJjdXJ2ZShwYXRoKTtcbiAgICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBYID0gW10sXG4gICAgICAgICAgICBZID0gW10sXG4gICAgICAgICAgICBwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gcFsxXTtcbiAgICAgICAgICAgICAgICB5ID0gcFsyXTtcbiAgICAgICAgICAgICAgICBYLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgWS5wdXNoKHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gY3VydmVEaW0oeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSk7XG4gICAgICAgICAgICAgICAgWCA9IFhbY29uY2F0XShkaW0ubWluLngsIGRpbS5tYXgueCk7XG4gICAgICAgICAgICAgICAgWSA9IFlbY29uY2F0XShkaW0ubWluLnksIGRpbS5tYXgueSk7XG4gICAgICAgICAgICAgICAgeCA9IHBbNV07XG4gICAgICAgICAgICAgICAgeSA9IHBbNl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhtaW4gPSBtbWluW2FwcGx5XSgwLCBYKSxcbiAgICAgICAgICAgIHltaW4gPSBtbWluW2FwcGx5XSgwLCBZKSxcbiAgICAgICAgICAgIHhtYXggPSBtbWF4W2FwcGx5XSgwLCBYKSxcbiAgICAgICAgICAgIHltYXggPSBtbWF4W2FwcGx5XSgwLCBZKSxcbiAgICAgICAgICAgIHdpZHRoID0geG1heCAtIHhtaW4sXG4gICAgICAgICAgICBoZWlnaHQgPSB5bWF4IC0geW1pbixcbiAgICAgICAgICAgICAgICBiYiA9IHtcbiAgICAgICAgICAgICAgICB4OiB4bWluLFxuICAgICAgICAgICAgICAgIHk6IHltaW4sXG4gICAgICAgICAgICAgICAgeDI6IHhtYXgsXG4gICAgICAgICAgICAgICAgeTI6IHltYXgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGN4OiB4bWluICsgd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIGN5OiB5bWluICsgaGVpZ2h0IC8gMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgcHRoLmJib3ggPSBjbG9uZShiYik7XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9LFxuICAgICAgICBwYXRoQ2xvbmUgPSBmdW5jdGlvbiAocGF0aEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgICAgIHJlcy50b1N0cmluZyA9IFIuX3BhdGgyc3RyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aFRvUmVsYXRpdmUgPSBSLl9wYXRoVG9SZWxhdGl2ZSA9IGZ1bmN0aW9uIChwYXRoQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpO1xuICAgICAgICAgICAgaWYgKHB0aC5yZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5yZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSLmlzKHBhdGhBcnJheSwgYXJyYXkpIHx8ICFSLmlzKHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0sIGFycmF5KSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5ID0gUi5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgICAgICBteCA9IDAsXG4gICAgICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgICAgIHkgPSBwYXRoQXJyYXlbMF1bMl07XG4gICAgICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcIk1cIiwgeCwgeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByZXNbaV0gPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhWzBdICE9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByWzBdID0gbG93ZXJDYXNlLmNhbGwocGFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzZdID0gKyhwYVs2XSAtIHgpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICsocGFbN10gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gKyhwYVsxXSAtIHkpLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gKyhwYVtqXSAtICgoaiAlIDIpID8geCA6IHkpKS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhWzBdID09IFwibVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpXVtrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSByZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzW2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9ICtyZXNbaV1bbGVuIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnRvU3RyaW5nID0gUi5fcGF0aDJzdHJpbmc7XG4gICAgICAgICAgICBwdGgucmVsID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBwYXRoVG9BYnNvbHV0ZSA9IFIuX3BhdGhUb0Fic29sdXRlID0gZnVuY3Rpb24gKHBhdGhBcnJheSkge1xuICAgICAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGhBcnJheSk7XG4gICAgICAgICAgICBpZiAocHRoLmFicykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVIuaXMocGF0aEFycmF5LCBhcnJheSkgfHwgIVIuaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgYXJyYXkpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICAgICAgICAgICAgICBwYXRoQXJyYXkgPSBSLnBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tcIk1cIiwgMCwgMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgICAgIG14ID0gMCxcbiAgICAgICAgICAgICAgICBteSA9IDAsXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgaWYgKHBhdGhBcnJheVswXVswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgICAgIHggPSArcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgICAgICBteSA9IHk7XG4gICAgICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgICAgICByZXNbMF0gPSBbXCJNXCIsIHgsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT0gMyAmJiBwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIgJiYgcGF0aEFycmF5WzFdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJSXCIgJiYgcGF0aEFycmF5WzJdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJaXCI7XG4gICAgICAgICAgICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gociA9IFtdKTtcbiAgICAgICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFbMF0gIT0gdXBwZXJDYXNlLmNhbGwocGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJbMF0gPSB1cHBlckNhc2UuY2FsbChwYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArKHBhWzZdICsgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICsocGFbN10gKyB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90cyA9IFt4LCB5XVtjb25jYXRdKHBhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMiwgamogPSBkb3RzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1tqXSA9ICtkb3RzW2pdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzW2NvbmNhdF0oY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteSA9ICtwYVsyXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gK3BhW2pdICsgKChqICUgMikgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYVswXSA9PSBcIlJcIikge1xuICAgICAgICAgICAgICAgICAgICBkb3RzID0gW3gsIHldW2NvbmNhdF0ocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlc1tjb25jYXRdKGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgICAgICByID0gW1wiUlwiXVtjb25jYXRdKHBhLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG14O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG15O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMudG9TdHJpbmcgPSBSLl9wYXRoMnN0cmluZztcbiAgICAgICAgICAgIHB0aC5hYnMgPSBwYXRoQ2xvbmUocmVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGwyYyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICAgICAgfSxcbiAgICAgICAgcTJjID0gZnVuY3Rpb24gKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciBfMTMgPSAxIC8gMyxcbiAgICAgICAgICAgICAgICBfMjMgPSAyIC8gMztcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIF8xMyAqIHgxICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgICAgIF8xMyAqIHkxICsgXzIzICogYXksXG4gICAgICAgICAgICAgICAgICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgICAgIF8xMyAqIHkyICsgXzIzICogYXksXG4gICAgICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgICAgICB5MlxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIGEyYyA9IGZ1bmN0aW9uICh4MSwgeTEsIHJ4LCByeSwgYW5nbGUsIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCB4MiwgeTIsIHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgdmFyIF8xMjAgPSBQSSAqIDEyMCAvIDE4MCxcbiAgICAgICAgICAgICAgICByYWQgPSBQSSAvIDE4MCAqICgrYW5nbGUgfHwgMCksXG4gICAgICAgICAgICAgICAgcmVzID0gW10sXG4gICAgICAgICAgICAgICAgeHksXG4gICAgICAgICAgICAgICAgcm90YXRlID0gY2FjaGVyKGZ1bmN0aW9uICh4LCB5LCByYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFggPSB4ICogbWF0aC5jb3MocmFkKSAtIHkgKiBtYXRoLnNpbihyYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7eDogWCwgeTogWX07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgICAgICAgICAgICAgeDEgPSB4eS54O1xuICAgICAgICAgICAgICAgIHkxID0geHkueTtcbiAgICAgICAgICAgICAgICB4eSA9IHJvdGF0ZSh4MiwgeTIsIC1yYWQpO1xuICAgICAgICAgICAgICAgIHgyID0geHkueDtcbiAgICAgICAgICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgICAgICAgICAgdmFyIGNvcyA9IG1hdGguY29zKFBJIC8gMTgwICogYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBzaW4gPSBtYXRoLnNpbihQSSAvIDE4MCAqIGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHkgPSAoeTEgLSB5MikgLyAyO1xuICAgICAgICAgICAgICAgIHZhciBoID0gKHggKiB4KSAvIChyeCAqIHJ4KSArICh5ICogeSkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICAgICAgaWYgKGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSBtYXRoLnNxcnQoaCk7XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgICAgICByeSA9IGggKiByeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgICAgICAgICAgICAgIHJ5MiA9IHJ5ICogcnksXG4gICAgICAgICAgICAgICAgICAgIGsgPSAobGFyZ2VfYXJjX2ZsYWcgPT0gc3dlZXBfZmxhZyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgICAgICAgICAgICAgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgICAgICAgICAgICBjeSA9IGsgKiAtcnkgKiB4IC8gcnggKyAoeTEgKyB5MikgLyAyLFxuICAgICAgICAgICAgICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICAgICAgICAgICAgICBmMiA9IG1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuXG4gICAgICAgICAgICAgICAgZjEgPSB4MSA8IGN4ID8gUEkgLSBmMSA6IGYxO1xuICAgICAgICAgICAgICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICAgICAgICAgICAgICBmMSA8IDAgJiYgKGYxID0gUEkgKiAyICsgZjEpO1xuICAgICAgICAgICAgICAgIGYyIDwgMCAmJiAoZjIgPSBQSSAqIDIgKyBmMik7XG4gICAgICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgICAgICAgICBmMSA9IGYxIC0gUEkgKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgICAgICAgICBmMiA9IGYyIC0gUEkgKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgICAgICAgICAgICAgZjIgPSByZWN1cnNpdmVbMV07XG4gICAgICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICAgICAgY3kgPSByZWN1cnNpdmVbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICAgICAgaWYgKGFicyhkZikgPiBfMTIwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYyb2xkID0gZjIsXG4gICAgICAgICAgICAgICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgICAgICAgICAgICAgIHkyb2xkID0geTI7XG4gICAgICAgICAgICAgICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgICAgICAgICAgICAgeTIgPSBjeSArIHJ5ICogbWF0aC5zaW4oZjIpO1xuICAgICAgICAgICAgICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZiA9IGYyIC0gZjE7XG4gICAgICAgICAgICB2YXIgYzEgPSBtYXRoLmNvcyhmMSksXG4gICAgICAgICAgICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICAgICAgICAgICAgYzIgPSBtYXRoLmNvcyhmMiksXG4gICAgICAgICAgICAgICAgczIgPSBtYXRoLnNpbihmMiksXG4gICAgICAgICAgICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICAgICAgICAgICAgaHggPSA0IC8gMyAqIHJ4ICogdCxcbiAgICAgICAgICAgICAgICBoeSA9IDQgLyAzICogcnkgKiB0LFxuICAgICAgICAgICAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICAgICAgICAgICAgbTIgPSBbeDEgKyBoeCAqIHMxLCB5MSAtIGh5ICogYzFdLFxuICAgICAgICAgICAgICAgIG0zID0gW3gyICsgaHggKiBzMiwgeTIgLSBoeSAqIGMyXSxcbiAgICAgICAgICAgICAgICBtNCA9IFt4MiwgeTJdO1xuICAgICAgICAgICAgbTJbMF0gPSAyICogbTFbMF0gLSBtMlswXTtcbiAgICAgICAgICAgIG0yWzFdID0gMiAqIG0xWzFdIC0gbTJbMV07XG4gICAgICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFttMiwgbTMsIG00XVtjb25jYXRdKHJlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IFttMiwgbTMsIG00XVtjb25jYXRdKHJlcykuam9pbigpW3NwbGl0XShcIixcIik7XG4gICAgICAgICAgICAgICAgdmFyIG5ld3JlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3cmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaW5kRG90QXRTZWdtZW50ID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgICAgICB2YXIgdDEgPSAxIC0gdDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG93KHQxLCAzKSAqIHAxeCArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgcG93KHQsIDMpICogcDJ4LFxuICAgICAgICAgICAgICAgIHk6IHBvdyh0MSwgMykgKiBwMXkgKyBwb3codDEsIDIpICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHBvdyh0LCAzKSAqIHAyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VydmVEaW0gPSBjYWNoZXIoZnVuY3Rpb24gKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgICAgICB2YXIgYSA9IChjMnggLSAyICogYzF4ICsgcDF4KSAtIChwMnggLSAyICogYzJ4ICsgYzF4KSxcbiAgICAgICAgICAgICAgICBiID0gMiAqIChjMXggLSBwMXgpIC0gMiAqIChjMnggLSBjMXgpLFxuICAgICAgICAgICAgICAgIGMgPSBwMXggLSBjMXgsXG4gICAgICAgICAgICAgICAgdDEgPSAoLWIgKyBtYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvIDIgLyBhLFxuICAgICAgICAgICAgICAgIHQyID0gKC1iIC0gbWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAyIC8gYSxcbiAgICAgICAgICAgICAgICB5ID0gW3AxeSwgcDJ5XSxcbiAgICAgICAgICAgICAgICB4ID0gW3AxeCwgcDJ4XSxcbiAgICAgICAgICAgICAgICBkb3Q7XG4gICAgICAgICAgICBhYnModDEpID4gXCIxZTEyXCIgJiYgKHQxID0gLjUpO1xuICAgICAgICAgICAgYWJzKHQyKSA+IFwiMWUxMlwiICYmICh0MiA9IC41KTtcbiAgICAgICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDEpO1xuICAgICAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICAgICAgeS5wdXNoKGRvdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+IDAgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDIpO1xuICAgICAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICAgICAgeS5wdXNoKGRvdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSAoYzJ5IC0gMiAqIGMxeSArIHAxeSkgLSAocDJ5IC0gMiAqIGMyeSArIGMxeSk7XG4gICAgICAgICAgICBiID0gMiAqIChjMXkgLSBwMXkpIC0gMiAqIChjMnkgLSBjMXkpO1xuICAgICAgICAgICAgYyA9IHAxeSAtIGMxeTtcbiAgICAgICAgICAgIHQxID0gKC1iICsgbWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAyIC8gYTtcbiAgICAgICAgICAgIHQyID0gKC1iIC0gbWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAyIC8gYTtcbiAgICAgICAgICAgIGFicyh0MSkgPiBcIjFlMTJcIiAmJiAodDEgPSAuNSk7XG4gICAgICAgICAgICBhYnModDIpID4gXCIxZTEyXCIgJiYgKHQyID0gLjUpO1xuICAgICAgICAgICAgaWYgKHQxID4gMCAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgICAgICBkb3QgPSBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0MSk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKGRvdC54KTtcbiAgICAgICAgICAgICAgICB5LnB1c2goZG90LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQyID4gMCAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICBkb3QgPSBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0Mik7XG4gICAgICAgICAgICAgICAgeC5wdXNoKGRvdC54KTtcbiAgICAgICAgICAgICAgICB5LnB1c2goZG90LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IHt4OiBtbWluW2FwcGx5XSgwLCB4KSwgeTogbW1pblthcHBseV0oMCwgeSl9LFxuICAgICAgICAgICAgICAgIG1heDoge3g6IG1tYXhbYXBwbHldKDAsIHgpLCB5OiBtbWF4W2FwcGx5XSgwLCB5KX1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBwYXRoMmN1cnZlID0gUi5fcGF0aDJjdXJ2ZSA9IGNhY2hlcihmdW5jdGlvbiAocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgICAgIHZhciBwdGggPSAhcGF0aDIgJiYgcGF0aHMocGF0aCk7XG4gICAgICAgICAgICBpZiAoIXBhdGgyICYmIHB0aC5jdXJ2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwID0gcGF0aFRvQWJzb2x1dGUocGF0aCksXG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICAgICAgYXR0cnMgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgICAgIGF0dHJzMiA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbngsIG55LCB0cSA9IHtUOjEsIFE6MX07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIkNcIiwgZC54LCBkLnksIGQueCwgZC55LCBkLngsIGQueV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIShwYXRoWzBdIGluIHRxKSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5ZID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShhMmNbYXBwbHldKDAsIFtkLngsIGQueV1bY29uY2F0XShwYXRoLnNsaWNlKDEpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIkNcIiB8fCBwY29tID09IFwiU1wiKSB7IC8vIEluIFwiU1wiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueCAqIDIgLSBkLmJ4OyAgICAgICAgICAvLyBBbmQgcmVmbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21lIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV1bY29uY2F0XShwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjb20gPT0gXCJRXCIgfHwgcGNvbSA9PSBcIlRcIikgeyAvLyBJbiBcIlRcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueCAqIDIgLSBkLnF4OyAgICAgICAgLy8gQW5kIG1ha2UgYSByZWZsZWN0aW9uIHNpbWlsYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHNvbWV0aGluZyBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShxMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShsMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXVtjb25jYXRdKGwyYyhkLngsIGQueSwgZC54LCBwYXRoWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0obDJjKGQueCwgZC55LCBkLlgsIGQuWSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZml4QXJjID0gZnVuY3Rpb24gKHBwLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcFtpXS5sZW5ndGggPiA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpID0gcHBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMxW2ldPVwiQVwiOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgJiYgKHBjb21zMltpXT1cIkFcIik7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgW1wiQ1wiXVtjb25jYXRdKHBpLnNwbGljZSgwLCA2KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpeE0gPSBmdW5jdGlvbiAocGF0aDEsIHBhdGgyLCBhMSwgYTIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoMi5zcGxpY2UoaSwgMCwgW1wiTVwiLCBhMi54LCBhMi55XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMS5ieCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhMS55ID0gcGF0aDFbaV1bMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGNvbXMxID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICAgICAgcGNvbXMyID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwMlxuICAgICAgICAgICAgICAgIHBmaXJzdCA9IFwiXCIsIC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuICAgICAgICAgICAgICAgIHBjb20gPSBcIlwiOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSAmJiAocGZpcnN0ID0gcFtpXVswXSk7IC8vIHNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMVtpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgICAgICAgICAgICAgICBpICYmICggcGNvbSA9IHBjb21zMVtpLTFdKTsgLy8gR2V0IHByZXZpb3VzIHBhdGggY29tbWFuZCBwY29tXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zMVtpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHBjb21zMVtpXSA9IFwiQ1wiOyAvLyBBIGlzIHRoZSBvbmx5IGNvbW1hbmRcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBtYXkgcHJvZHVjZSBtdWx0aXBsZSBDOnNcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgICAgIGZpeEFyYyhwLCBpKTsgLy8gZml4QXJjIGFkZHMgYWxzbyB0aGUgcmlnaHQgYW1vdW50IG9mIEE6cyB0byBwY29tczFcblxuICAgICAgICAgICAgICAgIGlmIChwMikgeyAvLyB0aGUgc2FtZSBwcm9jZWR1cmVzIGlzIGRvbmUgdG8gcDJcbiAgICAgICAgICAgICAgICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBmaXJzdCAhPSBcIkNcIilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMyW2ldID0gcGZpcnN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwY29tczJbaV0hPVwiQVwiICYmIHBmaXJzdD09XCJDXCIpIHBjb21zMltpXT1cIkNcIjtcblxuICAgICAgICAgICAgICAgICAgICBmaXhBcmMocDIsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXhNKHAsIHAyLCBhdHRycywgYXR0cnMyLCBpKTtcbiAgICAgICAgICAgICAgICBmaXhNKHAyLCBwLCBhdHRyczIsIGF0dHJzLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gcFtpXSxcbiAgICAgICAgICAgICAgICAgICAgc2VnMiA9IHAyICYmIHAyW2ldLFxuICAgICAgICAgICAgICAgICAgICBzZWdsZW4gPSBzZWcubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYXR0cnMueCA9IHNlZ1tzZWdsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0gc2VnW3NlZ2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgIGF0dHJzLmJ4ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICAgICAgYXR0cnMuYnkgPSB0b0Zsb2F0KHNlZ1tzZWdsZW4gLSAzXSkgfHwgYXR0cnMueTtcbiAgICAgICAgICAgICAgICBhdHRyczIuYnggPSBwMiAmJiAodG9GbG9hdChzZWcyW3NlZzJsZW4gLSA0XSkgfHwgYXR0cnMyLngpO1xuICAgICAgICAgICAgICAgIGF0dHJzMi5ieSA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDNdKSB8fCBhdHRyczIueSk7XG4gICAgICAgICAgICAgICAgYXR0cnMyLnggPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICBhdHRyczIueSA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwMikge1xuICAgICAgICAgICAgICAgIHB0aC5jdXJ2ZSA9IHBhdGhDbG9uZShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xuICAgICAgICB9LCBudWxsLCBwYXRoQ2xvbmUpLFxuICAgICAgICBwYXJzZURvdHMgPSBSLl9wYXJzZURvdHMgPSBjYWNoZXIoZnVuY3Rpb24gKGdyYWRpZW50KSB7XG4gICAgICAgICAgICB2YXIgZG90cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZ3JhZGllbnQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkb3QgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFyID0gZ3JhZGllbnRbaV0ubWF0Y2goL14oW146XSopOj8oW1xcZFxcLl0qKS8pO1xuICAgICAgICAgICAgICAgIGRvdC5jb2xvciA9IFIuZ2V0UkdCKHBhclsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvdC5jb2xvci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG90Lm9wYWNpdHkgPSBkb3QuY29sb3Iub3BhY2l0eTtcbiAgICAgICAgICAgICAgICBkb3QuY29sb3IgPSBkb3QuY29sb3IuaGV4O1xuICAgICAgICAgICAgICAgIHBhclsyXSAmJiAoZG90Lm9mZnNldCA9IHBhclsyXSArIFwiJVwiKTtcbiAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGlpID0gZG90cy5sZW5ndGggLSAxOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZG90c1tpXS5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdG9GbG9hdChkb3RzW2kgLSAxXS5vZmZzZXQgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBpaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG90c1tqXS5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBkb3RzW2pdLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRvRmxvYXQoZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoZW5kIC0gc3RhcnQpIC8gKGogLSBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90c1tpXS5vZmZzZXQgPSBzdGFydCArIFwiJVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvdHM7XG4gICAgICAgIH0pLFxuICAgICAgICB0ZWFyID0gUi5fdGVhciA9IGZ1bmN0aW9uIChlbCwgcGFwZXIpIHtcbiAgICAgICAgICAgIGVsID09IHBhcGVyLnRvcCAmJiAocGFwZXIudG9wID0gZWwucHJldik7XG4gICAgICAgICAgICBlbCA9PSBwYXBlci5ib3R0b20gJiYgKHBhcGVyLmJvdHRvbSA9IGVsLm5leHQpO1xuICAgICAgICAgICAgZWwubmV4dCAmJiAoZWwubmV4dC5wcmV2ID0gZWwucHJldik7XG4gICAgICAgICAgICBlbC5wcmV2ICYmIChlbC5wcmV2Lm5leHQgPSBlbC5uZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9mcm9udCA9IFIuX3RvZnJvbnQgPSBmdW5jdGlvbiAoZWwsIHBhcGVyKSB7XG4gICAgICAgICAgICBpZiAocGFwZXIudG9wID09PSBlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlYXIoZWwsIHBhcGVyKTtcbiAgICAgICAgICAgIGVsLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgZWwucHJldiA9IHBhcGVyLnRvcDtcbiAgICAgICAgICAgIHBhcGVyLnRvcC5uZXh0ID0gZWw7XG4gICAgICAgICAgICBwYXBlci50b3AgPSBlbDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9iYWNrID0gUi5fdG9iYWNrID0gZnVuY3Rpb24gKGVsLCBwYXBlcikge1xuICAgICAgICAgICAgaWYgKHBhcGVyLmJvdHRvbSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZWFyKGVsLCBwYXBlcik7XG4gICAgICAgICAgICBlbC5uZXh0ID0gcGFwZXIuYm90dG9tO1xuICAgICAgICAgICAgZWwucHJldiA9IG51bGw7XG4gICAgICAgICAgICBwYXBlci5ib3R0b20ucHJldiA9IGVsO1xuICAgICAgICAgICAgcGFwZXIuYm90dG9tID0gZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydGFmdGVyID0gUi5faW5zZXJ0YWZ0ZXIgPSBmdW5jdGlvbiAoZWwsIGVsMiwgcGFwZXIpIHtcbiAgICAgICAgICAgIHRlYXIoZWwsIHBhcGVyKTtcbiAgICAgICAgICAgIGVsMiA9PSBwYXBlci50b3AgJiYgKHBhcGVyLnRvcCA9IGVsKTtcbiAgICAgICAgICAgIGVsMi5uZXh0ICYmIChlbDIubmV4dC5wcmV2ID0gZWwpO1xuICAgICAgICAgICAgZWwubmV4dCA9IGVsMi5uZXh0O1xuICAgICAgICAgICAgZWwucHJldiA9IGVsMjtcbiAgICAgICAgICAgIGVsMi5uZXh0ID0gZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydGJlZm9yZSA9IFIuX2luc2VydGJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgZWwyLCBwYXBlcikge1xuICAgICAgICAgICAgdGVhcihlbCwgcGFwZXIpO1xuICAgICAgICAgICAgZWwyID09IHBhcGVyLmJvdHRvbSAmJiAocGFwZXIuYm90dG9tID0gZWwpO1xuICAgICAgICAgICAgZWwyLnByZXYgJiYgKGVsMi5wcmV2Lm5leHQgPSBlbCk7XG4gICAgICAgICAgICBlbC5wcmV2ID0gZWwyLnByZXY7XG4gICAgICAgICAgICBlbDIucHJldiA9IGVsO1xuICAgICAgICAgICAgZWwubmV4dCA9IGVsMjtcbiAgICAgICAgfSxcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBSYXBoYWVsLnRvTWF0cml4XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBtYXRyaXggb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgdG8gYSBnaXZlbiBwYXRoXG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAgICAgLSB0cmFuc2Zvcm0gKHN0cmluZ3xhcnJheSkgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICB0b01hdHJpeCA9IFIudG9NYXRyaXggPSBmdW5jdGlvbiAocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgYmIgPSBwYXRoRGltZW5zaW9ucyhwYXRoKSxcbiAgICAgICAgICAgICAgICBlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgXzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBFXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldEJCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHRyYWN0VHJhbnNmb3JtKGVsLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsLm1hdHJpeDtcbiAgICAgICAgfSxcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBSYXBoYWVsLnRyYW5zZm9ybVBhdGhcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHBhdGggdHJhbnNmb3JtZWQgYnkgYSBnaXZlbiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgICAgIC0gdHJhbnNmb3JtIChzdHJpbmd8YXJyYXkpIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICAgICAgPSAoc3RyaW5nKSBwYXRoXG4gICAgICAgIFxcKi9cbiAgICAgICAgdHJhbnNmb3JtUGF0aCA9IFIudHJhbnNmb3JtUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBQYXRoKHBhdGgsIHRvTWF0cml4KHBhdGgsIHRyYW5zZm9ybSkpO1xuICAgICAgICB9LFxuICAgICAgICBleHRyYWN0VHJhbnNmb3JtID0gUi5fZXh0cmFjdFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlbCwgdHN0cikge1xuICAgICAgICAgICAgaWYgKHRzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5fLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRzdHIgPSBTdHIodHN0cikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZywgZWwuXy50cmFuc2Zvcm0gfHwgRSk7XG4gICAgICAgICAgICB2YXIgdGRhdGEgPSBSLnBhcnNlVHJhbnNmb3JtU3RyaW5nKHRzdHIpLFxuICAgICAgICAgICAgICAgIGRlZyA9IDAsXG4gICAgICAgICAgICAgICAgZHggPSAwLFxuICAgICAgICAgICAgICAgIGR5ID0gMCxcbiAgICAgICAgICAgICAgICBzeCA9IDEsXG4gICAgICAgICAgICAgICAgc3kgPSAxLFxuICAgICAgICAgICAgICAgIF8gPSBlbC5fLFxuICAgICAgICAgICAgICAgIG0gPSBuZXcgTWF0cml4O1xuICAgICAgICAgICAgXy50cmFuc2Zvcm0gPSB0ZGF0YSB8fCBbXTtcbiAgICAgICAgICAgIGlmICh0ZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRkYXRhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0ZGF0YVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRsZW4gPSB0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBTdHIodFswXSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlID0gdFswXSAhPSBjb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXIgPSBhYnNvbHV0ZSA/IG0uaW52ZXJ0KCkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXCJ0XCIgJiYgdGxlbiA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGludmVyLngoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBpbnZlci55KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50cmFuc2xhdGUoeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bGVuID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYiA9IGJiIHx8IGVsLmdldEJCb3goMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgYmIueCArIGJiLndpZHRoIC8gMiwgYmIueSArIGJiLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZyArPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgdFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZyArPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bGVuID09IDIgfHwgdGxlbiA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBlbC5nZXRCQm94KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFt0bGVuIC0gMV0sIGJiLnggKyBiYi53aWR0aCAvIDIsIGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeCAqPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5ICo9IHRbdGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uc2NhbGUodFsxXSwgdFsyXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeCAqPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5ICo9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcIm1cIiAmJiB0bGVuID09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYWRkKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF8uZGlydHlUID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWwubWF0cml4ID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXFxcbiAgICAgICAgICAgICAqIEVsZW1lbnQubWF0cml4XG4gICAgICAgICAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICAgICAgICAgKipcbiAgICAgICAgICAgICAqIEtlZXBzIEBNYXRyaXggb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIGVsZW1lbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIFxcKi9cbiAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG5cbiAgICAgICAgICAgIF8uc3ggPSBzeDtcbiAgICAgICAgICAgIF8uc3kgPSBzeTtcbiAgICAgICAgICAgIF8uZGVnID0gZGVnO1xuICAgICAgICAgICAgXy5keCA9IGR4ID0gbS5lO1xuICAgICAgICAgICAgXy5keSA9IGR5ID0gbS5mO1xuXG4gICAgICAgICAgICBpZiAoc3ggPT0gMSAmJiBzeSA9PSAxICYmICFkZWcgJiYgXy5iYm94KSB7XG4gICAgICAgICAgICAgICAgXy5iYm94LnggKz0gK2R4O1xuICAgICAgICAgICAgICAgIF8uYmJveC55ICs9ICtkeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5kaXJ0eVQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRFbXB0eSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGl0ZW1bMF07XG4gICAgICAgICAgICBzd2l0Y2ggKGwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6IHJldHVybiBbbCwgMCwgMF07XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1cIjogcmV0dXJuIFtsLCAxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOiBpZiAoaXRlbS5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDAsIGl0ZW1bMl0sIGl0ZW1bM11dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJzXCI6IGlmIChpdGVtLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMSwgMSwgaXRlbVszXSwgaXRlbVs0XV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMSwgMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVxdWFsaXNlVHJhbnNmb3JtID0gUi5fZXF1YWxpc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgICAgICAgICB0MiA9IFN0cih0MikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZywgdDEpO1xuICAgICAgICAgICAgdDEgPSBSLnBhcnNlVHJhbnNmb3JtU3RyaW5nKHQxKSB8fCBbXTtcbiAgICAgICAgICAgIHQyID0gUi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MikgfHwgW107XG4gICAgICAgICAgICB2YXIgbWF4bGVuZ3RoID0gbW1heCh0MS5sZW5ndGgsIHQyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgZnJvbSA9IFtdLFxuICAgICAgICAgICAgICAgIHRvID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IDAsIGosIGpqLFxuICAgICAgICAgICAgICAgIHR0MSwgdHQyO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBtYXhsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHR0MSA9IHQxW2ldIHx8IGdldEVtcHR5KHQyW2ldKTtcbiAgICAgICAgICAgICAgICB0dDIgPSB0MltpXSB8fCBnZXRFbXB0eSh0dDEpO1xuICAgICAgICAgICAgICAgIGlmICgodHQxWzBdICE9IHR0MlswXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR0MVswXS50b0xvd2VyQ2FzZSgpID09IFwiclwiICYmICh0dDFbMl0gIT0gdHQyWzJdIHx8IHR0MVszXSAhPSB0dDJbM10pKSB8fFxuICAgICAgICAgICAgICAgICAgICAodHQxWzBdLnRvTG93ZXJDYXNlKCkgPT0gXCJzXCIgJiYgKHR0MVszXSAhPSB0dDJbM10gfHwgdHQxWzRdICE9IHR0Mls0XSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21baV0gPSBbXTtcbiAgICAgICAgICAgICAgICB0b1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gbW1heCh0dDEubGVuZ3RoLCB0dDIubGVuZ3RoKTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaiBpbiB0dDEgJiYgKGZyb21baV1bal0gPSB0dDFbal0pO1xuICAgICAgICAgICAgICAgICAgICBqIGluIHR0MiAmJiAodG9baV1bal0gPSB0dDJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogdG9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgUi5fZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lcjtcbiAgICAgICAgY29udGFpbmVyID0gaCA9PSBudWxsICYmICFSLmlzKHgsIFwib2JqZWN0XCIpID8gZy5kb2MuZ2V0RWxlbWVudEJ5SWQoeCkgOiB4O1xuICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5zdHlsZS5waXhlbFdpZHRoIHx8IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuc3R5bGUucGl4ZWxIZWlnaHQgfHwgY29udGFpbmVyLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogeSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB3XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyOiAxLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwucGF0aFRvUmVsYXRpdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byByZWxhdGl2ZSBmb3JtXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZ3xhcnJheSkgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2Ygc2VnbWVudHNcbiAgICAgPSAoYXJyYXkpIGFycmF5IG9mIHNlZ21lbnRzLlxuICAgIFxcKi9cbiAgICBSLnBhdGhUb1JlbGF0aXZlID0gcGF0aFRvUmVsYXRpdmU7XG4gICAgUi5fZW5naW5lID0ge307XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwucGF0aDJjdXJ2ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIHRvIGEgbmV3IHBhdGggd2hlcmUgYWxsIHNlZ21lbnRzIGFyZSBjdWJpYyBiZXppZXIgY3VydmVzLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50cy5cbiAgICBcXCovXG4gICAgUi5wYXRoMmN1cnZlID0gcGF0aDJjdXJ2ZTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5tYXRyaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBtYXRyaXggYmFzZWQgb24gZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gYSAobnVtYmVyKVxuICAgICAtIGIgKG51bWJlcilcbiAgICAgLSBjIChudW1iZXIpXG4gICAgIC0gZCAobnVtYmVyKVxuICAgICAtIGUgKG51bWJlcilcbiAgICAgLSBmIChudW1iZXIpXG4gICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgIFxcKi9cbiAgICBSLm1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hID0gK2E7XG4gICAgICAgICAgICB0aGlzLmIgPSArYjtcbiAgICAgICAgICAgIHRoaXMuYyA9ICtjO1xuICAgICAgICAgICAgdGhpcy5kID0gK2Q7XG4gICAgICAgICAgICB0aGlzLmUgPSArZTtcbiAgICAgICAgICAgIHRoaXMuZiA9ICtmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hID0gMTtcbiAgICAgICAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAgICAgICB0aGlzLmMgPSAwO1xuICAgICAgICAgICAgdGhpcy5kID0gMTtcbiAgICAgICAgICAgIHRoaXMuZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIChmdW5jdGlvbiAobWF0cml4cHJvdG8pIHtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguYWRkXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBBZGRzIGdpdmVuIG1hdHJpeCB0byBleGlzdGluZyBvbmUuXG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0gYSAobnVtYmVyKVxuICAgICAgICAgLSBiIChudW1iZXIpXG4gICAgICAgICAtIGMgKG51bWJlcilcbiAgICAgICAgIC0gZCAobnVtYmVyKVxuICAgICAgICAgLSBlIChudW1iZXIpXG4gICAgICAgICAtIGYgKG51bWJlcilcbiAgICAgICAgIG9yXG4gICAgICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uYWRkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbW10sIFtdLCBbXV0sXG4gICAgICAgICAgICAgICAgbSA9IFtbdGhpcy5hLCB0aGlzLmMsIHRoaXMuZV0sIFt0aGlzLmIsIHRoaXMuZCwgdGhpcy5mXSwgWzAsIDAsIDFdXSxcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBbW2EsIGMsIGVdLCBbYiwgZCwgZl0sIFswLCAwLCAxXV0sXG4gICAgICAgICAgICAgICAgeCwgeSwgeiwgcmVzO1xuXG4gICAgICAgICAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgbWF0cml4ID0gW1thLmEsIGEuYywgYS5lXSwgW2EuYiwgYS5kLCBhLmZdLCBbMCwgMCwgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgMzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh5ID0gMDsgeSA8IDM7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSAwOyB6IDwgMzsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gbVt4XVt6XSAqIG1hdHJpeFt6XVt5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRbeF1beV0gPSByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hID0gb3V0WzBdWzBdO1xuICAgICAgICAgICAgdGhpcy5iID0gb3V0WzFdWzBdO1xuICAgICAgICAgICAgdGhpcy5jID0gb3V0WzBdWzFdO1xuICAgICAgICAgICAgdGhpcy5kID0gb3V0WzFdWzFdO1xuICAgICAgICAgICAgdGhpcy5lID0gb3V0WzBdWzJdO1xuICAgICAgICAgICAgdGhpcy5mID0gb3V0WzFdWzJdO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5pbnZlcnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4XG4gICAgICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHggPSBtZS5hICogbWUuZCAtIG1lLmIgKiBtZS5jO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgobWUuZCAvIHgsIC1tZS5iIC8geCwgLW1lLmMgLyB4LCBtZS5hIC8geCwgKG1lLmMgKiBtZS5mIC0gbWUuZCAqIG1lLmUpIC8geCwgKG1lLmIgKiBtZS5lIC0gbWUuYSAqIG1lLmYpIC8geCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmNsb25lXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIGNvcHkgb2YgdGhlIG1hdHJpeFxuICAgICAgICAgPSAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMuZSwgdGhpcy5mKTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudHJhbnNsYXRlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBUcmFuc2xhdGUgdGhlIG1hdHJpeFxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHggKG51bWJlcilcbiAgICAgICAgIC0geSAobnVtYmVyKVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZCgxLCAwLCAwLCAxLCB4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2NhbGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNjYWxlcyB0aGUgbWF0cml4XG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0geCAobnVtYmVyKVxuICAgICAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbFxuICAgICAgICAgLSBjeCAobnVtYmVyKSAjb3B0aW9uYWxcbiAgICAgICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgICAgICB5ID09IG51bGwgJiYgKHkgPSB4KTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy5hZGQoMSwgMCwgMCwgMSwgY3gsIGN5KTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHgsIDAsIDAsIHksIDAsIDApO1xuICAgICAgICAgICAgKGN4IHx8IGN5KSAmJiB0aGlzLmFkZCgxLCAwLCAwLCAxLCAtY3gsIC1jeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnJvdGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUm90YXRlcyB0aGUgbWF0cml4XG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0gYSAobnVtYmVyKVxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5yb3RhdGUgPSBmdW5jdGlvbiAoYSwgeCwgeSkge1xuICAgICAgICAgICAgYSA9IFIucmFkKGEpO1xuICAgICAgICAgICAgeCA9IHggfHwgMDtcbiAgICAgICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgICAgICB2YXIgY29zID0gK21hdGguY29zKGEpLnRvRml4ZWQoOSksXG4gICAgICAgICAgICAgICAgc2luID0gK21hdGguc2luKGEpLnRvRml4ZWQoOSk7XG4gICAgICAgICAgICB0aGlzLmFkZChjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuYWRkKDEsIDAsIDAsIDEsIC14LCAteSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnhcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybiB4IGNvb3JkaW5hdGUgZm9yIGdpdmVuIHBvaW50IGFmdGVyIHRyYW5zZm9ybWF0aW9uIGRlc2NyaWJlZCBieSB0aGUgbWF0cml4LiBTZWUgYWxzbyBATWF0cml4LnlcbiAgICAgICAgID4gUGFyYW1ldGVyc1xuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmEgKyB5ICogdGhpcy5jICsgdGhpcy5lO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC55XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm4geSBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC54XG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0geCAobnVtYmVyKVxuICAgICAgICAgLSB5IChudW1iZXIpXG4gICAgICAgICA9IChudW1iZXIpIHlcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by55ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICogdGhpcy5iICsgeSAqIHRoaXMuZCArIHRoaXMuZjtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpc1tTdHIuZnJvbUNoYXJDb2RlKDk3ICsgaSldLnRvRml4ZWQoNCk7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFIuc3ZnID9cbiAgICAgICAgICAgICAgICBcIm1hdHJpeChcIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXS5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICAgICAgW3RoaXMuZ2V0KDApLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDMpLCAwLCAwXS5qb2luKCk7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLnRvRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIgKyB0aGlzLmdldCgwKSArXG4gICAgICAgICAgICAgICAgXCIsIE0xMj1cIiArIHRoaXMuZ2V0KDIpICsgXCIsIE0yMT1cIiArIHRoaXMuZ2V0KDEpICsgXCIsIE0yMj1cIiArIHRoaXMuZ2V0KDMpICtcbiAgICAgICAgICAgICAgICBcIiwgRHg9XCIgKyB0aGlzLmdldCg0KSArIFwiLCBEeT1cIiArIHRoaXMuZ2V0KDUpICsgXCIsIHNpemluZ21ldGhvZD0nYXV0byBleHBhbmQnKVwiO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by5vZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZS50b0ZpeGVkKDQpLCB0aGlzLmYudG9GaXhlZCg0KV07XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG5vcm0oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKGEpIHtcbiAgICAgICAgICAgIHZhciBtYWcgPSBtYXRoLnNxcnQobm9ybShhKSk7XG4gICAgICAgICAgICBhWzBdICYmIChhWzBdIC89IG1hZyk7XG4gICAgICAgICAgICBhWzFdICYmIChhWzFdIC89IG1hZyk7XG4gICAgICAgIH1cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc3BsaXRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNwbGl0cyBtYXRyaXggaW50byBwcmltaXRpdmUgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICA9IChvYmplY3QpIGluIGZvcm1hdDpcbiAgICAgICAgIG8gZHggKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeFxuICAgICAgICAgbyBkeSAobnVtYmVyKSB0cmFuc2xhdGlvbiBieSB5XG4gICAgICAgICBvIHNjYWxleCAobnVtYmVyKSBzY2FsZSBieSB4XG4gICAgICAgICBvIHNjYWxleSAobnVtYmVyKSBzY2FsZSBieSB5XG4gICAgICAgICBvIHNoZWFyIChudW1iZXIpIHNoZWFyXG4gICAgICAgICBvIHJvdGF0ZSAobnVtYmVyKSByb3RhdGlvbiBpbiBkZWdcbiAgICAgICAgIG8gaXNTaW1wbGUgKGJvb2xlYW4pIGNvdWxkIGl0IGJlIHJlcHJlc2VudGVkIHZpYSBzaW1wbGUgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc3BsaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvblxuICAgICAgICAgICAgb3V0LmR4ID0gdGhpcy5lO1xuICAgICAgICAgICAgb3V0LmR5ID0gdGhpcy5mO1xuXG4gICAgICAgICAgICAvLyBzY2FsZSBhbmQgc2hlYXJcbiAgICAgICAgICAgIHZhciByb3cgPSBbW3RoaXMuYSwgdGhpcy5jXSwgW3RoaXMuYiwgdGhpcy5kXV07XG4gICAgICAgICAgICBvdXQuc2NhbGV4ID0gbWF0aC5zcXJ0KG5vcm0ocm93WzBdKSk7XG4gICAgICAgICAgICBub3JtYWxpemUocm93WzBdKTtcblxuICAgICAgICAgICAgb3V0LnNoZWFyID0gcm93WzBdWzBdICogcm93WzFdWzBdICsgcm93WzBdWzFdICogcm93WzFdWzFdO1xuICAgICAgICAgICAgcm93WzFdID0gW3Jvd1sxXVswXSAtIHJvd1swXVswXSAqIG91dC5zaGVhciwgcm93WzFdWzFdIC0gcm93WzBdWzFdICogb3V0LnNoZWFyXTtcblxuICAgICAgICAgICAgb3V0LnNjYWxleSA9IG1hdGguc3FydChub3JtKHJvd1sxXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1sxXSk7XG4gICAgICAgICAgICBvdXQuc2hlYXIgLz0gb3V0LnNjYWxleTtcblxuICAgICAgICAgICAgLy8gcm90YXRpb25cbiAgICAgICAgICAgIHZhciBzaW4gPSAtcm93WzBdWzFdLFxuICAgICAgICAgICAgICAgIGNvcyA9IHJvd1sxXVsxXTtcbiAgICAgICAgICAgIGlmIChjb3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IFIuZGVnKG1hdGguYWNvcyhjb3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2luIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gMzYwIC0gb3V0LnJvdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBSLmRlZyhtYXRoLmFzaW4oc2luKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dC5pc1NpbXBsZSA9ICErb3V0LnNoZWFyLnRvRml4ZWQoOSkgJiYgKG91dC5zY2FsZXgudG9GaXhlZCg5KSA9PSBvdXQuc2NhbGV5LnRvRml4ZWQoOSkgfHwgIW91dC5yb3RhdGUpO1xuICAgICAgICAgICAgb3V0LmlzU3VwZXJTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIG91dC5zY2FsZXgudG9GaXhlZCg5KSA9PSBvdXQuc2NhbGV5LnRvRml4ZWQoOSkgJiYgIW91dC5yb3RhdGU7XG4gICAgICAgICAgICBvdXQubm9Sb3RhdGlvbiA9ICErb3V0LnNoZWFyLnRvRml4ZWQoOSkgJiYgIW91dC5yb3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC50b1RyYW5zZm9ybVN0cmluZ1xuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJuIHRyYW5zZm9ybSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIG1hdHJpeFxuICAgICAgICAgPSAoc3RyaW5nKSB0cmFuc2Zvcm0gc3RyaW5nXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8udG9UcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoc2hvcnRlcikge1xuICAgICAgICAgICAgdmFyIHMgPSBzaG9ydGVyIHx8IHRoaXNbc3BsaXRdKCk7XG4gICAgICAgICAgICBpZiAocy5pc1NpbXBsZSkge1xuICAgICAgICAgICAgICAgIHMuc2NhbGV4ID0gK3Muc2NhbGV4LnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXkgPSArcy5zY2FsZXkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnJvdGF0ZSA9ICtzLnJvdGF0ZS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAgKHMuZHggfHwgcy5keSA/IFwidFwiICsgW3MuZHgsIHMuZHldIDogRSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHMuc2NhbGV4ICE9IDEgfHwgcy5zY2FsZXkgIT0gMSA/IFwic1wiICsgW3Muc2NhbGV4LCBzLnNjYWxleSwgMCwgMF0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFtzLnJvdGF0ZSwgMCwgMF0gOiBFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibVwiICsgW3RoaXMuZ2V0KDApLCB0aGlzLmdldCgxKSwgdGhpcy5nZXQoMiksIHRoaXMuZ2V0KDMpLCB0aGlzLmdldCg0KSwgdGhpcy5nZXQoNSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKE1hdHJpeC5wcm90b3R5cGUpO1xuXG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfSxcbiAgICBwcmV2ZW50VG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH0sXG4gICAgc3RvcFRvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgZ2V0RXZlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzY3JvbGxZID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBnLmRvYy5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFggPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBnLmRvYy5ib2R5LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCArIHNjcm9sbFgsXG4gICAgICAgICAgICB5OiBlLmNsaWVudFkgKyBzY3JvbGxZXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChnLmRvYy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChlbGVtZW50LCBlLCBwb3MueCwgcG9zLnkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRFdmVudFBvc2l0aW9uKGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZGUgPSBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzW2ldLnRhcmdldCA9PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUudGFyZ2V0VG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ID0gb2xkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnRUb3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBzdG9wVG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hNYXBbdHlwZV0sIF9mLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW3R5cGVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hNYXBbdHlwZV0sIF9mLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZy5kb2MuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUgfHwgZy53aW4uZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxZID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBnLmRvYy5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBnLmRvYy5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYICsgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBzY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gZS5wcmV2ZW50RGVmYXVsdCB8fCBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBlLnN0b3BQcm9wYWdhdGlvbiB8fCBzdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1lbnQsIGUsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb2JqLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXRhY2hlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpLFxuICAgIGRyYWcgPSBbXSxcbiAgICBkcmFnTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICAgIHNjcm9sbFkgPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGcuZG9jLmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsWCA9IGcuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGcuZG9jLmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIGRyYWdpLFxuICAgICAgICAgICAgaiA9IGRyYWcubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbal07XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNUb3VjaCAmJiBlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGUudG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSBlLnRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09IGRyYWdpLmVsLl9kcmFnLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCA/IGUub3JpZ2luYWxFdmVudCA6IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkcmFnaS5lbC5ub2RlLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBnLndpbi5vcGVyYSAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIG8gPSBkcmFnaS5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgICAgICBnLndpbi5vcGVyYSAmJiAobmV4dCA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgbyAmJiBldmUoXCJyYXBoYWVsLmRyYWcub3Zlci5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbCwgbyk7XG4gICAgICAgICAgICB4ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICB5ICs9IHNjcm9sbFk7XG4gICAgICAgICAgICBldmUoXCJyYXBoYWVsLmRyYWcubW92ZS5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCB4IC0gZHJhZ2kuZWwuX2RyYWcueCwgeSAtIGRyYWdpLmVsLl9kcmFnLnksIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBSLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgdmFyIGkgPSBkcmFnLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbaV07XG4gICAgICAgICAgICBkcmFnaS5lbC5fZHJhZyA9IHt9O1xuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5kcmFnLmVuZC5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbmRfc2NvcGUgfHwgZHJhZ2kuc3RhcnRfc2NvcGUgfHwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH0sXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZWxcbiAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICoqXG4gICAgICogWW91IGNhbiBhZGQgeW91ciBvd24gbWV0aG9kIHRvIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGhhY2sgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IG9yXG4gICAgICogd2FudCB0byB3cmFwIHNvbWUgY29tbW9uIHRyYW5zZm9ybWF0aW9uIG9yIGF0dHJpYnV0ZXMgaW4gb25lIG1ldGhvZC4gSW4gZGlmZmVyZW5jZSB0byBjYW52YXMgbWV0aG9kcyxcbiAgICAgKiB5b3UgY2FuIHJlZGVmaW5lIGVsZW1lbnQgbWV0aG9kIGF0IGFueSB0aW1lLiBFeHBlbmRpbmcgZWxlbWVudCBtZXRob2RzIHdvdWxkbuKAmXQgYWZmZWN0IHNldC5cbiAgICAgPiBVc2FnZVxuICAgICB8IFJhcGhhZWwuZWwucmVkID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICB0aGlzLmF0dHIoe2ZpbGw6IFwiI2YwMFwifSk7XG4gICAgIHwgfTtcbiAgICAgfCAvLyB0aGVuIHVzZSBpdFxuICAgICB8IHBhcGVyLmNpcmNsZSgxMDAsIDEwMCwgMjApLnJlZCgpO1xuICAgIFxcKi9cbiAgICBlbHByb3RvID0gUi5lbCA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgY2xpY2sgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgZG91YmxlIGNsaWNrIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgZG91YmxlIGNsaWNrIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlZG93blxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZWRvd24gZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2Vkb3duIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZW1vdmUgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2Vtb3ZlIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlb3V0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2VvdXQgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2VvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlb3ZlciBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZW92ZXIgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZXVwIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZXVwIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgdG91Y2hzdGFydCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgdG91Y2hzdGFydCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaG1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgdG91Y2htb3ZlIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNobW92ZSBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciB0b3VjaGVuZCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoZW5kIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoY2FuY2VsIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVudG91Y2hjYW5jZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgdG91Y2hjYW5jZWwgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGZvciAodmFyIGkgPSBldmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBSW2V2ZW50TmFtZV0gPSBlbHByb3RvW2V2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFIuaXMoZm4sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7bmFtZTogZXZlbnROYW1lLCBmOiBmbiwgdW5iaW5kOiBhZGRFdmVudCh0aGlzLnNoYXBlIHx8IHRoaXMubm9kZSB8fCBnLmRvYywgZXZlbnROYW1lLCBmbiwgc2NvcGUgfHwgdGhpcyl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUltcInVuXCIgKyBldmVudE5hbWVdID0gZWxwcm90b1tcInVuXCIgKyBldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBsID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobC0tKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50c1tsXS5uYW1lID09IGV2ZW50TmFtZSAmJiAoUi5pcyhmbiwgXCJ1bmRlZmluZWRcIikgfHwgZXZlbnRzW2xdLmYgPT0gZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHNbbF0udW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIWV2ZW50cy5sZW5ndGggJiYgZGVsZXRlIHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoZXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIG9yIHJldHJpZXZlcyBnaXZlbiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4ga2V5LlxuICAgICAqKlxuICAgICAqIFNlZSBhbHNvIEBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0ga2V5IChzdHJpbmcpIGtleSB0byBzdG9yZSBkYXRhXG4gICAgIC0gdmFsdWUgKGFueSkgI29wdGlvbmFsIHZhbHVlIHRvIHN0b3JlXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICAgKiBvciwgaWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZDpcbiAgICAgPSAoYW55KSB2YWx1ZVxuICAgICAqIG9yLCBpZiBrZXkgYW5kIHZhbHVlIGFyZSBub3Qgc3BlY2lmaWVkOlxuICAgICA9IChvYmplY3QpIEtleS92YWx1ZSBwYWlycyBmb3IgYWxsIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudC5cbiAgICAgPiBVc2FnZVxuICAgICB8IGZvciAodmFyIGkgPSAwLCBpIDwgNSwgaSsrKSB7XG4gICAgIHwgICAgIHBhcGVyLmNpcmNsZSgxMCArIDE1ICogaSwgMTAsIDEwKVxuICAgICB8ICAgICAgICAgIC5hdHRyKHtmaWxsOiBcIiMwMDBcIn0pXG4gICAgIHwgICAgICAgICAgLmRhdGEoXCJpXCIsIGkpXG4gICAgIHwgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgICAgICAgICBhbGVydCh0aGlzLmRhdGEoXCJpXCIpKTtcbiAgICAgfCAgICAgICAgICB9KTtcbiAgICAgfCB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZGF0YSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZWxkYXRhW3RoaXMuaWRdID0gZWxkYXRhW3RoaXMuaWRdIHx8IHt9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoUi5pcyhrZXksIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBrZXkpIGlmIChrZXlbaGFzXShpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEoaSwga2V5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmUoXCJyYXBoYWVsLmRhdGEuZ2V0LlwiICsgdGhpcy5pZCwgdGhpcywgZGF0YVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgZXZlKFwicmFwaGFlbC5kYXRhLnNldC5cIiArIHRoaXMuaWQsIHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJlbW92ZURhdGFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGFuIGVsZW1lbnQgYnkgZ2l2ZW4ga2V5LlxuICAgICAqIElmIGtleSBpcyBub3QgcHJvdmlkZWQsIHJlbW92ZXMgYWxsIHRoZSBkYXRhIG9mIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBrZXkgKHN0cmluZykgI29wdGlvbmFsIGtleVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgZWxkYXRhW3RoaXMuaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxkYXRhW3RoaXMuaWRdICYmIGRlbGV0ZSBlbGRhdGFbdGhpcy5pZF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXREYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgZGF0YVxuICAgICA9IChvYmplY3QpIGRhdGFcbiAgICBcXCovXG4gICAgZWxwcm90by5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xvbmUoZWxkYXRhW3RoaXMuaWRdIHx8IHt9KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBob3ZlciBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgIC0gaWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGhvdmVyIGluIGhhbmRsZXJcbiAgICAgLSBvY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgaG92ZXIgb3V0IGhhbmRsZXJcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0LCBzY29wZV9pbiwgc2NvcGVfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlb3ZlcihmX2luLCBzY29wZV9pbikubW91c2VvdXQoZl9vdXQsIHNjb3BlX291dCB8fCBzY29wZV9pbik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZvciBob3ZlciBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVubW91c2VvdmVyKGZfaW4pLnVubW91c2VvdXQoZl9vdXQpO1xuICAgIH07XG4gICAgdmFyIGRyYWdnYWJsZSA9IFtdO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRyYWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGRyYWcgb2YgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIG9ubW92ZSAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIG1vdmluZ1xuICAgICAtIG9uc3RhcnQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBkcmFnIHN0YXJ0XG4gICAgIC0gb25lbmQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBkcmFnIGVuZFxuICAgICAtIG1jb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBtb3ZpbmcgaGFuZGxlclxuICAgICAtIHNjb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBkcmFnIHN0YXJ0IGhhbmRsZXJcbiAgICAgLSBlY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgZHJhZyBlbmQgaGFuZGxlclxuICAgICAqIEFkZGl0aW9uYWxseSBmb2xsb3dpbmcgYGRyYWdgIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZDogYGRyYWcuc3RhcnQuPGlkPmAgb24gc3RhcnQsXG4gICAgICogYGRyYWcuZW5kLjxpZD5gIG9uIGVuZCBhbmQgYGRyYWcubW92ZS48aWQ+YCBvbiBldmVyeSBtb3ZlLiBXaGVuIGVsZW1lbnQgd2lsbCBiZSBkcmFnZ2VkIG92ZXIgYW5vdGhlciBlbGVtZW50XG4gICAgICogYGRyYWcub3Zlci48aWQ+YCB3aWxsIGJlIGZpcmVkIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBTdGFydCBldmVudCBhbmQgc3RhcnQgaGFuZGxlciB3aWxsIGJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogTW92ZSBldmVudCBhbmQgbW92ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBkeCAobnVtYmVyKSBzaGlmdCBieSB4IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8gZHkgKG51bWJlcikgc2hpZnQgYnkgeSBmcm9tIHRoZSBzdGFydCBwb2ludFxuICAgICBvIHggKG51bWJlcikgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyB5IChudW1iZXIpIHkgcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8gZXZlbnQgKG9iamVjdCkgRE9NIGV2ZW50IG9iamVjdFxuICAgICAqIEVuZCBldmVudCBhbmQgZW5kIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGV2ZW50IChvYmplY3QpIERPTSBldmVudCBvYmplY3RcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmRyYWcgPSBmdW5jdGlvbiAob25tb3ZlLCBvbnN0YXJ0LCBvbmVuZCwgbW92ZV9zY29wZSwgc3RhcnRfc2NvcGUsIGVuZF9zY29wZSkge1xuICAgICAgICBmdW5jdGlvbiBzdGFydChlKSB7XG4gICAgICAgICAgICAoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIHNjcm9sbFkgPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGcuZG9jLmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBnLmRvYy5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB0aGlzLl9kcmFnLmlkID0gZS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgZS50b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLnRvdWNoZXMubGVuZ3RoLCB0b3VjaDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoID0gZS50b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnLmlkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT0gdGhpcy5fZHJhZy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZHJhZy54ID0geCArIHNjcm9sbFg7XG4gICAgICAgICAgICB0aGlzLl9kcmFnLnkgPSB5ICsgc2Nyb2xsWTtcbiAgICAgICAgICAgICFkcmFnLmxlbmd0aCAmJiBSLm1vdXNlbW92ZShkcmFnTW92ZSkubW91c2V1cChkcmFnVXApO1xuICAgICAgICAgICAgZHJhZy5wdXNoKHtlbDogdGhpcywgbW92ZV9zY29wZTogbW92ZV9zY29wZSwgc3RhcnRfc2NvcGU6IHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGU6IGVuZF9zY29wZX0pO1xuICAgICAgICAgICAgb25zdGFydCAmJiBldmUub24oXCJyYXBoYWVsLmRyYWcuc3RhcnQuXCIgKyB0aGlzLmlkLCBvbnN0YXJ0KTtcbiAgICAgICAgICAgIG9ubW92ZSAmJiBldmUub24oXCJyYXBoYWVsLmRyYWcubW92ZS5cIiArIHRoaXMuaWQsIG9ubW92ZSk7XG4gICAgICAgICAgICBvbmVuZCAmJiBldmUub24oXCJyYXBoYWVsLmRyYWcuZW5kLlwiICsgdGhpcy5pZCwgb25lbmQpO1xuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5kcmFnLnN0YXJ0LlwiICsgdGhpcy5pZCwgc3RhcnRfc2NvcGUgfHwgbW92ZV9zY29wZSB8fCB0aGlzLCB0aGlzLl9kcmFnLngsIHRoaXMuX2RyYWcueSwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhZyA9IHt9O1xuICAgICAgICBkcmFnZ2FibGUucHVzaCh7ZWw6IHRoaXMsIHN0YXJ0OiBzdGFydH0pO1xuICAgICAgICB0aGlzLm1vdXNlZG93bihzdGFydCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQub25EcmFnT3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2hvcnRjdXQgZm9yIGFzc2lnbmluZyBldmVudCBoYW5kbGVyIGZvciBgZHJhZy5vdmVyLjxpZD5gIGV2ZW50LCB3aGVyZSBpZCBpcyBpZCBvZiB0aGUgZWxlbWVudCAoc2VlIEBFbGVtZW50LmlkKS5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGV2ZW50LCBmaXJzdCBhcmd1bWVudCB3b3VsZCBiZSB0aGUgZWxlbWVudCB5b3UgYXJlIGRyYWdnaW5nIG92ZXJcbiAgICBcXCovXG4gICAgZWxwcm90by5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZiA/IGV2ZS5vbihcInJhcGhhZWwuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCwgZikgOiBldmUudW5iaW5kKFwicmFwaGFlbC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZHJhZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgZHJhZyBldmVudCBoYW5kbGVycyBmcm9tIGdpdmVuIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5kcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IGRyYWdnYWJsZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChkcmFnZ2FibGVbaV0uZWwgPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy51bm1vdXNlZG93bihkcmFnZ2FibGVbaV0uc3RhcnQpO1xuICAgICAgICAgICAgZHJhZ2dhYmxlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGV2ZS51bmJpbmQoXCJyYXBoYWVsLmRyYWcuKi5cIiArIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgICFkcmFnZ2FibGUubGVuZ3RoICYmIFIudW5tb3VzZW1vdmUoZHJhZ01vdmUpLnVubW91c2V1cChkcmFnVXApO1xuICAgICAgICBkcmFnID0gW107XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuY2lyY2xlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIGNpcmNsZS5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSByIChudW1iZXIpIHJhZGl1c1xuICAgICA9IChvYmplY3QpIFJhcGhhw6tsIGVsZW1lbnQgb2JqZWN0IHdpdGggdHlwZSDigJxjaXJjbGXigJ1cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmNpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHZhciBvdXQgPSBSLl9lbmdpbmUuY2lyY2xlKHRoaXMsIHggfHwgMCwgeSB8fCAwLCByIHx8IDApO1xuICAgICAgICB0aGlzLl9fc2V0X18gJiYgdGhpcy5fX3NldF9fLnB1c2gob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5yZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKlxuICAgICAqIERyYXdzIGEgcmVjdGFuZ2xlLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodFxuICAgICAtIHIgKG51bWJlcikgI29wdGlvbmFsIHJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgPSAob2JqZWN0KSBSYXBoYcOrbCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUg4oCccmVjdOKAnVxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gcmVndWxhciByZWN0YW5nbGVcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoMTAsIDEwLCA1MCwgNTApO1xuICAgICB8IC8vIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCg0MCwgNDAsIDUwLCA1MCwgMTApO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgICAgICB2YXIgb3V0ID0gUi5fZW5naW5lLnJlY3QodGhpcywgeCB8fCAwLCB5IHx8IDAsIHcgfHwgMCwgaCB8fCAwLCByIHx8IDApO1xuICAgICAgICB0aGlzLl9fc2V0X18gJiYgdGhpcy5fX3NldF9fLnB1c2gob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5lbGxpcHNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhbiBlbGxpcHNlLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHJ4IChudW1iZXIpIGhvcml6b250YWwgcmFkaXVzXG4gICAgIC0gcnkgKG51bWJlcikgdmVydGljYWwgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgUmFwaGHDq2wgZWxlbWVudCBvYmplY3Qgd2l0aCB0eXBlIOKAnGVsbGlwc2XigJ1cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuZWxsaXBzZSg1MCwgNTAsIDQwLCAyMCk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZWxsaXBzZSA9IGZ1bmN0aW9uICh4LCB5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIG91dCA9IFIuX2VuZ2luZS5lbGxpcHNlKHRoaXMsIHggfHwgMCwgeSB8fCAwLCByeCB8fCAwLCByeSB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIHBhdGggZWxlbWVudCBieSBnaXZlbiBwYXRoIGRhdGEgc3RyaW5nLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmcpICNvcHRpb25hbCBwYXRoIHN0cmluZyBpbiBTVkcgZm9ybWF0LlxuICAgICAqIFBhdGggc3RyaW5nIGNvbnNpc3RzIG9mIG9uZS1sZXR0ZXIgY29tbWFuZHMsIGZvbGxvd2VkIGJ5IGNvbW1hIHNlcHJhcmF0ZWQgYXJndW1lbnRzIGluIG51bWVyY2FsIGZvcm0uIEV4YW1wbGU6XG4gICAgIHwgXCJNMTAsMjBMMzAsNDBcIlxuICAgICAqIEhlcmUgd2UgY2FuIHNlZSB0d28gY29tbWFuZHM6IOKAnE3igJ0sIHdpdGggYXJndW1lbnRzIGAoMTAsIDIwKWAgYW5kIOKAnEzigJ0gd2l0aCBhcmd1bWVudHMgYCgzMCwgNDApYC4gVXBwZXIgY2FzZSBsZXR0ZXIgbWVhbiBjb21tYW5kIGlzIGFic29sdXRlLCBsb3dlciBjYXNl4oCUcmVsYXRpdmUuXG4gICAgICpcbiAgICAgIyA8cD5IZXJlIGlzIHNob3J0IGxpc3Qgb2YgY29tbWFuZHMgYXZhaWxhYmxlLCBmb3IgbW9yZSBkZXRhaWxzIHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcIiB0aXRsZT1cIkRldGFpbHMgb2YgYSBwYXRoJ3MgZGF0YSBhdHRyaWJ1dGUncyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIHBhdGggc3RyaW5nIGZvcm1hdDwvYT4uPC9wPlxuICAgICAjIDx0YWJsZT48dGhlYWQ+PHRyPjx0aD5Db21tYW5kPC90aD48dGg+TmFtZTwvdGg+PHRoPlBhcmFtZXRlcnM8L3RoPjwvdHI+PC90aGVhZD48dGJvZHk+XG4gICAgICMgPHRyPjx0ZD5NPC90ZD48dGQ+bW92ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+WjwvdGQ+PHRkPmNsb3NlcGF0aDwvdGQ+PHRkPihub25lKTwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkw8L3RkPjx0ZD5saW5ldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5IPC90ZD48dGQ+aG9yaXpvbnRhbCBsaW5ldG88L3RkPjx0ZD54KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlY8L3RkPjx0ZD52ZXJ0aWNhbCBsaW5ldG88L3RkPjx0ZD55KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkM8L3RkPjx0ZD5jdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UzwvdGQ+PHRkPnNtb290aCBjdXJ2ZXRvPC90ZD48dGQ+KHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UTwvdGQ+PHRkPnF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5UPC90ZD48dGQ+c21vb3RoIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5BPC90ZD48dGQ+ZWxsaXB0aWNhbCBhcmM8L3RkPjx0ZD4ocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5SPC90ZD48dGQ+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbOKAk1JvbV9zcGxpbmUjQ2F0bXVsbC5FMi44MC45M1JvbV9zcGxpbmVcIj5DYXRtdWxsLVJvbSBjdXJ2ZXRvPC9hPio8L3RkPjx0ZD54MSB5MSAoeCB5KSs8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPlxuICAgICAqICog4oCcQ2F0bXVsbC1Sb20gY3VydmV0b+KAnSBpcyBhIG5vdCBzdGFuZGFyZCBTVkcgY29tbWFuZCBhbmQgYWRkZWQgaW4gMi4wIHRvIG1ha2UgbGlmZSBlYXNpZXIuXG4gICAgICogTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlbiBwYXRoIGNvbnNpc3Qgb2YganVzdCB0aHJlZSBjb21tYW5kczog4oCcTTEwLDEwUuKApnrigJ0uIEluIHRoaXMgY2FzZSBwYXRoIHdpbGwgc21vb3RobHkgY29ubmVjdHMgdG8gaXRzIGJlZ2lubmluZy5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIucGF0aChcIk0xMCAxMEw5MCA5MFwiKTtcbiAgICAgfCAvLyBkcmF3IGEgZGlhZ29uYWwgbGluZTpcbiAgICAgfCAvLyBtb3ZlIHRvIDEwLDEwLCBsaW5lIHRvIDkwLDkwXG4gICAgICogRm9yIGV4YW1wbGUgb2YgcGF0aCBzdHJpbmdzLCBjaGVjayBvdXQgdGhlc2UgaWNvbnM6IGh0dHA6Ly9yYXBoYWVsanMuY29tL2ljb25zL1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnBhdGggPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgICAgICBwYXRoU3RyaW5nICYmICFSLmlzKHBhdGhTdHJpbmcsIHN0cmluZykgJiYgIVIuaXMocGF0aFN0cmluZ1swXSwgYXJyYXkpICYmIChwYXRoU3RyaW5nICs9IEUpO1xuICAgICAgICB2YXIgb3V0ID0gUi5fZW5naW5lLnBhdGgoUi5mb3JtYXRbYXBwbHldKFIsIGFyZ3VtZW50cyksIHRoaXMpO1xuICAgICAgICB0aGlzLl9fc2V0X18gJiYgdGhpcy5fX3NldF9fLnB1c2gob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5pbWFnZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRW1iZWRzIGFuIGltYWdlIGludG8gdGhlIHN1cmZhY2UuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHNyYyAoc3RyaW5nKSBVUkkgb2YgdGhlIHNvdXJjZSBpbWFnZVxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB3aWR0aCAobnVtYmVyKSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICAgICA9IChvYmplY3QpIFJhcGhhw6tsIGVsZW1lbnQgb2JqZWN0IHdpdGggdHlwZSDigJxpbWFnZeKAnVxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5pbWFnZShcImFwcGxlLnBuZ1wiLCAxMCwgMTAsIDgwLCA4MCk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgIHZhciBvdXQgPSBSLl9lbmdpbmUuaW1hZ2UodGhpcywgc3JjIHx8IFwiYWJvdXQ6YmxhbmtcIiwgeCB8fCAwLCB5IHx8IDAsIHcgfHwgMCwgaCB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZy4gSWYgeW91IG5lZWQgbGluZSBicmVha3MsIHB1dCDigJxcXG7igJ0gaW4gdGhlIHN0cmluZy5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxuICAgICAtIHRleHQgKHN0cmluZykgVGhlIHRleHQgc3RyaW5nIHRvIGRyYXdcbiAgICAgPSAob2JqZWN0KSBSYXBoYcOrbCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUg4oCcdGV4dOKAnVxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHQgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJSYXBoYcOrbFxcbmtpY2tzXFxuYnV0dCFcIik7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBvdXQgPSBSLl9lbmdpbmUudGV4dCh0aGlzLCB4IHx8IDAsIHkgfHwgMCwgU3RyKHRleHQpKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc2V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGtlZXAgYW5kIG9wZXJhdGUgc2V2ZXJhbCBlbGVtZW50cyBhdCBvbmNlLlxuICAgICAqIFdhcm5pbmc6IGl0IGRvZXNu4oCZdCBjcmVhdGUgYW55IGVsZW1lbnRzIGZvciBpdHNlbGYgaW4gdGhlIHBhZ2UsIGl0IGp1c3QgZ3JvdXBzIGV4aXN0aW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgYWN0IGFzIHBzZXVkbyBlbGVtZW50cyDigJQgYWxsIG1ldGhvZHMgYXZhaWxhYmxlIHRvIGFuIGVsZW1lbnQgY2FuIGJlIHVzZWQgb24gYSBzZXQuXG4gICAgID0gKG9iamVjdCkgYXJyYXktbGlrZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHNldCBvZiBlbGVtZW50c1xuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHN0ID0gcGFwZXIuc2V0KCk7XG4gICAgIHwgc3QucHVzaChcbiAgICAgfCAgICAgcGFwZXIuY2lyY2xlKDEwLCAxMCwgNSksXG4gICAgIHwgICAgIHBhcGVyLmNpcmNsZSgzMCwgMTAsIDUpXG4gICAgIHwgKTtcbiAgICAgfCBzdC5hdHRyKHtmaWxsOiBcInJlZFwifSk7IC8vIGNoYW5nZXMgdGhlIGZpbGwgb2YgYm90aCBjaXJjbGVzXG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uc2V0ID0gZnVuY3Rpb24gKGl0ZW1zQXJyYXkpIHtcbiAgICAgICAgIVIuaXMoaXRlbXNBcnJheSwgXCJhcnJheVwiKSAmJiAoaXRlbXNBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGgpKTtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBTZXQoaXRlbXNBcnJheSk7XG4gICAgICAgIHRoaXMuX19zZXRfXyAmJiB0aGlzLl9fc2V0X18ucHVzaChvdXQpO1xuICAgICAgICBvdXRbXCJwYXBlclwiXSA9IHRoaXM7XG4gICAgICAgIG91dFtcInR5cGVcIl0gPSBcInNldFwiO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnNldFN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIEBQYXBlci5zZXQuIEFsbCBlbGVtZW50cyB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIGFuZCBiZWZvcmUgY2FsbGluZ1xuICAgICAqIEBQYXBlci5zZXRGaW5pc2ggd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0LlxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgcGFwZXIuc2V0U3RhcnQoKTtcbiAgICAgfCBwYXBlci5jaXJjbGUoMTAsIDEwLCA1KSxcbiAgICAgfCBwYXBlci5jaXJjbGUoMzAsIDEwLCA1KVxuICAgICB8IHZhciBzdCA9IHBhcGVyLnNldEZpbmlzaCgpO1xuICAgICB8IHN0LmF0dHIoe2ZpbGw6IFwicmVkXCJ9KTsgLy8gY2hhbmdlcyB0aGUgZmlsbCBvZiBib3RoIGNpcmNsZXNcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5zZXRTdGFydCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdGhpcy5fX3NldF9fID0gc2V0IHx8IHRoaXMuc2V0KCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc2V0RmluaXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQFBhcGVyLnNldFN0YXJ0LiBUaGlzIG1ldGhvZCBmaW5pc2hlcyBjYXRjaGluZyBhbmQgcmV0dXJucyByZXN1bHRpbmcgc2V0LlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHNldFxuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnNldEZpbmlzaCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX19zZXRfXztcbiAgICAgICAgZGVsZXRlIHRoaXMuX19zZXRfXztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nZXRTaXplXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBPYnRhaW5zIGN1cnJlbnQgcGFwZXIgYWN0dWFsIHNpemUuXG4gICAgICoqXG4gICAgID0gKG9iamVjdClcbiAgICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY2FudmFzLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb250YWluZXIub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc2V0U2l6ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSWYgeW91IG5lZWQgdG8gY2hhbmdlIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcyBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHdpZHRoIChudW1iZXIpIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gUi5fZW5naW5lLnNldFNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zZXRWaWV3Qm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZXRzIHRoZSB2aWV3IGJveCBvZiB0aGUgcGFwZXIuIFByYWN0aWNhbGx5IGl0IGdpdmVzIHlvdSBhYmlsaXR5IHRvIHpvb20gYW5kIHBhbiB3aG9sZSBwYXBlciBzdXJmYWNlIGJ5XG4gICAgICogc3BlY2lmeWluZyBuZXcgYm91bmRhcmllcy5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSBuZXcgeCBwb3NpdGlvbiwgZGVmYXVsdCBpcyBgMGBcbiAgICAgLSB5IChudW1iZXIpIG5ldyB5IHBvc2l0aW9uLCBkZWZhdWx0IGlzIGAwYFxuICAgICAtIHcgKG51bWJlcikgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICAgLSBoIChudW1iZXIpIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAtIGZpdCAoYm9vbGVhbikgYHRydWVgIGlmIHlvdSB3YW50IGdyYXBoaWNzIHRvIGZpdCBpbnRvIG5ldyBib3VuZGFyeSBib3hcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5zZXRWaWV3Qm94ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIGZpdCkge1xuICAgICAgICByZXR1cm4gUi5fZW5naW5lLnNldFZpZXdCb3guY2FsbCh0aGlzLCB4LCB5LCB3LCBoLCBmaXQpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnRvcFxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBQb2ludHMgdG8gdGhlIHRvcG1vc3QgZWxlbWVudCBvbiB0aGUgcGFwZXJcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmJvdHRvbVxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBQb2ludHMgdG8gdGhlIGJvdHRvbSBlbGVtZW50IG9uIHRoZSBwYXBlclxuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnRvcCA9IHBhcGVycHJvdG8uYm90dG9tID0gbnVsbDtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmFwaGFlbFxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBQb2ludHMgdG8gdGhlIEBSYXBoYWVsIG9iamVjdC9mdW5jdGlvblxuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnJhcGhhZWwgPSBSO1xuICAgIHZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCwgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgICAgIHRvcCAgPSBib3gudG9wICArIChnLndpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCApIC0gY2xpZW50VG9wLFxuICAgICAgICAgICAgbGVmdCA9IGJveC5sZWZ0ICsgKGcud2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gY2xpZW50TGVmdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHk6IHRvcCxcbiAgICAgICAgICAgIHg6IGxlZnRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nZXRFbGVtZW50QnlQb2ludFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB5b3UgdG9wbW9zdCBlbGVtZW50IHVuZGVyIGdpdmVuIHBvaW50LlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIFJhcGhhw6tsIGVsZW1lbnQgb2JqZWN0XG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiAgICAgPiBVc2FnZVxuICAgICB8IHBhcGVyLmdldEVsZW1lbnRCeVBvaW50KG1vdXNlWCwgbW91c2VZKS5hdHRyKHtzdHJva2U6IFwiI2YwMFwifSk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZ2V0RWxlbWVudEJ5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLFxuICAgICAgICAgICAgc3ZnID0gcGFwZXIuY2FudmFzLFxuICAgICAgICAgICAgdGFyZ2V0ID0gZy5kb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGcud2luLm9wZXJhICYmIHRhcmdldC50YWdOYW1lID09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgIHZhciBzbyA9IGdldE9mZnNldChzdmcpLFxuICAgICAgICAgICAgICAgIHNyID0gc3ZnLmNyZWF0ZVNWR1JlY3QoKTtcbiAgICAgICAgICAgIHNyLnggPSB4IC0gc28ueDtcbiAgICAgICAgICAgIHNyLnkgPSB5IC0gc28ueTtcbiAgICAgICAgICAgIHNyLndpZHRoID0gc3IuaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIHZhciBoaXRzID0gc3ZnLmdldEludGVyc2VjdGlvbkxpc3Qoc3IsIG51bGwpO1xuICAgICAgICAgICAgaWYgKGhpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gaGl0c1toaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGFyZ2V0LnBhcmVudE5vZGUgJiYgdGFyZ2V0ICE9IHN2Zy5wYXJlbnROb2RlICYmICF0YXJnZXQucmFwaGFlbCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID09IHBhcGVyLmNhbnZhcy5wYXJlbnROb2RlICYmICh0YXJnZXQgPSBzdmcpO1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgJiYgdGFyZ2V0LnJhcGhhZWwgPyBwYXBlci5nZXRCeUlkKHRhcmdldC5yYXBoYWVsaWQpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdldEVsZW1lbnRzQnlCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHNldCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYW4gaW50ZXJzZWN0aW5nIGJvdW5kaW5nIGJveFxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBiYm94IChvYmplY3QpIGJib3ggdG8gY2hlY2sgd2l0aFxuICAgICA9IChvYmplY3QpIEBTZXRcbiAgICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZ2V0RWxlbWVudHNCeUJCb3ggPSBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICB2YXIgc2V0ID0gdGhpcy5zZXQoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKFIuaXNCQm94SW50ZXJzZWN0KGVsLmdldEJCb3goKSwgYmJveCkpIHtcbiAgICAgICAgICAgICAgICBzZXQucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogUGFwZXIuZ2V0QnlJZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB5b3UgZWxlbWVudCBieSBpdHMgaW50ZXJuYWwgSUQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGlkIChudW1iZXIpIGlkXG4gICAgID0gKG9iamVjdCkgUmFwaGHDq2wgZWxlbWVudCBvYmplY3RcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBib3QgPSB0aGlzLmJvdHRvbTtcbiAgICAgICAgd2hpbGUgKGJvdCkge1xuICAgICAgICAgICAgaWYgKGJvdC5pZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3QgPSBib3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5mb3JFYWNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IG9uIHRoZSBwYXBlclxuICAgICAqXG4gICAgICogSWYgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIGl0IHdpbGwgc3RvcCBsb29wIHJ1bm5pbmcuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgIC0gdGhpc0FyZyAob2JqZWN0KSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrXG4gICAgID0gKG9iamVjdCkgUGFwZXIgb2JqZWN0XG4gICAgID4gVXNhZ2VcbiAgICAgfCBwYXBlci5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICB8ICAgICBlbC5hdHRyKHsgc3Ryb2tlOiBcImJsdWVcIiB9KTtcbiAgICAgfCB9KTtcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBib3QgPSB0aGlzLmJvdHRvbTtcbiAgICAgICAgd2hpbGUgKGJvdCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgYm90KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdCA9IGJvdC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdldEVsZW1lbnRzQnlQb2ludFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzZXQgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGNvbW1vbiBwb2ludCBpbnNpZGVcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKG9iamVjdCkgQFNldFxuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmdldEVsZW1lbnRzQnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBzZXQgPSB0aGlzLnNldCgpO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwuaXNQb2ludEluc2lkZSh4LCB5KSkge1xuICAgICAgICAgICAgICAgIHNldC5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB4X3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyBTICsgdGhpcy55O1xuICAgIH1cbiAgICBmdW5jdGlvbiB4X3lfd19oKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueSArIFMgKyB0aGlzLndpZHRoICsgXCIgXFx4ZDcgXCIgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaXNQb2ludEluc2lkZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGlzIGVsZW1lbnTigJlzIHNoYXBlXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgcG9pbnQgaW5zaWRlIHRoZSBzaGFwZVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmlzUG9pbnRJbnNpZGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcnAgPSB0aGlzLnJlYWxQYXRoID0gZ2V0UGF0aFt0aGlzLnR5cGVdKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSAmJiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScpLmxlbmd0aCkge1xuICAgICAgICAgICAgcnAgPSBSLnRyYW5zZm9ybVBhdGgocnAsIHRoaXMuYXR0cigndHJhbnNmb3JtJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSLmlzUG9pbnRJbnNpZGVQYXRoKHJwLCB4LCB5KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybiBib3VuZGluZyBib3ggZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBpc1dpdGhvdXRUcmFuc2Zvcm0gKGJvb2xlYW4pIGZsYWcsIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBoYXZlIGJvdW5kaW5nIGJveCBiZWZvcmUgdHJhbnNmb3JtYXRpb25zLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgID0gKG9iamVjdCkgQm91bmRpbmcgYm94IG9iamVjdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHRvcCBsZWZ0IGNvcm5lciB4XG4gICAgIG8gICAgIHk6IChudW1iZXIpIHRvcCBsZWZ0IGNvcm5lciB5XG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSBib3R0b20gcmlnaHQgY29ybmVyIHhcbiAgICAgbyAgICAgeTI6IChudW1iZXIpIGJvdHRvbSByaWdodCBjb3JuZXIgeVxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGhcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHRcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0QkJveCA9IGZ1bmN0aW9uIChpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAoXy5kaXJ0eSB8fCAhXy5iYm94d3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWxQYXRoID0gZ2V0UGF0aFt0aGlzLnR5cGVdKHRoaXMpO1xuICAgICAgICAgICAgICAgIF8uYmJveHd0ID0gcGF0aERpbWVuc2lvbnModGhpcy5yZWFsUGF0aCk7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QudG9TdHJpbmcgPSB4X3lfd19oO1xuICAgICAgICAgICAgICAgIF8uZGlydHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF8uYmJveHd0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLmRpcnR5IHx8IF8uZGlydHlUIHx8ICFfLmJib3gpIHtcbiAgICAgICAgICAgIGlmIChfLmRpcnR5IHx8ICF0aGlzLnJlYWxQYXRoKSB7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbFBhdGggPSBnZXRQYXRoW3RoaXMudHlwZV0odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmJib3ggPSBwYXRoRGltZW5zaW9ucyhtYXBQYXRoKHRoaXMucmVhbFBhdGgsIHRoaXMubWF0cml4KSk7XG4gICAgICAgICAgICBfLmJib3gudG9TdHJpbmcgPSB4X3lfd19oO1xuICAgICAgICAgICAgXy5kaXJ0eSA9IF8uZGlydHlUID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy5iYm94O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xvbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICA9IChvYmplY3QpIGNsb25lIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBlbHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5wYXBlclt0aGlzLnR5cGVdKCkuYXR0cih0aGlzLmF0dHIoKSk7XG4gICAgICAgIHRoaXMuX19zZXRfXyAmJiB0aGlzLl9fc2V0X18ucHVzaChvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2xvd1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJuIHNldCBvZiBlbGVtZW50cyB0aGF0IGNyZWF0ZSBnbG93LWxpa2UgZWZmZWN0IGFyb3VuZCBnaXZlbiBlbGVtZW50LiBTZWUgQFBhcGVyLnNldC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEdsb3cgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgZWxlbWVudC4gSWYgeW91IGNoYW5nZSBlbGVtZW50IGF0dHJpYnV0ZXMgaXQgd29u4oCZdCBhZGp1c3QgaXRzZWxmLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBnbG93IChvYmplY3QpICNvcHRpb25hbCBwYXJhbWV0ZXJzIG9iamVjdCB3aXRoIGFsbCBwcm9wZXJ0aWVzIG9wdGlvbmFsOlxuICAgICBvIHtcbiAgICAgbyAgICAgd2lkdGggKG51bWJlcikgc2l6ZSBvZiB0aGUgZ2xvdywgZGVmYXVsdCBpcyBgMTBgXG4gICAgIG8gICAgIGZpbGwgKGJvb2xlYW4pIHdpbGwgaXQgYmUgZmlsbGVkLCBkZWZhdWx0IGlzIGBmYWxzZWBcbiAgICAgbyAgICAgb3BhY2l0eSAobnVtYmVyKSBvcGFjaXR5LCBkZWZhdWx0IGlzIGAwLjVgXG4gICAgIG8gICAgIG9mZnNldHggKG51bWJlcikgaG9yaXpvbnRhbCBvZmZzZXQsIGRlZmF1bHQgaXMgYDBgXG4gICAgIG8gICAgIG9mZnNldHkgKG51bWJlcikgdmVydGljYWwgb2Zmc2V0LCBkZWZhdWx0IGlzIGAwYFxuICAgICBvICAgICBjb2xvciAoc3RyaW5nKSBnbG93IGNvbG91ciwgZGVmYXVsdCBpcyBgYmxhY2tgXG4gICAgIG8gfVxuICAgICA9IChvYmplY3QpIEBQYXBlci5zZXQgb2YgZWxlbWVudHMgdGhhdCByZXByZXNlbnRzIGdsb3dcbiAgICBcXCovXG4gICAgZWxwcm90by5nbG93ID0gZnVuY3Rpb24gKGdsb3cpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvdyA9IGdsb3cgfHwge307XG4gICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgd2lkdGg6IChnbG93LndpZHRoIHx8IDEwKSArICgrdGhpcy5hdHRyKFwic3Ryb2tlLXdpZHRoXCIpIHx8IDEpLFxuICAgICAgICAgICAgZmlsbDogZ2xvdy5maWxsIHx8IGZhbHNlLFxuICAgICAgICAgICAgb3BhY2l0eTogZ2xvdy5vcGFjaXR5ID09IG51bGwgPyAuNSA6IGdsb3cub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldHg6IGdsb3cub2Zmc2V0eCB8fCAwLFxuICAgICAgICAgICAgb2Zmc2V0eTogZ2xvdy5vZmZzZXR5IHx8IDAsXG4gICAgICAgICAgICBjb2xvcjogZ2xvdy5jb2xvciB8fCBcIiMwMDBcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgYyA9IHMud2lkdGggLyAyLFxuICAgICAgICAgICAgciA9IHRoaXMucGFwZXIsXG4gICAgICAgICAgICBvdXQgPSByLnNldCgpLFxuICAgICAgICAgICAgcGF0aCA9IHRoaXMucmVhbFBhdGggfHwgZ2V0UGF0aFt0aGlzLnR5cGVdKHRoaXMpO1xuICAgICAgICBwYXRoID0gdGhpcy5tYXRyaXggPyBtYXBQYXRoKHBhdGgsIHRoaXMubWF0cml4KSA6IHBhdGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYyArIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2goci5wYXRoKHBhdGgpLmF0dHIoe1xuICAgICAgICAgICAgICAgIHN0cm9rZTogcy5jb2xvcixcbiAgICAgICAgICAgICAgICBmaWxsOiBzLmZpbGwgPyBzLmNvbG9yIDogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6ICsocy53aWR0aCAvIGMgKiBpKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICsocy5vcGFjaXR5IC8gYykudG9GaXhlZCgzKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuaW5zZXJ0QmVmb3JlKHRoaXMpLnRyYW5zbGF0ZShzLm9mZnNldHgsIHMub2Zmc2V0eSk7XG4gICAgfTtcbiAgICB2YXIgY3VydmVzbGVuZ3RocyA9IHt9LFxuICAgIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSLmZpbmREb3RzQXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBnZXRUYXRMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRMZW5ndGhGYWN0b3J5ID0gZnVuY3Rpb24gKGlzdG90YWwsIHN1YnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCBsZW5ndGgsIG9ubHlzdGFydCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcIkNcIiArIHBvaW50LnN0YXJ0LngsIHBvaW50LnN0YXJ0LnksIHBvaW50Lm0ueCwgcG9pbnQubS55LCBwb2ludC54LCBwb2ludC55XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seXN0YXJ0KSB7cmV0dXJuIHNwO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwYXRocy5zdGFydCA9IHNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwID0gW1wiTVwiICsgcG9pbnQueCwgcG9pbnQueSArIFwiQ1wiICsgcG9pbnQubi54LCBwb2ludC5uLnksIHBvaW50LmVuZC54LCBwb2ludC5lbmQueSwgcFs1XSwgcFs2XV0uam9pbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gK3BbNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzdG90YWwgJiYgIXN1YnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0sIGxlbmd0aCAtIGxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt4OiBwb2ludC54LCB5OiBwb2ludC55LCBhbHBoYTogcG9pbnQuYWxwaGF9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBsO1xuICAgICAgICAgICAgICAgICAgICB4ID0gK3BbNV07XG4gICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3AgKz0gcC5zaGlmdCgpICsgcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnBhdGhzLmVuZCA9IHNwO1xuICAgICAgICAgICAgcG9pbnQgPSBpc3RvdGFsID8gbGVuIDogc3VicGF0aCA/IHN1YnBhdGhzIDogUi5maW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHBvaW50LmFscGhhICYmIChwb2ludCA9IHt4OiBwb2ludC54LCB5OiBwb2ludC55LCBhbHBoYTogcG9pbnQuYWxwaGF9KTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBnZXRUb3RhbExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMSksXG4gICAgICAgIGdldFBvaW50QXRMZW5ndGggPSBnZXRMZW5ndGhGYWN0b3J5KCksXG4gICAgICAgIGdldFN1YnBhdGhzQXRMZW5ndGggPSBnZXRMZW5ndGhGYWN0b3J5KDAsIDEpO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gcGF0aCBpbiBwaXhlbHMuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nLlxuICAgICAqKlxuICAgICA9IChudW1iZXIpIGxlbmd0aC5cbiAgICBcXCovXG4gICAgUi5nZXRUb3RhbExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybiBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIG9uIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZ1xuICAgICAtIGxlbmd0aCAobnVtYmVyKVxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZVxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGVcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuZ2V0UG9pbnRBdExlbmd0aCA9IGdldFBvaW50QXRMZW5ndGg7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJuIHN1YnBhdGggb2YgYSBnaXZlbiBwYXRoIGZyb20gZ2l2ZW4gbGVuZ3RoIHRvIGdpdmVuIGxlbmd0aC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBmcm9tIChudW1iZXIpIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHNlZ21lbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBwYXRoc3RyaW5nIGZvciB0aGUgc2VnbWVudFxuICAgIFxcKi9cbiAgICBSLmdldFN1YnBhdGggPSBmdW5jdGlvbiAocGF0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG90YWxMZW5ndGgocGF0aCkgLSB0byA8IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIGZyb20pLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGdldFN1YnBhdGhzQXRMZW5ndGgocGF0aCwgdG8sIDEpO1xuICAgICAgICByZXR1cm4gZnJvbSA/IGdldFN1YnBhdGhzQXRMZW5ndGgoYSwgZnJvbSkuZW5kIDogYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGxlbmd0aCBvZiB0aGUgcGF0aCBpbiBwaXhlbHMuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnQgb2Yg4oCccGF0aOKAnSB0eXBlLlxuICAgICA9IChudW1iZXIpIGxlbmd0aC5cbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRUb3RhbExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0VG90YWxMZW5ndGgocGF0aCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm4gY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBvbiB0aGUgZ2l2ZW4gcGF0aC4gT25seSB3b3JrcyBmb3IgZWxlbWVudCBvZiDigJxwYXRo4oCdIHR5cGUuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGxlbmd0aCAobnVtYmVyKVxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZVxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGVcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0UG9pbnRBdExlbmd0aChwYXRoLCBsZW5ndGgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBwYXRoIG9mIHRoZSBlbGVtZW50LiBPbmx5IHdvcmtzIGZvciBlbGVtZW50cyBvZiDigJxwYXRo4oCdIHR5cGUgYW5kIHNpbXBsZSBlbGVtZW50cyBsaWtlIGNpcmNsZS5cbiAgICAgPSAob2JqZWN0KSBwYXRoXG4gICAgICoqXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGgsXG4gICAgICAgICAgICBnZXRQYXRoID0gUi5fZ2V0UGF0aFt0aGlzLnR5cGVdO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZXRQYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZ2V0UGF0aCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJuIHN1YnBhdGggb2YgYSBnaXZlbiBlbGVtZW50IGZyb20gZ2l2ZW4gbGVuZ3RoIHRvIGdpdmVuIGxlbmd0aC4gT25seSB3b3JrcyBmb3IgZWxlbWVudCBvZiDigJxwYXRo4oCdIHR5cGUuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcikgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgIC0gdG8gKG51bWJlcikgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIHBhdGhzdHJpbmcgZm9yIHRoZSBzZWdtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0U3VicGF0aCA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSLmdldFN1YnBhdGgocGF0aCwgZnJvbSwgdG8pO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZWFzaW5nX2Zvcm11bGFzXG4gICAgIFsgcHJvcGVydHkgXVxuICAgICAqKlxuICAgICAqIE9iamVjdCB0aGF0IGNvbnRhaW5zIGVhc2luZyBmb3JtdWxhcyBmb3IgYW5pbWF0aW9uLiBZb3UgY291bGQgZXh0ZW5kIGl0IHdpdGggeW91ciBvd24uIEJ5IGRlZmF1bHQgaXQgaGFzIGZvbGxvd2luZyBsaXN0IG9mIGVhc2luZzpcbiAgICAgIyA8dWw+XG4gICAgICMgICAgIDxsaT7igJxsaW5lYXLigJ08L2xpPlxuICAgICAjICAgICA8bGk+4oCcJmx0O+KAnSBvciDigJxlYXNlSW7igJ0gb3Ig4oCcZWFzZS1pbuKAnTwvbGk+XG4gICAgICMgICAgIDxsaT7igJw+4oCdIG9yIOKAnGVhc2VPdXTigJ0gb3Ig4oCcZWFzZS1vdXTigJ08L2xpPlxuICAgICAjICAgICA8bGk+4oCcJmx0Oz7igJ0gb3Ig4oCcZWFzZUluT3V04oCdIG9yIOKAnGVhc2UtaW4tb3V04oCdPC9saT5cbiAgICAgIyAgICAgPGxpPuKAnGJhY2tJbuKAnSBvciDigJxiYWNrLWlu4oCdPC9saT5cbiAgICAgIyAgICAgPGxpPuKAnGJhY2tPdXTigJ0gb3Ig4oCcYmFjay1vdXTigJ08L2xpPlxuICAgICAjICAgICA8bGk+4oCcZWxhc3RpY+KAnTwvbGk+XG4gICAgICMgICAgIDxsaT7igJxib3VuY2XigJ08L2xpPlxuICAgICAjIDwvdWw+XG4gICAgICMgPHA+U2VlIGFsc28gPGEgaHJlZj1cImh0dHA6Ly9yYXBoYWVsanMuY29tL2Vhc2luZy5odG1sXCI+RWFzaW5nIGRlbW88L2E+LjwvcD5cbiAgICBcXCovXG4gICAgdmFyIGVmID0gUi5lYXNpbmdfZm9ybXVsYXMgPSB7XG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuICAgICAgICBcIjxcIjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwb3cobiwgMS43KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCI+XCI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcG93KG4sIC40OCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiPD5cIjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBxID0gLjQ4IC0gbiAvIDEuMDQsXG4gICAgICAgICAgICAgICAgUSA9IG1hdGguc3FydCguMTczNCArIHEgKiBxKSxcbiAgICAgICAgICAgICAgICB4ID0gUSAtIHEsXG4gICAgICAgICAgICAgICAgWCA9IHBvdyhhYnMoeCksIDEgLyAzKSAqICh4IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICAgICAgeSA9IC1RIC0gcSxcbiAgICAgICAgICAgICAgICBZID0gcG93KGFicyh5KSwgMSAvIDMpICogKHkgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgICB0ID0gWCArIFkgKyAuNTtcbiAgICAgICAgICAgIHJldHVybiAoMSAtIHQpICogMyAqIHQgKiB0ICsgdCAqIHQgKiB0O1xuICAgICAgICB9LFxuICAgICAgICBiYWNrSW46IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gbiAqIG4gKiAoKHMgKyAxKSAqIG4gLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmFja091dDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIG4gPSBuIC0gMTtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgZWxhc3RpYzogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIGlmIChuID09ICEhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvdygyLCAtMTAgKiBuKSAqIG1hdGguc2luKChuIC0gLjA3NSkgKiAoMiAqIFBJKSAvIC4zKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGJvdW5jZTogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBzID0gNy41NjI1LFxuICAgICAgICAgICAgICAgIHAgPSAyLjc1LFxuICAgICAgICAgICAgICAgIGw7XG4gICAgICAgICAgICBpZiAobiA8ICgxIC8gcCkpIHtcbiAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8ICgyIC8gcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAoMS41IC8gcCk7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBzICogbiAqIG4gKyAuNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPCAoMi41IC8gcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gLT0gKDIuMjUgLyBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBzICogbiAqIG4gKyAuOTM3NTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gLT0gKDIuNjI1IC8gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjk4NDM3NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBlZi5lYXNlSW4gPSBlZltcImVhc2UtaW5cIl0gPSBlZltcIjxcIl07XG4gICAgZWYuZWFzZU91dCA9IGVmW1wiZWFzZS1vdXRcIl0gPSBlZltcIj5cIl07XG4gICAgZWYuZWFzZUluT3V0ID0gZWZbXCJlYXNlLWluLW91dFwiXSA9IGVmW1wiPD5cIl07XG4gICAgZWZbXCJiYWNrLWluXCJdID0gZWYuYmFja0luO1xuICAgIGVmW1wiYmFjay1vdXRcIl0gPSBlZi5iYWNrT3V0O1xuXG4gICAgdmFyIGFuaW1hdGlvbkVsZW1lbnRzID0gW10sXG4gICAgICAgIHJlcXVlc3RBbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgTm93ID0gK25ldyBEYXRlLFxuICAgICAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGwgPCBhbmltYXRpb25FbGVtZW50cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gYW5pbWF0aW9uRWxlbWVudHNbbF07XG4gICAgICAgICAgICAgICAgaWYgKGUuZWwucmVtb3ZlZCB8fCBlLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBOb3cgLSBlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBtcyA9IGUubXMsXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZyA9IGUuZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gZS5kaWZmLFxuICAgICAgICAgICAgICAgICAgICB0byA9IGUudG8sXG4gICAgICAgICAgICAgICAgICAgIHQgPSBlLnQsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQgPSBlLmVsLFxuICAgICAgICAgICAgICAgICAgICBzZXQgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgbm93LFxuICAgICAgICAgICAgICAgICAgICBpbml0ID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGtleTtcbiAgICAgICAgICAgICAgICBpZiAoZS5pbml0c3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWUgPSAoZS5pbml0c3RhdHVzICogZS5hbmltLnRvcCAtIGUucHJldikgLyAoZS5wZXJjZW50IC0gZS5wcmV2KSAqIG1zO1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXR1cyA9IGUuaW5pdHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUuaW5pdHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wICYmIGFuaW1hdGlvbkVsZW1lbnRzLnNwbGljZShsLS0sIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RhdHVzID0gKGUucHJldiArIChlLnBlcmNlbnQgLSBlLnByZXYpICogKHRpbWUgLyBtcykpIC8gZS5hbmltLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IG1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBlYXNpbmcodGltZSAvIG1zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBmcm9tKSBpZiAoZnJvbVtoYXNdKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGF2YWlsYWJsZUFuaW1BdHRyc1thdHRyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbnU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9ICtmcm9tW2F0dHJdICsgcG9zICogbXMgKiBkaWZmW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29sb3VyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IFwicmdiKFwiICsgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0bzI1NShyb3VuZChmcm9tW2F0dHJdLnIgKyBwb3MgKiBtcyAqIGRpZmZbYXR0cl0ucikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0bzI1NShyb3VuZChmcm9tW2F0dHJdLmcgKyBwb3MgKiBtcyAqIGRpZmZbYXR0cl0uZykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0bzI1NShyb3VuZChmcm9tW2F0dHJdLmIgKyBwb3MgKiBtcyAqIGRpZmZbYXR0cl0uYikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZyb21bYXR0cl0ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93W2ldID0gW2Zyb21bYXR0cl1baV1bMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gZnJvbVthdHRyXVtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93W2ldW2pdID0gK2Zyb21bYXR0cl1baV1bal0gKyBwb3MgKiBtcyAqIGRpZmZbYXR0cl1baV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dbaV0gPSBub3dbaV0uam9pbihTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBub3cuam9pbihTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZlthdHRyXS5yZWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gZnJvbVthdHRyXS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93W2ldID0gW2Zyb21bYXR0cl1baV1bMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gZnJvbVthdHRyXVtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXVtqXSA9IGZyb21bYXR0cl1baV1bal0gKyBwb3MgKiBtcyAqIGRpZmZbYXR0cl1baV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtmcm9tW2F0dHJdW2ldICsgcG9zICogbXMgKiBkaWZmW2F0dHJdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyA9IFtbXCJyXCIsIGdldCgyKSwgMCwgMF0sIFtcInRcIiwgZ2V0KDMpLCBnZXQoNCldLCBbXCJzXCIsIGdldCgwKSwgZ2V0KDEpLCAwLCAwXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBbW1wibVwiLCBnZXQoMCksIGdldCgxKSwgZ2V0KDIpLCBnZXQoMyksIGdldCg0KSwgZ2V0KDUpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNzdlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PSBcImNsaXAtcmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXSA9ICtmcm9tW2F0dHJdW2ldICsgcG9zICogbXMgKiBkaWZmW2F0dHJdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tMiA9IFtdW2NvbmNhdF0oZnJvbVthdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhhdC5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2F0dHJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93W2ldID0gK2Zyb20yW2ldICsgcG9zICogbXMgKiBkaWZmW2F0dHJdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0W2F0dHJdID0gbm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXR0cihzZXQpO1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGlkLCB0aGF0LCBhbmltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmUoXCJyYXBoYWVsLmFuaW0uZnJhbWUuXCIgKyBpZCwgdGhhdCwgYW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkodGhhdC5pZCwgdGhhdCwgZS5hbmltKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oZiwgZWwsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiICsgZWwuaWQsIGVsLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmUoXCJyYXBoYWVsLmFuaW0uZmluaXNoLlwiICsgZWwuaWQsIGVsLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLmlzKGYsIFwiZnVuY3Rpb25cIikgJiYgZi5jYWxsKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KShlLmNhbGxiYWNrLCB0aGF0LCBlLmFuaW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmF0dHIodG8pO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25FbGVtZW50cy5zcGxpY2UobC0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucmVwZWF0ID4gMSAmJiAhZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB0bykgaWYgKHRvW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRba2V5XSA9IGUudG90YWxPcmlnaW5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZWwuYXR0cihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkFuaW1hdGlvbihlLmFuaW0sIGUuZWwsIGUuYW5pbS5wZXJjZW50c1swXSwgbnVsbCwgZS50b3RhbE9yaWdpbiwgZS5yZXBlYXQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uZXh0ICYmICFlLnN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkFuaW1hdGlvbihlLmFuaW0sIGUuZWwsIGUubmV4dCwgbnVsbCwgZS50b3RhbE9yaWdpbiwgZS5yZXBlYXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoICYmIHJlcXVlc3RBbmltRnJhbWUoYW5pbWF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXB0bzI1NSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yID4gMjU1ID8gMjU1IDogY29sb3IgPCAwID8gMCA6IGNvbG9yO1xuICAgICAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFuaW1hdGVXaXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBY3RzIHNpbWlsYXIgdG8gQEVsZW1lbnQuYW5pbWF0ZSwgYnV0IGVuc3VyZSB0aGF0IGdpdmVuIGFuaW1hdGlvbiBydW5zIGluIHN5bmMgd2l0aCBhbm90aGVyIGdpdmVuIGVsZW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGVsIChvYmplY3QpIGVsZW1lbnQgdG8gc3luYyB3aXRoXG4gICAgIC0gYW5pbSAob2JqZWN0KSBhbmltYXRpb24gdG8gc3luYyB3aXRoXG4gICAgIC0gcGFyYW1zIChvYmplY3QpICNvcHRpb25hbCBmaW5hbCBhdHRyaWJ1dGVzIGZvciB0aGUgZWxlbWVudCwgc2VlIGFsc28gQEVsZW1lbnQuYXR0clxuICAgICAtIG1zIChudW1iZXIpICNvcHRpb25hbCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZvciBhbmltYXRpb24gdG8gcnVuXG4gICAgIC0gZWFzaW5nIChzdHJpbmcpICNvcHRpb25hbCBlYXNpbmcgdHlwZS4gQWNjZXB0IG9uIG9mIEBSYXBoYWVsLmVhc2luZ19mb3JtdWxhcyBvciBDU1MgZm9ybWF0OiBgY3ViaWMmI3gyMDEwO2JlemllcihYWCwmIzE2MDtYWCwmIzE2MDtYWCwmIzE2MDtYWClgXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uIFdpbGwgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uLlxuICAgICAqIG9yXG4gICAgIC0gZWxlbWVudCAob2JqZWN0KSBlbGVtZW50IHRvIHN5bmMgd2l0aFxuICAgICAtIGFuaW0gKG9iamVjdCkgYW5pbWF0aW9uIHRvIHN5bmMgd2l0aFxuICAgICAtIGFuaW1hdGlvbiAob2JqZWN0KSAjb3B0aW9uYWwgYW5pbWF0aW9uIG9iamVjdCwgc2VlIEBSYXBoYWVsLmFuaW1hdGlvblxuICAgICAqKlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hbmltYXRlV2l0aCA9IGZ1bmN0aW9uIChlbCwgYW5pbSwgcGFyYW1zLCBtcywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtZW50LnJlbW92ZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHBhcmFtcyBpbnN0YW5jZW9mIEFuaW1hdGlvbiA/IHBhcmFtcyA6IFIuYW5pbWF0aW9uKHBhcmFtcywgbXMsIGVhc2luZywgY2FsbGJhY2spLFxuICAgICAgICAgICAgeCwgeTtcbiAgICAgICAgcnVuQW5pbWF0aW9uKGEsIGVsZW1lbnQsIGEucGVyY2VudHNbMF0sIG51bGwsIGVsZW1lbnQuYXR0cigpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkVsZW1lbnRzW2ldLmFuaW0gPT0gYW5pbSAmJiBhbmltYXRpb25FbGVtZW50c1tpXS5lbCA9PSBlbCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzW2lpIC0gMV0uc3RhcnQgPSBhbmltYXRpb25FbGVtZW50c1tpXS5zdGFydDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgLy9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdmFyIGEgPSBwYXJhbXMgPyBSLmFuaW1hdGlvbihwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSA6IGFuaW0sXG4gICAgICAgIC8vICAgICBzdGF0dXMgPSBlbGVtZW50LnN0YXR1cyhhbmltKTtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMuYW5pbWF0ZShhKS5zdGF0dXMoYSwgc3RhdHVzICogYW5pbS5tcyAvIGEubXMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQ3ViaWNCZXppZXJBdFRpbWUodCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgY3ggPSAzICogcDF4LFxuICAgICAgICAgICAgYnggPSAzICogKHAyeCAtIHAxeCkgLSBjeCxcbiAgICAgICAgICAgIGF4ID0gMSAtIGN4IC0gYngsXG4gICAgICAgICAgICBjeSA9IDMgKiBwMXksXG4gICAgICAgICAgICBieSA9IDMgKiAocDJ5IC0gcDF5KSAtIGN5LFxuICAgICAgICAgICAgYXkgPSAxIC0gY3kgLSBieTtcbiAgICAgICAgZnVuY3Rpb24gc2FtcGxlQ3VydmVYKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvbHZlKHgsIGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciB0ID0gc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbik7XG4gICAgICAgICAgICByZXR1cm4gKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSB7XG4gICAgICAgICAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGQyLCBpO1xuICAgICAgICAgICAgZm9yKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB4MiA9IHNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICAgICAgICAgIGlmIChhYnMoeDIpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQyID0gKDMgKiBheCAqIHQyICsgMiAqIGJ4KSAqIHQyICsgY3g7XG4gICAgICAgICAgICAgICAgaWYgKGFicyhkMikgPCAxZS02KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0MiA9IHQyIC0geDIgLyBkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQwID0gMDtcbiAgICAgICAgICAgIHQxID0gMTtcbiAgICAgICAgICAgIHQyID0geDtcbiAgICAgICAgICAgIGlmICh0MiA8IHQwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQyID4gdDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodDAgPCB0MSkge1xuICAgICAgICAgICAgICAgIHgyID0gc2FtcGxlQ3VydmVYKHQyKTtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHgyIC0geCkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPiB4Mikge1xuICAgICAgICAgICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQyID0gKHQxIC0gdDApIC8gMiArIHQwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb2x2ZSh0LCAxIC8gKDIwMCAqIGR1cmF0aW9uKSk7XG4gICAgfVxuICAgIGVscHJvdG8ub25BbmltYXRpb24gPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBmID8gZXZlLm9uKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiICsgdGhpcy5pZCwgZikgOiBldmUudW5iaW5kKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiICsgdGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKGFuaW0sIG1zKSB7XG4gICAgICAgIHZhciBwZXJjZW50cyA9IFtdLFxuICAgICAgICAgICAgbmV3QW5pbSA9IHt9O1xuICAgICAgICB0aGlzLm1zID0gbXM7XG4gICAgICAgIHRoaXMudGltZXMgPSAxO1xuICAgICAgICBpZiAoYW5pbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhbmltKSBpZiAoYW5pbVtoYXNdKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgbmV3QW5pbVt0b0Zsb2F0KGF0dHIpXSA9IGFuaW1bYXR0cl07XG4gICAgICAgICAgICAgICAgcGVyY2VudHMucHVzaCh0b0Zsb2F0KGF0dHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcmNlbnRzLnNvcnQoc29ydEJ5TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW0gPSBuZXdBbmltO1xuICAgICAgICB0aGlzLnRvcCA9IHBlcmNlbnRzW3BlcmNlbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnBlcmNlbnRzID0gcGVyY2VudHM7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBBbmltYXRpb24uZGVsYXlcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIGV4aXN0aW5nIGFuaW1hdGlvbiBvYmplY3Qgd2l0aCBnaXZlbiBkZWxheS5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gZGVsYXkgKG51bWJlcikgbnVtYmVyIG9mIG1zIHRvIHBhc3MgYmV0d2VlbiBhbmltYXRpb24gc3RhcnQgYW5kIGFjdHVhbCBhbmltYXRpb25cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBuZXcgYWx0ZXJlZCBBbmltYXRpb24gb2JqZWN0XG4gICAgIHwgdmFyIGFuaW0gPSBSYXBoYWVsLmFuaW1hdGlvbih7Y3g6IDEwLCBjeTogMjB9LCAyZTMpO1xuICAgICB8IGNpcmNsZTEuYW5pbWF0ZShhbmltKTsgLy8gcnVuIHRoZSBnaXZlbiBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgfCBjaXJjbGUyLmFuaW1hdGUoYW5pbS5kZWxheSg1MDApKTsgLy8gcnVuIHRoZSBnaXZlbiBhbmltYXRpb24gYWZ0ZXIgNTAwIG1zXG4gICAgXFwqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQW5pbWF0aW9uKHRoaXMuYW5pbSwgdGhpcy5tcyk7XG4gICAgICAgIGEudGltZXMgPSB0aGlzLnRpbWVzO1xuICAgICAgICBhLmRlbCA9ICtkZWxheSB8fCAwO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBBbmltYXRpb24ucmVwZWF0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiBleGlzdGluZyBhbmltYXRpb24gb2JqZWN0IHdpdGggZ2l2ZW4gcmVwZXRpdGlvbi5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gcmVwZWF0IChudW1iZXIpIG51bWJlciBpdGVyYXRpb25zIG9mIGFuaW1hdGlvbi4gRm9yIGluZmluaXRlIGFuaW1hdGlvbiBwYXNzIGBJbmZpbml0eWBcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBuZXcgYWx0ZXJlZCBBbmltYXRpb24gb2JqZWN0XG4gICAgXFwqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIHZhciBhID0gbmV3IEFuaW1hdGlvbih0aGlzLmFuaW0sIHRoaXMubXMpO1xuICAgICAgICBhLmRlbCA9IHRoaXMuZGVsO1xuICAgICAgICBhLnRpbWVzID0gbWF0aC5mbG9vcihtbWF4KHRpbWVzLCAwKSkgfHwgMTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBydW5BbmltYXRpb24oYW5pbSwgZWxlbWVudCwgcGVyY2VudCwgc3RhdHVzLCB0b3RhbE9yaWdpbiwgdGltZXMpIHtcbiAgICAgICAgcGVyY2VudCA9IHRvRmxvYXQocGVyY2VudCk7XG4gICAgICAgIHZhciBwYXJhbXMsXG4gICAgICAgICAgICBpc0luQW5pbSxcbiAgICAgICAgICAgIGlzSW5BbmltU2V0LFxuICAgICAgICAgICAgcGVyY2VudHMgPSBbXSxcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgbXMgPSBhbmltLm1zLFxuICAgICAgICAgICAgZnJvbSA9IHt9LFxuICAgICAgICAgICAgdG8gPSB7fSxcbiAgICAgICAgICAgIGRpZmYgPSB7fTtcbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBhbmltYXRpb25FbGVtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhbmltYXRpb25FbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZS5lbC5pZCA9PSBlbGVtZW50LmlkICYmIGUuYW5pbSA9PSBhbmltKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnBlcmNlbnQgIT0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbkFuaW1TZXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbkFuaW0gPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihlLnRvdGFsT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gK3RvOyAvLyBOYU5cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltLnBlcmNlbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhbmltLnBlcmNlbnRzW2ldID09IHBlcmNlbnQgfHwgYW5pbS5wZXJjZW50c1tpXSA+IHN0YXR1cyAqIGFuaW0udG9wKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IGFuaW0ucGVyY2VudHNbaV07XG4gICAgICAgICAgICAgICAgcHJldiA9IGFuaW0ucGVyY2VudHNbaSAtIDFdIHx8IDA7XG4gICAgICAgICAgICAgICAgbXMgPSBtcyAvIGFuaW0udG9wICogKHBlcmNlbnQgLSBwcmV2KTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gYW5pbS5wZXJjZW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gYW5pbS5hbmltW3BlcmNlbnRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoYW5pbS5hbmltW2FuaW0ucGVyY2VudHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNJbkFuaW0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gcGFyYW1zKSBpZiAocGFyYW1zW2hhc10oYXR0cikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlQW5pbUF0dHJzW2hhc10oYXR0cikgfHwgZWxlbWVudC5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2hhc10oYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVthdHRyXSA9IGVsZW1lbnQuYXR0cihhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgKGZyb21bYXR0cl0gPT0gbnVsbCkgJiYgKGZyb21bYXR0cl0gPSBhdmFpbGFibGVBdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgIHRvW2F0dHJdID0gcGFyYW1zW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGF2YWlsYWJsZUFuaW1BdHRyc1thdHRyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBudTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0gKHRvW2F0dHJdIC0gZnJvbVthdHRyXSkgLyBtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb2xvdXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2F0dHJdID0gUi5nZXRSR0IoZnJvbVthdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQ29sb3VyID0gUi5nZXRSR0IodG9bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6ICh0b0NvbG91ci5yIC0gZnJvbVthdHRyXS5yKSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnOiAodG9Db2xvdXIuZyAtIGZyb21bYXR0cl0uZykgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjogKHRvQ29sb3VyLmIgLSBmcm9tW2F0dHJdLmIpIC8gbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aGVzID0gcGF0aDJjdXJ2ZShmcm9tW2F0dHJdLCB0b1thdHRyXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvUGF0aCA9IHBhdGhlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2F0dHJdID0gcGF0aGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGZyb21bYXR0cl0ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdW2ldID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMSwgamogPSBmcm9tW2F0dHJdW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl1baV1bal0gPSAodG9QYXRoW2ldW2pdIC0gZnJvbVthdHRyXVtpXVtqXSkgLyBtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgXyA9IGVsZW1lbnQuXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXEgPSBlcXVhbGlzZVRyYW5zZm9ybShfW2F0dHJdLCB0b1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21bYXR0cl0gPSBlcS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1thdHRyXSA9IGVxLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0ucmVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gZnJvbVthdHRyXS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdW2ldID0gW2Zyb21bYXR0cl1baV1bMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBmcm9tW2F0dHJdW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdW2ldW2pdID0gKHRvW2F0dHJdW2ldW2pdIC0gZnJvbVthdHRyXVtpXVtqXSkgLyBtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gKGVsZW1lbnQubWF0cml4IHx8IG5ldyBNYXRyaXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF86IHt0cmFuc2Zvcm06IF8udHJhbnNmb3JtfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEJCb3goMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVthdHRyXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0VHJhbnNmb3JtKHRvMiwgdG9bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1thdHRyXSA9IHRvMi5fLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0bzIubWF0cml4LmEgLSBtLmEpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG8yLm1hdHJpeC5iIC0gbS5iKSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvMi5tYXRyaXguYyAtIG0uYykgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0bzIubWF0cml4LmQgLSBtLmQpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG8yLm1hdHJpeC5lIC0gbS5lKSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvMi5tYXRyaXguZiAtIG0uZikgLyBtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tW2F0dHJdID0gW18uc3gsIF8uc3ksIF8uZGVnLCBfLmR4LCBfLmR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHRvMiA9IHtfOnt9LCBnZXRCQm94OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LmdldEJCb3goKTsgfX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhY3RUcmFuc2Zvcm0odG8yLCB0b1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZbYXR0cl0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAodG8yLl8uc3ggLSBfLnN4KSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgKHRvMi5fLnN5IC0gXy5zeSkgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICh0bzIuXy5kZWcgLSBfLmRlZykgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICh0bzIuXy5keCAtIF8uZHgpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAodG8yLl8uZHkgLSBfLmR5KSAvIG1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNzdlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBTdHIocGFyYW1zW2F0dHJdKVtzcGxpdF0oc2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTIgPSBTdHIoZnJvbVthdHRyXSlbc3BsaXRdKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGlwLXJlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2F0dHJdID0gZnJvbTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGZyb20yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXVtpXSA9ICh2YWx1ZXNbaV0gLSBmcm9tW2F0dHJdW2ldKSAvIG1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvW2F0dHJdID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXVtjb25jYXRdKHBhcmFtc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTIgPSBbXVtjb25jYXRdKGZyb21bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZWxlbWVudC5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2F0dHJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl1baV0gPSAoKHZhbHVlc1tpXSB8fCAwKSAtIChmcm9tMltpXSB8fCAwKSkgLyBtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gcGFyYW1zLmVhc2luZyxcbiAgICAgICAgICAgICAgICBlYXN5ZWFzeSA9IFIuZWFzaW5nX2Zvcm11bGFzW2Vhc2luZ107XG4gICAgICAgICAgICBpZiAoIWVhc3llYXN5KSB7XG4gICAgICAgICAgICAgICAgZWFzeWVhc3kgPSBTdHIoZWFzaW5nKS5tYXRjaChiZXppZXJyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGVhc3llYXN5ICYmIGVhc3llYXN5Lmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJ2ZSA9IGVhc3llYXN5O1xuICAgICAgICAgICAgICAgICAgICBlYXN5ZWFzeSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3ViaWNCZXppZXJBdFRpbWUodCwgK2N1cnZlWzFdLCArY3VydmVbMl0sICtjdXJ2ZVszXSwgK2N1cnZlWzRdLCBtcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWFzeWVhc3kgPSBwaXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcmFtcy5zdGFydCB8fCBhbmltLnN0YXJ0IHx8ICtuZXcgRGF0ZTtcbiAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgYW5pbTogYW5pbSxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiBwZXJjZW50LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aW1lc3RhbXAgKyAoYW5pbS5kZWwgfHwgMCksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgIGluaXRzdGF0dXM6IHN0YXR1cyB8fCAwLFxuICAgICAgICAgICAgICAgIHN0b3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1zOiBtcyxcbiAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc3llYXN5LFxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgZGlmZjogZGlmZixcbiAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgZWw6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHBhcmFtcy5jYWxsYmFjayxcbiAgICAgICAgICAgICAgICBwcmV2OiBwcmV2LFxuICAgICAgICAgICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiB0aW1lcyB8fCBhbmltLnRpbWVzLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogZWxlbWVudC5hdHRyKCksXG4gICAgICAgICAgICAgICAgdG90YWxPcmlnaW46IHRvdGFsT3JpZ2luXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgIWlzSW5BbmltICYmICFpc0luQW5pbVNldCkge1xuICAgICAgICAgICAgICAgIGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZS5zdGFydCA9IG5ldyBEYXRlIC0gbXMgKiBzdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbkFuaW1TZXQpIHtcbiAgICAgICAgICAgICAgICBlLnN0YXJ0ID0gbmV3IERhdGUgLSBlLm1zICogc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoID09IDEgJiYgcmVxdWVzdEFuaW1GcmFtZShhbmltYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNJbkFuaW0uaW5pdHN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGlzSW5BbmltLnN0YXJ0ID0gbmV3IERhdGUgLSBpc0luQW5pbS5tcyAqIHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBldmUoXCJyYXBoYWVsLmFuaW0uc3RhcnQuXCIgKyBlbGVtZW50LmlkLCBlbGVtZW50LCBhbmltKTtcbiAgICB9XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuYW5pbWF0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBARWxlbWVudC5hbmltYXRlIG9yIEBFbGVtZW50LmFuaW1hdGVXaXRoIG1ldGhvZHMuXG4gICAgICogU2VlIGFsc28gQEFuaW1hdGlvbi5kZWxheSBhbmQgQEFuaW1hdGlvbi5yZXBlYXQgbWV0aG9kcy5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGZpbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50LCBzZWUgYWxzbyBARWxlbWVudC5hdHRyXG4gICAgIC0gbXMgKG51bWJlcikgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0aW9uIHRvIHJ1blxuICAgICAtIGVhc2luZyAoc3RyaW5nKSAjb3B0aW9uYWwgZWFzaW5nIHR5cGUuIEFjY2VwdCBvbmUgb2YgQFJhcGhhZWwuZWFzaW5nX2Zvcm11bGFzIG9yIENTUyBmb3JtYXQ6IGBjdWJpYyYjeDIwMTA7YmV6aWVyKFhYLCYjMTYwO1hYLCYjMTYwO1hYLCYjMTYwO1hYKWBcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbi4gV2lsbCBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbmltYXRpb24uXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgQEFuaW1hdGlvblxuICAgIFxcKi9cbiAgICBSLmFuaW1hdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChwYXJhbXMgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFIuaXMoZWFzaW5nLCBcImZ1bmN0aW9uXCIpIHx8ICFlYXNpbmcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZWFzaW5nIHx8IG51bGw7XG4gICAgICAgICAgICBlYXNpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IE9iamVjdChwYXJhbXMpO1xuICAgICAgICBtcyA9ICttcyB8fCAwO1xuICAgICAgICB2YXIgcCA9IHt9LFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIGF0dHI7XG4gICAgICAgIGZvciAoYXR0ciBpbiBwYXJhbXMpIGlmIChwYXJhbXNbaGFzXShhdHRyKSAmJiB0b0Zsb2F0KGF0dHIpICE9IGF0dHIgJiYgdG9GbG9hdChhdHRyKSArIFwiJVwiICE9IGF0dHIpIHtcbiAgICAgICAgICAgIGpzb24gPSB0cnVlO1xuICAgICAgICAgICAgcFthdHRyXSA9IHBhcmFtc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHBlcmNlbnQtbGlrZSBzeW50YXggaXMgdXNlZCBhbmQgZW5kLW9mLWFsbCBhbmltYXRpb24gY2FsbGJhY2sgdXNlZFxuICAgICAgICAgICAgaWYoY2FsbGJhY2spe1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RLZXkgPSAwO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSBpbiBwYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRvSW50KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXJhbXNbaGFzXShpKSAmJiBwZXJjZW50ID4gbGFzdEtleSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0S2V5ID0gcGVyY2VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0S2V5ICs9ICclJztcbiAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRlZmluZWQgY2FsbGJhY2sgaW4gdGhlIGxhc3Qga2V5ZnJhbWUsIHNraXBcbiAgICAgICAgICAgICAgICAhcGFyYW1zW2xhc3RLZXldLmNhbGxiYWNrICYmIChwYXJhbXNbbGFzdEtleV0uY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24ocGFyYW1zLCBtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNpbmcgJiYgKHAuZWFzaW5nID0gZWFzaW5nKTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIChwLmNhbGxiYWNrID0gY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oezEwMDogcH0sIG1zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYW5pbWF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhbmQgc3RhcnRzIGFuaW1hdGlvbiBmb3IgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGZpbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50LCBzZWUgYWxzbyBARWxlbWVudC5hdHRyXG4gICAgIC0gbXMgKG51bWJlcikgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0aW9uIHRvIHJ1blxuICAgICAtIGVhc2luZyAoc3RyaW5nKSAjb3B0aW9uYWwgZWFzaW5nIHR5cGUuIEFjY2VwdCBvbmUgb2YgQFJhcGhhZWwuZWFzaW5nX2Zvcm11bGFzIG9yIENTUyBmb3JtYXQ6IGBjdWJpYyYjeDIwMTA7YmV6aWVyKFhYLCYjMTYwO1hYLCYjMTYwO1hYLCYjMTYwO1hYKWBcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbi4gV2lsbCBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbmltYXRpb24uXG4gICAgICogb3JcbiAgICAgLSBhbmltYXRpb24gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCwgc2VlIEBSYXBoYWVsLmFuaW1hdGlvblxuICAgICAqKlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hbmltYXRlID0gZnVuY3Rpb24gKHBhcmFtcywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW0gPSBwYXJhbXMgaW5zdGFuY2VvZiBBbmltYXRpb24gPyBwYXJhbXMgOiBSLmFuaW1hdGlvbihwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgcnVuQW5pbWF0aW9uKGFuaW0sIGVsZW1lbnQsIGFuaW0ucGVyY2VudHNbMF0sIG51bGwsIGVsZW1lbnQuYXR0cigpKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZXRUaW1lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0dXMgb2YgYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IGluIG1pbGxpc2Vjb25kcy4gU2ltaWxhciB0byBARWxlbWVudC5zdGF0dXMgbWV0aG9kLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBhbmltIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgLSB2YWx1ZSAobnVtYmVyKSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudCBpZiBgdmFsdWVgIGlzIHNwZWNpZmllZFxuICAgICAqIE5vdGUsIHRoYXQgZHVyaW5nIGFuaW1hdGlvbiBmb2xsb3dpbmcgZXZlbnRzIGFyZSB0cmlnZ2VyZWQ6XG4gICAgICpcbiAgICAgKiBPbiBlYWNoIGFuaW1hdGlvbiBmcmFtZSBldmVudCBgYW5pbS5mcmFtZS48aWQ+YCwgb24gc3RhcnQgYGFuaW0uc3RhcnQuPGlkPmAgYW5kIG9uIGVuZCBgYW5pbS5maW5pc2guPGlkPmAuXG4gICAgXFwqL1xuICAgIGVscHJvdG8uc2V0VGltZSA9IGZ1bmN0aW9uIChhbmltLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYW5pbSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyhhbmltLCBtbWluKHZhbHVlLCBhbmltLm1zKSAvIGFuaW0ubXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RhdHVzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHN0YXR1cyBvZiBhbmltYXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGFuaW0gKG9iamVjdCkgI29wdGlvbmFsIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgLSB2YWx1ZSAobnVtYmVyKSAjb3B0aW9uYWwgMCDigJMgMS4gSWYgc3BlY2lmaWVkLCBtZXRob2Qgd29ya3MgbGlrZSBhIHNldHRlciBhbmQgc2V0cyB0aGUgc3RhdHVzIG9mIGEgZ2l2ZW4gYW5pbWF0aW9uIHRvIHRoZSB2YWx1ZS4gVGhpcyB3aWxsIGNhdXNlIGFuaW1hdGlvbiB0byBqdW1wIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBzdGF0dXNcbiAgICAgKiBvclxuICAgICA9IChhcnJheSkgc3RhdHVzIGlmIGBhbmltYCBpcyBub3Qgc3BlY2lmaWVkLiBBcnJheSBvZiBvYmplY3RzIGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIGFuaW06IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgbyAgICAgc3RhdHVzOiAobnVtYmVyKSBzdGF0dXNcbiAgICAgbyB9XG4gICAgICogb3JcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50IGlmIGB2YWx1ZWAgaXMgc3BlY2lmaWVkXG4gICAgXFwqL1xuICAgIGVscHJvdG8uc3RhdHVzID0gZnVuY3Rpb24gKGFuaW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgZTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bkFuaW1hdGlvbihhbmltLCB0aGlzLCAtMSwgbW1pbih2YWx1ZSwgMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW4gPSBhbmltYXRpb25FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZSA9IGFuaW1hdGlvbkVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlLmVsLmlkID09IHRoaXMuaWQgJiYgKCFhbmltIHx8IGUuYW5pbSA9PSBhbmltKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW06IGUuYW5pbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogZS5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnBhdXNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTdG9wcyBhbmltYXRpb24gb2YgdGhlIGVsZW1lbnQgd2l0aCBhYmlsaXR5IHRvIHJlc3VtZSBpdCBsYXRlciBvbi5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gYW5pbSAob2JqZWN0KSAjb3B0aW9uYWwgYW5pbWF0aW9uIG9iamVjdFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5wYXVzZSA9IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBpKyspIGlmIChhbmltYXRpb25FbGVtZW50c1tpXS5lbC5pZCA9PSB0aGlzLmlkICYmICghYW5pbSB8fCBhbmltYXRpb25FbGVtZW50c1tpXS5hbmltID09IGFuaW0pKSB7XG4gICAgICAgICAgICBpZiAoZXZlKFwicmFwaGFlbC5hbmltLnBhdXNlLlwiICsgdGhpcy5pZCwgdGhpcywgYW5pbWF0aW9uRWxlbWVudHNbaV0uYW5pbSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHNbaV0ucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJlc3VtZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVzdW1lcyBhbmltYXRpb24gaWYgaXQgd2FzIHBhdXNlZCB3aXRoIEBFbGVtZW50LnBhdXNlIG1ldGhvZC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gYW5pbSAob2JqZWN0KSAjb3B0aW9uYWwgYW5pbWF0aW9uIG9iamVjdFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZXN1bWUgPSBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aDsgaSsrKSBpZiAoYW5pbWF0aW9uRWxlbWVudHNbaV0uZWwuaWQgPT0gdGhpcy5pZCAmJiAoIWFuaW0gfHwgYW5pbWF0aW9uRWxlbWVudHNbaV0uYW5pbSA9PSBhbmltKSkge1xuICAgICAgICAgICAgdmFyIGUgPSBhbmltYXRpb25FbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChldmUoXCJyYXBoYWVsLmFuaW0ucmVzdW1lLlwiICsgdGhpcy5pZCwgdGhpcywgZS5hbmltKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZS5wYXVzZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMoZS5hbmltLCBlLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zdG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTdG9wcyBhbmltYXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGFuaW0gKG9iamVjdCkgI29wdGlvbmFsIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uc3RvcCA9IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBpKyspIGlmIChhbmltYXRpb25FbGVtZW50c1tpXS5lbC5pZCA9PSB0aGlzLmlkICYmICghYW5pbSB8fCBhbmltYXRpb25FbGVtZW50c1tpXS5hbmltID09IGFuaW0pKSB7XG4gICAgICAgICAgICBpZiAoZXZlKFwicmFwaGFlbC5hbmltLnN0b3AuXCIgKyB0aGlzLmlkLCB0aGlzLCBhbmltYXRpb25FbGVtZW50c1tpXS5hbmltKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbGVtZW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0b3BBbmltYXRpb24ocGFwZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25FbGVtZW50cy5sZW5ndGg7IGkrKykgaWYgKGFuaW1hdGlvbkVsZW1lbnRzW2ldLmVsLnBhcGVyID09IHBhcGVyKSB7XG4gICAgICAgICAgICBhbmltYXRpb25FbGVtZW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBldmUub24oXCJyYXBoYWVsLnJlbW92ZVwiLCBzdG9wQW5pbWF0aW9uKTtcbiAgICBldmUub24oXCJyYXBoYWVsLmNsZWFyXCIsIHN0b3BBbmltYXRpb24pO1xuICAgIGVscHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJhcGhhXFx4ZWJsXFx1MjAxOXMgb2JqZWN0XCI7XG4gICAgfTtcblxuICAgIC8vIFNldFxuICAgIHZhciBTZXQgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2V0XCI7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXSAmJiAoaXRlbXNbaV0uY29uc3RydWN0b3IgPT0gZWxwcm90by5jb25zdHJ1Y3RvciB8fCBpdGVtc1tpXS5jb25zdHJ1Y3RvciA9PSBTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aF0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldHByb3RvID0gU2V0LnByb3RvdHlwZTtcbiAgICAvKlxcXG4gICAgICogU2V0LnB1c2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZWFjaCBhcmd1bWVudCB0byB0aGUgY3VycmVudCBzZXQuXG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSxcbiAgICAgICAgICAgIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiAoaXRlbS5jb25zdHJ1Y3RvciA9PSBlbHByb3RvLmNvbnN0cnVjdG9yIHx8IGl0ZW0uY29uc3RydWN0b3IgPT0gU2V0KSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXNbbGVuXSA9IHRoaXMuaXRlbXNbbGVuXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQucG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGxhc3QgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICAgPSAob2JqZWN0KSBlbGVtZW50XG4gICAgXFwqL1xuICAgIHNldHByb3RvLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggJiYgZGVsZXRlIHRoaXNbdGhpcy5sZW5ndGgtLV07XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnBvcCgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5mb3JFYWNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiBJZiBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAgaXQgd2lsbCBzdG9wIGxvb3AgcnVubmluZy5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSBmdW5jdGlvbiB0byBydW5cbiAgICAgLSB0aGlzQXJnIChvYmplY3QpIGNvbnRleHQgb2JqZWN0IGZvciB0aGUgY2FsbGJhY2tcbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLml0ZW1zW2ldLCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBlbHByb3RvKSBpZiAoZWxwcm90b1toYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgc2V0cHJvdG9bbWV0aG9kXSA9IChmdW5jdGlvbiAobWV0aG9kbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsW21ldGhvZG5hbWVdW2FwcGx5XShlbCwgYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG1ldGhvZCk7XG4gICAgfVxuICAgIHNldHByb3RvLmF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgJiYgUi5pcyhuYW1lLCBhcnJheSkgJiYgUi5pcyhuYW1lWzBdLCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gbmFtZS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tqXS5hdHRyKG5hbWVbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnNwbGljZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBpbmRleCAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZGVsZXRpb25cbiAgICAgLSBjb3VudCAobnVtYmVyKSBudW1iZXIgb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgLSBpbnNlcnRpb27igKYgKG9iamVjdCkgI29wdGlvbmFsIGVsZW1lbnRzIHRvIGluc2VydFxuICAgICA9IChvYmplY3QpIHNldCBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBpbnNlcnRpb24pIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBtbWF4KHRoaXMubGVuZ3RoICsgaW5kZXgsIDApIDogaW5kZXg7XG4gICAgICAgIGNvdW50ID0gbW1heCgwLCBtbWluKHRoaXMubGVuZ3RoIC0gaW5kZXgsIGNvdW50KSk7XG4gICAgICAgIHZhciB0YWlsID0gW10sXG4gICAgICAgICAgICB0b2RlbCA9IFtdLFxuICAgICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvZGVsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGFpbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuICsgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleCArIGldID0gdGhpc1tpbmRleCArIGldID0gaSA8IGFyZ2xlbiA/IGFyZ3NbaV0gOiB0YWlsW2kgLSBhcmdsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCA9IHRoaXMubGVuZ3RoIC09IGNvdW50IC0gYXJnbGVuO1xuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldCh0b2RlbCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmV4Y2x1ZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gZWxlbWVudCAob2JqZWN0KSBlbGVtZW50IHRvIHJlbW92ZVxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgb2JqZWN0IHdhcyBmb3VuZCAmIHJlbW92ZWQgZnJvbSB0aGUgc2V0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmV4Y2x1ZGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAodGhpc1tpXSA9PSBlbCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2V0cHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIChSLmlzKGVhc2luZywgXCJmdW5jdGlvblwiKSB8fCAhZWFzaW5nKSAmJiAoY2FsbGJhY2sgPSBlYXNpbmcgfHwgbnVsbCk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSBsZW4sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgc2V0ID0gdGhpcyxcbiAgICAgICAgICAgIGNvbGxlY3RvcjtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrICYmIChjb2xsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAhLS1sZW4gJiYgY2FsbGJhY2suY2FsbChzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFzaW5nID0gUi5pcyhlYXNpbmcsIHN0cmluZykgPyBlYXNpbmcgOiBjb2xsZWN0b3I7XG4gICAgICAgIHZhciBhbmltID0gUi5hbmltYXRpb24ocGFyYW1zLCBtcywgZWFzaW5nLCBjb2xsZWN0b3IpO1xuICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1stLWldLmFuaW1hdGUoYW5pbSk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0gJiYgIXRoaXMuaXRlbXNbaV0ucmVtb3ZlZCAmJiB0aGlzLml0ZW1zW2ldLmFuaW1hdGVXaXRoKGl0ZW0sIGFuaW0sIGFuaW0pO1xuICAgICAgICAgICAgKHRoaXMuaXRlbXNbaV0gJiYgIXRoaXMuaXRlbXNbaV0ucmVtb3ZlZCkgfHwgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBzZXRwcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmluc2VydEFmdGVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHNldHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4ID0gW10sXG4gICAgICAgICAgICB5ID0gW10sXG4gICAgICAgICAgICB4MiA9IFtdLFxuICAgICAgICAgICAgeTIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpLS07KSBpZiAoIXRoaXMuaXRlbXNbaV0ucmVtb3ZlZCkge1xuICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuaXRlbXNbaV0uZ2V0QkJveCgpO1xuICAgICAgICAgICAgeC5wdXNoKGJveC54KTtcbiAgICAgICAgICAgIHkucHVzaChib3gueSk7XG4gICAgICAgICAgICB4Mi5wdXNoKGJveC54ICsgYm94LndpZHRoKTtcbiAgICAgICAgICAgIHkyLnB1c2goYm94LnkgKyBib3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gbW1pblthcHBseV0oMCwgeCk7XG4gICAgICAgIHkgPSBtbWluW2FwcGx5XSgwLCB5KTtcbiAgICAgICAgeDIgPSBtbWF4W2FwcGx5XSgwLCB4Mik7XG4gICAgICAgIHkyID0gbW1heFthcHBseV0oMCwgeTIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHNldHByb3RvLmNsb25lID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcyA9IHRoaXMucGFwZXIuc2V0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcy5wdXNoKHRoaXMuaXRlbXNbaV0uY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBzZXRwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmFwaGFcXHhlYmxcXHUyMDE4cyBzZXRcIjtcbiAgICB9O1xuXG4gICAgc2V0cHJvdG8uZ2xvdyA9IGZ1bmN0aW9uKGdsb3dDb25maWcpIHtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMucGFwZXIuc2V0KCk7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihzaGFwZSwgaW5kZXgpe1xuICAgICAgICAgICAgdmFyIGcgPSBzaGFwZS5nbG93KGdsb3dDb25maWcpO1xuICAgICAgICAgICAgaWYoZyAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24oc2hhcGUyLCBpbmRleDIpe1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cbiAgICAvKlxcXG4gICAgICogU2V0LmlzUG9pbnRJbnNpZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERldGVybWluZSBpZiBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhpcyBzZXTigJlzIGVsZW1lbnRzXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgcG9pbnQgaXMgaW5zaWRlIGFueSBvZiB0aGUgc2V0J3MgZWxlbWVudHNcbiAgICAgXFwqL1xuICAgIHNldHByb3RvLmlzUG9pbnRJbnNpZGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgaXNQb2ludEluc2lkZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwuaXNQb2ludEluc2lkZSh4LCB5KSkge1xuICAgICAgICAgICAgICAgIGlzUG9pbnRJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc3RvcCBsb29wXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZTtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwucmVnaXN0ZXJGb250XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGdpdmVuIGZvbnQgdG8gdGhlIHJlZ2lzdGVyZWQgc2V0IG9mIGZvbnRzIGZvciBSYXBoYcOrbC4gU2hvdWxkIGJlIHVzZWQgYXMgYW4gaW50ZXJuYWwgY2FsbCBmcm9tIHdpdGhpbiBDdWbDs27igJlzIGZvbnQgZmlsZS5cbiAgICAgKiBSZXR1cm5zIG9yaWdpbmFsIHBhcmFtZXRlciwgc28gaXQgY291bGQgYmUgdXNlZCB3aXRoIGNoYWluaW5nLlxuICAgICAjIDxhIGhyZWY9XCJodHRwOi8vd2lraS5naXRodWIuY29tL3NvcmNjdS9jdWZvbi9hYm91dFwiPk1vcmUgYWJvdXQgQ3Vmw7NuIGFuZCBob3cgdG8gY29udmVydCB5b3VyIGZvbnQgZm9ybSBUVEYsIE9URiwgZXRjIHRvIEphdmFTY3JpcHQgZmlsZS48L2E+XG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGZvbnQgKG9iamVjdCkgdGhlIGZvbnQgdG8gcmVnaXN0ZXJcbiAgICAgPSAob2JqZWN0KSB0aGUgZm9udCB5b3UgcGFzc2VkIGluXG4gICAgID4gVXNhZ2VcbiAgICAgfCBDdWZvbi5yZWdpc3RlckZvbnQoUmFwaGFlbC5yZWdpc3RlckZvbnQoe+KApn0pKTtcbiAgICBcXCovXG4gICAgUi5yZWdpc3RlckZvbnQgPSBmdW5jdGlvbiAoZm9udCkge1xuICAgICAgICBpZiAoIWZvbnQuZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb250cyA9IHRoaXMuZm9udHMgfHwge307XG4gICAgICAgIHZhciBmb250Y29weSA9IHtcbiAgICAgICAgICAgICAgICB3OiBmb250LncsXG4gICAgICAgICAgICAgICAgZmFjZToge30sXG4gICAgICAgICAgICAgICAgZ2x5cGhzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbWlseSA9IGZvbnQuZmFjZVtcImZvbnQtZmFtaWx5XCJdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZvbnQuZmFjZSkgaWYgKGZvbnQuZmFjZVtoYXNdKHByb3ApKSB7XG4gICAgICAgICAgICBmb250Y29weS5mYWNlW3Byb3BdID0gZm9udC5mYWNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvbnRzW2ZhbWlseV0pIHtcbiAgICAgICAgICAgIHRoaXMuZm9udHNbZmFtaWx5XS5wdXNoKGZvbnRjb3B5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9udHNbZmFtaWx5XSA9IFtmb250Y29weV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb250LnN2Zykge1xuICAgICAgICAgICAgZm9udGNvcHkuZmFjZVtcInVuaXRzLXBlci1lbVwiXSA9IHRvSW50KGZvbnQuZmFjZVtcInVuaXRzLXBlci1lbVwiXSwgMTApO1xuICAgICAgICAgICAgZm9yICh2YXIgZ2x5cGggaW4gZm9udC5nbHlwaHMpIGlmIChmb250LmdseXBoc1toYXNdKGdseXBoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZm9udC5nbHlwaHNbZ2x5cGhdO1xuICAgICAgICAgICAgICAgIGZvbnRjb3B5LmdseXBoc1tnbHlwaF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHc6IHBhdGgudyxcbiAgICAgICAgICAgICAgICAgICAgazoge30sXG4gICAgICAgICAgICAgICAgICAgIGQ6IHBhdGguZCAmJiBcIk1cIiArIHBhdGguZC5yZXBsYWNlKC9bbWxjeHRydl0vZywgZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2w6IFwiTFwiLCBjOiBcIkNcIiwgeDogXCJ6XCIsIHQ6IFwibVwiLCByOiBcImxcIiwgdjogXCJjXCJ9W2NvbW1hbmRdIHx8IFwiTVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgKyBcInpcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguaykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHBhdGguaykgaWYgKHBhdGhbaGFzXShrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udGNvcHkuZ2x5cGhzW2dseXBoXS5rW2tdID0gcGF0aC5rW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb250O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdldEZvbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEZpbmRzIGZvbnQgb2JqZWN0IGluIHRoZSByZWdpc3RlcmVkIGZvbnRzIGJ5IGdpdmVuIHBhcmFtZXRlcnMuIFlvdSBjb3VsZCBzcGVjaWZ5IG9ubHkgb25lIHdvcmQgZnJvbSB0aGUgZm9udCBuYW1lLCBsaWtlIOKAnE15cmlhZOKAnSBmb3Ig4oCcTXlyaWFkIFByb+KAnS5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gZmFtaWx5IChzdHJpbmcpIGZvbnQgZmFtaWx5IG5hbWUgb3IgYW55IHdvcmQgZnJvbSBpdFxuICAgICAtIHdlaWdodCAoc3RyaW5nKSAjb3B0aW9uYWwgZm9udCB3ZWlnaHRcbiAgICAgLSBzdHlsZSAoc3RyaW5nKSAjb3B0aW9uYWwgZm9udCBzdHlsZVxuICAgICAtIHN0cmV0Y2ggKHN0cmluZykgI29wdGlvbmFsIGZvbnQgc3RyZXRjaFxuICAgICA9IChvYmplY3QpIHRoZSBmb250IG9iamVjdFxuICAgICA+IFVzYWdlXG4gICAgIHwgcGFwZXIucHJpbnQoMTAwLCAxMDAsIFwiVGVzdCBzdHJpbmdcIiwgcGFwZXIuZ2V0Rm9udChcIlRpbWVzXCIsIDgwMCksIDMwKTtcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5nZXRGb250ID0gZnVuY3Rpb24gKGZhbWlseSwgd2VpZ2h0LCBzdHlsZSwgc3RyZXRjaCkge1xuICAgICAgICBzdHJldGNoID0gc3RyZXRjaCB8fCBcIm5vcm1hbFwiO1xuICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IFwibm9ybWFsXCI7XG4gICAgICAgIHdlaWdodCA9ICt3ZWlnaHQgfHwge25vcm1hbDogNDAwLCBib2xkOiA3MDAsIGxpZ2h0ZXI6IDMwMCwgYm9sZGVyOiA4MDB9W3dlaWdodF0gfHwgNDAwO1xuICAgICAgICBpZiAoIVIuZm9udHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udCA9IFIuZm9udHNbZmFtaWx5XTtcbiAgICAgICAgaWYgKCFmb250KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGZhbWlseS5yZXBsYWNlKC9bXlxcd1xcZFxccyshfi46Xy1dL2csIEUpICsgXCIoXFxcXHN8JClcIiwgXCJpXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgZm9udE5hbWUgaW4gUi5mb250cykgaWYgKFIuZm9udHNbaGFzXShmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS50ZXN0KGZvbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmb250ID0gUi5mb250c1tmb250TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhlZm9udDtcbiAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZvbnQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoZWZvbnQgPSBmb250W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGVmb250LmZhY2VbXCJmb250LXdlaWdodFwiXSA9PSB3ZWlnaHQgJiYgKHRoZWZvbnQuZmFjZVtcImZvbnQtc3R5bGVcIl0gPT0gc3R5bGUgfHwgIXRoZWZvbnQuZmFjZVtcImZvbnQtc3R5bGVcIl0pICYmIHRoZWZvbnQuZmFjZVtcImZvbnQtc3RyZXRjaFwiXSA9PSBzdHJldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhlZm9udDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wcmludFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBwYXRoIHRoYXQgcmVwcmVzZW50IGdpdmVuIHRleHQgd3JpdHRlbiB1c2luZyBnaXZlbiBmb250IGF0IGdpdmVuIHBvc2l0aW9uIHdpdGggZ2l2ZW4gc2l6ZS5cbiAgICAgKiBSZXN1bHQgb2YgdGhlIG1ldGhvZCBpcyBwYXRoIGVsZW1lbnQgdGhhdCBjb250YWlucyB3aG9sZSB0ZXh0IGFzIGEgc2VwYXJhdGUgcGF0aC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSB0ZXh0XG4gICAgIC0geSAobnVtYmVyKSB5IHBvc2l0aW9uIG9mIHRoZSB0ZXh0XG4gICAgIC0gc3RyaW5nIChzdHJpbmcpIHRleHQgdG8gcHJpbnRcbiAgICAgLSBmb250IChvYmplY3QpIGZvbnQgb2JqZWN0LCBzZWUgQFBhcGVyLmdldEZvbnRcbiAgICAgLSBzaXplIChudW1iZXIpICNvcHRpb25hbCBzaXplIG9mIHRoZSBmb250LCBkZWZhdWx0IGlzIGAxNmBcbiAgICAgLSBvcmlnaW4gKHN0cmluZykgI29wdGlvbmFsIGNvdWxkIGJlIGBcImJhc2VsaW5lXCJgIG9yIGBcIm1pZGRsZVwiYCwgZGVmYXVsdCBpcyBgXCJtaWRkbGVcImBcbiAgICAgLSBsZXR0ZXJfc3BhY2luZyAobnVtYmVyKSAjb3B0aW9uYWwgbnVtYmVyIGluIHJhbmdlIGAtMS4uMWAsIGRlZmF1bHQgaXMgYDBgXG4gICAgIC0gbGluZV9zcGFjaW5nIChudW1iZXIpICNvcHRpb25hbCBudW1iZXIgaW4gcmFuZ2UgYDEuLjNgLCBkZWZhdWx0IGlzIGAxYFxuICAgICA9IChvYmplY3QpIHJlc3VsdGluZyBwYXRoIGVsZW1lbnQsIHdoaWNoIGNvbnNpc3Qgb2YgYWxsIGxldHRlcnNcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciB0eHQgPSByLnByaW50KDEwLCA1MCwgXCJwcmludFwiLCByLmdldEZvbnQoXCJNdXNlb1wiKSwgMzApLmF0dHIoe2ZpbGw6IFwiI2ZmZlwifSk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8ucHJpbnQgPSBmdW5jdGlvbiAoeCwgeSwgc3RyaW5nLCBmb250LCBzaXplLCBvcmlnaW4sIGxldHRlcl9zcGFjaW5nLCBsaW5lX3NwYWNpbmcpIHtcbiAgICAgICAgb3JpZ2luID0gb3JpZ2luIHx8IFwibWlkZGxlXCI7IC8vIGJhc2VsaW5lfG1pZGRsZVxuICAgICAgICBsZXR0ZXJfc3BhY2luZyA9IG1tYXgobW1pbihsZXR0ZXJfc3BhY2luZyB8fCAwLCAxKSwgLTEpO1xuICAgICAgICBsaW5lX3NwYWNpbmcgPSBtbWF4KG1taW4obGluZV9zcGFjaW5nIHx8IDEsIDMpLCAxKTtcbiAgICAgICAgdmFyIGxldHRlcnMgPSBTdHIoc3RyaW5nKVtzcGxpdF0oRSksXG4gICAgICAgICAgICBzaGlmdCA9IDAsXG4gICAgICAgICAgICBub3RmaXJzdCA9IDAsXG4gICAgICAgICAgICBwYXRoID0gRSxcbiAgICAgICAgICAgIHNjYWxlO1xuICAgICAgICBSLmlzKGZvbnQsIFwic3RyaW5nXCIpICYmIChmb250ID0gdGhpcy5nZXRGb250KGZvbnQpKTtcbiAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgIHNjYWxlID0gKHNpemUgfHwgMTYpIC8gZm9udC5mYWNlW1widW5pdHMtcGVyLWVtXCJdO1xuICAgICAgICAgICAgdmFyIGJiID0gZm9udC5mYWNlLmJib3hbc3BsaXRdKHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgdG9wID0gK2JiWzBdLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBiYlszXSAtIGJiWzFdLFxuICAgICAgICAgICAgICAgIHNoaWZ0eSA9IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gK2JiWzFdICsgKG9yaWdpbiA9PSBcImJhc2VsaW5lXCIgPyBsaW5lSGVpZ2h0ICsgKCtmb250LmZhY2UuZGVzY2VudCkgOiBsaW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsZXR0ZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tpXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VyciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5vdGZpcnN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnR5ICs9IGxpbmVIZWlnaHQgKiBsaW5lX3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBub3RmaXJzdCAmJiBmb250LmdseXBoc1tsZXR0ZXJzW2kgLSAxXV0gfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gZm9udC5nbHlwaHNbbGV0dGVyc1tpXV07XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ICs9IG5vdGZpcnN0ID8gKHByZXYudyB8fCBmb250LncpICsgKHByZXYuayAmJiBwcmV2LmtbbGV0dGVyc1tpXV0gfHwgMCkgKyAoZm9udC53ICogbGV0dGVyX3NwYWNpbmcpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbm90Zmlyc3QgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyciAmJiBjdXJyLmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBSLnRyYW5zZm9ybVBhdGgoY3Vyci5kLCBbXCJ0XCIsIHNoaWZ0ICogc2NhbGUsIHNoaWZ0eSAqIHNjYWxlLCBcInNcIiwgc2NhbGUsIHNjYWxlLCB0b3AsIGhlaWdodCwgXCJ0XCIsICh4IC0gdG9wKSAvIHNjYWxlLCAoeSAtIGhlaWdodCkgLyBzY2FsZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHBhdGgpLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogXCIjMDAwXCIsXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogUGFwZXIuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbXBvcnRzIGVsZW1lbnRzIGluIEpTT04gYXJyYXkgaW4gZm9ybWF0IGB7dHlwZTogdHlwZSwgPGF0dHJpYnV0ZXM+fWBcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0ganNvbiAoYXJyYXkpXG4gICAgID0gKG9iamVjdCkgcmVzdWx0aW5nIHNldCBvZiBpbXBvcnRlZCBlbGVtZW50c1xuICAgICA+IFVzYWdlXG4gICAgIHwgcGFwZXIuYWRkKFtcbiAgICAgfCAgICAge1xuICAgICB8ICAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgfCAgICAgICAgIGN4OiAxMCxcbiAgICAgfCAgICAgICAgIGN5OiAxMCxcbiAgICAgfCAgICAgICAgIHI6IDVcbiAgICAgfCAgICAgfSxcbiAgICAgfCAgICAge1xuICAgICB8ICAgICAgICAgdHlwZTogXCJyZWN0XCIsXG4gICAgIHwgICAgICAgICB4OiAxMCxcbiAgICAgfCAgICAgICAgIHk6IDEwLFxuICAgICB8ICAgICAgICAgd2lkdGg6IDEwLFxuICAgICB8ICAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgfCAgICAgICAgIGZpbGw6IFwiI2ZjMFwiXG4gICAgIHwgICAgIH1cbiAgICAgfCBdKTtcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5hZGQgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICBpZiAoUi5pcyhqc29uLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5zZXQoKSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBpaSA9IGpzb24ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBqID0ganNvbltpXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1toYXNdKGoudHlwZSkgJiYgcmVzLnB1c2godGhpc1tqLnR5cGVdKCkuYXR0cihqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZm9ybWF0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTaW1wbGUgZm9ybWF0IGZ1bmN0aW9uLiBSZXBsYWNlcyBjb25zdHJ1Y3Rpb24gb2YgdHlwZSDigJxgezxudW1iZXI+fWDigJ0gdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHRva2VuIChzdHJpbmcpIHN0cmluZyB0byBmb3JtYXRcbiAgICAgLSDigKYgKHN0cmluZykgcmVzdCBvZiBhcmd1bWVudHMgd2lsbCBiZSB0cmVhdGVkIGFzIHBhcmFtZXRlcnMgZm9yIHJlcGxhY2VtZW50XG4gICAgID0gKHN0cmluZykgZm9ybWF0ZWQgc3RyaW5nXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgeCA9IDEwLFxuICAgICB8ICAgICB5ID0gMjAsXG4gICAgIHwgICAgIHdpZHRoID0gNDAsXG4gICAgIHwgICAgIGhlaWdodCA9IDUwO1xuICAgICB8IC8vIHRoaXMgd2lsbCBkcmF3IGEgcmVjdGFuZ3VsYXIgc2hhcGUgZXF1aXZhbGVudCB0byBcIk0xMCwyMGg0MHY1MGgtNDB6XCJcbiAgICAgfCBwYXBlci5wYXRoKFJhcGhhZWwuZm9ybWF0KFwiTXswfSx7MX1oezJ9dnszfWh7NH16XCIsIHgsIHksIHdpZHRoLCBoZWlnaHQsIC13aWR0aCkpO1xuICAgIFxcKi9cbiAgICBSLmZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBhcmdzID0gUi5pcyhwYXJhbXMsIGFycmF5KSA/IFswXVtjb25jYXRdKHBhcmFtcykgOiBhcmd1bWVudHM7XG4gICAgICAgIHRva2VuICYmIFIuaXModG9rZW4sIHN0cmluZykgJiYgYXJncy5sZW5ndGggLSAxICYmICh0b2tlbiA9IHRva2VuLnJlcGxhY2UoZm9ybWF0cmcsIGZ1bmN0aW9uIChzdHIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzWysraV0gPT0gbnVsbCA/IEUgOiBhcmdzW2ldO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBFO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZnVsbGZpbGxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEEgbGl0dGxlIGJpdCBtb3JlIGFkdmFuY2VkIGZvcm1hdCBmdW5jdGlvbiB0aGFuIEBSYXBoYWVsLmZvcm1hdC4gUmVwbGFjZXMgY29uc3RydWN0aW9uIG9mIHR5cGUg4oCcYHs8bmFtZT59YOKAnSB0byB0aGUgY29ycmVzcG9uZGluZyBhcmd1bWVudC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuICAgICAtIGpzb24gKG9iamVjdCkgb2JqZWN0IHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIGFzIGEgcmVwbGFjZW1lbnRcbiAgICAgPSAoc3RyaW5nKSBmb3JtYXRlZCBzdHJpbmdcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIHRoaXMgd2lsbCBkcmF3IGEgcmVjdGFuZ3VsYXIgc2hhcGUgZXF1aXZhbGVudCB0byBcIk0xMCwyMGg0MHY1MGgtNDB6XCJcbiAgICAgfCBwYXBlci5wYXRoKFJhcGhhZWwuZnVsbGZpbGwoXCJNe3h9LHt5fWh7ZGltLndpZHRofXZ7ZGltLmhlaWdodH1oe2RpbVsnbmVnYXRpdmUgd2lkdGgnXX16XCIsIHtcbiAgICAgfCAgICAgeDogMTAsXG4gICAgIHwgICAgIHk6IDIwLFxuICAgICB8ICAgICBkaW06IHtcbiAgICAgfCAgICAgICAgIHdpZHRoOiA0MCxcbiAgICAgfCAgICAgICAgIGhlaWdodDogNTAsXG4gICAgIHwgICAgICAgICBcIm5lZ2F0aXZlIHdpZHRoXCI6IC00MFxuICAgICB8ICAgICB9XG4gICAgIHwgfSkpO1xuICAgIFxcKi9cbiAgICBSLmZ1bGxmaWxsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgICAgICBvYmpOb3RhdGlvblJlZ2V4ID0gLyg/Oig/Ol58XFwuKSguKz8pKD89XFxbfFxcLnwkfFxcKCl8XFxbKCd8XCIpKC4rPylcXDJcXF0pKFxcKFxcKSk/L2csIC8vIG1hdGNoZXMgLnh4eHh4IG9yIFtcInh4eHh4XCJdIHRvIHJ1biBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICByZXBsYWNlciA9IGZ1bmN0aW9uIChhbGwsIGtleSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgICAgICBrZXkucmVwbGFjZShvYmpOb3RhdGlvblJlZ2V4LCBmdW5jdGlvbiAoYWxsLCBuYW1lLCBxdW90ZSwgcXVvdGVkTmFtZSwgaXNGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHF1b3RlZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXMgPT0gXCJmdW5jdGlvblwiICYmIGlzRnVuYyAmJiAocmVzID0gcmVzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzID0gKHJlcyA9PSBudWxsIHx8IHJlcyA9PSBvYmogPyBhbGwgOiByZXMpICsgXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UodG9rZW5SZWdleCwgZnVuY3Rpb24gKGFsbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5uaW5qYVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSWYgeW91IHdhbnQgdG8gbGVhdmUgbm8gdHJhY2Ugb2YgUmFwaGHDq2wgKFdlbGwsIFJhcGhhw6tsIGNyZWF0ZXMgb25seSBvbmUgZ2xvYmFsIHZhcmlhYmxlIGBSYXBoYWVsYCwgYnV0IGFueXdheS4pIFlvdSBjYW4gdXNlIGBuaW5qYWAgbWV0aG9kLlxuICAgICAqIEJld2FyZSwgdGhhdCBpbiB0aGlzIGNhc2UgcGx1Z2lucyBjb3VsZCBzdG9wIHdvcmtpbmcsIGJlY2F1c2UgdGhleSBhcmUgZGVwZW5kaW5nIG9uIGdsb2JhbCB2YXJpYWJsZSBleGlzdGVuY2UuXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgUmFwaGFlbCBvYmplY3RcbiAgICAgPiBVc2FnZVxuICAgICB8IChmdW5jdGlvbiAobG9jYWxfcmFwaGFlbCkge1xuICAgICB8ICAgICB2YXIgcGFwZXIgPSBsb2NhbF9yYXBoYWVsKDEwLCAxMCwgMzIwLCAyMDApO1xuICAgICB8ICAgICDigKZcbiAgICAgfCB9KShSYXBoYWVsLm5pbmphKCkpO1xuICAgIFxcKi9cbiAgICBSLm5pbmphID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob2xkUmFwaGFlbC53YXMpIHtcbiAgICAgICAgICAgIGcud2luLlJhcGhhZWwgPSBvbGRSYXBoYWVsLmlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSUU4IHJhaXNlcyBhbiBlcnJvciB3aGVuIGRlbGV0aW5nIHdpbmRvdyBwcm9wZXJ0eVxuICAgICAgICAgICAgd2luZG93LlJhcGhhZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuUmFwaGFlbDtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnN0XG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG1ldGhvZCB0byBlbGVtZW50cyBhbmQgc2V0cy4gSXQgaXMgd2lzZSB0byBhZGQgYSBzZXQgbWV0aG9kIGZvciBlYWNoIGVsZW1lbnQgbWV0aG9kXG4gICAgICogeW91IGFkZGVkLCBzbyB5b3Ugd2lsbCBiZSBhYmxlIHRvIGNhbGwgdGhlIHNhbWUgbWV0aG9kIG9uIHNldHMgdG9vLlxuICAgICAqKlxuICAgICAqIFNlZSBhbHNvIEBSYXBoYWVsLmVsLlxuICAgICA+IFVzYWdlXG4gICAgIHwgUmFwaGFlbC5lbC5yZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgIHRoaXMuYXR0cih7ZmlsbDogXCIjZjAwXCJ9KTtcbiAgICAgfCB9O1xuICAgICB8IFJhcGhhZWwuc3QucmVkID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgIHwgICAgICAgICBlbC5yZWQoKTtcbiAgICAgfCAgICAgfSk7XG4gICAgIHwgfTtcbiAgICAgfCAvLyB0aGVuIHVzZSBpdFxuICAgICB8IHBhcGVyLnNldChwYXBlci5jaXJjbGUoMTAwLCAxMDAsIDIwKSwgcGFwZXIuY2lyY2xlKDExMCwgMTAwLCAyMCkpLnJlZCgpO1xuICAgIFxcKi9cbiAgICBSLnN0ID0gc2V0cHJvdG87XG5cbiAgICBldmUub24oXCJyYXBoYWVsLkRPTWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gRmlyZWZveCA8My42IGZpeDogaHR0cDovL3dlYnJlZmxlY3Rpb24uYmxvZ3Nwb3QuY29tLzIwMDkvMTEvMTk1LWNoYXJzLXRvLWhlbHAtbGF6eS1sb2FkaW5nLmh0bWxcbiAgICAoZnVuY3Rpb24gKGRvYywgbG9hZGVkLCBmKSB7XG4gICAgICAgIGlmIChkb2MucmVhZHlTdGF0ZSA9PSBudWxsICYmIGRvYy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKGxvYWRlZCwgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihsb2FkZWQsIGYsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb2MucmVhZHlTdGF0ZSA9IFwiY29tcGxldGVcIjtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIGRvYy5yZWFkeVN0YXRlID0gXCJsb2FkaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNMb2FkZWQoKSB7XG4gICAgICAgICAgICAoL2luLykudGVzdChkb2MucmVhZHlTdGF0ZSkgPyBzZXRUaW1lb3V0KGlzTG9hZGVkLCA5KSA6IFIuZXZlKFwicmFwaGFlbC5ET01sb2FkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzTG9hZGVkKCk7XG4gICAgfSkoZG9jdW1lbnQsIFwiRE9NQ29udGVudExvYWRlZFwiKTtcblxuICAgIHJldHVybiBSO1xufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2Rldi9yYXBoYWVsLnN2Zy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2Rldi9yYXBoYWVsLnN2Zy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmFwaGFlbC5jb3JlICovIFwiLi9kZXYvcmFwaGFlbC5jb3JlLmpzXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oUikge1xuICAgIGlmIChSICYmICFSLnN2Zykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgICAgdG9JbnQgPSBwYXJzZUludCxcbiAgICAgICAgbWF0aCA9IE1hdGgsXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgYWJzID0gbWF0aC5hYnMsXG4gICAgICAgIHBvdyA9IG1hdGgucG93LFxuICAgICAgICBzZXBhcmF0b3IgPSAvWywgXSsvLFxuICAgICAgICBldmUgPSBSLmV2ZSxcbiAgICAgICAgRSA9IFwiXCIsXG4gICAgICAgIFMgPSBcIiBcIjtcbiAgICB2YXIgeGxpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgbWFya2VycyA9IHtcbiAgICAgICAgICAgIGJsb2NrOiBcIk01LDAgMCwyLjUgNSw1elwiLFxuICAgICAgICAgICAgY2xhc3NpYzogXCJNNSwwIDAsMi41IDUsNSAzLjUsMyAzLjUsMnpcIixcbiAgICAgICAgICAgIGRpYW1vbmQ6IFwiTTIuNSwwIDUsMi41IDIuNSw1IDAsMi41elwiLFxuICAgICAgICAgICAgb3BlbjogXCJNNiwxIDEsMy41IDYsNlwiLFxuICAgICAgICAgICAgb3ZhbDogXCJNMi41LDBBMi41LDIuNSwwLDAsMSwyLjUsNSAyLjUsMi41LDAsMCwxLDIuNSwwelwiXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlckNvdW50ZXIgPSB7fTtcbiAgICBSLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIFwiWW91ciBicm93c2VyIHN1cHBvcnRzIFNWRy5cXG5Zb3UgYXJlIHJ1bm5pbmcgUmFwaGFcXHhlYmwgXCIgKyB0aGlzLnZlcnNpb247XG4gICAgfTtcbiAgICB2YXIgJCA9IGZ1bmN0aW9uIChlbCwgYXR0cikge1xuICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZWwgPSAkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSBpZiAoYXR0cltoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBrZXkuc3Vic3RyaW5nKDYpLCBTdHIoYXR0cltrZXldKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgU3RyKGF0dHJba2V5XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gUi5fZy5kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgZWwpO1xuICAgICAgICAgICAgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLndlYmtpdFRhcEhpZ2hsaWdodENvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuICAgIGFkZEdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBncmFkaWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IFwibGluZWFyXCIsXG4gICAgICAgICAgICBpZCA9IGVsZW1lbnQuaWQgKyBncmFkaWVudCxcbiAgICAgICAgICAgIGZ4ID0gLjUsIGZ5ID0gLjUsXG4gICAgICAgICAgICBvID0gZWxlbWVudC5ub2RlLFxuICAgICAgICAgICAgU1ZHID0gZWxlbWVudC5wYXBlcixcbiAgICAgICAgICAgIHMgPSBvLnN0eWxlLFxuICAgICAgICAgICAgZWwgPSBSLl9nLmRvYy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gU3RyKGdyYWRpZW50KS5yZXBsYWNlKFIuX3JhZGlhbF9ncmFkaWVudCwgZnVuY3Rpb24gKGFsbCwgX2Z4LCBfZnkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJyYWRpYWxcIjtcbiAgICAgICAgICAgICAgICBpZiAoX2Z4ICYmIF9meSkge1xuICAgICAgICAgICAgICAgICAgICBmeCA9IHRvRmxvYXQoX2Z4KTtcbiAgICAgICAgICAgICAgICAgICAgZnkgPSB0b0Zsb2F0KF9meSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSAoKGZ5ID4gLjUpICogMiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3coZnggLSAuNSwgMikgKyBwb3coZnkgLSAuNSwgMikgPiAuMjUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChmeSA9IG1hdGguc3FydCguMjUgLSBwb3coZnggLSAuNSwgMikpICogZGlyICsgLjUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBmeSAhPSAuNSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ5ID0gZnkudG9GaXhlZCg1KSAtIDFlLTUgKiBkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC5zcGxpdCgvXFxzKlxcLVxccyovKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwibGluZWFyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBncmFkaWVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gLXRvRmxvYXQoYW5nbGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBbMCwgMCwgbWF0aC5jb3MoUi5yYWQoYW5nbGUpKSwgbWF0aC5zaW4oUi5yYWQoYW5nbGUpKV0sXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IDEgLyAobW1heChhYnModmVjdG9yWzJdKSwgYWJzKHZlY3RvclszXSkpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHZlY3RvclsyXSAqPSBtYXg7XG4gICAgICAgICAgICAgICAgdmVjdG9yWzNdICo9IG1heDtcbiAgICAgICAgICAgICAgICBpZiAodmVjdG9yWzJdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JbMF0gPSAtdmVjdG9yWzJdO1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JbMl0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmVjdG9yWzNdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JbMV0gPSAtdmVjdG9yWzNdO1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JbM10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkb3RzID0gUi5fcGFyc2VEb3RzKGdyYWRpZW50KTtcbiAgICAgICAgICAgIGlmICghZG90cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQgPSBpZC5yZXBsYWNlKC9bXFwoXFwpXFxzLFxceGIwI10vZywgXCJfXCIpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ncmFkaWVudCAmJiBpZCAhPSBlbGVtZW50LmdyYWRpZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgU1ZHLmRlZnMucmVtb3ZlQ2hpbGQoZWxlbWVudC5ncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZ3JhZGllbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZWxlbWVudC5ncmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGVsID0gJCh0eXBlICsgXCJHcmFkaWVudFwiLCB7aWQ6IGlkfSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ncmFkaWVudCA9IGVsO1xuICAgICAgICAgICAgICAgICQoZWwsIHR5cGUgPT0gXCJyYWRpYWxcIiA/IHtcbiAgICAgICAgICAgICAgICAgICAgZng6IGZ4LFxuICAgICAgICAgICAgICAgICAgICBmeTogZnlcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICB4MTogdmVjdG9yWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MTogdmVjdG9yWzFdLFxuICAgICAgICAgICAgICAgICAgICB4MjogdmVjdG9yWzJdLFxuICAgICAgICAgICAgICAgICAgICB5MjogdmVjdG9yWzNdLFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogZWxlbWVudC5tYXRyaXguaW52ZXJ0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBTVkcuZGVmcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZG90cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKCQoXCJzdG9wXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZG90c1tpXS5vZmZzZXQgPyBkb3RzW2ldLm9mZnNldCA6IGkgPyBcIjEwMCVcIiA6IFwiMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RvcC1jb2xvclwiOiBkb3RzW2ldLmNvbG9yIHx8IFwiI2ZmZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdG9wLW9wYWNpdHlcIjogaXNGaW5pdGUoZG90c1tpXS5vcGFjaXR5KSA/IGRvdHNbaV0ub3BhY2l0eSA6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkKG8sIHtcbiAgICAgICAgICAgIGZpbGw6IGZpbGx1cmwoaWQpLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHMuZmlsbCA9IEU7XG4gICAgICAgIHMub3BhY2l0eSA9IDE7XG4gICAgICAgIHMuZmlsbE9wYWNpdHkgPSAxO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGlzSUU5b3IxMCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgcmV0dXJuIG1vZGUgJiYgKG1vZGUgPT09IDkgfHwgbW9kZSA9PT0gMTApO1xuICAgIH0sXG4gICAgZmlsbHVybCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGlzSUU5b3IxMCgpKSB7XG4gICAgICAgICAgcmV0dXJuIFwidXJsKCcjXCIgKyBpZCArIFwiJylcIjtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhdGlvbiA9IGRvY3VtZW50LmxvY2F0aW9uO1xuICAgICAgdmFyIGxvY2F0aW9uU3RyaW5nID0gKFxuICAgICAgICAgIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArXG4gICAgICAgICAgbG9jYXRpb24uaG9zdCArXG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgK1xuICAgICAgICAgIGxvY2F0aW9uLnNlYXJjaFxuICAgICAgKTtcbiAgICAgIHJldHVybiBcInVybCgnXCIgKyBsb2NhdGlvblN0cmluZyArIFwiI1wiICsgaWQgKyBcIicpXCI7XG4gICAgfSxcbiAgICB1cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBiYm94ID0gby5nZXRCQm94KDEpO1xuICAgICAgICAkKG8ucGF0dGVybiwge3BhdHRlcm5UcmFuc2Zvcm06IG8ubWF0cml4LmludmVydCgpICsgXCIgdHJhbnNsYXRlKFwiICsgYmJveC54ICsgXCIsXCIgKyBiYm94LnkgKyBcIilcIn0pO1xuICAgIH0sXG4gICAgYWRkQXJyb3cgPSBmdW5jdGlvbiAobywgdmFsdWUsIGlzRW5kKSB7XG4gICAgICAgIGlmIChvLnR5cGUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBTdHIodmFsdWUpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCItXCIpLFxuICAgICAgICAgICAgICAgIHAgPSBvLnBhcGVyLFxuICAgICAgICAgICAgICAgIHNlID0gaXNFbmQgPyBcImVuZFwiIDogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgIG5vZGUgPSBvLm5vZGUsXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBvLmF0dHJzLFxuICAgICAgICAgICAgICAgIHN0cm9rZSA9IGF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgICAgICAgICAgIGkgPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBcImNsYXNzaWNcIixcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgIHJlZlgsXG4gICAgICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgICAgICB3ID0gMyxcbiAgICAgICAgICAgICAgICBoID0gMyxcbiAgICAgICAgICAgICAgICB0ID0gNTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzaWNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm92YWxcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpZGVcIjogaCA9IDU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmFycm93XCI6IGggPSAyOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvbmdcIjogdyA9IDU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2hvcnRcIjogdyA9IDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09IFwib3BlblwiKSB7XG4gICAgICAgICAgICAgICAgdyArPSAyO1xuICAgICAgICAgICAgICAgIGggKz0gMjtcbiAgICAgICAgICAgICAgICB0ICs9IDI7XG4gICAgICAgICAgICAgICAgZHggPSAxO1xuICAgICAgICAgICAgICAgIHJlZlggPSBpc0VuZCA/IDQgOiAxO1xuICAgICAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGF0dHJzLnN0cm9rZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZlggPSBkeCA9IHcgLyAyO1xuICAgICAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGF0dHJzLnN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoby5fLmFycm93cykge1xuICAgICAgICAgICAgICAgIGlmIChpc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICBvLl8uYXJyb3dzLmVuZFBhdGggJiYgbWFya2VyQ291bnRlcltvLl8uYXJyb3dzLmVuZFBhdGhdLS07XG4gICAgICAgICAgICAgICAgICAgIG8uXy5hcnJvd3MuZW5kTWFya2VyICYmIG1hcmtlckNvdW50ZXJbby5fLmFycm93cy5lbmRNYXJrZXJdLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgby5fLmFycm93cy5zdGFydFBhdGggJiYgbWFya2VyQ291bnRlcltvLl8uYXJyb3dzLnN0YXJ0UGF0aF0tLTtcbiAgICAgICAgICAgICAgICAgICAgby5fLmFycm93cy5zdGFydE1hcmtlciAmJiBtYXJrZXJDb3VudGVyW28uXy5hcnJvd3Muc3RhcnRNYXJrZXJdLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvLl8uYXJyb3dzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoSWQgPSBcInJhcGhhZWwtbWFya2VyLVwiICsgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VySWQgPSBcInJhcGhhZWwtbWFya2VyLVwiICsgc2UgKyB0eXBlICsgdyArIGggKyBcIi1vYmpcIiArIG8uaWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFSLl9nLmRvYy5nZXRFbGVtZW50QnlJZChwYXRoSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZGVmcy5hcHBlbmRDaGlsZCgkKCQoXCJwYXRoXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ6IG1hcmtlcnNbdHlwZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcGF0aElkXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlcltwYXRoSWRdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJDb3VudGVyW3BhdGhJZF0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IFIuX2cuZG9jLmdldEVsZW1lbnRCeUlkKG1hcmtlcklkKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlO1xuICAgICAgICAgICAgICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlciA9ICQoJChcIm1hcmtlclwiKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1hcmtlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyV2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWDogcmVmWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlk6IGggLyAyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1c2UgPSAkKCQoXCJ1c2VcIiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieGxpbms6aHJlZlwiOiBcIiNcIiArIHBhdGhJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogKGlzRW5kID8gXCJyb3RhdGUoMTgwIFwiICsgdyAvIDIgKyBcIiBcIiArIGggLyAyICsgXCIpIFwiIDogRSkgKyBcInNjYWxlKFwiICsgdyAvIHQgKyBcIixcIiArIGggLyB0ICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAoMSAvICgodyAvIHQgKyBoIC8gdCkgLyAyKSkudG9GaXhlZCg0KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmFwcGVuZENoaWxkKHVzZSk7XG4gICAgICAgICAgICAgICAgICAgIHAuZGVmcy5hcHBlbmRDaGlsZChtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJDb3VudGVyW21hcmtlcklkXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlclttYXJrZXJJZF0rKztcbiAgICAgICAgICAgICAgICAgICAgdXNlID0gbWFya2VyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidXNlXCIpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHVzZSwgYXR0cik7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZHggKiAodHlwZSAhPSBcImRpYW1vbmRcIiAmJiB0eXBlICE9IFwib3ZhbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IG8uXy5hcnJvd3Muc3RhcnRkeCAqIHN0cm9rZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFIuZ2V0VG90YWxMZW5ndGgoYXR0cnMucGF0aCkgLSBkZWx0YSAqIHN0cm9rZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZGVsdGEgKiBzdHJva2U7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gUi5nZXRUb3RhbExlbmd0aChhdHRycy5wYXRoKSAtIChvLl8uYXJyb3dzLmVuZGR4ICogc3Ryb2tlIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgYXR0cltcIm1hcmtlci1cIiArIHNlXSA9IFwidXJsKCNcIiArIG1hcmtlcklkICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRvIHx8IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5kID0gUi5nZXRTdWJwYXRoKGF0dHJzLnBhdGgsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJChub2RlLCBhdHRyKTtcbiAgICAgICAgICAgICAgICBvLl8uYXJyb3dzW3NlICsgXCJQYXRoXCJdID0gcGF0aElkO1xuICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Nbc2UgKyBcIk1hcmtlclwiXSA9IG1hcmtlcklkO1xuICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Nbc2UgKyBcImR4XCJdID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgby5fLmFycm93c1tzZSArIFwiVHlwZVwiXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgby5fLmFycm93c1tzZSArIFwiU3RyaW5nXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gby5fLmFycm93cy5zdGFydGR4ICogc3Ryb2tlIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gUi5nZXRUb3RhbExlbmd0aChhdHRycy5wYXRoKSAtIGZyb207XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gUi5nZXRUb3RhbExlbmd0aChhdHRycy5wYXRoKSAtIChvLl8uYXJyb3dzLmVuZGR4ICogc3Ryb2tlIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvLl8uYXJyb3dzW3NlICsgXCJQYXRoXCJdICYmICQobm9kZSwge2Q6IFIuZ2V0U3VicGF0aChhdHRycy5wYXRoLCBmcm9tLCB0byl9KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5fLmFycm93c1tzZSArIFwiUGF0aFwiXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5fLmFycm93c1tzZSArIFwiTWFya2VyXCJdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvLl8uYXJyb3dzW3NlICsgXCJkeFwiXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5fLmFycm93c1tzZSArIFwiVHlwZVwiXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5fLmFycm93c1tzZSArIFwiU3RyaW5nXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChhdHRyIGluIG1hcmtlckNvdW50ZXIpIGlmIChtYXJrZXJDb3VudGVyW2hhc10oYXR0cikgJiYgIW1hcmtlckNvdW50ZXJbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IFIuX2cuZG9jLmdldEVsZW1lbnRCeUlkKGF0dHIpO1xuICAgICAgICAgICAgICAgIGl0ZW0gJiYgaXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXNoYXJyYXkgPSB7XG4gICAgICAgIFwiLVwiOiBbMywgMV0sXG4gICAgICAgIFwiLlwiOiBbMSwgMV0sXG4gICAgICAgIFwiLS5cIjogWzMsIDEsIDEsIDFdLFxuICAgICAgICBcIi0uLlwiOiBbMywgMSwgMSwgMSwgMSwgMV0sXG4gICAgICAgIFwiLiBcIjogWzEsIDNdLFxuICAgICAgICBcIi0gXCI6IFs0LCAzXSxcbiAgICAgICAgXCItLVwiOiBbOCwgM10sXG4gICAgICAgIFwiLSAuXCI6IFs0LCAzLCAxLCAzXSxcbiAgICAgICAgXCItLS5cIjogWzgsIDMsIDEsIDNdLFxuICAgICAgICBcIi0tLi5cIjogWzgsIDMsIDEsIDMsIDEsIDNdXG4gICAgfSxcbiAgICBhZGREYXNoZXMgPSBmdW5jdGlvbiAobywgdmFsdWUsIHBhcmFtcykge1xuICAgICAgICB2YWx1ZSA9IGRhc2hhcnJheVtTdHIodmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IG8uYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gfHwgXCIxXCIsXG4gICAgICAgICAgICAgICAgYnV0dCA9IHtyb3VuZDogd2lkdGgsIHNxdWFyZTogd2lkdGgsIGJ1dHQ6IDB9W28uYXR0cnNbXCJzdHJva2UtbGluZWNhcFwiXSB8fCBwYXJhbXNbXCJzdHJva2UtbGluZWNhcFwiXV0gfHwgMCxcbiAgICAgICAgICAgICAgICBkYXNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGRhc2hlc1tpXSA9IHZhbHVlW2ldICogd2lkdGggKyAoKGkgJSAyKSA/IDEgOiAtMSkgKiBidXR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChvLm5vZGUsIHtcInN0cm9rZS1kYXNoYXJyYXlcIjogZGFzaGVzLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgJChvLm5vZGUsIHtcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJub25lXCJ9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0RmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uIChvLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBvLm5vZGUsXG4gICAgICAgICAgICBhdHRycyA9IG8uYXR0cnMsXG4gICAgICAgICAgICB2aXMgPSBub2RlLnN0eWxlLnZpc2liaWxpdHk7XG4gICAgICAgIG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFSLl9hdmFpbGFibGVBdHRyc1toYXNdKGF0dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1thdHRdO1xuICAgICAgICAgICAgICAgIGF0dHJzW2F0dF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgby5ibHVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aXRsZVwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBleGlzdGluZyA8dGl0bGU+LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlLmxlbmd0aCAmJiAodGl0bGUgPSB0aXRsZVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gJChcInRpdGxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gUi5fZy5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZS5hcHBlbmRDaGlsZCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG4gPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG4udGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhsID0gJChcImFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG4uaW5zZXJ0QmVmb3JlKGhsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbiA9IGhsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dCA9PSBcInRhcmdldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG4uc2V0QXR0cmlidXRlTlMoeGxpbmssIFwic2hvd1wiLCB2YWx1ZSA9PSBcImJsYW5rXCIgPyBcIm5ld1wiIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbi5zZXRBdHRyaWJ1dGVOUyh4bGluaywgYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImN1cnNvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5jdXJzb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnRyYW5zZm9ybSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFycm93LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBcnJvdyhvLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFycm93LWVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQXJyb3cobywgdmFsdWUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGlwLXJlY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gU3RyKHZhbHVlKS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3QubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmNsaXAgJiYgby5jbGlwLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvLmNsaXAucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gJChcImNsaXBQYXRoXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYyA9ICQoXCJyZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlkID0gUi5jcmVhdGVVVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChyYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiByZWN0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiByZWN0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0WzNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQocmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGFwZXIuZGVmcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7XCJjbGlwLXBhdGhcIjogXCJ1cmwoI1wiICsgZWwuaWQgKyBcIilcIn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uY2xpcCA9IHJjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBSLl9nLmRvYy5nZXRFbGVtZW50QnlJZChwYXRoLnJlcGxhY2UoLyhedXJsXFwoI3xcXCkkKS9nLCBFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAgJiYgY2xpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG5vZGUsIHtcImNsaXAtcGF0aFwiOiBFfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvLmNsaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnR5cGUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG5vZGUsIHtkOiB2YWx1ZSA/IGF0dHJzLnBhdGggPSBSLl9wYXRoVG9BYnNvbHV0ZSh2YWx1ZSkgOiBcIk0wLDBcIn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uXy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFydFN0cmluZ1wiIGluIG8uXy5hcnJvd3MgJiYgYWRkQXJyb3cobywgby5fLmFycm93cy5zdGFydFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5kU3RyaW5nXCIgaW4gby5fLmFycm93cyAmJiBhZGRBcnJvdyhvLCBvLl8uYXJyb3dzLmVuZFN0cmluZywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ID0gXCJ4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdHRycy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5meCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gLWF0dHJzLnggLSAoYXR0cnMud2lkdGggfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyeFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dCA9PSBcInJ4XCIgJiYgby50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjeFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnBhdHRlcm4gJiYgdXBkYXRlUG9zaXRpb24obyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5meSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dCA9IFwieVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnMueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IC1hdHRycy55IC0gKGF0dHJzLmhlaWdodCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ID09IFwicnlcIiAmJiBvLnR5cGUgPT0gXCJyZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImN5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0dGVybiAmJiB1cGRhdGVQb3NpdGlvbihvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnR5cGUgPT0gXCJyZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG5vZGUsIHtyeDogdmFsdWUsIHJ5OiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8udHlwZSA9PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBcImhyZWZcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJva2Utd2lkdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLl8uc3ggIT0gMSB8fCBvLl8uc3kgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIC89IG1tYXgoYWJzKG8uXy5zeCksIGFicyhvLl8uc3kpKSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnNbXCJzdHJva2UtZGFzaGFycmF5XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGFzaGVzKG8sIGF0dHJzW1wic3Ryb2tlLWRhc2hhcnJheVwiXSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLl8uYXJyb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFydFN0cmluZ1wiIGluIG8uXy5hcnJvd3MgJiYgYWRkQXJyb3cobywgby5fLmFycm93cy5zdGFydFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbmRTdHJpbmdcIiBpbiBvLl8uYXJyb3dzICYmIGFkZEFycm93KG8sIG8uXy5hcnJvd3MuZW5kU3RyaW5nLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3Ryb2tlLWRhc2hhcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGFzaGVzKG8sIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNVUkwgPSBTdHIodmFsdWUpLm1hdGNoKFIuX0lTVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VSTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gJChcInBhdHRlcm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlnID0gJChcImltYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlkID0gUi5jcmVhdGVVVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbCwge3g6IDAsIHk6IDAsIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCBoZWlnaHQ6IDEsIHdpZHRoOiAxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChpZywge3g6IDAsIHk6IDAsIFwieGxpbms6aHJlZlwiOiBpc1VSTFsxXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGlnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5fcHJlbG9hZChpc1VSTFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB0aGlzLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSB0aGlzLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZWwsIHt3aWR0aDogdywgaGVpZ2h0OiBofSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGlnLCB7d2lkdGg6IHcsIGhlaWdodDogaH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KShlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXBlci5kZWZzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG5vZGUsIHtmaWxsOiBcInVybCgjXCIgKyBlbC5pZCArIFwiKVwifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXR0ZXJuID0gZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXR0ZXJuICYmIHVwZGF0ZVBvc2l0aW9uKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsciA9IFIuZ2V0UkdCKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5ncmFkaWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnMuZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIVIuaXMoYXR0cnMub3BhY2l0eSwgXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5pcyhwYXJhbXMub3BhY2l0eSwgXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7b3BhY2l0eTogYXR0cnMub3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFSLmlzKGF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdLCBcInVuZGVmaW5lZFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLmlzKHBhcmFtc1tcImZpbGwtb3BhY2l0eVwiXSwgXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7XCJmaWxsLW9wYWNpdHlcIjogYXR0cnNbXCJmaWxsLW9wYWNpdHlcIl19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG8udHlwZSA9PSBcImNpcmNsZVwiIHx8IG8udHlwZSA9PSBcImVsbGlwc2VcIiB8fCBTdHIodmFsdWUpLmNoYXJBdCgpICE9IFwiclwiKSAmJiBhZGRHcmFkaWVudEZpbGwobywgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib3BhY2l0eVwiIGluIGF0dHJzIHx8IFwiZmlsbC1vcGFjaXR5XCIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gUi5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQobm9kZS5nZXRBdHRyaWJ1dGUoXCJmaWxsXCIpLnJlcGxhY2UoL151cmxcXCgjfFxcKSQvZywgRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGdyYWRpZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0sIHtcInN0b3Atb3BhY2l0eVwiOiAoXCJvcGFjaXR5XCIgaW4gYXR0cnMgPyBhdHRycy5vcGFjaXR5IDogMSkgKiAoXCJmaWxsLW9wYWNpdHlcIiBpbiBhdHRycyA/IGF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdIDogMSl9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5ncmFkaWVudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNscltoYXNdKFwib3BhY2l0eVwiKSAmJiAkKG5vZGUsIHtcImZpbGwtb3BhY2l0eVwiOiBjbHIub3BhY2l0eSA+IDEgPyBjbHIub3BhY2l0eSAvIDEwMCA6IGNsci5vcGFjaXR5fSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJva2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsciA9IFIuZ2V0UkdCKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgY2xyLmhleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHQgPT0gXCJzdHJva2VcIiAmJiBjbHJbaGFzXShcIm9wYWNpdHlcIikgJiYgJChub2RlLCB7XCJzdHJva2Utb3BhY2l0eVwiOiBjbHIub3BhY2l0eSA+IDEgPyBjbHIub3BhY2l0eSAvIDEwMCA6IGNsci5vcGFjaXR5fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ID09IFwic3Ryb2tlXCIgJiYgby5fLmFycm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRTdHJpbmdcIiBpbiBvLl8uYXJyb3dzICYmIGFkZEFycm93KG8sIG8uXy5hcnJvd3Muc3RhcnRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5kU3RyaW5nXCIgaW4gby5fLmFycm93cyAmJiBhZGRBcnJvdyhvLCBvLl8uYXJyb3dzLmVuZFN0cmluZywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdyYWRpZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAoby50eXBlID09IFwiY2lyY2xlXCIgfHwgby50eXBlID09IFwiZWxsaXBzZVwiIHx8IFN0cih2YWx1ZSkuY2hhckF0KCkgIT0gXCJyXCIpICYmIGFkZEdyYWRpZW50RmlsbChvLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wYWNpdHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5ncmFkaWVudCAmJiAhYXR0cnNbaGFzXShcInN0cm9rZS1vcGFjaXR5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7XCJzdHJva2Utb3BhY2l0eVwiOiB2YWx1ZSA+IDEgPyB2YWx1ZSAvIDEwMCA6IHZhbHVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxsLW9wYWNpdHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5ncmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gUi5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQobm9kZS5nZXRBdHRyaWJ1dGUoXCJmaWxsXCIpLnJlcGxhY2UoL151cmxcXCgjfFxcKSQvZywgRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wcyA9IGdyYWRpZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzdG9wc1tzdG9wcy5sZW5ndGggLSAxXSwge1wic3RvcC1vcGFjaXR5XCI6IHZhbHVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ID09IFwiZm9udC1zaXplXCIgJiYgKHZhbHVlID0gdG9JbnQodmFsdWUsIDEwKSArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzcnVsZSA9IGF0dC5yZXBsYWNlKC8oXFwtLikvZywgZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdy5zdWJzdHJpbmcoMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtjc3NydWxlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHVuZVRleHQobywgcGFyYW1zKTtcbiAgICAgICAgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gdmlzO1xuICAgIH0sXG4gICAgbGVhZGluZyA9IDEuMixcbiAgICB0dW5lVGV4dCA9IGZ1bmN0aW9uIChlbCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChlbC50eXBlICE9IFwidGV4dFwiIHx8ICEocGFyYW1zW2hhc10oXCJ0ZXh0XCIpIHx8IHBhcmFtc1toYXNdKFwiZm9udFwiKSB8fCBwYXJhbXNbaGFzXShcImZvbnQtc2l6ZVwiKSB8fCBwYXJhbXNbaGFzXShcInhcIikgfHwgcGFyYW1zW2hhc10oXCJ5XCIpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gZWwuYXR0cnMsXG4gICAgICAgICAgICBub2RlID0gZWwubm9kZSxcbiAgICAgICAgICAgIGZvbnRTaXplID0gbm9kZS5maXJzdENoaWxkID8gdG9JbnQoUi5fZy5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLmZpcnN0Q2hpbGQsIEUpLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXNpemVcIiksIDEwKSA6IDEwO1xuXG4gICAgICAgIGlmIChwYXJhbXNbaGFzXShcInRleHRcIikpIHtcbiAgICAgICAgICAgIGEudGV4dCA9IHBhcmFtcy50ZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZXh0cyA9IFN0cihwYXJhbXMudGV4dCkuc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICAgICAgdHNwYW5zID0gW10sXG4gICAgICAgICAgICAgICAgdHNwYW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZXh0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHNwYW4gPSAkKFwidHNwYW5cIik7XG4gICAgICAgICAgICAgICAgaSAmJiAkKHRzcGFuLCB7ZHk6IGZvbnRTaXplICogbGVhZGluZywgeDogYS54fSk7XG4gICAgICAgICAgICAgICAgdHNwYW4uYXBwZW5kQ2hpbGQoUi5fZy5kb2MuY3JlYXRlVGV4dE5vZGUodGV4dHNbaV0pKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcbiAgICAgICAgICAgICAgICB0c3BhbnNbaV0gPSB0c3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRzcGFucyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gdHNwYW5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgJCh0c3BhbnNbaV0sIHtkeTogZm9udFNpemUgKiBsZWFkaW5nLCB4OiBhLnh9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0c3BhbnNbMF0sIHtkeTogMH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICQobm9kZSwge3g6IGEueCwgeTogYS55fSk7XG4gICAgICAgIGVsLl8uZGlydHkgPSAxO1xuICAgICAgICB2YXIgYmIgPSBlbC5fZ2V0QkJveCgpLFxuICAgICAgICAgICAgZGlmID0gYS55IC0gKGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgZGlmICYmIFIuaXMoZGlmLCBcImZpbml0ZVwiKSAmJiAkKHRzcGFuc1swXSwge2R5OiBkaWZ9KTtcbiAgICB9LFxuICAgIGdldFJlYWxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN2Zykge1xuICAgICAgICB2YXIgWCA9IDAsXG4gICAgICAgICAgICBZID0gMDtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBFbGVtZW50Lm5vZGVcbiAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgKipcbiAgICAgICAgICogR2l2ZXMgeW91IGEgcmVmZXJlbmNlIHRvIHRoZSBET00gb2JqZWN0LCBzbyB5b3UgY2FuIGFzc2lnbiBldmVudCBoYW5kbGVycyBvciBqdXN0IG1lc3MgYXJvdW5kLlxuICAgICAgICAgKipcbiAgICAgICAgICogTm90ZTogRG9u4oCZdCBtZXNzIHdpdGggaXQuXG4gICAgICAgICA+IFVzYWdlXG4gICAgICAgICB8IC8vIGRyYXcgYSBjaXJjbGUgYXQgY29vcmRpbmF0ZSAxMCwxMCB3aXRoIHJhZGl1cyBvZiAxMFxuICAgICAgICAgfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKTtcbiAgICAgICAgIHwgYy5ub2RlLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICB8ICAgICBjLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpO1xuICAgICAgICAgfCB9O1xuICAgICAgICBcXCovXG4gICAgICAgIHRoaXNbMF0gPSB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQucmFwaGFlbFxuICAgICAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBJbnRlcm5hbCByZWZlcmVuY2UgdG8gQFJhcGhhZWwgb2JqZWN0LiBJbiBjYXNlIGl0IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICA+IFVzYWdlXG4gICAgICAgICB8IFJhcGhhZWwuZWwucmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgfCAgICAgdmFyIGhzYiA9IHRoaXMucGFwZXIucmFwaGFlbC5yZ2IyaHNiKHRoaXMuYXR0cihcImZpbGxcIikpO1xuICAgICAgICAgfCAgICAgaHNiLmggPSAxO1xuICAgICAgICAgfCAgICAgdGhpcy5hdHRyKHtmaWxsOiB0aGlzLnBhcGVyLnJhcGhhZWwuaHNiMnJnYihoc2IpLmhleH0pO1xuICAgICAgICAgfCB9XG4gICAgICAgIFxcKi9cbiAgICAgICAgbm9kZS5yYXBoYWVsID0gdHJ1ZTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBFbGVtZW50LmlkXG4gICAgICAgICBbIHByb3BlcnR5IChudW1iZXIpIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFVuaXF1ZSBpZCBvZiB0aGUgZWxlbWVudC4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9mIHRoZSBlbGVtZW50LFxuICAgICAgICAgKiBiZWNhdXNlIGFsbCBldmVudHMgYXJlIGZpcmVkIGluIGZvcm1hdCBgPG1vZHVsZT4uPGFjdGlvbj4uPGlkPmAuIEFsc28gdXNlZnVsIGZvciBAUGFwZXIuZ2V0QnlJZCBtZXRob2QuXG4gICAgICAgIFxcKi9cbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgbm9kZS5yYXBoYWVsaWQgPSB0aGlzLmlkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgYSA1IGxldHRlci9kaWdpdCBpZCwgZW5vdWdoIGZvciAzNl41ID0gNjA0NjYxNzYgZWxlbWVudHNcbiAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBpZFxuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBndWlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIjAwMDBcIiArIChNYXRoLnJhbmRvbSgpKk1hdGgucG93KDM2LDUpIDw8IDApLnRvU3RyaW5nKDM2KSkuc2xpY2UoLTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXggPSBSLm1hdHJpeCgpO1xuICAgICAgICB0aGlzLnJlYWxQYXRoID0gbnVsbDtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBFbGVtZW50LnBhcGVyXG4gICAgICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIEludGVybmFsIHJlZmVyZW5jZSB0byDigJxwYXBlcuKAnSB3aGVyZSBvYmplY3QgZHJhd24uIE1haW5seSBmb3IgdXNlIGluIHBsdWdpbnMgYW5kIGVsZW1lbnQgZXh0ZW5zaW9ucy5cbiAgICAgICAgID4gVXNhZ2VcbiAgICAgICAgIHwgUmFwaGFlbC5lbC5jcm9zcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHwgICAgIHRoaXMuYXR0cih7ZmlsbDogXCJyZWRcIn0pO1xuICAgICAgICAgfCAgICAgdGhpcy5wYXBlci5wYXRoKFwiTTEwLDEwTDUwLDUwTTUwLDEwTDEwLDUwXCIpXG4gICAgICAgICB8ICAgICAgICAgLmF0dHIoe3N0cm9rZTogXCJyZWRcIn0pO1xuICAgICAgICAgfCB9XG4gICAgICAgIFxcKi9cbiAgICAgICAgdGhpcy5wYXBlciA9IHN2ZztcbiAgICAgICAgdGhpcy5hdHRycyA9IHRoaXMuYXR0cnMgfHwge307XG4gICAgICAgIHRoaXMuXyA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogW10sXG4gICAgICAgICAgICBzeDogMSxcbiAgICAgICAgICAgIHN5OiAxLFxuICAgICAgICAgICAgZGVnOiAwLFxuICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICBkeTogMCxcbiAgICAgICAgICAgIGRpcnR5OiAxXG4gICAgICAgIH07XG4gICAgICAgICFzdmcuYm90dG9tICYmIChzdmcuYm90dG9tID0gdGhpcyk7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogRWxlbWVudC5wcmV2XG4gICAgICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgZWxlbWVudCBpbiB0aGUgaGllcmFyY2h5LlxuICAgICAgICBcXCovXG4gICAgICAgIHRoaXMucHJldiA9IHN2Zy50b3A7XG4gICAgICAgIHN2Zy50b3AgJiYgKHN2Zy50b3AubmV4dCA9IHRoaXMpO1xuICAgICAgICBzdmcudG9wID0gdGhpcztcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBFbGVtZW50Lm5leHRcbiAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBuZXh0IGVsZW1lbnQgaW4gdGhlIGhpZXJhcmNoeS5cbiAgICAgICAgXFwqL1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH0sXG4gICAgZWxwcm90byA9IFIuZWw7XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IGVscHJvdG87XG4gICAgZWxwcm90by5jb25zdHJ1Y3RvciA9IEVsZW1lbnQ7XG5cbiAgICBSLl9lbmdpbmUucGF0aCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBTVkcpIHtcbiAgICAgICAgdmFyIGVsID0gJChcInBhdGhcIik7XG4gICAgICAgIFNWRy5jYW52YXMgJiYgU1ZHLmNhbnZhcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciBwID0gbmV3IEVsZW1lbnQoZWwsIFNWRyk7XG4gICAgICAgIHAudHlwZSA9IFwicGF0aFwiO1xuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHAsIHtcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDBcIixcbiAgICAgICAgICAgIHBhdGg6IHBhdGhTdHJpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEZXByZWNhdGVkISBVc2UgQEVsZW1lbnQudHJhbnNmb3JtIGluc3RlYWQuXG4gICAgICogQWRkcyByb3RhdGlvbiBieSBnaXZlbiBhbmdsZSBhcm91bmQgZ2l2ZW4gcG9pbnQgdG8gdGhlIGxpc3Qgb2ZcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgb2YgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGRlZyAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlIG9mIHJvdGF0aW9uXG4gICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlIG9mIHJvdGF0aW9uXG4gICAgICogSWYgY3ggJiBjeSBhcmVu4oCZdCBzcGVjaWZpZWQgY2VudHJlIG9mIHRoZSBzaGFwZSBpcyB1c2VkIGFzIGEgcG9pbnQgb2Ygcm90YXRpb24uXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yb3RhdGUgPSBmdW5jdGlvbiAoZGVnLCBjeCwgY3kpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGVnID0gU3RyKGRlZykuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGRlZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjeCA9IHRvRmxvYXQoZGVnWzFdKTtcbiAgICAgICAgICAgIGN5ID0gdG9GbG9hdChkZWdbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZyA9IHRvRmxvYXQoZGVnWzBdKTtcbiAgICAgICAgKGN5ID09IG51bGwpICYmIChjeCA9IGN5KTtcbiAgICAgICAgaWYgKGN4ID09IG51bGwgfHwgY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goMSk7XG4gICAgICAgICAgICBjeCA9IGJib3gueCArIGJib3gud2lkdGggLyAyO1xuICAgICAgICAgICAgY3kgPSBiYm94LnkgKyBiYm94LmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odGhpcy5fLnRyYW5zZm9ybS5jb25jYXQoW1tcInJcIiwgZGVnLCBjeCwgY3ldXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnNjYWxlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEZXByZWNhdGVkISBVc2UgQEVsZW1lbnQudHJhbnNmb3JtIGluc3RlYWQuXG4gICAgICogQWRkcyBzY2FsZSBieSBnaXZlbiBhbW91bnQgcmVsYXRpdmUgdG8gZ2l2ZW4gcG9pbnQgdG8gdGhlIGxpc3Qgb2ZcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgb2YgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHN4IChudW1iZXIpIGhvcmlzb250YWwgc2NhbGUgYW1vdW50XG4gICAgIC0gc3kgKG51bWJlcikgdmVydGljYWwgc2NhbGUgYW1vdW50XG4gICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlIG9mIHNjYWxlXG4gICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlIG9mIHNjYWxlXG4gICAgICogSWYgY3ggJiBjeSBhcmVu4oCZdCBzcGVjaWZpZWQgY2VudHJlIG9mIHRoZSBzaGFwZSBpcyB1c2VkIGluc3RlYWQuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zY2FsZSA9IGZ1bmN0aW9uIChzeCwgc3ksIGN4LCBjeSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzeCA9IFN0cihzeCkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHN4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN5ID0gdG9GbG9hdChzeFsxXSk7XG4gICAgICAgICAgICBjeCA9IHRvRmxvYXQoc3hbMl0pO1xuICAgICAgICAgICAgY3kgPSB0b0Zsb2F0KHN4WzNdKTtcbiAgICAgICAgfVxuICAgICAgICBzeCA9IHRvRmxvYXQoc3hbMF0pO1xuICAgICAgICAoc3kgPT0gbnVsbCkgJiYgKHN5ID0gc3gpO1xuICAgICAgICAoY3kgPT0gbnVsbCkgJiYgKGN4ID0gY3kpO1xuICAgICAgICBpZiAoY3ggPT0gbnVsbCB8fCBjeSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCgxKTtcbiAgICAgICAgfVxuICAgICAgICBjeCA9IGN4ID09IG51bGwgPyBiYm94LnggKyBiYm94LndpZHRoIC8gMiA6IGN4O1xuICAgICAgICBjeSA9IGN5ID09IG51bGwgPyBiYm94LnkgKyBiYm94LmhlaWdodCAvIDIgOiBjeTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odGhpcy5fLnRyYW5zZm9ybS5jb25jYXQoW1tcInNcIiwgc3gsIHN5LCBjeCwgY3ldXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRyYW5zbGF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRGVwcmVjYXRlZCEgVXNlIEBFbGVtZW50LnRyYW5zZm9ybSBpbnN0ZWFkLlxuICAgICAqIEFkZHMgdHJhbnNsYXRpb24gYnkgZ2l2ZW4gYW1vdW50IHRvIHRoZSBsaXN0IG9mIHRyYW5zZm9ybWF0aW9ucyBvZiB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gZHggKG51bWJlcikgaG9yaXNvbnRhbCBzaGlmdFxuICAgICAtIGR5IChudW1iZXIpIHZlcnRpY2FsIHNoaWZ0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0gU3RyKGR4KS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoZHgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZHkgPSB0b0Zsb2F0KGR4WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBkeCA9IHRvRmxvYXQoZHhbMF0pIHx8IDA7XG4gICAgICAgIGR5ID0gK2R5IHx8IDA7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJ0XCIsIGR4LCBkeV1dKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBlbGVtZW50IHdoaWNoIGlzIHNlcGFyYXRlIHRvIG90aGVyIGF0dHJpYnV0ZXMsXG4gICAgICogaS5lLiB0cmFuc2xhdGlvbiBkb2VzbuKAmXQgY2hhbmdlIGB4YCBvciBgeWAgb2YgdGhlIHJlY3RhbmdlLiBUaGUgZm9ybWF0XG4gICAgICogb2YgdHJhbnNmb3JtYXRpb24gc3RyaW5nIGlzIHNpbWlsYXIgdG8gdGhlIHBhdGggc3RyaW5nIHN5bnRheDpcbiAgICAgfCBcInQxMDAsMTAwcjMwLDEwMCwxMDBzMiwyLDEwMCwxMDByNDVzMS41XCJcbiAgICAgKiBFYWNoIGxldHRlciBpcyBhIGNvbW1hbmQuIFRoZXJlIGFyZSBmb3VyIGNvbW1hbmRzOiBgdGAgaXMgZm9yIHRyYW5zbGF0ZSwgYHJgIGlzIGZvciByb3RhdGUsIGBzYCBpcyBmb3JcbiAgICAgKiBzY2FsZSBhbmQgYG1gIGlzIGZvciBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgYWxzbyBhbHRlcm5hdGl2ZSDigJxhYnNvbHV0ZeKAnSB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlOiBgVGAsIGBSYCBhbmQgYFNgLiBUaGV5IHdpbGwgbm90IHRha2UgcHJldmlvdXMgdHJhbnNmb3JtYXRpb24gaW50byBhY2NvdW50LiBGb3IgZXhhbXBsZSwgYC4uLlQxMDAsMGAgd2lsbCBhbHdheXMgbW92ZSBlbGVtZW50IDEwMCBweCBob3Jpc29udGFsbHksIHdoaWxlIGAuLi50MTAwLDBgIGNvdWxkIG1vdmUgaXQgdmVydGljYWxseSBpZiB0aGVyZSBpcyBgcjkwYCBiZWZvcmUuIEp1c3QgY29tcGFyZSByZXN1bHRzIG9mIGByOTB0MTAwLDBgIGFuZCBgcjkwVDEwMCwwYC5cbiAgICAgKlxuICAgICAqIFNvLCB0aGUgZXhhbXBsZSBsaW5lIGFib3ZlIGNvdWxkIGJlIHJlYWQgbGlrZSDigJx0cmFuc2xhdGUgYnkgMTAwLCAxMDA7IHJvdGF0ZSAzMMKwIGFyb3VuZCAxMDAsIDEwMDsgc2NhbGUgdHdpY2UgYXJvdW5kIDEwMCwgMTAwO1xuICAgICAqIHJvdGF0ZSA0NcKwIGFyb3VuZCBjZW50cmU7IHNjYWxlIDEuNSB0aW1lcyByZWxhdGl2ZSB0byBjZW50cmXigJ0uIEFzIHlvdSBjYW4gc2VlIHJvdGF0ZSBhbmQgc2NhbGUgY29tbWFuZHMgaGF2ZSBvcmlnaW5cbiAgICAgKiBjb29yZGluYXRlcyBhcyBvcHRpb25hbCBwYXJhbWV0ZXJzLCB0aGUgZGVmYXVsdCBpcyB0aGUgY2VudHJlIHBvaW50IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIE1hdHJpeCBhY2NlcHRzIHNpeCBwYXJhbWV0ZXJzLlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGVsID0gcGFwZXIucmVjdCgxMCwgMjAsIDMwMCwgMjAwKTtcbiAgICAgfCAvLyB0cmFuc2xhdGUgMTAwLCAxMDAsIHJvdGF0ZSA0NcKwLCB0cmFuc2xhdGUgLTEwMCwgMFxuICAgICB8IGVsLnRyYW5zZm9ybShcInQxMDAsMTAwcjQ1dC0xMDAsMFwiKTtcbiAgICAgfCAvLyBpZiB5b3Ugd2FudCB5b3UgY2FuIGFwcGVuZCBvciBwcmVwZW5kIHRyYW5zZm9ybWF0aW9uc1xuICAgICB8IGVsLnRyYW5zZm9ybShcIi4uLnQ1MCw1MFwiKTtcbiAgICAgfCBlbC50cmFuc2Zvcm0oXCJzMi4uLlwiKTtcbiAgICAgfCAvLyBvciBldmVuIHdyYXBcbiAgICAgfCBlbC50cmFuc2Zvcm0oXCJ0NTAsNTAuLi50LTUwLTUwXCIpO1xuICAgICB8IC8vIHRvIHJlc2V0IHRyYW5zZm9ybWF0aW9uIGNhbGwgbWV0aG9kIHdpdGggZW1wdHkgc3RyaW5nXG4gICAgIHwgZWwudHJhbnNmb3JtKFwiXCIpO1xuICAgICB8IC8vIHRvIGdldCBjdXJyZW50IHZhbHVlIGNhbGwgaXQgd2l0aG91dCBwYXJhbWV0ZXJzXG4gICAgIHwgY29uc29sZS5sb2coZWwudHJhbnNmb3JtKCkpO1xuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSB0c3RyIChzdHJpbmcpICNvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdcbiAgICAgKiBJZiB0c3RyIGlzbuKAmXQgc3BlY2lmaWVkXG4gICAgID0gKHN0cmluZykgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdcbiAgICAgKiBlbHNlXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHN0cikge1xuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgaWYgKHRzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF8udHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIFIuX2V4dHJhY3RUcmFuc2Zvcm0odGhpcywgdHN0cik7XG5cbiAgICAgICAgdGhpcy5jbGlwICYmICQodGhpcy5jbGlwLCB7dHJhbnNmb3JtOiB0aGlzLm1hdHJpeC5pbnZlcnQoKX0pO1xuICAgICAgICB0aGlzLnBhdHRlcm4gJiYgdXBkYXRlUG9zaXRpb24odGhpcyk7XG4gICAgICAgIHRoaXMubm9kZSAmJiAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcblxuICAgICAgICBpZiAoXy5zeCAhPSAxIHx8IF8uc3kgIT0gMSkge1xuICAgICAgICAgICAgdmFyIHN3ID0gdGhpcy5hdHRyc1toYXNdKFwic3Ryb2tlLXdpZHRoXCIpID8gdGhpcy5hdHRyc1tcInN0cm9rZS13aWR0aFwiXSA6IDE7XG4gICAgICAgICAgICB0aGlzLmF0dHIoe1wic3Ryb2tlLXdpZHRoXCI6IHN3fSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmhpZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgaW52aXNpYmxlLiBTZWUgQEVsZW1lbnQuc2hvdy5cbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCF0aGlzLnJlbW92ZWQpIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2hvd1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTWFrZXMgZWxlbWVudCB2aXNpYmxlLiBTZWUgQEVsZW1lbnQuaGlkZS5cbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCF0aGlzLnJlbW92ZWQpIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBmcm9tIHRoZSBwYXBlci5cbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0UmVhbE5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCB8fCAhbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcGFwZXIuX19zZXRfXyAmJiBwYXBlci5fX3NldF9fLmV4Y2x1ZGUodGhpcyk7XG4gICAgICAgIGV2ZS51bmJpbmQoXCJyYXBoYWVsLiouKi5cIiArIHRoaXMuaWQpO1xuICAgICAgICBpZiAodGhpcy5ncmFkaWVudCkge1xuICAgICAgICAgICAgcGFwZXIuZGVmcy5yZW1vdmVDaGlsZCh0aGlzLmdyYWRpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBSLl90ZWFyKHRoaXMsIHBhcGVyKTtcblxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGN1c3RvbSBkYXRhIGZvciBlbGVtZW50XG4gICAgICAgIHRoaXMucmVtb3ZlRGF0YSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHR5cGVvZiB0aGlzW2ldID09IFwiZnVuY3Rpb25cIiA/IFIuX3JlbW92ZWRGYWN0b3J5KGkpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgZWxwcm90by5fZ2V0QkJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIHZhciBoaWRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FudmFzSGlkZGVuID0gZmFsc2UsXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZTtcbiAgICAgICAgaWYgKHRoaXMucGFwZXIuY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjb250YWluZXJTdHlsZSA9IHRoaXMucGFwZXIuY2FudmFzLnBhcmVudEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIH0gLy9JRTEwKyBjYW4ndCBmaW5kIHBhcmVudEVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXBlci5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlID0gdGhpcy5wYXBlci5jYW52YXMucGFyZW50Tm9kZS5zdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNvbnRhaW5lclN0eWxlICYmIGNvbnRhaW5lclN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICBjYW52YXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYm94ID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBiYm94ID0gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IDMuMC54LCAyNS4wLjEgKHByb2JhYmx5IG1vcmUgdmVyc2lvbnMgYWZmZWN0ZWQpIHBsYXkgYmFkbHkgaGVyZSAtIHBvc3NpYmxlIGZpeFxuICAgICAgICAgICAgYmJveCA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLm5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLm5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLm5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLm5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBiYm94ID0gYmJveCB8fCB7fTtcbiAgICAgICAgICAgIGlmKGNhbnZhc0hpZGRlbil7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaWRlICYmIHRoaXMuaGlkZSgpO1xuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmF0dHJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGF0dHJOYW1lIChzdHJpbmcpIGF0dHJpYnV0ZeKAmXMgbmFtZVxuICAgICAtIHZhbHVlIChzdHJpbmcpIHZhbHVlXG4gICAgICogb3JcbiAgICAgLSBwYXJhbXMgKG9iamVjdCkgb2JqZWN0IG9mIG5hbWUvdmFsdWUgcGFpcnNcbiAgICAgKiBvclxuICAgICAtIGF0dHJOYW1lIChzdHJpbmcpIGF0dHJpYnV0ZeKAmXMgbmFtZVxuICAgICAqIG9yXG4gICAgIC0gYXR0ck5hbWVzIChhcnJheSkgaW4gdGhpcyBjYXNlIG1ldGhvZCByZXR1cm5zIGFycmF5IG9mIGN1cnJlbnQgdmFsdWVzIGZvciBnaXZlbiBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudCBpZiBhdHRyc05hbWUgJiB2YWx1ZSBvciBwYXJhbXMgYXJlIHBhc3NlZCBpbi5cbiAgICAgPSAoLi4uKSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGlmIG9ubHkgYXR0cnNOYW1lIGlzIHBhc3NlZCBpbi5cbiAgICAgPSAoYXJyYXkpIGFycmF5IG9mIHZhbHVlcyBvZiB0aGUgYXR0cmlidXRlIGlmIGF0dHJzTmFtZXMgaXMgcGFzc2VkIGluLlxuICAgICA9IChvYmplY3QpIG9iamVjdCBvZiBhdHRyaWJ1dGVzIGlmIG5vdGhpbmcgaXMgcGFzc2VkIGluLlxuICAgICA+IFBvc3NpYmxlIHBhcmFtZXRlcnNcbiAgICAgIyA8cD5QbGVhc2UgcmVmZXIgdG8gdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvXCIgdGl0bGU9XCJUaGUgVzNDIFJlY29tbWVuZGF0aW9uIGZvciB0aGUgU1ZHIGxhbmd1YWdlIGRlc2NyaWJlcyB0aGVzZSBwcm9wZXJ0aWVzIGluIGRldGFpbC5cIj5TVkcgc3BlY2lmaWNhdGlvbjwvYT4gZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHRoZXNlIHBhcmFtZXRlcnMuPC9wPlxuICAgICBvIGFycm93LWVuZCAoc3RyaW5nKSBhcnJvd2hlYWQgb24gdGhlIGVuZCBvZiB0aGUgcGF0aC4gVGhlIGZvcm1hdCBmb3Igc3RyaW5nIGlzIGA8dHlwZT5bLTx3aWR0aD5bLTxsZW5ndGg+XV1gLiBQb3NzaWJsZSB0eXBlczogYGNsYXNzaWNgLCBgYmxvY2tgLCBgb3BlbmAsIGBvdmFsYCwgYGRpYW1vbmRgLCBgbm9uZWAsIHdpZHRoOiBgd2lkZWAsIGBuYXJyb3dgLCBgbWVkaXVtYCwgbGVuZ3RoOiBgbG9uZ2AsIGBzaG9ydGAsIGBtaWRpdW1gLlxuICAgICBvIGNsaXAtcmVjdCAoc3RyaW5nKSBjb21tYSBvciBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzOiB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgIG8gY3Vyc29yIChzdHJpbmcpIENTUyB0eXBlIG9mIHRoZSBjdXJzb3JcbiAgICAgbyBjeCAobnVtYmVyKSB0aGUgeC1heGlzIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLCBvciBlbGxpcHNlXG4gICAgIG8gY3kgKG51bWJlcikgdGhlIHktYXhpcyBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSwgb3IgZWxsaXBzZVxuICAgICBvIGZpbGwgKHN0cmluZykgY29sb3VyLCBncmFkaWVudCBvciBpbWFnZVxuICAgICBvIGZpbGwtb3BhY2l0eSAobnVtYmVyKVxuICAgICBvIGZvbnQgKHN0cmluZylcbiAgICAgbyBmb250LWZhbWlseSAoc3RyaW5nKVxuICAgICBvIGZvbnQtc2l6ZSAobnVtYmVyKSBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAgIG8gZm9udC13ZWlnaHQgKHN0cmluZylcbiAgICAgbyBoZWlnaHQgKG51bWJlcilcbiAgICAgbyBocmVmIChzdHJpbmcpIFVSTCwgaWYgc3BlY2lmaWVkIGVsZW1lbnQgYmVoYXZlcyBhcyBoeXBlcmxpbmtcbiAgICAgbyBvcGFjaXR5IChudW1iZXIpXG4gICAgIG8gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmcgZm9ybWF0XG4gICAgIG8gciAobnVtYmVyKSByYWRpdXMgb2YgdGhlIGNpcmNsZSwgZWxsaXBzZSBvciByb3VuZGVkIGNvcm5lciBvbiB0aGUgcmVjdFxuICAgICBvIHJ4IChudW1iZXIpIGhvcmlzb250YWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlXG4gICAgIG8gcnkgKG51bWJlcikgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlXG4gICAgIG8gc3JjIChzdHJpbmcpIGltYWdlIFVSTCwgb25seSB3b3JrcyBmb3IgQEVsZW1lbnQuaW1hZ2UgZWxlbWVudFxuICAgICBvIHN0cm9rZSAoc3RyaW5nKSBzdHJva2UgY29sb3VyXG4gICAgIG8gc3Ryb2tlLWRhc2hhcnJheSAoc3RyaW5nKSBb4oCc4oCdLCDigJxub25l4oCdLCDigJxgLWDigJ0sIOKAnGAuYOKAnSwg4oCcYC0uYOKAnSwg4oCcYC0uLmDigJ0sIOKAnGAuIGDigJ0sIOKAnGAtIGDigJ0sIOKAnGAtLWDigJ0sIOKAnGAtIC5g4oCdLCDigJxgLS0uYOKAnSwg4oCcYC0tLi5g4oCdXVxuICAgICBvIHN0cm9rZS1saW5lY2FwIChzdHJpbmcpIFvigJxgYnV0dGDigJ0sIOKAnGBzcXVhcmVg4oCdLCDigJxgcm91bmRg4oCdXVxuICAgICBvIHN0cm9rZS1saW5lam9pbiAoc3RyaW5nKSBb4oCcYGJldmVsYOKAnSwg4oCcYHJvdW5kYOKAnSwg4oCcYG1pdGVyYOKAnV1cbiAgICAgbyBzdHJva2UtbWl0ZXJsaW1pdCAobnVtYmVyKVxuICAgICBvIHN0cm9rZS1vcGFjaXR5IChudW1iZXIpXG4gICAgIG8gc3Ryb2tlLXdpZHRoIChudW1iZXIpIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMsIGRlZmF1bHQgaXMgJzEnXG4gICAgIG8gdGFyZ2V0IChzdHJpbmcpIHVzZWQgd2l0aCBocmVmXG4gICAgIG8gdGV4dCAoc3RyaW5nKSBjb250ZW50cyBvZiB0aGUgdGV4dCBlbGVtZW50LiBVc2UgYFxcbmAgZm9yIG11bHRpbGluZSB0ZXh0XG4gICAgIG8gdGV4dC1hbmNob3IgKHN0cmluZykgW+KAnGBzdGFydGDigJ0sIOKAnGBtaWRkbGVg4oCdLCDigJxgZW5kYOKAnV0sIGRlZmF1bHQgaXMg4oCcYG1pZGRsZWDigJ1cbiAgICAgbyB0aXRsZSAoc3RyaW5nKSB3aWxsIGNyZWF0ZSB0b29sdGlwIHdpdGggYSBnaXZlbiB0ZXh0XG4gICAgIG8gdHJhbnNmb3JtIChzdHJpbmcpIHNlZSBARWxlbWVudC50cmFuc2Zvcm1cbiAgICAgbyB3aWR0aCAobnVtYmVyKVxuICAgICBvIHggKG51bWJlcilcbiAgICAgbyB5IChudW1iZXIpXG4gICAgID4gR3JhZGllbnRzXG4gICAgICogTGluZWFyIGdyYWRpZW50IGZvcm1hdDog4oCcYOKAuWFuZ2xl4oC6LeKAuWNvbG91cuKAulst4oC5Y29sb3Vy4oC6WzrigLlvZmZzZXTigLpdXSot4oC5Y29sb3Vy4oC6YOKAnSwgZXhhbXBsZTog4oCcYDkwLSNmZmYtIzAwMGDigJ0g4oCTIDkwwrBcbiAgICAgKiBncmFkaWVudCBmcm9tIHdoaXRlIHRvIGJsYWNrIG9yIOKAnGAwLSNmZmYtI2YwMDoyMC0jMDAwYOKAnSDigJMgMMKwIGdyYWRpZW50IGZyb20gd2hpdGUgdmlhIHJlZCAoYXQgMjAlKSB0byBibGFjay5cbiAgICAgKlxuICAgICAqIHJhZGlhbCBncmFkaWVudDog4oCcYHJbKOKAuWZ44oC6LCDigLlmeeKAuild4oC5Y29sb3Vy4oC6Wy3igLljb2xvdXLigLpbOuKAuW9mZnNldOKAul1dKi3igLljb2xvdXLigLpg4oCdLCBleGFtcGxlOiDigJxgciNmZmYtIzAwMGDigJ0g4oCTXG4gICAgICogZ3JhZGllbnQgZnJvbSB3aGl0ZSB0byBibGFjayBvciDigJxgcigwLjI1LCAwLjc1KSNmZmYtIzAwMGDigJ0g4oCTIGdyYWRpZW50IGZyb20gd2hpdGUgdG8gYmxhY2sgd2l0aCBmb2N1cyBwb2ludFxuICAgICAqIGF0IDAuMjUsIDAuNzUuIEZvY3VzIHBvaW50IGNvb3JkaW5hdGVzIGFyZSBpbiAwLi4xIHJhbmdlLiBSYWRpYWwgZ3JhZGllbnRzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gY2lyY2xlcyBhbmQgZWxsaXBzZXMuXG4gICAgID4gUGF0aCBTdHJpbmdcbiAgICAgIyA8cD5QbGVhc2UgcmVmZXIgdG8gPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXCIgdGl0bGU9XCJEZXRhaWxzIG9mIGEgcGF0aOKAmXMgZGF0YSBhdHRyaWJ1dGXigJlzIGZvcm1hdCBhcmUgZGVzY3JpYmVkIGluIHRoZSBTVkcgc3BlY2lmaWNhdGlvbi5cIj5TVkcgZG9jdW1lbnRhdGlvbiByZWdhcmRpbmcgcGF0aCBzdHJpbmc8L2E+LiBSYXBoYcOrbCBmdWxseSBzdXBwb3J0cyBpdC48L3A+XG4gICAgID4gQ29sb3VyIFBhcnNpbmdcbiAgICAgIyA8dWw+XG4gICAgICMgICAgIDxsaT5Db2xvdXIgbmFtZSAo4oCcPGNvZGU+cmVkPC9jb2RlPuKAnSwg4oCcPGNvZGU+Z3JlZW48L2NvZGU+4oCdLCDigJw8Y29kZT5jb3JuZmxvd2VyYmx1ZTwvY29kZT7igJ0sIGV0Yyk8L2xpPlxuICAgICAjICAgICA8bGk+I+KAouKAouKAoiDigJQgc2hvcnRlbmVkIEhUTUwgY29sb3VyOiAo4oCcPGNvZGU+IzAwMDwvY29kZT7igJ0sIOKAnDxjb2RlPiNmYzA8L2NvZGU+4oCdLCBldGMpPC9saT5cbiAgICAgIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3VyOiAo4oCcPGNvZGU+IzAwMDAwMDwvY29kZT7igJ0sIOKAnDxjb2RlPiNiZDIzMDA8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHPigJkgdmFsdWVzOiAo4oCcPGNvZGU+cmdiKDIwMCwmbmJzcDsxMDAsJm5ic3A7MCk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlOiAo4oCcPGNvZGU+cmdiKDEwMCUsJm5ic3A7MTc1JSwmbmJzcDswJSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHPigJkgdmFsdWVzOiAo4oCcPGNvZGU+cmdiYSgyMDAsJm5ic3A7MTAwLCZuYnNwOzAsIC41KTwvY29kZT7igJ0pPC9saT5cbiAgICAgIyAgICAgPGxpPnJnYmEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlOiAo4oCcPGNvZGU+cmdiYSgxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUsIDUwJSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGh1ZSwgc2F0dXJhdGlvbiBhbmQgYnJpZ2h0bmVzcyB2YWx1ZXM6ICjigJw8Y29kZT5oc2IoMC41LCZuYnNwOzAuMjUsJm5ic3A7MSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlPC9saT5cbiAgICAgIyAgICAgPGxpPmhzYmEo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IHdpdGggb3BhY2l0eTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2wo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsbW9zdCB0aGUgc2FtZSBhcyBoc2IsIHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlwiIHRpdGxlPVwiSFNMIGFuZCBIU1YgLSBXaWtpcGVkaWEsIHRoZSBmcmVlIGVuY3ljbG9wZWRpYVwiPldpa2lwZWRpYSBwYWdlPC9hPjwvbGk+XG4gICAgICMgICAgIDxsaT5oc2wo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlPC9saT5cbiAgICAgIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IHdpdGggb3BhY2l0eTwvbGk+XG4gICAgICMgICAgIDxsaT5PcHRpb25hbGx5IGZvciBoc2IgYW5kIGhzbCB5b3UgY291bGQgc3BlY2lmeSBodWUgYXMgYSBkZWdyZWU6IOKAnDxjb2RlPmhzbCgyNDBkZWcsJm5ic3A7MSwmbmJzcDsuNSk8L2NvZGU+4oCdIG9yLCBpZiB5b3Ugd2FudCB0byBnbyBmYW5jeSwg4oCcPGNvZGU+aHNsKDI0MMKwLCZuYnNwOzEsJm5ic3A7LjUpPC9jb2RlPuKAnTwvbGk+XG4gICAgICMgPC91bD5cbiAgICBcXCovXG4gICAgZWxwcm90by5hdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5hdHRycykgaWYgKHRoaXMuYXR0cnNbaGFzXShhKSkge1xuICAgICAgICAgICAgICAgIHJlc1thXSA9IHRoaXMuYXR0cnNbYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMuZ3JhZGllbnQgJiYgcmVzLmZpbGwgPT0gXCJub25lXCIgJiYgKHJlcy5maWxsID0gcmVzLmdyYWRpZW50KSAmJiBkZWxldGUgcmVzLmdyYWRpZW50O1xuICAgICAgICAgICAgcmVzLnRyYW5zZm9ybSA9IHRoaXMuXy50cmFuc2Zvcm07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIFIuaXMobmFtZSwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiZmlsbFwiICYmIHRoaXMuYXR0cnMuZmlsbCA9PSBcIm5vbmVcIiAmJiB0aGlzLmF0dHJzLmdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuZ3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy50cmFuc2Zvcm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gdGhpcy5hdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFIuaXModGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW25hbWVdLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tuYW1lXS5kZWY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gUi5fYXZhaWxhYmxlQXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlpIC0gMSA/IG91dCA6IG91dFtuYW1lc1swXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgUi5pcyhuYW1lLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBvdXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W25hbWVbaV1dID0gdGhpcy5hdHRyKG5hbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgcGFyYW1zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSAhPSBudWxsICYmIFIuaXMobmFtZSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5hdHRyLlwiICsga2V5ICsgXCIuXCIgKyB0aGlzLmlkLCB0aGlzLCBwYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzKSBpZiAodGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2hhc10oa2V5KSAmJiBwYXJhbXNbaGFzXShrZXkpICYmIFIuaXModGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2tleV0sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHZhciBwYXIgPSB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNba2V5XS5hcHBseSh0aGlzLCBbXS5jb25jYXQocGFyYW1zW2tleV0pKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgZm9yICh2YXIgc3Via2V5IGluIHBhcikgaWYgKHBhcltoYXNdKHN1YmtleSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc3Via2V5XSA9IHBhcltzdWJrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEZpbGxBbmRTdHJva2UodGhpcywgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b0Zyb250XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNb3ZlcyB0aGUgZWxlbWVudCBzbyBpdCBpcyB0aGUgY2xvc2VzdCB0byB0aGUgdmlld2Vy4oCZcyBleWVzLCBvbiB0b3Agb2Ygb3RoZXIgZWxlbWVudHMuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50b0Zyb250ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGdldFJlYWxOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMucGFwZXI7XG4gICAgICAgIHN2Zy50b3AgIT0gdGhpcyAmJiBSLl90b2Zyb250KHRoaXMsIHN2Zyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9CYWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNb3ZlcyB0aGUgZWxlbWVudCBzbyBpdCBpcyB0aGUgZnVydGhlc3QgZnJvbSB0aGUgdmlld2Vy4oCZcyBleWVzLCBiZWhpbmQgb3RoZXIgZWxlbWVudHMuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50b0JhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gZ2V0UmVhbE5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIFIuX3RvYmFjayh0aGlzLCB0aGlzLnBhcGVyKTtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMucGFwZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgY3VycmVudCBvYmplY3QgYWZ0ZXIgdGhlIGdpdmVuIG9uZS5cbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCB8fCAhZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IGdldFJlYWxOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgIHZhciBhZnRlck5vZGUgPSBnZXRSZWFsTm9kZShlbGVtZW50Lm5vZGUgfHwgZWxlbWVudFtlbGVtZW50Lmxlbmd0aCAtIDFdLm5vZGUpO1xuICAgICAgICBpZiAoYWZ0ZXJOb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBhZnRlck5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgYWZ0ZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyTm9kZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIFIuX2luc2VydGFmdGVyKHRoaXMsIGVsZW1lbnQsIHRoaXMucGFwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmluc2VydEJlZm9yZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBjdXJyZW50IG9iamVjdCBiZWZvcmUgdGhlIGdpdmVuIG9uZS5cbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBnZXRSZWFsTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICB2YXIgYmVmb3JlTm9kZSA9IGdldFJlYWxOb2RlKGVsZW1lbnQubm9kZSB8fCBlbGVtZW50WzBdLm5vZGUpO1xuICAgICAgICBiZWZvcmVOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGJlZm9yZU5vZGUpO1xuICAgICAgICBSLl9pbnNlcnRiZWZvcmUodGhpcywgZWxlbWVudCwgdGhpcy5wYXBlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZWxwcm90by5ibHVyID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsLiBObyBTYWZhcmkgc3VwcG9ydC4gVXNlIGl0IG9uIHlvdXIgb3duIHJpc2suXG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgaWYgKCtzaXplICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgZmx0ciA9ICQoXCJmaWx0ZXJcIiksXG4gICAgICAgICAgICAgICAgYmx1ciA9ICQoXCJmZUdhdXNzaWFuQmx1clwiKTtcbiAgICAgICAgICAgIHQuYXR0cnMuYmx1ciA9IHNpemU7XG4gICAgICAgICAgICBmbHRyLmlkID0gUi5jcmVhdGVVVUlEKCk7XG4gICAgICAgICAgICAkKGJsdXIsIHtzdGREZXZpYXRpb246ICtzaXplIHx8IDEuNX0pO1xuICAgICAgICAgICAgZmx0ci5hcHBlbmRDaGlsZChibHVyKTtcbiAgICAgICAgICAgIHQucGFwZXIuZGVmcy5hcHBlbmRDaGlsZChmbHRyKTtcbiAgICAgICAgICAgIHQuX2JsdXIgPSBmbHRyO1xuICAgICAgICAgICAgJCh0Lm5vZGUsIHtmaWx0ZXI6IFwidXJsKCNcIiArIGZsdHIuaWQgKyBcIilcIn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHQuX2JsdXIpIHtcbiAgICAgICAgICAgICAgICB0Ll9ibHVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodC5fYmx1cik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHQuX2JsdXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHQuYXR0cnMuYmx1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuY2lyY2xlID0gZnVuY3Rpb24gKHN2ZywgeCwgeSwgcikge1xuICAgICAgICB2YXIgZWwgPSAkKFwiY2lyY2xlXCIpO1xuICAgICAgICBzdmcuY2FudmFzICYmIHN2Zy5jYW52YXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgcmVzID0gbmV3IEVsZW1lbnQoZWwsIHN2Zyk7XG4gICAgICAgIHJlcy5hdHRycyA9IHtjeDogeCwgY3k6IHksIHI6IHIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMFwifTtcbiAgICAgICAgcmVzLnR5cGUgPSBcImNpcmNsZVwiO1xuICAgICAgICAkKGVsLCByZXMuYXR0cnMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLnJlY3QgPSBmdW5jdGlvbiAoc3ZnLCB4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIHZhciBlbCA9ICQoXCJyZWN0XCIpO1xuICAgICAgICBzdmcuY2FudmFzICYmIHN2Zy5jYW52YXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgcmVzID0gbmV3IEVsZW1lbnQoZWwsIHN2Zyk7XG4gICAgICAgIHJlcy5hdHRycyA9IHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCByeDogciB8fCAwLCByeTogciB8fCAwLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDBcIn07XG4gICAgICAgIHJlcy50eXBlID0gXCJyZWN0XCI7XG4gICAgICAgICQoZWwsIHJlcy5hdHRycyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuZWxsaXBzZSA9IGZ1bmN0aW9uIChzdmcsIHgsIHksIHJ4LCByeSkge1xuICAgICAgICB2YXIgZWwgPSAkKFwiZWxsaXBzZVwiKTtcbiAgICAgICAgc3ZnLmNhbnZhcyAmJiBzdmcuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBFbGVtZW50KGVsLCBzdmcpO1xuICAgICAgICByZXMuYXR0cnMgPSB7Y3g6IHgsIGN5OiB5LCByeDogcngsIHJ5OiByeSwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwXCJ9O1xuICAgICAgICByZXMudHlwZSA9IFwiZWxsaXBzZVwiO1xuICAgICAgICAkKGVsLCByZXMuYXR0cnMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLmltYWdlID0gZnVuY3Rpb24gKHN2Zywgc3JjLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgIHZhciBlbCA9ICQoXCJpbWFnZVwiKTtcbiAgICAgICAgJChlbCwge3g6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwifSk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBcImhyZWZcIiwgc3JjKTtcbiAgICAgICAgc3ZnLmNhbnZhcyAmJiBzdmcuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBFbGVtZW50KGVsLCBzdmcpO1xuICAgICAgICByZXMuYXR0cnMgPSB7eDogeCwgeTogeSwgd2lkdGg6IHcsIGhlaWdodDogaCwgc3JjOiBzcmN9O1xuICAgICAgICByZXMudHlwZSA9IFwiaW1hZ2VcIjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS50ZXh0ID0gZnVuY3Rpb24gKHN2ZywgeCwgeSwgdGV4dCkge1xuICAgICAgICB2YXIgZWwgPSAkKFwidGV4dFwiKTtcbiAgICAgICAgc3ZnLmNhbnZhcyAmJiBzdmcuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBFbGVtZW50KGVsLCBzdmcpO1xuICAgICAgICByZXMuYXR0cnMgPSB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFIuX2F2YWlsYWJsZUF0dHJzW1wiZm9udC1mYW1pbHlcIl0sXG4gICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBSLl9hdmFpbGFibGVBdHRyc1tcImZvbnQtc2l6ZVwiXSxcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICBmaWxsOiBcIiMwMDBcIlxuICAgICAgICB9O1xuICAgICAgICByZXMudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHJlcywgcmVzLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5zZXRTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld0JveC5hcHBseSh0aGlzLCB0aGlzLl92aWV3Qm94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb24gPSBSLl9nZXRDb250YWluZXIuYXBwbHkoMCwgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbiAmJiBjb24uY29udGFpbmVyO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1ZHIGNvbnRhaW5lciBub3QgZm91bmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gY29uLngsXG4gICAgICAgICAgICB5ID0gY29uLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbi53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbi5oZWlnaHQsXG4gICAgICAgICAgICBjbnZzID0gJChcInN2Z1wiKSxcbiAgICAgICAgICAgIGNzcyA9IFwib3ZlcmZsb3c6aGlkZGVuO1wiLFxuICAgICAgICAgICAgaXNGbG9hdGluZztcbiAgICAgICAgeCA9IHggfHwgMDtcbiAgICAgICAgeSA9IHkgfHwgMDtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCA1MTI7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCAzNDI7XG4gICAgICAgICQoY252cywge1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLjEsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PSAxKSB7XG4gICAgICAgICAgICBjbnZzLnN0eWxlLmNzc1RleHQgPSBjc3MgKyBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6XCIgKyB4ICsgXCJweDt0b3A6XCIgKyB5ICsgXCJweFwiO1xuICAgICAgICAgICAgUi5fZy5kb2MuYm9keS5hcHBlbmRDaGlsZChjbnZzKTtcbiAgICAgICAgICAgIGlzRmxvYXRpbmcgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY252cy5zdHlsZS5jc3NUZXh0ID0gY3NzICsgXCJwb3NpdGlvbjpyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjbnZzLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbnZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIgPSBuZXcgUi5fUGFwZXI7XG4gICAgICAgIGNvbnRhaW5lci53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjb250YWluZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb250YWluZXIuY2FudmFzID0gY252cztcbiAgICAgICAgY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIGNvbnRhaW5lci5fbGVmdCA9IGNvbnRhaW5lci5fdG9wID0gMDtcbiAgICAgICAgaXNGbG9hdGluZyAmJiAoY29udGFpbmVyLnJlbmRlcmZpeCA9IGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgY29udGFpbmVyLnJlbmRlcmZpeCgpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgUi5fZW5naW5lLnNldFZpZXdCb3ggPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgZml0KSB7XG4gICAgICAgIGV2ZShcInJhcGhhZWwuc2V0Vmlld0JveFwiLCB0aGlzLCB0aGlzLl92aWV3Qm94LCBbeCwgeSwgdywgaCwgZml0XSk7XG4gICAgICAgIHZhciBwYXBlclNpemUgPSB0aGlzLmdldFNpemUoKSxcbiAgICAgICAgICAgIHNpemUgPSBtbWF4KHcgLyBwYXBlclNpemUud2lkdGgsIGggLyBwYXBlclNpemUuaGVpZ2h0KSxcbiAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wLFxuICAgICAgICAgICAgYXNwZWN0UmF0aW8gPSBmaXQgPyBcInhNaWRZTWlkIG1lZXRcIiA6IFwieE1pbllNaW5cIixcbiAgICAgICAgICAgIHZiLFxuICAgICAgICAgICAgc3c7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YlNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl92YlNpemU7XG4gICAgICAgICAgICB2YiA9IFwiMCAwIFwiICsgdGhpcy53aWR0aCArIFMgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZiU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB2YiA9IHggKyBTICsgeSArIFMgKyB3ICsgUyArIGg7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgdmlld0JveDogdmIsXG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpb1xuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKHNpemUgJiYgdG9wKSB7XG4gICAgICAgICAgICBzdyA9IFwic3Ryb2tlLXdpZHRoXCIgaW4gdG9wLmF0dHJzID8gdG9wLmF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdIDogMTtcbiAgICAgICAgICAgIHRvcC5hdHRyKHtcInN0cm9rZS13aWR0aFwiOiBzd30pO1xuICAgICAgICAgICAgdG9wLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgdG9wLl8uZGlydHlUID0gMTtcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXdCb3ggPSBbeCwgeSwgdywgaCwgISFmaXRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5yZW5kZXJmaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEZpeGVzIHRoZSBpc3N1ZSBvZiBGaXJlZm94IGFuZCBJRTkgcmVnYXJkaW5nIHN1YnBpeGVsIHJlbmRlcmluZy4gSWYgcGFwZXIgaXMgZGVwZW5kZW50XG4gICAgICogb24gb3RoZXIgZWxlbWVudHMgYWZ0ZXIgcmVmbG93IGl0IGNvdWxkIHNoaWZ0IGhhbGYgcGl4ZWwgd2hpY2ggY2F1c2UgZm9yIGxpbmVzIHRvIGxvc3QgdGhlaXIgY3Jpc3BuZXNzLlxuICAgICAqIFRoaXMgbWV0aG9kIGZpeGVzIHRoZSBpc3N1ZS5cbiAgICAgKipcbiAgICAgICBTcGVjaWFsIHRoYW5rcyB0byBNYXJpdXN6IE5vd2FrIChodHRwOi8vd3d3Lm1lZGlrb28uY29tLykgZm9yIHRoaXMgbWV0aG9kLlxuICAgIFxcKi9cbiAgICBSLnByb3RvdHlwZS5yZW5kZXJmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbnZzID0gdGhpcy5jYW52YXMsXG4gICAgICAgICAgICBzID0gY252cy5zdHlsZSxcbiAgICAgICAgICAgIHBvcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBvcyA9IGNudnMuZ2V0U2NyZWVuQ1RNKCkgfHwgY252cy5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcG9zID0gY252cy5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IC1wb3MuZSAlIDEsXG4gICAgICAgICAgICB0b3AgPSAtcG9zLmYgJSAxO1xuICAgICAgICBpZiAobGVmdCB8fCB0b3ApIHtcbiAgICAgICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdCA9ICh0aGlzLl9sZWZ0ICsgbGVmdCkgJSAxO1xuICAgICAgICAgICAgICAgIHMubGVmdCA9IHRoaXMuX2xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9wID0gKHRoaXMuX3RvcCArIHRvcCkgJSAxO1xuICAgICAgICAgICAgICAgIHMudG9wID0gdGhpcy5fdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENsZWFycyB0aGUgcGFwZXIsIGkuZS4gcmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzLlxuICAgIFxcKi9cbiAgICBSLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUi5ldmUoXCJyYXBoYWVsLmNsZWFyXCIsIHRoaXMpO1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2FudmFzO1xuICAgICAgICB3aGlsZSAoYy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBjLnJlbW92ZUNoaWxkKGMuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCA9IG51bGw7XG4gICAgICAgICh0aGlzLmRlc2MgPSAkKFwiZGVzY1wiKSkuYXBwZW5kQ2hpbGQoUi5fZy5kb2MuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggUmFwaGFcXHhlYmwgXCIgKyBSLnZlcnNpb24pKTtcbiAgICAgICAgYy5hcHBlbmRDaGlsZCh0aGlzLmRlc2MpO1xuICAgICAgICBjLmFwcGVuZENoaWxkKHRoaXMuZGVmcyA9ICQoXCJkZWZzXCIpKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgdGhlIHBhcGVyIGZyb20gdGhlIERPTS5cbiAgICBcXCovXG4gICAgUi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmUoXCJyYXBoYWVsLnJlbW92ZVwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZSAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdHlwZW9mIHRoaXNbaV0gPT0gXCJmdW5jdGlvblwiID8gUi5fcmVtb3ZlZEZhY3RvcnkoaSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2V0cHJvdG8gPSBSLnN0O1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBlbHByb3RvKSBpZiAoZWxwcm90b1toYXNdKG1ldGhvZCkgJiYgIXNldHByb3RvW2hhc10obWV0aG9kKSkge1xuICAgICAgICBzZXRwcm90b1ttZXRob2RdID0gKGZ1bmN0aW9uIChtZXRob2RuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxbbWV0aG9kbmFtZV0uYXBwbHkoZWwsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShtZXRob2QpO1xuICAgIH1cbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9kZXYvcmFwaGFlbC52bWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9kZXYvcmFwaGFlbC52bWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhcGhhZWwuY29yZSAqLyBcIi4vZGV2L3JhcGhhZWwuY29yZS5qc1wiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKFIpIHtcbiAgICBpZiAoUiAmJiAhUi52bWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICAgIG1hdGggPSBNYXRoLFxuICAgICAgICByb3VuZCA9IG1hdGgucm91bmQsXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgbW1pbiA9IG1hdGgubWluLFxuICAgICAgICBhYnMgPSBtYXRoLmFicyxcbiAgICAgICAgZmlsbFN0cmluZyA9IFwiZmlsbFwiLFxuICAgICAgICBzZXBhcmF0b3IgPSAvWywgXSsvLFxuICAgICAgICBldmUgPSBSLmV2ZSxcbiAgICAgICAgbXMgPSBcIiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnRcIixcbiAgICAgICAgUyA9IFwiIFwiLFxuICAgICAgICBFID0gXCJcIixcbiAgICAgICAgbWFwID0ge006IFwibVwiLCBMOiBcImxcIiwgQzogXCJjXCIsIFo6IFwieFwiLCBtOiBcInRcIiwgbDogXCJyXCIsIGM6IFwidlwiLCB6OiBcInhcIn0sXG4gICAgICAgIGJpdGVzID0gLyhbY2xtel0pLD8oW15jbG16XSopL2dpLFxuICAgICAgICBibHVycmVnZXhwID0gLyBwcm9naWQ6XFxTK0JsdXJcXChbXlxcKV0rXFwpL2csXG4gICAgICAgIHZhbCA9IC8tP1teLFxccy1dKy9nLFxuICAgICAgICBjc3NEb3QgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKVwiLFxuICAgICAgICB6b29tID0gMjE2MDAsXG4gICAgICAgIHBhdGhUeXBlcyA9IHtwYXRoOiAxLCByZWN0OiAxLCBpbWFnZTogMX0sXG4gICAgICAgIG92YWxUeXBlcyA9IHtjaXJjbGU6IDEsIGVsbGlwc2U6IDF9LFxuICAgICAgICBwYXRoMnZtbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSAgL1thaHFzdHZdL2lnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBSLl9wYXRoVG9BYnNvbHV0ZTtcbiAgICAgICAgICAgIFN0cihwYXRoKS5tYXRjaCh0b3RhbCkgJiYgKGNvbW1hbmQgPSBSLl9wYXRoMmN1cnZlKTtcbiAgICAgICAgICAgIHRvdGFsID0gL1tjbG16XS9nO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gUi5fcGF0aFRvQWJzb2x1dGUgJiYgIVN0cihwYXRoKS5tYXRjaCh0b3RhbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gU3RyKHBhdGgpLnJlcGxhY2UoYml0ZXMsIGZ1bmN0aW9uIChhbGwsIGNvbW1hbmQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTW92ZSA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKSA9PSBcIm1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IG1hcFtjb21tYW5kXTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5yZXBsYWNlKHZhbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3ZlICYmIHZhbHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gdmFscyArIG1hcFtjb21tYW5kID09IFwibVwiID8gXCJsXCIgOiBcIkxcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFscy5wdXNoKHJvdW5kKHZhbHVlICogem9vbSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyArIHZhbHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYSA9IGNvbW1hbmQocGF0aCksIHAsIHI7XG4gICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwID0gcGFbaV07XG4gICAgICAgICAgICAgICAgciA9IHBhW2ldWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgciA9PSBcInpcIiAmJiAociA9IFwieFwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMSwgamogPSBwLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSByb3VuZChwW2pdICogem9vbSkgKyAoaiAhPSBqaiAtIDEgPyBcIixcIiA6IEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMuam9pbihTKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGVuc2F0aW9uID0gZnVuY3Rpb24gKGRlZywgZHgsIGR5KSB7XG4gICAgICAgICAgICB2YXIgbSA9IFIubWF0cml4KCk7XG4gICAgICAgICAgICBtLnJvdGF0ZSgtZGVnLCAuNSwgLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkeDogbS54KGR4LCBkeSksXG4gICAgICAgICAgICAgICAgZHk6IG0ueShkeCwgZHkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb29yZHMgPSBmdW5jdGlvbiAocCwgc3gsIHN5LCBkeCwgZHksIGRlZykge1xuICAgICAgICAgICAgdmFyIF8gPSBwLl8sXG4gICAgICAgICAgICAgICAgbSA9IHAubWF0cml4LFxuICAgICAgICAgICAgICAgIGZpbGxwb3MgPSBfLmZpbGxwb3MsXG4gICAgICAgICAgICAgICAgbyA9IHAubm9kZSxcbiAgICAgICAgICAgICAgICBzID0gby5zdHlsZSxcbiAgICAgICAgICAgICAgICB5ID0gMSxcbiAgICAgICAgICAgICAgICBmbGlwID0gXCJcIixcbiAgICAgICAgICAgICAgICBkeGR5LFxuICAgICAgICAgICAgICAgIGt4ID0gem9vbSAvIHN4LFxuICAgICAgICAgICAgICAgIGt5ID0gem9vbSAvIHN5O1xuICAgICAgICAgICAgcy52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlmICghc3ggfHwgIXN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5jb29yZHNpemUgPSBhYnMoa3gpICsgUyArIGFicyhreSk7XG4gICAgICAgICAgICBzLnJvdGF0aW9uID0gZGVnICogKHN4ICogc3kgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGlmIChkZWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbXBlbnNhdGlvbihkZWcsIGR4LCBkeSk7XG4gICAgICAgICAgICAgICAgZHggPSBjLmR4O1xuICAgICAgICAgICAgICAgIGR5ID0gYy5keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN4IDwgMCAmJiAoZmxpcCArPSBcInhcIik7XG4gICAgICAgICAgICBzeSA8IDAgJiYgKGZsaXAgKz0gXCIgeVwiKSAmJiAoeSA9IC0xKTtcbiAgICAgICAgICAgIHMuZmxpcCA9IGZsaXA7XG4gICAgICAgICAgICBvLmNvb3Jkb3JpZ2luID0gKGR4ICogLWt4KSArIFMgKyAoZHkgKiAta3kpO1xuICAgICAgICAgICAgaWYgKGZpbGxwb3MgfHwgXy5maWxsc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxsID0gby5nZXRFbGVtZW50c0J5VGFnTmFtZShmaWxsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBmaWxsID0gZmlsbCAmJiBmaWxsWzBdO1xuICAgICAgICAgICAgICAgIG8ucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGxwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGNvbXBlbnNhdGlvbihkZWcsIG0ueChmaWxscG9zWzBdLCBmaWxscG9zWzFdKSwgbS55KGZpbGxwb3NbMF0sIGZpbGxwb3NbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5wb3NpdGlvbiA9IGMuZHggKiB5ICsgUyArIGMuZHkgKiB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXy5maWxsc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnNpemUgPSBfLmZpbGxzaXplWzBdICogYWJzKHN4KSArIFMgKyBfLmZpbGxzaXplWzFdICogYWJzKHN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgby5hcHBlbmRDaGlsZChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICB9O1xuICAgIFIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAgXCJZb3VyIGJyb3dzZXIgZG9lc25cXHUyMDE5dCBzdXBwb3J0IFNWRy4gRmFsbGluZyBkb3duIHRvIFZNTC5cXG5Zb3UgYXJlIHJ1bm5pbmcgUmFwaGFcXHhlYmwgXCIgKyB0aGlzLnZlcnNpb247XG4gICAgfTtcbiAgICB2YXIgYWRkQXJyb3cgPSBmdW5jdGlvbiAobywgdmFsdWUsIGlzRW5kKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBTdHIodmFsdWUpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCItXCIpLFxuICAgICAgICAgICAgc2UgPSBpc0VuZCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICBpID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGUgPSBcImNsYXNzaWNcIixcbiAgICAgICAgICAgIHcgPSBcIm1lZGl1bVwiLFxuICAgICAgICAgICAgaCA9IFwibWVkaXVtXCI7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzaWNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwib3ZhbFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwid2lkZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJuYXJyb3dcIjogaCA9IHZhbHVlc1tpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic2hvcnRcIjogdyA9IHZhbHVlc1tpXTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cm9rZSA9IG8ubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0cm9rZVwiKVswXTtcbiAgICAgICAgc3Ryb2tlW3NlICsgXCJhcnJvd1wiXSA9IHR5cGU7XG4gICAgICAgIHN0cm9rZVtzZSArIFwiYXJyb3dsZW5ndGhcIl0gPSB3O1xuICAgICAgICBzdHJva2Vbc2UgKyBcImFycm93d2lkdGhcIl0gPSBoO1xuICAgIH0sXG4gICAgc2V0RmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uIChvLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gby5wYXBlci5jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBvLmF0dHJzID0gby5hdHRycyB8fCB7fTtcbiAgICAgICAgdmFyIG5vZGUgPSBvLm5vZGUsXG4gICAgICAgICAgICBhID0gby5hdHRycyxcbiAgICAgICAgICAgIHMgPSBub2RlLnN0eWxlLFxuICAgICAgICAgICAgeHksXG4gICAgICAgICAgICBuZXdwYXRoID0gcGF0aFR5cGVzW28udHlwZV0gJiYgKHBhcmFtcy54ICE9IGEueCB8fCBwYXJhbXMueSAhPSBhLnkgfHwgcGFyYW1zLndpZHRoICE9IGEud2lkdGggfHwgcGFyYW1zLmhlaWdodCAhPSBhLmhlaWdodCB8fCBwYXJhbXMuY3ggIT0gYS5jeCB8fCBwYXJhbXMuY3kgIT0gYS5jeSB8fCBwYXJhbXMucnggIT0gYS5yeCB8fCBwYXJhbXMucnkgIT0gYS5yeSB8fCBwYXJhbXMuciAhPSBhLnIpLFxuICAgICAgICAgICAgaXNPdmFsID0gb3ZhbFR5cGVzW28udHlwZV0gJiYgKGEuY3ggIT0gcGFyYW1zLmN4IHx8IGEuY3kgIT0gcGFyYW1zLmN5IHx8IGEuciAhPSBwYXJhbXMuciB8fCBhLnJ4ICE9IHBhcmFtcy5yeCB8fCBhLnJ5ICE9IHBhcmFtcy5yeSksXG4gICAgICAgICAgICByZXMgPSBvO1xuXG5cbiAgICAgICAgZm9yICh2YXIgcGFyIGluIHBhcmFtcykgaWYgKHBhcmFtc1toYXNdKHBhcikpIHtcbiAgICAgICAgICAgIGFbcGFyXSA9IHBhcmFtc1twYXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdwYXRoKSB7XG4gICAgICAgICAgICBhLnBhdGggPSBSLl9nZXRQYXRoW28udHlwZV0obyk7XG4gICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5ocmVmICYmIChub2RlLmhyZWYgPSBwYXJhbXMuaHJlZik7XG4gICAgICAgIHBhcmFtcy50aXRsZSAmJiAobm9kZS50aXRsZSA9IHBhcmFtcy50aXRsZSk7XG4gICAgICAgIHBhcmFtcy50YXJnZXQgJiYgKG5vZGUudGFyZ2V0ID0gcGFyYW1zLnRhcmdldCk7XG4gICAgICAgIHBhcmFtcy5jdXJzb3IgJiYgKHMuY3Vyc29yID0gcGFyYW1zLmN1cnNvcik7XG4gICAgICAgIFwiYmx1clwiIGluIHBhcmFtcyAmJiBvLmJsdXIocGFyYW1zLmJsdXIpO1xuICAgICAgICBpZiAocGFyYW1zLnBhdGggJiYgby50eXBlID09IFwicGF0aFwiIHx8IG5ld3BhdGgpIHtcbiAgICAgICAgICAgIG5vZGUucGF0aCA9IHBhdGgydm1sKH5TdHIoYS5wYXRoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyXCIpID8gUi5fcGF0aFRvQWJzb2x1dGUoYS5wYXRoKSA6IGEucGF0aCk7XG4gICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgaWYgKG8udHlwZSA9PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgICAgICBvLl8uZmlsbHBvcyA9IFthLngsIGEueV07XG4gICAgICAgICAgICAgICAgby5fLmZpbGxzaXplID0gW2Eud2lkdGgsIGEuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICBzZXRDb29yZHMobywgMSwgMSwgMCwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXCJ0cmFuc2Zvcm1cIiBpbiBwYXJhbXMgJiYgby50cmFuc2Zvcm0ocGFyYW1zLnRyYW5zZm9ybSk7XG4gICAgICAgIGlmIChpc092YWwpIHtcbiAgICAgICAgICAgIHZhciBjeCA9ICthLmN4LFxuICAgICAgICAgICAgICAgIGN5ID0gK2EuY3ksXG4gICAgICAgICAgICAgICAgcnggPSArYS5yeCB8fCArYS5yIHx8IDAsXG4gICAgICAgICAgICAgICAgcnkgPSArYS5yeSB8fCArYS5yIHx8IDA7XG4gICAgICAgICAgICBub2RlLnBhdGggPSBSLmZvcm1hdChcImFyezB9LHsxfSx7Mn0sezN9LHs0fSx7MX0sezR9LHsxfXhcIiwgcm91bmQoKGN4IC0gcngpICogem9vbSksIHJvdW5kKChjeSAtIHJ5KSAqIHpvb20pLCByb3VuZCgoY3ggKyByeCkgKiB6b29tKSwgcm91bmQoKGN5ICsgcnkpICogem9vbSksIHJvdW5kKGN4ICogem9vbSkpO1xuICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbGlwLXJlY3RcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gU3RyKHBhcmFtc1tcImNsaXAtcmVjdFwiXSkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChyZWN0Lmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmVjdFsyXSA9ICtyZWN0WzJdICsgKCtyZWN0WzBdKTtcbiAgICAgICAgICAgICAgICByZWN0WzNdID0gK3JlY3RbM10gKyAoK3JlY3RbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBub2RlLmNsaXBSZWN0IHx8IFIuX2cuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZSA9IGRpdi5zdHlsZTtcbiAgICAgICAgICAgICAgICBkc3R5bGUuY2xpcCA9IFIuZm9ybWF0KFwicmVjdCh7MX1weCB7Mn1weCB7M31weCB7MH1weClcIiwgcmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNsaXBSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAgICAgZHN0eWxlLnRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZHN0eWxlLndpZHRoID0gby5wYXBlci53aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZHN0eWxlLmhlaWdodCA9IG8ucGFwZXIuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRpdiwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGlwUmVjdCA9IGRpdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmFtc1tcImNsaXAtcmVjdFwiXSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2xpcFJlY3QgJiYgKG5vZGUuY2xpcFJlY3Quc3R5bGUuY2xpcCA9IFwiYXV0b1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby50ZXh0cGF0aCkge1xuICAgICAgICAgICAgdmFyIHRleHRwYXRoU3R5bGUgPSBvLnRleHRwYXRoLnN0eWxlO1xuICAgICAgICAgICAgcGFyYW1zLmZvbnQgJiYgKHRleHRwYXRoU3R5bGUuZm9udCA9IHBhcmFtcy5mb250KTtcbiAgICAgICAgICAgIHBhcmFtc1tcImZvbnQtZmFtaWx5XCJdICYmICh0ZXh0cGF0aFN0eWxlLmZvbnRGYW1pbHkgPSAnXCInICsgcGFyYW1zW1wiZm9udC1mYW1pbHlcIl0uc3BsaXQoXCIsXCIpWzBdLnJlcGxhY2UoL15bJ1wiXSt8WydcIl0rJC9nLCBFKSArICdcIicpO1xuICAgICAgICAgICAgcGFyYW1zW1wiZm9udC1zaXplXCJdICYmICh0ZXh0cGF0aFN0eWxlLmZvbnRTaXplID0gcGFyYW1zW1wiZm9udC1zaXplXCJdKTtcbiAgICAgICAgICAgIHBhcmFtc1tcImZvbnQtd2VpZ2h0XCJdICYmICh0ZXh0cGF0aFN0eWxlLmZvbnRXZWlnaHQgPSBwYXJhbXNbXCJmb250LXdlaWdodFwiXSk7XG4gICAgICAgICAgICBwYXJhbXNbXCJmb250LXN0eWxlXCJdICYmICh0ZXh0cGF0aFN0eWxlLmZvbnRTdHlsZSA9IHBhcmFtc1tcImZvbnQtc3R5bGVcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImFycm93LXN0YXJ0XCIgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBhZGRBcnJvdyhyZXMsIHBhcmFtc1tcImFycm93LXN0YXJ0XCJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJhcnJvdy1lbmRcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGFkZEFycm93KHJlcywgcGFyYW1zW1wiYXJyb3ctZW5kXCJdLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm9wYWNpdHkgIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zLmZpbGwgIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zLnNyYyAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXMuc3Ryb2tlICE9IG51bGwgfHxcbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS13aWR0aFwiXSAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2Utb3BhY2l0eVwiXSAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXNbXCJmaWxsLW9wYWNpdHlcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLWRhc2hhcnJheVwiXSAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbGluZWpvaW5cIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLWxpbmVjYXBcIl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKGZpbGxTdHJpbmcpLFxuICAgICAgICAgICAgICAgIG5ld2ZpbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpbGwgPSBmaWxsICYmIGZpbGxbMF07XG4gICAgICAgICAgICAhZmlsbCAmJiAobmV3ZmlsbCA9IGZpbGwgPSBjcmVhdGVOb2RlKGZpbGxTdHJpbmcpKTtcbiAgICAgICAgICAgIGlmIChvLnR5cGUgPT0gXCJpbWFnZVwiICYmIHBhcmFtcy5zcmMpIHtcbiAgICAgICAgICAgICAgICBmaWxsLnNyYyA9IHBhcmFtcy5zcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZmlsbCAmJiAoZmlsbC5vbiA9IHRydWUpO1xuICAgICAgICAgICAgaWYgKGZpbGwub24gPT0gbnVsbCB8fCBwYXJhbXMuZmlsbCA9PSBcIm5vbmVcIiB8fCBwYXJhbXMuZmlsbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpbGwub24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsLm9uICYmIHBhcmFtcy5maWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVVJMID0gU3RyKHBhcmFtcy5maWxsKS5tYXRjaChSLl9JU1VSTCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwucGFyZW50Tm9kZSA9PSBub2RlICYmIG5vZGUucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwucm90YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5zcmMgPSBpc1VSTFsxXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC50eXBlID0gXCJ0aWxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gby5nZXRCQm94KDEpO1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnBvc2l0aW9uID0gYmJveC54ICsgUyArIGJib3gueTtcbiAgICAgICAgICAgICAgICAgICAgby5fLmZpbGxwb3MgPSBbYmJveC54LCBiYm94LnldO1xuXG4gICAgICAgICAgICAgICAgICAgIFIuX3ByZWxvYWQoaXNVUkxbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5maWxsc2l6ZSA9IFt0aGlzLm9mZnNldFdpZHRoLCB0aGlzLm9mZnNldEhlaWdodF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwuY29sb3IgPSBSLmdldFJHQihwYXJhbXMuZmlsbCkuaGV4O1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnNyYyA9IEU7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwudHlwZSA9IFwic29saWRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFIuZ2V0UkdCKHBhcmFtcy5maWxsKS5lcnJvciAmJiAocmVzLnR5cGUgaW4ge2NpcmNsZTogMSwgZWxsaXBzZTogMX0gfHwgU3RyKHBhcmFtcy5maWxsKS5jaGFyQXQoKSAhPSBcInJcIikgJiYgYWRkR3JhZGllbnRGaWxsKHJlcywgcGFyYW1zLmZpbGwsIGZpbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZ3JhZGllbnQgPSBwYXJhbXMuZmlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwucm90YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJmaWxsLW9wYWNpdHlcIiBpbiBwYXJhbXMgfHwgXCJvcGFjaXR5XCIgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAoKCthW1wiZmlsbC1vcGFjaXR5XCJdICsgMSB8fCAyKSAtIDEpICogKCgrYS5vcGFjaXR5ICsgMSB8fCAyKSAtIDEpICogKCgrUi5nZXRSR0IocGFyYW1zLmZpbGwpLm8gKyAxIHx8IDIpIC0gMSk7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IG1taW4obW1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgICAgICAgICAgZmlsbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbC5zcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5jb2xvciA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZmlsbCk7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gKG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIikgJiYgbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0cm9rZVwiKVswXSksXG4gICAgICAgICAgICBuZXdzdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICFzdHJva2UgJiYgKG5ld3N0cm9rZSA9IHN0cm9rZSA9IGNyZWF0ZU5vZGUoXCJzdHJva2VcIikpO1xuICAgICAgICAgICAgaWYgKChwYXJhbXMuc3Ryb2tlICYmIHBhcmFtcy5zdHJva2UgIT0gXCJub25lXCIpIHx8XG4gICAgICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLXdpZHRoXCJdIHx8XG4gICAgICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLW9wYWNpdHlcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1kYXNoYXJyYXlcIl0gfHxcbiAgICAgICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1saW5lam9pblwiXSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1saW5lY2FwXCJdKSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlLm9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChwYXJhbXMuc3Ryb2tlID09IFwibm9uZVwiIHx8IHBhcmFtcy5zdHJva2UgPT09IG51bGwgfHwgc3Ryb2tlLm9uID09IG51bGwgfHwgcGFyYW1zLnN0cm9rZSA9PSAwIHx8IHBhcmFtc1tcInN0cm9rZS13aWR0aFwiXSA9PSAwKSAmJiAoc3Ryb2tlLm9uID0gZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gUi5nZXRSR0IocGFyYW1zLnN0cm9rZSk7XG4gICAgICAgICAgICBzdHJva2Uub24gJiYgcGFyYW1zLnN0cm9rZSAmJiAoc3Ryb2tlLmNvbG9yID0gc3Ryb2tlQ29sb3IuaGV4KTtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAoKCthW1wic3Ryb2tlLW9wYWNpdHlcIl0gKyAxIHx8IDIpIC0gMSkgKiAoKCthLm9wYWNpdHkgKyAxIHx8IDIpIC0gMSkgKiAoKCtzdHJva2VDb2xvci5vICsgMSB8fCAyKSAtIDEpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gKHRvRmxvYXQocGFyYW1zW1wic3Ryb2tlLXdpZHRoXCJdKSB8fCAxKSAqIC43NTtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBtbWluKG1tYXgob3BhY2l0eSwgMCksIDEpO1xuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLXdpZHRoXCJdID09IG51bGwgJiYgKHdpZHRoID0gYVtcInN0cm9rZS13aWR0aFwiXSk7XG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2Utd2lkdGhcIl0gJiYgKHN0cm9rZS53ZWlnaHQgPSB3aWR0aCk7XG4gICAgICAgICAgICB3aWR0aCAmJiB3aWR0aCA8IDEgJiYgKG9wYWNpdHkgKj0gd2lkdGgpICYmIChzdHJva2Uud2VpZ2h0ID0gMSk7XG4gICAgICAgICAgICBzdHJva2Uub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1saW5lam9pblwiXSAmJiAoc3Ryb2tlLmpvaW5zdHlsZSA9IHBhcmFtc1tcInN0cm9rZS1saW5lam9pblwiXSB8fCBcIm1pdGVyXCIpO1xuICAgICAgICAgICAgc3Ryb2tlLm1pdGVybGltaXQgPSBwYXJhbXNbXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSB8fCA4O1xuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLWxpbmVjYXBcIl0gJiYgKHN0cm9rZS5lbmRjYXAgPSBwYXJhbXNbXCJzdHJva2UtbGluZWNhcFwiXSA9PSBcImJ1dHRcIiA/IFwiZmxhdFwiIDogcGFyYW1zW1wic3Ryb2tlLWxpbmVjYXBcIl0gPT0gXCJzcXVhcmVcIiA/IFwic3F1YXJlXCIgOiBcInJvdW5kXCIpO1xuICAgICAgICAgICAgaWYgKFwic3Ryb2tlLWRhc2hhcnJheVwiIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBkYXNoYXJyYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiLVwiOiBcInNob3J0ZGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi5cIjogXCJzaG9ydGRvdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0uXCI6IFwic2hvcnRkYXNoZG90XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLS4uXCI6IFwic2hvcnRkYXNoZG90ZG90XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLiBcIjogXCJkb3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCItIFwiOiBcImRhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgXCItLVwiOiBcImxvbmdkYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLSAuXCI6IFwiZGFzaGRvdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0tLlwiOiBcImxvbmdkYXNoZG90XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLS0uLlwiOiBcImxvbmdkYXNoZG90ZG90XCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN0cm9rZS5kYXNoc3R5bGUgPSBkYXNoYXJyYXlbaGFzXShwYXJhbXNbXCJzdHJva2UtZGFzaGFycmF5XCJdKSA/IGRhc2hhcnJheVtwYXJhbXNbXCJzdHJva2UtZGFzaGFycmF5XCJdXSA6IEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdzdHJva2UgJiYgbm9kZS5hcHBlbmRDaGlsZChzdHJva2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmVzLnBhcGVyLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gRTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gcmVzLnBhcGVyLnNwYW4sXG4gICAgICAgICAgICAgICAgbSA9IDEwMCxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IGEuZm9udCAmJiBhLmZvbnQubWF0Y2goL1xcZCsoPzpcXC5cXGQqKT8oPz1weCkvKTtcbiAgICAgICAgICAgIHMgPSBzcGFuLnN0eWxlO1xuICAgICAgICAgICAgYS5mb250ICYmIChzLmZvbnQgPSBhLmZvbnQpO1xuICAgICAgICAgICAgYVtcImZvbnQtZmFtaWx5XCJdICYmIChzLmZvbnRGYW1pbHkgPSBhW1wiZm9udC1mYW1pbHlcIl0pO1xuICAgICAgICAgICAgYVtcImZvbnQtd2VpZ2h0XCJdICYmIChzLmZvbnRXZWlnaHQgPSBhW1wiZm9udC13ZWlnaHRcIl0pO1xuICAgICAgICAgICAgYVtcImZvbnQtc3R5bGVcIl0gJiYgKHMuZm9udFN0eWxlID0gYVtcImZvbnQtc3R5bGVcIl0pO1xuICAgICAgICAgICAgZm9udFNpemUgPSB0b0Zsb2F0KGFbXCJmb250LXNpemVcIl0gfHwgZm9udFNpemUgJiYgZm9udFNpemVbMF0pIHx8IDEwO1xuICAgICAgICAgICAgcy5mb250U2l6ZSA9IGZvbnRTaXplICogbSArIFwicHhcIjtcbiAgICAgICAgICAgIHJlcy50ZXh0cGF0aC5zdHJpbmcgJiYgKHNwYW4uaW5uZXJIVE1MID0gU3RyKHJlcy50ZXh0cGF0aC5zdHJpbmcpLnJlcGxhY2UoLzwvZywgXCImIzYwO1wiKS5yZXBsYWNlKC8mL2csIFwiJiMzODtcIikucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XG4gICAgICAgICAgICB2YXIgYnJlY3QgPSBzcGFuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmVzLlcgPSBhLncgPSAoYnJlY3QucmlnaHQgLSBicmVjdC5sZWZ0KSAvIG07XG4gICAgICAgICAgICByZXMuSCA9IGEuaCA9IChicmVjdC5ib3R0b20gLSBicmVjdC50b3ApIC8gbTtcbiAgICAgICAgICAgIC8vIHJlcy5wYXBlci5jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgcmVzLlggPSBhLng7XG4gICAgICAgICAgICByZXMuWSA9IGEueSArIHJlcy5IIC8gMjtcblxuICAgICAgICAgICAgKFwieFwiIGluIHBhcmFtcyB8fCBcInlcIiBpbiBwYXJhbXMpICYmIChyZXMucGF0aC52ID0gUi5mb3JtYXQoXCJtezB9LHsxfWx7Mn0sezF9XCIsIHJvdW5kKGEueCAqIHpvb20pLCByb3VuZChhLnkgKiB6b29tKSwgcm91bmQoYS54ICogem9vbSkgKyAxKSk7XG4gICAgICAgICAgICB2YXIgZGlydHlhdHRycyA9IFtcInhcIiwgXCJ5XCIsIFwidGV4dFwiLCBcImZvbnRcIiwgXCJmb250LWZhbWlseVwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtc2l6ZVwiXTtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBkZCA9IGRpcnR5YXR0cnMubGVuZ3RoOyBkIDwgZGQ7IGQrKykgaWYgKGRpcnR5YXR0cnNbZF0gaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVzLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXh0LWFuY2hvciBlbXVsYXRpb25cbiAgICAgICAgICAgIHN3aXRjaCAoYVtcInRleHQtYW5jaG9yXCJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJlcy50ZXh0cGF0aC5zdHlsZVtcInYtdGV4dC1hbGlnblwiXSA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICByZXMuYmJ4ID0gcmVzLlcgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVzLnRleHRwYXRoLnN0eWxlW1widi10ZXh0LWFsaWduXCJdID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgICByZXMuYmJ4ID0gLXJlcy5XIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXMudGV4dHBhdGguc3R5bGVbXCJ2LXRleHQtYWxpZ25cIl0gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICByZXMuYmJ4ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy50ZXh0cGF0aC5zdHlsZVtcInYtdGV4dC1rZXJuXCJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXMucGFwZXIuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBFO1xuICAgIH0sXG4gICAgYWRkR3JhZGllbnRGaWxsID0gZnVuY3Rpb24gKG8sIGdyYWRpZW50LCBmaWxsKSB7XG4gICAgICAgIG8uYXR0cnMgPSBvLmF0dHJzIHx8IHt9O1xuICAgICAgICB2YXIgYXR0cnMgPSBvLmF0dHJzLFxuICAgICAgICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgb2luZGV4LFxuICAgICAgICAgICAgdHlwZSA9IFwibGluZWFyXCIsXG4gICAgICAgICAgICBmeGZ5ID0gXCIuNSAuNVwiO1xuICAgICAgICBvLmF0dHJzLmdyYWRpZW50ID0gZ3JhZGllbnQ7XG4gICAgICAgIGdyYWRpZW50ID0gU3RyKGdyYWRpZW50KS5yZXBsYWNlKFIuX3JhZGlhbF9ncmFkaWVudCwgZnVuY3Rpb24gKGFsbCwgZngsIGZ5KSB7XG4gICAgICAgICAgICB0eXBlID0gXCJyYWRpYWxcIjtcbiAgICAgICAgICAgIGlmIChmeCAmJiBmeSkge1xuICAgICAgICAgICAgICAgIGZ4ID0gdG9GbG9hdChmeCk7XG4gICAgICAgICAgICAgICAgZnkgPSB0b0Zsb2F0KGZ5KTtcbiAgICAgICAgICAgICAgICBwb3coZnggLSAuNSwgMikgKyBwb3coZnkgLSAuNSwgMikgPiAuMjUgJiYgKGZ5ID0gbWF0aC5zcXJ0KC4yNSAtIHBvdyhmeCAtIC41LCAyKSkgKiAoKGZ5ID4gLjUpICogMiAtIDEpICsgLjUpO1xuICAgICAgICAgICAgICAgIGZ4ZnkgPSBmeCArIFMgKyBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC5zcGxpdCgvXFxzKlxcLVxccyovKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJsaW5lYXJcIikge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gZ3JhZGllbnQuc2hpZnQoKTtcbiAgICAgICAgICAgIGFuZ2xlID0gLXRvRmxvYXQoYW5nbGUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkb3RzID0gUi5fcGFyc2VEb3RzKGdyYWRpZW50KTtcbiAgICAgICAgaWYgKCFkb3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvID0gby5zaGFwZSB8fCBvLm5vZGU7XG4gICAgICAgIGlmIChkb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgby5yZW1vdmVDaGlsZChmaWxsKTtcbiAgICAgICAgICAgIGZpbGwub24gPSB0cnVlO1xuICAgICAgICAgICAgZmlsbC5tZXRob2QgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGZpbGwuY29sb3IgPSBkb3RzWzBdLmNvbG9yO1xuICAgICAgICAgICAgZmlsbC5jb2xvcjIgPSBkb3RzW2RvdHMubGVuZ3RoIC0gMV0uY29sb3I7XG4gICAgICAgICAgICB2YXIgY2xycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZG90cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG90c1tpXS5vZmZzZXQgJiYgY2xycy5wdXNoKGRvdHNbaV0ub2Zmc2V0ICsgUyArIGRvdHNbaV0uY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbC5jb2xvcnMgPSBjbHJzLmxlbmd0aCA/IGNscnMuam9pbigpIDogXCIwJSBcIiArIGZpbGwuY29sb3I7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcInJhZGlhbFwiKSB7XG4gICAgICAgICAgICAgICAgZmlsbC50eXBlID0gXCJncmFkaWVudFRpdGxlXCI7XG4gICAgICAgICAgICAgICAgZmlsbC5mb2N1cyA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgICAgIGZpbGwuZm9jdXNzaXplID0gXCIwIDBcIjtcbiAgICAgICAgICAgICAgICBmaWxsLmZvY3VzcG9zaXRpb24gPSBmeGZ5O1xuICAgICAgICAgICAgICAgIGZpbGwuYW5nbGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaWxsLnJvdGF0ZT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmaWxsLnR5cGUgPSBcImdyYWRpZW50XCI7XG4gICAgICAgICAgICAgICAgZmlsbC5hbmdsZSA9ICgyNzAgLSBhbmdsZSkgJSAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLmFwcGVuZENoaWxkKGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCB2bWwpIHtcbiAgICAgICAgdGhpc1swXSA9IHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIG5vZGUucmFwaGFlbCA9IHRydWU7XG4gICAgICAgIHRoaXMuaWQgPSBSLl9vaWQrKztcbiAgICAgICAgbm9kZS5yYXBoYWVsaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLlggPSAwO1xuICAgICAgICB0aGlzLlkgPSAwO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIHRoaXMucGFwZXIgPSB2bWw7XG4gICAgICAgIHRoaXMubWF0cml4ID0gUi5tYXRyaXgoKTtcbiAgICAgICAgdGhpcy5fID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBbXSxcbiAgICAgICAgICAgIHN4OiAxLFxuICAgICAgICAgICAgc3k6IDEsXG4gICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgZGVnOiAwLFxuICAgICAgICAgICAgZGlydHk6IDEsXG4gICAgICAgICAgICBkaXJ0eVQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgIXZtbC5ib3R0b20gJiYgKHZtbC5ib3R0b20gPSB0aGlzKTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdm1sLnRvcDtcbiAgICAgICAgdm1sLnRvcCAmJiAodm1sLnRvcC5uZXh0ID0gdGhpcyk7XG4gICAgICAgIHZtbC50b3AgPSB0aGlzO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGVscHJvdG8gPSBSLmVsO1xuXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSBlbHByb3RvO1xuICAgIGVscHJvdG8uY29uc3RydWN0b3IgPSBFbGVtZW50O1xuICAgIGVscHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gKHRzdHIpIHtcbiAgICAgICAgaWYgKHRzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy50cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZicyA9IHRoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdCxcbiAgICAgICAgICAgIHZidCA9IHZicyA/IFwic1wiICsgW3Zicy5zY2FsZSwgdmJzLnNjYWxlXSArIFwiLTEtMXRcIiArIFt2YnMuZHgsIHZicy5keV0gOiBFLFxuICAgICAgICAgICAgb2xkdDtcbiAgICAgICAgaWYgKHZicykge1xuICAgICAgICAgICAgb2xkdCA9IHRzdHIgPSBTdHIodHN0cikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZywgdGhpcy5fLnRyYW5zZm9ybSB8fCBFKTtcbiAgICAgICAgfVxuICAgICAgICBSLl9leHRyYWN0VHJhbnNmb3JtKHRoaXMsIHZidCArIHRzdHIpO1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXguY2xvbmUoKSxcbiAgICAgICAgICAgIHNrZXcgPSB0aGlzLnNrZXcsXG4gICAgICAgICAgICBvID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgc3BsaXQsXG4gICAgICAgICAgICBpc0dyYWQgPSB+U3RyKHRoaXMuYXR0cnMuZmlsbCkuaW5kZXhPZihcIi1cIiksXG4gICAgICAgICAgICBpc1BhdHQgPSAhU3RyKHRoaXMuYXR0cnMuZmlsbCkuaW5kZXhPZihcInVybChcIik7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUoMSwgMSk7XG4gICAgICAgIGlmIChpc1BhdHQgfHwgaXNHcmFkIHx8IHRoaXMudHlwZSA9PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgIHNrZXcubWF0cml4ID0gXCIxIDAgMCAxXCI7XG4gICAgICAgICAgICBza2V3Lm9mZnNldCA9IFwiMCAwXCI7XG4gICAgICAgICAgICBzcGxpdCA9IG1hdHJpeC5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKChpc0dyYWQgJiYgc3BsaXQubm9Sb3RhdGlvbikgfHwgIXNwbGl0LmlzU2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgby5zdHlsZS5maWx0ZXIgPSBtYXRyaXgudG9GaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgICAgICAgICAgYmJ0ID0gdGhpcy5nZXRCQm94KDEpLFxuICAgICAgICAgICAgICAgICAgICBkeCA9IGJiLnggLSBiYnQueCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBiYi55IC0gYmJ0Lnk7XG4gICAgICAgICAgICAgICAgby5jb29yZG9yaWdpbiA9IChkeCAqIC16b29tKSArIFMgKyAoZHkgKiAtem9vbSk7XG4gICAgICAgICAgICAgICAgc2V0Q29vcmRzKHRoaXMsIDEsIDEsIGR4LCBkeSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG8uc3R5bGUuZmlsdGVyID0gRTtcbiAgICAgICAgICAgICAgICBzZXRDb29yZHModGhpcywgc3BsaXQuc2NhbGV4LCBzcGxpdC5zY2FsZXksIHNwbGl0LmR4LCBzcGxpdC5keSwgc3BsaXQucm90YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG8uc3R5bGUuZmlsdGVyID0gRTtcbiAgICAgICAgICAgIHNrZXcubWF0cml4ID0gU3RyKG1hdHJpeCk7XG4gICAgICAgICAgICBza2V3Lm9mZnNldCA9IG1hdHJpeC5vZmZzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkdCAhPT0gbnVsbCkgeyAvLyBlbXB0eSBzdHJpbmcgdmFsdWUgaXMgdHJ1ZSBhcyB3ZWxsXG4gICAgICAgICAgICB0aGlzLl8udHJhbnNmb3JtID0gb2xkdDtcbiAgICAgICAgICAgIFIuX2V4dHJhY3RUcmFuc2Zvcm0odGhpcywgb2xkdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLnJvdGF0ZSA9IGZ1bmN0aW9uIChkZWcsIGN4LCBjeSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWcgPSBTdHIoZGVnKS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoZGVnLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGN4ID0gdG9GbG9hdChkZWdbMV0pO1xuICAgICAgICAgICAgY3kgPSB0b0Zsb2F0KGRlZ1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVnID0gdG9GbG9hdChkZWdbMF0pO1xuICAgICAgICAoY3kgPT0gbnVsbCkgJiYgKGN4ID0gY3kpO1xuICAgICAgICBpZiAoY3ggPT0gbnVsbCB8fCBjeSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgIGN4ID0gYmJveC54ICsgYmJveC53aWR0aCAvIDI7XG4gICAgICAgICAgICBjeSA9IGJib3gueSArIGJib3guaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl8uZGlydHlUID0gMTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odGhpcy5fLnRyYW5zZm9ybS5jb25jYXQoW1tcInJcIiwgZGVnLCBjeCwgY3ldXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8udHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkeCA9IFN0cihkeCkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGR4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGR5ID0gdG9GbG9hdChkeFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB0b0Zsb2F0KGR4WzBdKSB8fCAwO1xuICAgICAgICBkeSA9ICtkeSB8fCAwO1xuICAgICAgICBpZiAodGhpcy5fLmJib3gpIHtcbiAgICAgICAgICAgIHRoaXMuXy5iYm94LnggKz0gZHg7XG4gICAgICAgICAgICB0aGlzLl8uYmJveC55ICs9IGR5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJ0XCIsIGR4LCBkeV1dKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZWxwcm90by5zY2FsZSA9IGZ1bmN0aW9uIChzeCwgc3ksIGN4LCBjeSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzeCA9IFN0cihzeCkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHN4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN5ID0gdG9GbG9hdChzeFsxXSk7XG4gICAgICAgICAgICBjeCA9IHRvRmxvYXQoc3hbMl0pO1xuICAgICAgICAgICAgY3kgPSB0b0Zsb2F0KHN4WzNdKTtcbiAgICAgICAgICAgIGlzTmFOKGN4KSAmJiAoY3ggPSBudWxsKTtcbiAgICAgICAgICAgIGlzTmFOKGN5KSAmJiAoY3kgPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBzeCA9IHRvRmxvYXQoc3hbMF0pO1xuICAgICAgICAoc3kgPT0gbnVsbCkgJiYgKHN5ID0gc3gpO1xuICAgICAgICAoY3kgPT0gbnVsbCkgJiYgKGN4ID0gY3kpO1xuICAgICAgICBpZiAoY3ggPT0gbnVsbCB8fCBjeSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCgxKTtcbiAgICAgICAgfVxuICAgICAgICBjeCA9IGN4ID09IG51bGwgPyBiYm94LnggKyBiYm94LndpZHRoIC8gMiA6IGN4O1xuICAgICAgICBjeSA9IGN5ID09IG51bGwgPyBiYm94LnkgKyBiYm94LmhlaWdodCAvIDIgOiBjeTtcblxuICAgICAgICB0aGlzLnRyYW5zZm9ybSh0aGlzLl8udHJhbnNmb3JtLmNvbmNhdChbW1wic1wiLCBzeCwgc3ksIGN4LCBjeV1dKSk7XG4gICAgICAgIHRoaXMuXy5kaXJ0eVQgPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIXRoaXMucmVtb3ZlZCAmJiAodGhpcy5ub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZWxwcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAhdGhpcy5yZW1vdmVkICYmICh0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9IEUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5lZWRlZCB0byBmaXggdGhlIHZtbCBzZXRWaWV3Qm94IGlzc3Vlc1xuICAgIGVscHJvdG8uYXV4R2V0QkJveCA9IFIuZWwuZ2V0QkJveDtcbiAgICBlbHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGIgPSB0aGlzLmF1eEdldEJCb3goKTtcbiAgICAgIGlmICh0aGlzLnBhcGVyICYmIHRoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdClcbiAgICAgIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcbiAgICAgICAgdmFyIHogPSAxL3RoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdC5zY2FsZTtcbiAgICAgICAgYy54ID0gYi54IC0gdGhpcy5wYXBlci5fdmlld0JveFNoaWZ0LmR4O1xuICAgICAgICBjLnggKj0gejtcbiAgICAgICAgYy55ID0gYi55IC0gdGhpcy5wYXBlci5fdmlld0JveFNoaWZ0LmR5O1xuICAgICAgICBjLnkgKj0gejtcbiAgICAgICAgYy53aWR0aCAgPSBiLndpZHRoICAqIHo7XG4gICAgICAgIGMuaGVpZ2h0ID0gYi5oZWlnaHQgKiB6O1xuICAgICAgICBjLngyID0gYy54ICsgYy53aWR0aDtcbiAgICAgICAgYy55MiA9IGMueSArIGMuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiO1xuICAgIH07XG4gICAgZWxwcm90by5fZ2V0QkJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLlggKyAodGhpcy5iYnggfHwgMCkgLSB0aGlzLlcgLyAyLFxuICAgICAgICAgICAgeTogdGhpcy5ZIC0gdGhpcy5ILFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuVyxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5IXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBlbHByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCB8fCAhdGhpcy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcGVyLl9fc2V0X18gJiYgdGhpcy5wYXBlci5fX3NldF9fLmV4Y2x1ZGUodGhpcyk7XG4gICAgICAgIFIuZXZlLnVuYmluZChcInJhcGhhZWwuKi4qLlwiICsgdGhpcy5pZCk7XG4gICAgICAgIFIuX3RlYXIodGhpcywgdGhpcy5wYXBlcik7XG4gICAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMuc2hhcGUgJiYgdGhpcy5zaGFwZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB0eXBlb2YgdGhpc1tpXSA9PSBcImZ1bmN0aW9uXCIgPyBSLl9yZW1vdmVkRmFjdG9yeShpKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGVscHJvdG8uYXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBhIGluIHRoaXMuYXR0cnMpIGlmICh0aGlzLmF0dHJzW2hhc10oYSkpIHtcbiAgICAgICAgICAgICAgICByZXNbYV0gPSB0aGlzLmF0dHJzW2FdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLmdyYWRpZW50ICYmIHJlcy5maWxsID09IFwibm9uZVwiICYmIChyZXMuZmlsbCA9IHJlcy5ncmFkaWVudCkgJiYgZGVsZXRlIHJlcy5ncmFkaWVudDtcbiAgICAgICAgICAgIHJlcy50cmFuc2Zvcm0gPSB0aGlzLl8udHJhbnNmb3JtO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBSLmlzKG5hbWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBmaWxsU3RyaW5nICYmIHRoaXMuYXR0cnMuZmlsbCA9PSBcIm5vbmVcIiAmJiB0aGlzLmF0dHJzLmdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuZ3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gdGhpcy5hdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFIuaXModGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW25hbWVdLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tuYW1lXS5kZWY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W25hbWVdID0gUi5fYXZhaWxhYmxlQXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlpIC0gMSA/IG91dCA6IG91dFtuYW1lc1swXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0cnMgJiYgdmFsdWUgPT0gbnVsbCAmJiBSLmlzKG5hbWUsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZVtpXV0gPSB0aGlzLmF0dHIobmFtZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID09IG51bGwgJiYgUi5pcyhuYW1lLCBcIm9iamVjdFwiKSAmJiAocGFyYW1zID0gbmFtZSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGV2ZShcInJhcGhhZWwuYXR0ci5cIiArIGtleSArIFwiLlwiICsgdGhpcy5pZCwgdGhpcywgcGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlcykgaWYgKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1toYXNdKGtleSkgJiYgcGFyYW1zW2hhc10oa2V5KSAmJiBSLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1trZXldLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhciA9IHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1trZXldLmFwcGx5KHRoaXMsIFtdLmNvbmNhdChwYXJhbXNba2V5XSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHN1YmtleSBpbiBwYXIpIGlmIChwYXJbaGFzXShzdWJrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tzdWJrZXldID0gcGFyW3N1YmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcy5wYXBlci5jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50ZXh0ICYmIHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHBhdGguc3RyaW5nID0gcGFyYW1zLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICAvLyB0aGlzLnBhcGVyLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8udG9Gcm9udCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIXRoaXMucmVtb3ZlZCAmJiB0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICB0aGlzLnBhcGVyICYmIHRoaXMucGFwZXIudG9wICE9IHRoaXMgJiYgUi5fdG9mcm9udCh0aGlzLCB0aGlzLnBhcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLnRvQmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgIT0gdGhpcy5ub2RlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCB0aGlzLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIFIuX3RvYmFjayh0aGlzLCB0aGlzLnBhcGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5jb25zdHJ1Y3RvciA9PSBSLnN0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudFtlbGVtZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsZW1lbnQubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIGVsZW1lbnQubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50Lm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIFIuX2luc2VydGFmdGVyKHRoaXMsIGVsZW1lbnQsIHRoaXMucGFwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuY29uc3RydWN0b3IgPT0gUi5zdC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWxlbWVudC5ub2RlKTtcbiAgICAgICAgUi5faW5zZXJ0YmVmb3JlKHRoaXMsIGVsZW1lbnQsIHRoaXMucGFwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uYmx1ciA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5ub2RlLnJ1bnRpbWVTdHlsZSxcbiAgICAgICAgICAgIGYgPSBzLmZpbHRlcjtcbiAgICAgICAgZiA9IGYucmVwbGFjZShibHVycmVnZXhwLCBFKTtcbiAgICAgICAgaWYgKCtzaXplICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLmJsdXIgPSBzaXplO1xuICAgICAgICAgICAgcy5maWx0ZXIgPSBmICsgUyArIG1zICsgXCIuQmx1cihwaXhlbHJhZGl1cz1cIiArICgrc2l6ZSB8fCAxLjUpICsgXCIpXCI7XG4gICAgICAgICAgICBzLm1hcmdpbiA9IFIuZm9ybWF0KFwiLXswfXB4IDAgMCAtezB9cHhcIiwgcm91bmQoK3NpemUgfHwgMS41KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzLmZpbHRlciA9IGY7XG4gICAgICAgICAgICBzLm1hcmdpbiA9IDA7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRycy5ibHVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSLl9lbmdpbmUucGF0aCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCB2bWwpIHtcbiAgICAgICAgdmFyIGVsID0gY3JlYXRlTm9kZShcInNoYXBlXCIpO1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gY3NzRG90O1xuICAgICAgICBlbC5jb29yZHNpemUgPSB6b29tICsgUyArIHpvb207XG4gICAgICAgIGVsLmNvb3Jkb3JpZ2luID0gdm1sLmNvb3Jkb3JpZ2luO1xuICAgICAgICB2YXIgcCA9IG5ldyBFbGVtZW50KGVsLCB2bWwpLFxuICAgICAgICAgICAgYXR0ciA9IHtmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDBcIn07XG4gICAgICAgIHBhdGhTdHJpbmcgJiYgKGF0dHIucGF0aCA9IHBhdGhTdHJpbmcpO1xuICAgICAgICBwLnR5cGUgPSBcInBhdGhcIjtcbiAgICAgICAgcC5wYXRoID0gW107XG4gICAgICAgIHAuUGF0aCA9IEU7XG4gICAgICAgIHNldEZpbGxBbmRTdHJva2UocCwgYXR0cik7XG4gICAgICAgIHZtbC5jYW52YXMgJiYgdm1sLmNhbnZhcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciBza2V3ID0gY3JlYXRlTm9kZShcInNrZXdcIik7XG4gICAgICAgIHNrZXcub24gPSB0cnVlO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChza2V3KTtcbiAgICAgICAgcC5za2V3ID0gc2tldztcbiAgICAgICAgcC50cmFuc2Zvcm0oRSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgUi5fZW5naW5lLnJlY3QgPSBmdW5jdGlvbiAodm1sLCB4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIHZhciBwYXRoID0gUi5fcmVjdFBhdGgoeCwgeSwgdywgaCwgciksXG4gICAgICAgICAgICByZXMgPSB2bWwucGF0aChwYXRoKSxcbiAgICAgICAgICAgIGEgPSByZXMuYXR0cnM7XG4gICAgICAgIHJlcy5YID0gYS54ID0geDtcbiAgICAgICAgcmVzLlkgPSBhLnkgPSB5O1xuICAgICAgICByZXMuVyA9IGEud2lkdGggPSB3O1xuICAgICAgICByZXMuSCA9IGEuaGVpZ2h0ID0gaDtcbiAgICAgICAgYS5yID0gcjtcbiAgICAgICAgYS5wYXRoID0gcGF0aDtcbiAgICAgICAgcmVzLnR5cGUgPSBcInJlY3RcIjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5lbGxpcHNlID0gZnVuY3Rpb24gKHZtbCwgeCwgeSwgcngsIHJ5KSB7XG4gICAgICAgIHZhciByZXMgPSB2bWwucGF0aCgpLFxuICAgICAgICAgICAgYSA9IHJlcy5hdHRycztcbiAgICAgICAgcmVzLlggPSB4IC0gcng7XG4gICAgICAgIHJlcy5ZID0geSAtIHJ5O1xuICAgICAgICByZXMuVyA9IHJ4ICogMjtcbiAgICAgICAgcmVzLkggPSByeSAqIDI7XG4gICAgICAgIHJlcy50eXBlID0gXCJlbGxpcHNlXCI7XG4gICAgICAgIHNldEZpbGxBbmRTdHJva2UocmVzLCB7XG4gICAgICAgICAgICBjeDogeCxcbiAgICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgICAgcng6IHJ4LFxuICAgICAgICAgICAgcnk6IHJ5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLmNpcmNsZSA9IGZ1bmN0aW9uICh2bWwsIHgsIHksIHIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHZtbC5wYXRoKCksXG4gICAgICAgICAgICBhID0gcmVzLmF0dHJzO1xuICAgICAgICByZXMuWCA9IHggLSByO1xuICAgICAgICByZXMuWSA9IHkgLSByO1xuICAgICAgICByZXMuVyA9IHJlcy5IID0gciAqIDI7XG4gICAgICAgIHJlcy50eXBlID0gXCJjaXJjbGVcIjtcbiAgICAgICAgc2V0RmlsbEFuZFN0cm9rZShyZXMsIHtcbiAgICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgICAgY3k6IHksXG4gICAgICAgICAgICByOiByXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLmltYWdlID0gZnVuY3Rpb24gKHZtbCwgc3JjLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgIHZhciBwYXRoID0gUi5fcmVjdFBhdGgoeCwgeSwgdywgaCksXG4gICAgICAgICAgICByZXMgPSB2bWwucGF0aChwYXRoKS5hdHRyKHtzdHJva2U6IFwibm9uZVwifSksXG4gICAgICAgICAgICBhID0gcmVzLmF0dHJzLFxuICAgICAgICAgICAgbm9kZSA9IHJlcy5ub2RlLFxuICAgICAgICAgICAgZmlsbCA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZmlsbFN0cmluZylbMF07XG4gICAgICAgIGEuc3JjID0gc3JjO1xuICAgICAgICByZXMuWCA9IGEueCA9IHg7XG4gICAgICAgIHJlcy5ZID0gYS55ID0geTtcbiAgICAgICAgcmVzLlcgPSBhLndpZHRoID0gdztcbiAgICAgICAgcmVzLkggPSBhLmhlaWdodCA9IGg7XG4gICAgICAgIGEucGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcy50eXBlID0gXCJpbWFnZVwiO1xuICAgICAgICBmaWxsLnBhcmVudE5vZGUgPT0gbm9kZSAmJiBub2RlLnJlbW92ZUNoaWxkKGZpbGwpO1xuICAgICAgICBmaWxsLnJvdGF0ZSA9IHRydWU7XG4gICAgICAgIGZpbGwuc3JjID0gc3JjO1xuICAgICAgICBmaWxsLnR5cGUgPSBcInRpbGVcIjtcbiAgICAgICAgcmVzLl8uZmlsbHBvcyA9IFt4LCB5XTtcbiAgICAgICAgcmVzLl8uZmlsbHNpemUgPSBbdywgaF07XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZmlsbCk7XG4gICAgICAgIHNldENvb3JkcyhyZXMsIDEsIDEsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLnRleHQgPSBmdW5jdGlvbiAodm1sLCB4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBlbCA9IGNyZWF0ZU5vZGUoXCJzaGFwZVwiKSxcbiAgICAgICAgICAgIHBhdGggPSBjcmVhdGVOb2RlKFwicGF0aFwiKSxcbiAgICAgICAgICAgIG8gPSBjcmVhdGVOb2RlKFwidGV4dHBhdGhcIik7XG4gICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgIHRleHQgPSB0ZXh0IHx8IFwiXCI7XG4gICAgICAgIHBhdGgudiA9IFIuZm9ybWF0KFwibXswfSx7MX1sezJ9LHsxfVwiLCByb3VuZCh4ICogem9vbSksIHJvdW5kKHkgKiB6b29tKSwgcm91bmQoeCAqIHpvb20pICsgMSk7XG4gICAgICAgIHBhdGgudGV4dHBhdGhvayA9IHRydWU7XG4gICAgICAgIG8uc3RyaW5nID0gU3RyKHRleHQpO1xuICAgICAgICBvLm9uID0gdHJ1ZTtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IGNzc0RvdDtcbiAgICAgICAgZWwuY29vcmRzaXplID0gem9vbSArIFMgKyB6b29tO1xuICAgICAgICBlbC5jb29yZG9yaWdpbiA9IFwiMCAwXCI7XG4gICAgICAgIHZhciBwID0gbmV3IEVsZW1lbnQoZWwsIHZtbCksXG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIGZpbGw6IFwiIzAwMFwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgZm9udDogUi5fYXZhaWxhYmxlQXR0cnMuZm9udCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICBwLnNoYXBlID0gZWw7XG4gICAgICAgIHAucGF0aCA9IHBhdGg7XG4gICAgICAgIHAudGV4dHBhdGggPSBvO1xuICAgICAgICBwLnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgcC5hdHRycy50ZXh0ID0gU3RyKHRleHQpO1xuICAgICAgICBwLmF0dHJzLnggPSB4O1xuICAgICAgICBwLmF0dHJzLnkgPSB5O1xuICAgICAgICBwLmF0dHJzLncgPSAxO1xuICAgICAgICBwLmF0dHJzLmggPSAxO1xuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHAsIGF0dHIpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChvKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgIHZtbC5jYW52YXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgc2tldyA9IGNyZWF0ZU5vZGUoXCJza2V3XCIpO1xuICAgICAgICBza2V3Lm9uID0gdHJ1ZTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoc2tldyk7XG4gICAgICAgIHAuc2tldyA9IHNrZXc7XG4gICAgICAgIHAudHJhbnNmb3JtKEUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5zZXRTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jYW52YXMuc3R5bGU7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID09ICt3aWR0aCAmJiAod2lkdGggKz0gXCJweFwiKTtcbiAgICAgICAgaGVpZ2h0ID09ICtoZWlnaHQgJiYgKGhlaWdodCArPSBcInB4XCIpO1xuICAgICAgICBjcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNzLmNsaXAgPSBcInJlY3QoMCBcIiArIHdpZHRoICsgXCIgXCIgKyBoZWlnaHQgKyBcIiAwKVwiO1xuICAgICAgICBpZiAodGhpcy5fdmlld0JveCkge1xuICAgICAgICAgICAgUi5fZW5naW5lLnNldFZpZXdCb3guYXBwbHkodGhpcywgdGhpcy5fdmlld0JveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuc2V0Vmlld0JveCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBmaXQpIHtcbiAgICAgICAgUi5ldmUoXCJyYXBoYWVsLnNldFZpZXdCb3hcIiwgdGhpcywgdGhpcy5fdmlld0JveCwgW3gsIHksIHcsIGgsIGZpdF0pO1xuICAgICAgICB2YXIgcGFwZXJTaXplID0gdGhpcy5nZXRTaXplKCksXG4gICAgICAgICAgICB3aWR0aCA9IHBhcGVyU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcGVyU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICBILCBXO1xuICAgICAgICBpZiAoZml0KSB7XG4gICAgICAgICAgICBIID0gaGVpZ2h0IC8gaDtcbiAgICAgICAgICAgIFcgPSB3aWR0aCAvIHc7XG4gICAgICAgICAgICBpZiAodyAqIEggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHggLT0gKHdpZHRoIC0gdyAqIEgpIC8gMiAvIEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaCAqIFcgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5IC09IChoZWlnaHQgLSBoICogVykgLyAyIC8gVztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3Qm94ID0gW3gsIHksIHcsIGgsICEhZml0XTtcbiAgICAgICAgdGhpcy5fdmlld0JveFNoaWZ0ID0ge1xuICAgICAgICAgICAgZHg6IC14LFxuICAgICAgICAgICAgZHk6IC15LFxuICAgICAgICAgICAgc2NhbGU6IHBhcGVyU2l6ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC50cmFuc2Zvcm0oXCIuLi5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHZhciBjcmVhdGVOb2RlO1xuICAgIFIuX2VuZ2luZS5pbml0V2luID0gZnVuY3Rpb24gKHdpbikge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChkb2Muc3R5bGVTaGVldHMubGVuZ3RoIDwgMzEpIHtcbiAgICAgICAgICAgICAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoXCIucnZtbFwiLCBcImJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBtb3JlIHJvb20sIGFkZCB0byB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgICAgIGRvYy5zdHlsZVNoZWV0c1swXS5hZGRSdWxlKFwiLnJ2bWxcIiwgXCJiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgIWRvYy5uYW1lc3BhY2VzLnJ2bWwgJiYgZG9jLm5hbWVzcGFjZXMuYWRkKFwicnZtbFwiLCBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzxydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInJ2bWxcIj4nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzwnICsgdGFnTmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwicnZtbFwiPicpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgUi5fZW5naW5lLmluaXRXaW4oUi5fZy53aW4pO1xuICAgIFIuX2VuZ2luZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb24gPSBSLl9nZXRDb250YWluZXIuYXBwbHkoMCwgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbi5jb250YWluZXIsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb24uaGVpZ2h0LFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHdpZHRoID0gY29uLndpZHRoLFxuICAgICAgICAgICAgeCA9IGNvbi54LFxuICAgICAgICAgICAgeSA9IGNvbi55O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVk1MIGNvbnRhaW5lciBub3QgZm91bmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBuZXcgUi5fUGFwZXIsXG4gICAgICAgICAgICBjID0gcmVzLmNhbnZhcyA9IFIuX2cuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBjcyA9IGMuc3R5bGU7XG4gICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgNTEyO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMzQyO1xuICAgICAgICByZXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgd2lkdGggPT0gK3dpZHRoICYmICh3aWR0aCArPSBcInB4XCIpO1xuICAgICAgICBoZWlnaHQgPT0gK2hlaWdodCAmJiAoaGVpZ2h0ICs9IFwicHhcIik7XG4gICAgICAgIHJlcy5jb29yZHNpemUgPSB6b29tICogMWUzICsgUyArIHpvb20gKiAxZTM7XG4gICAgICAgIHJlcy5jb29yZG9yaWdpbiA9IFwiMCAwXCI7XG4gICAgICAgIHJlcy5zcGFuID0gUi5fZy5kb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHJlcy5zcGFuLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTk5OTllbTt0b3A6LTk5OTllbTtwYWRkaW5nOjA7bWFyZ2luOjA7bGluZS1oZWlnaHQ6MTtcIjtcbiAgICAgICAgYy5hcHBlbmRDaGlsZChyZXMuc3Bhbik7XG4gICAgICAgIGNzLmNzc1RleHQgPSBSLmZvcm1hdChcInRvcDowO2xlZnQ6MDt3aWR0aDp7MH07aGVpZ2h0OnsxfTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtjbGlwOnJlY3QoMCB7MH0gezF9IDApO292ZXJmbG93OmhpZGRlblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PSAxKSB7XG4gICAgICAgICAgICBSLl9nLmRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgY3MubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgICAgICBjcy50b3AgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgY3MucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGMsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy5yZW5kZXJmaXggPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSLmV2ZShcInJhcGhhZWwuY2xlYXJcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmlubmVySFRNTCA9IEU7XG4gICAgICAgIHRoaXMuc3BhbiA9IFIuX2cuZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLnNwYW4uc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotOTk5OWVtO3RvcDotOTk5OWVtO3BhZGRpbmc6MDttYXJnaW46MDtsaW5lLWhlaWdodDoxO2Rpc3BsYXk6aW5saW5lO1wiO1xuICAgICAgICB0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLnNwYW4pO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IHRoaXMudG9wID0gbnVsbDtcbiAgICB9O1xuICAgIFIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUi5ldmUoXCJyYXBoYWVsLnJlbW92ZVwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHR5cGVvZiB0aGlzW2ldID09IFwiZnVuY3Rpb25cIiA/IFIuX3JlbW92ZWRGYWN0b3J5KGkpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHByb3RvID0gUi5zdDtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gZWxwcm90bykgaWYgKGVscHJvdG9baGFzXShtZXRob2QpICYmICFzZXRwcm90b1toYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgc2V0cHJvdG9bbWV0aG9kXSA9IChmdW5jdGlvbiAobWV0aG9kbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsW21ldGhvZG5hbWVdLmFwcGx5KGVsLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobWV0aG9kKTtcbiAgICB9XG59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZS1yYXBoYWVsL2V2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZXZlLXJhcGhhZWwvZXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187Ly8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyBcbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIFxcXFxcbi8vIOKUgiBFdmUgMC41LjAgLSBKYXZhU2NyaXB0IEV2ZW50cyBMaWJyYXJ5ICAgICAgICAgICAgICAgICAgICAgIOKUgiBcXFxcXG4vLyDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKQgXFxcXFxuLy8g4pSCIEF1dGhvciBEbWl0cnkgQmFyYW5vdnNraXkgKGh0dHA6Ly9kbWl0cnkuYmFyYW5vdnNraXkuY29tLykg4pSCIFxcXFxcbi8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCBcXFxcXG5cbihmdW5jdGlvbiAoZ2xvYikge1xuICAgIHZhciB2ZXJzaW9uID0gXCIwLjUuMFwiLFxuICAgICAgICBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIHNlcGFyYXRvciA9IC9bXFwuXFwvXS8sXG4gICAgICAgIGNvbWFzZXBhcmF0b3IgPSAvXFxzKixcXHMqLyxcbiAgICAgICAgd2lsZGNhcmQgPSBcIipcIixcbiAgICAgICAgZnVuID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG51bXNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50X2V2ZW50LFxuICAgICAgICBzdG9wLFxuICAgICAgICBldmVudHMgPSB7bjoge319LFxuICAgICAgICBmaXJzdERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxhc3REZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9ianRvcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXIgaW5zdGFuY2VvZiBBcnJheSB8fCBvYmp0b3MuY2FsbChhcikgPT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmVcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogRmlyZXMgZXZlbnQgd2l0aCBnaXZlbiBgbmFtZWAsIGdpdmVuIHNjb3BlIGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgID4gQXJndW1lbnRzXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlICpldmVudCosIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWRcbiAgICAgLSBzY29wZSAob2JqZWN0KSBjb250ZXh0IGZvciB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgLSB2YXJhcmdzICguLi4pIHRoZSByZXN0IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHNlbnQgdG8gZXZlbnQgaGFuZGxlcnNcblxuICAgICA9IChvYmplY3QpIGFycmF5IG9mIHJldHVybmVkIHZhbHVlcyBmcm9tIHRoZSBsaXN0ZW5lcnMuIEFycmF5IGhhcyB0d28gbWV0aG9kcyBgLmZpcnN0RGVmaW5lZCgpYCBhbmQgYC5sYXN0RGVmaW5lZCgpYCB0byBnZXQgZmlyc3Qgb3IgbGFzdCBub3QgYHVuZGVmaW5lZGAgdmFsdWUuXG4gICAgXFwqL1xuICAgICAgICB2YXIgZXZlID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50cyxcbiAgICAgICAgICAgICAgICBvbGRzdG9wID0gc3RvcCxcbiAgICAgICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBldmUubGlzdGVuZXJzKG5hbWUpLFxuICAgICAgICAgICAgICAgIHogPSAwLFxuICAgICAgICAgICAgICAgIGYgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IHt9LFxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIGNlID0gY3VycmVudF9ldmVudCxcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIG91dC5maXJzdERlZmluZWQgPSBmaXJzdERlZmluZWQ7XG4gICAgICAgICAgICBvdXQubGFzdERlZmluZWQgPSBsYXN0RGVmaW5lZDtcbiAgICAgICAgICAgIGN1cnJlbnRfZXZlbnQgPSBuYW1lO1xuICAgICAgICAgICAgc3RvcCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKFwiekluZGV4XCIgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKGxpc3RlbmVyc1tpXS56SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uekluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtsaXN0ZW5lcnNbaV0uekluZGV4XSA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVkLnNvcnQobnVtc29ydCk7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXhlZFt6XSA8IDApIHtcbiAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6KytdXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChcInpJbmRleFwiIGluIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwuekluZGV4ID09IGluZGV4ZWRbel0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBxdWV1ZVtpbmRleGVkW3pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICYmIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbbC56SW5kZXhdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gY2U7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG4gICAgICAgIGV2ZS5fZXZlbnRzID0gZXZlbnRzO1xuICAgIC8qXFxcbiAgICAgKiBldmUubGlzdGVuZXJzXG4gICAgIFsgbWV0aG9kIF1cblxuICAgICAqIEludGVybmFsIG1ldGhvZCB3aGljaCBnaXZlcyB5b3UgYXJyYXkgb2YgYWxsIGV2ZW50IGhhbmRsZXJzIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGdpdmVuIGBuYW1lYC5cblxuICAgICA+IEFyZ3VtZW50c1xuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBldmVudCBoYW5kbGVyc1xuICAgIFxcKi9cbiAgICBldmUubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBqaixcbiAgICAgICAgICAgIG5lcyxcbiAgICAgICAgICAgIGVzID0gW2VdLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlID0gZXNbal0ubjtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtlW25hbWVzW2ldXSwgZVt3aWxkY2FyZF1dO1xuICAgICAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGl0ZW0uZiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcyA9IG5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5zZXBhcmF0b3JcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSWYgZm9yIHNvbWUgcmVhc29ucyB5b3UgZG9u4oCZdCBsaWtlIGRlZmF1bHQgc2VwYXJhdG9ycyAoYC5gIG9yIGAvYCkgeW91IGNhbiBzcGVjaWZ5IHlvdXJzXG4gICAgICogaGVyZS4gQmUgYXdhcmUgdGhhdCBpZiB5b3UgcGFzcyBhIHN0cmluZyBsb25nZXIgdGhhbiBvbmUgY2hhcmFjdGVyIGl0IHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgICAqIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuXG4gICAgIC0gc2VwYXJhdG9yIChzdHJpbmcpIG5ldyBzZXBhcmF0b3IuIEVtcHR5IHN0cmluZyByZXNldHMgdG8gZGVmYXVsdDogYC5gIG9yIGAvYC5cbiAgICBcXCovXG4gICAgZXZlLnNlcGFyYXRvciA9IGZ1bmN0aW9uIChzZXApIHtcbiAgICAgICAgaWYgKHNlcCkge1xuICAgICAgICAgICAgc2VwID0gU3RyKHNlcCkucmVwbGFjZSgvKD89W1xcLlxcXlxcXVxcW1xcLV0pL2csIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIHNlcCA9IFwiW1wiICsgc2VwICsgXCJdXCI7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAvW1xcLlxcL10vO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lLiBZb3UgY2FuIHVzZSB3aWxkY2FyZHMg4oCcYCpg4oCdIGZvciB0aGUgbmFtZXM6XG4gICAgIHwgZXZlLm9uKFwiKi51bmRlci4qXCIsIGYpO1xuICAgICB8IGV2ZShcIm1vdXNlLnVuZGVyLmZsb29yXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIG5hbWUgKGFycmF5KSBpZiB5b3UgZG9u4oCZdCB3YW50IHRvIHVzZSBzZXBhcmF0b3JzLCB5b3UgY2FuIHVzZSBhcnJheSBvZiBzdHJpbmdzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHJldHVybmVkIGZ1bmN0aW9uIGFjY2VwdHMgYSBzaW5nbGUgbnVtZXJpYyBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIHotaW5kZXggb2YgdGhlIGhhbmRsZXIuIEl0IGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIG9ubHkgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNvbWUgc3Vic2V0IG9mIGhhbmRsZXJzIHdpbGwgYmUgaW52b2tlZCBpbiBhIGdpdmVuIG9yZGVyLCBkZXNwaXRlIG9mIHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LiBcbiAgICAgPiBFeGFtcGxlOlxuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIGVhdEl0KSgyKTtcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBzY3JlYW0pO1xuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIGNhdGNoSXQpKDEpO1xuICAgICAqIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBgY2F0Y2hJdGAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGBlYXRJdGAuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwdXQgeW91ciBoYW5kbGVyIGJlZm9yZSBub24taW5kZXhlZCBoYW5kbGVycywgc3BlY2lmeSBhIG5lZ2F0aXZlIHZhbHVlLlxuICAgICAqIE5vdGU6IEkgYXNzdW1lIG1vc3Qgb2YgdGhlIHRpbWUgeW91IGRvbuKAmXQgbmVlZCB0byB3b3JyeSBhYm91dCB6LWluZGV4LCBidXQgaXTigJlzIG5pY2UgdG8gaGF2ZSB0aGlzIGZlYXR1cmUg4oCcanVzdCBpbiBjYXNl4oCdLlxuICAgIFxcKi9cbiAgICBldmUub24gPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICBpZiAodHlwZW9mIGYgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IChpc0FycmF5KG5hbWVbMF0pID8gbmFtZSA6IFtuYW1lXSkgOiBTdHIobmFtZSkuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IGlzQXJyYXkobmFtZSkgPyBuYW1lIDogU3RyKG5hbWUpLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUuaGFzT3duUHJvcGVydHkobmFtZXNbaV0pICYmIGVbbmFtZXNbaV1dIHx8IChlW25hbWVzW2ldXSA9IHtuOiB7fX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmYgPSBlLmYgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlLmYubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGUuZltpXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICFleGlzdCAmJiBlLmYucHVzaChmKTtcbiAgICAgICAgICAgIH0obmFtZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHpJbmRleCkge1xuICAgICAgICAgICAgaWYgKCt6SW5kZXggPT0gK3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGYuekluZGV4ID0gK3pJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBnaXZlbiBldmVudCB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBBcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcmVzdWx0IGZ1bmN0aW9uIHdpbGwgYmUgYWxzb1xuICAgICAqIGNvbmNhdGVkIHRvIHRoZSBsaXN0IG9mIGZpbmFsIGFyZ3VtZW50cy5cbiAgICAgfCBlbC5vbmNsaWNrID0gZXZlLmYoXCJjbGlja1wiLCAxLCAyKTtcbiAgICAgfCBldmUub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICB8ICAgICBjb25zb2xlLmxvZyhhLCBiLCBjKTsgLy8gMSwgMiwgW2V2ZW50IG9iamVjdF1cbiAgICAgfCB9KTtcbiAgICAgPiBBcmd1bWVudHNcbiAgICAgLSBldmVudCAoc3RyaW5nKSBldmVudCBuYW1lXG4gICAgIC0gdmFyYXJncyAo4oCmKSBhbmQgYW55IG90aGVyIGFyZ3VtZW50c1xuICAgICA9IChmdW5jdGlvbikgcG9zc2libGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICBldmUuZiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUuYXBwbHkobnVsbCwgW2V2ZW50LCBudWxsXS5jb25jYXQoYXR0cnMpLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSXMgdXNlZCBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlciB0byBzdG9wIHRoZSBldmVudCwgcHJldmVudGluZyBhbnkgc3Vic2VxdWVudCBsaXN0ZW5lcnMgZnJvbSBmaXJpbmcuXG4gICAgXFwqL1xuICAgIGV2ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wID0gMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gc3VibmFtZSAoc3RyaW5nKSAjb3B0aW9uYWwgc3VibmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgaWYgYHN1Ym5hbWVgIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBvclxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAsIGlmIGN1cnJlbnQgZXZlbnTigJlzIG5hbWUgY29udGFpbnMgYHN1Ym5hbWVgXG4gICAgXFwqL1xuICAgIGV2ZS5udCA9IGZ1bmN0aW9uIChzdWJuYW1lKSB7XG4gICAgICAgIHZhciBjdXIgPSBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudC5qb2luKFwiLlwiKSA6IGN1cnJlbnRfZXZlbnQ7XG4gICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIgKyBzdWJuYW1lICsgXCIoPzpcXFxcLnxcXFxcL3wkKVwiKS50ZXN0KGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGluc2lkZSBldmVudCBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQgYWN0dWFsIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqKlxuICAgICAqKlxuICAgICA9IChhcnJheSkgbmFtZXMgb2YgdGhlIGV2ZW50XG4gICAgXFwqL1xuICAgIGV2ZS5udHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudCA6IGN1cnJlbnRfZXZlbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub2ZmXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzIGFzc2lnbmVkIHRvIGdpdmVuIG5hbWUuXG4gICAgICogSWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCBhbGwgdGhlIGV2ZW50cyB3aWxsIGJlIGNsZWFyZWQuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogZXZlLnVuYmluZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBldmUub2ZmXG4gICAgXFwqL1xuICAgIGV2ZS5vZmYgPSBldmUudW5iaW5kID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBldmUuX2V2ZW50cyA9IGV2ZW50cyA9IHtuOiB7fX07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IChpc0FycmF5KG5hbWVbMF0pID8gbmFtZSA6IFtuYW1lXSkgOiBTdHIobmFtZSkuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXZlLm9mZihuYW1lc1tpXSwgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gbmFtZSA6IFN0cihuYW1lKS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNwbGljZSxcbiAgICAgICAgICAgIGksIGlpLCBqLCBqaixcbiAgICAgICAgICAgIGN1ciA9IFtldmVudHNdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXIubGVuZ3RoOyBqICs9IHNwbGljZS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlID0gW2osIDFdO1xuICAgICAgICAgICAgICAgIGUgPSBjdXJbal0ubjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gIT0gd2lsZGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW25hbWVzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlKSBpZiAoZVtoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLnNwbGljZS5hcHBseShjdXIsIHNwbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBjdXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGN1cltpXTtcbiAgICAgICAgICAgIHdoaWxlIChlLm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGUuZi5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZS5mW2pdID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmYuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWUuZi5sZW5ndGggJiYgZGVsZXRlIGUuZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jcyA9IGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGZ1bmNzLmxlbmd0aDsgaiA8IGpqOyBqKyspIGlmIChmdW5jc1tqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmNzLmxlbmd0aCAmJiBkZWxldGUgZS5uW2tleV0uZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUubikgaWYgKGUubltoYXNdKGtleSkgJiYgZS5uW2tleV0uZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5vbmNlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lIHRvIG9ubHkgcnVuIG9uY2UgdGhlbiB1bmJpbmQgaXRzZWxmLlxuICAgICB8IGV2ZS5vbmNlKFwibG9naW5cIiwgZik7XG4gICAgIHwgZXZlKFwibG9naW5cIik7IC8vIHRyaWdnZXJzIGZcbiAgICAgfCBldmUoXCJsb2dpblwiKTsgLy8gbm8gbGlzdGVuZXJzXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgID4gQXJndW1lbnRzXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICA9IChmdW5jdGlvbikgc2FtZSByZXR1cm4gZnVuY3Rpb24gYXMgQGV2ZS5vblxuICAgIFxcKi9cbiAgICBldmUub25jZSA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIHZhciBmMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5vZmYobmFtZSwgZjIpO1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV2ZS5vbihuYW1lLCBmMik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLnZlcnNpb25cbiAgICAgWyBwcm9wZXJ0eSAoc3RyaW5nKSBdXG4gICAgICoqXG4gICAgICogQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LlxuICAgIFxcKi9cbiAgICBldmUudmVyc2lvbiA9IHZlcnNpb247XG4gICAgZXZlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgYXJlIHJ1bm5pbmcgRXZlIFwiICsgdmVyc2lvbjtcbiAgICB9O1xuICAgICggdHJ1ZSAmJiBtb2R1bGUuZXhwb3J0cykgPyAobW9kdWxlLmV4cG9ydHMgPSBldmUpIDogKCB0cnVlID8gKCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIGV2ZTsgfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKSkgOiAodW5kZWZpbmVkKSk7XG59KSh0aGlzKTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18iLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyIsIlIiLCJhcHBseSIsInVuZGVmaW5lZCIsImV2ZSIsImZpcnN0IiwiaXMiLCJsb2FkZWQiLCJvbiIsImFycmF5IiwiX2VuZ2luZSIsInNwbGljZSIsIm51IiwiYWRkIiwiYXJncyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmIiwicG9wIiwidmVyc2lvbiIsInNlcGFyYXRvciIsImVsZW1lbnRzIiwiY2lyY2xlIiwicmVjdCIsInBhdGgiLCJlbGxpcHNlIiwidGV4dCIsImltYWdlIiwiZm9ybWF0cmciLCJwcm90byIsImhhcyIsImciLCJkb2MiLCJkb2N1bWVudCIsIndpbiIsIm9sZFJhcGhhZWwiLCJ3YXMiLCJSYXBoYWVsIiwiUGFwZXIiLCJjYSIsImN1c3RvbUF0dHJpYnV0ZXMiLCJwYXBlcnByb3RvIiwiYXBwZW5kQ2hpbGQiLCJjb25jYXQiLCJzdXBwb3J0c1RvdWNoIiwiVG91Y2hFdmVudCIsIkRvY3VtZW50VG91Y2giLCJFIiwiUyIsIlN0ciIsIlN0cmluZyIsInNwbGl0IiwiZXZlbnRzIiwidG91Y2hNYXAiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwibG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJtYXRoIiwiTWF0aCIsIm1tYXgiLCJtYXgiLCJtbWluIiwibWluIiwiYWJzIiwicG93IiwiUEkiLCJzdHJpbmciLCJ0b1N0cmluZyIsImZpbGxTdHJpbmciLCJvYmplY3RUb1N0cmluZyIsInBhcGVyIiwicHVzaCIsIklTVVJMIiwiX0lTVVJMIiwiY29sb3VyUmVnRXhwIiwiaXNuYW4iLCJiZXppZXJyZyIsInJvdW5kIiwic2V0QXR0cmlidXRlIiwidG9GbG9hdCIsInBhcnNlRmxvYXQiLCJ0b0ludCIsInBhcnNlSW50IiwidXBwZXJDYXNlIiwidG9VcHBlckNhc2UiLCJhdmFpbGFibGVBdHRycyIsIl9hdmFpbGFibGVBdHRycyIsImJsdXIiLCJjdXJzb3IiLCJjeCIsImN5IiwiZmlsbCIsImZvbnQiLCJncmFkaWVudCIsImhlaWdodCIsImhyZWYiLCJvcGFjaXR5IiwicngiLCJyeSIsInNyYyIsInN0cm9rZSIsInRhcmdldCIsInRpdGxlIiwidHJhbnNmb3JtIiwid2lkdGgiLCJ4IiwieSIsImF2YWlsYWJsZUFuaW1BdHRycyIsIl9hdmFpbGFibGVBbmltQXR0cnMiLCJ3aGl0ZXNwYWNlIiwiY29tbWFTcGFjZXMiLCJoc3JnIiwiaHMiLCJyZyIsInAycyIsInBhdGhDb21tYW5kIiwidENvbW1hbmQiLCJwYXRoVmFsdWVzIiwicmFkaWFsX2dyYWRpZW50IiwiX3JhZGlhbF9ncmFkaWVudCIsImVsZGF0YSIsInNvcnRCeUtleSIsImEiLCJiIiwic29ydEJ5TnVtYmVyIiwiZnVuIiwicGlwZSIsInJlY3RQYXRoIiwiX3JlY3RQYXRoIiwidyIsImgiLCJlbGxpcHNlUGF0aCIsImdldFBhdGgiLCJfZ2V0UGF0aCIsImVsIiwiYXR0ciIsImF0dHJzIiwiYmJveCIsIl9nZXRCQm94Iiwic2V0IiwibWFwUGF0aCIsIm1hdHJpeCIsImoiLCJpaSIsImpqIiwicGF0aGkiLCJwYXRoMmN1cnZlIiwiX2ciLCJ0eXBlIiwiU1ZHQW5nbGUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsInN0eWxlIiwiYmVoYXZpb3IiLCJhZGoiLCJzdmciLCJ2bWwiLCJfUGFwZXIiLCJmbiIsIl9pZCIsImlzQXJyYXkiLCJjbG9uZSIsIm9iaiIsInJlcyIsImNvbnN0cnVjdG9yIiwiYW5nbGUiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJhdGFuMiIsInJhZCIsImRlZyIsInNuYXBUbyIsInZhbHVlcyIsInRvbGVyYW5jZSIsInJlbSIsImNyZWF0ZVVVSUQiLCJ1dWlkUmVnRXgiLCJ1dWlkUmVwbGFjZXIiLCJyZXBsYWNlIiwicmFuZG9tIiwidiIsInNldFdpbmRvdyIsIm5ld3dpbiIsImluaXRXaW4iLCJ0b0hleCIsImNvbG9yIiwidHJpbSIsImJvZCIsImRvY3VtIiwiQWN0aXZlWE9iamVjdCIsIndyaXRlIiwiY2xvc2UiLCJib2R5IiwiZSIsImNyZWF0ZVBvcHVwIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjYWNoZXIiLCJxdWVyeUNvbW1hbmRWYWx1ZSIsImRpc3BsYXkiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaHNidG9TdHJpbmciLCJoc2x0b1N0cmluZyIsInJnYnRvU3RyaW5nIiwiaGV4IiwicHJlcGFyZVJHQiIsImNsciIsImdldFJHQiIsInBhY2thZ2VSR0IiLCJyZ2IiLCJoc2IycmdiIiwiaHNsMnJnYiIsInJnYjJoc2wiLCJyZ2IyaHNiIiwiRyIsIkIiLCJYIiwiQyIsIkgiLCJWIiwiTCIsIk0iLCJfcGF0aDJzdHJpbmciLCJqb2luIiwicmVwdXNoIiwiaXRlbSIsInNjb3BlIiwicG9zdHByb2Nlc3NvciIsIm5ld2YiLCJhcmciLCJjYWNoZSIsImNvdW50Iiwic2hpZnQiLCJwcmVsb2FkIiwiX3ByZWxvYWQiLCJpbWciLCJjc3NUZXh0Iiwib25sb2FkIiwicmVtb3ZlQ2hpbGQiLCJvbmVycm9yIiwiY2xyVG9TdHJpbmciLCJjb2xvdXIiLCJpbmRleE9mIiwiZXJyb3IiLCJzdWJzdHJpbmciLCJjaGFyQXQiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJtYXRjaCIsImhzYiIsImhzbCIsImdldENvbG9yIiwic3RhcnQiLCJyZXNldCIsImNhdG11bGxSb20yYmV6aWVyIiwiY3JwIiwieiIsImlMZW4iLCJwYXJzZVBhdGhTdHJpbmciLCJwYXRoU3RyaW5nIiwicHRoIiwicGF0aHMiLCJhcnIiLCJwYXRoQ2xvbmUiLCJwYXJhbUNvdW50cyIsInEiLCJkYXRhIiwicGFyYW1zIiwicGFyc2VUcmFuc2Zvcm1TdHJpbmciLCJUU3RyaW5nIiwiZWxlbSIsIm5ld0RhdGEiLCJuZXdMZXZlbCIsInBzIiwic2xlZXAiLCJzZXRUaW1lb3V0IiwiZmluZERvdHNBdFNlZ21lbnQiLCJwMXgiLCJwMXkiLCJjMXgiLCJjMXkiLCJjMngiLCJjMnkiLCJwMngiLCJwMnkiLCJ0MSIsInQxMyIsInQxMiIsInQyIiwidDMiLCJteCIsIm15IiwibngiLCJueSIsImF4IiwiYXkiLCJhbHBoYSIsImVuZCIsImJlemllckJCb3giLCJjdXJ2ZURpbSIsImlzUG9pbnRJbnNpZGVCQm94IiwiaXNCQm94SW50ZXJzZWN0IiwiYmJveDEiLCJiYm94MiIsImJhc2UzIiwicDEiLCJwMiIsInAzIiwicDQiLCJiZXpsZW4iLCJ4NCIsInk0IiwiejIiLCJUdmFsdWVzIiwiQ3ZhbHVlcyIsInN1bSIsImN0IiwieGJhc2UiLCJ5YmFzZSIsImNvbWIiLCJzcXJ0IiwiZ2V0VGF0TGVuIiwibGwiLCJzdGVwIiwiaW50ZXJzZWN0IiwiZGVub21pbmF0b3IiLCJweCIsInB5IiwicHgyIiwidG9GaXhlZCIsInB5MiIsImludGVyIiwiYmV6MSIsImJlejIiLCJpbnRlckhlbHBlciIsImludGVyQ291bnQiLCJqdXN0Q291bnQiLCJsMSIsImwyIiwibjEiLCJuMiIsImRvdHMxIiwiZG90czIiLCJ4eSIsImRpIiwiZGkxIiwiZGoiLCJkajEiLCJjaSIsImNqIiwicGF0aEludGVyc2VjdGlvbiIsInBhdGgxIiwicGF0aDIiLCJpbnRlclBhdGhIZWxwZXIiLCJwYXRoSW50ZXJzZWN0aW9uTnVtYmVyIiwiX3BhdGgyY3VydmUiLCJ4MW0iLCJ5MW0iLCJ4Mm0iLCJ5Mm0iLCJwaSIsInBqIiwiaW50ciIsImsiLCJrayIsInNlZ21lbnQxIiwic2VnbWVudDIiLCJpc1BvaW50SW5zaWRlUGF0aCIsInBhdGhCQm94IiwiX3JlbW92ZWRGYWN0b3J5IiwibWV0aG9kbmFtZSIsInBhdGhEaW1lbnNpb25zIiwiWSIsImRpbSIsInhtaW4iLCJ5bWluIiwieG1heCIsInltYXgiLCJiYiIsInBhdGhBcnJheSIsInBhdGhUb1JlbGF0aXZlIiwiX3BhdGhUb1JlbGF0aXZlIiwicmVsIiwicGEiLCJsZW4iLCJwYXRoVG9BYnNvbHV0ZSIsIl9wYXRoVG9BYnNvbHV0ZSIsImNyeiIsImRvdHMiLCJsMmMiLCJxMmMiLCJfMTMiLCJfMjMiLCJhMmMiLCJsYXJnZV9hcmNfZmxhZyIsInN3ZWVwX2ZsYWciLCJyZWN1cnNpdmUiLCJfMTIwIiwicm90YXRlIiwiY29zIiwic2luIiwicngyIiwicnkyIiwiZjEiLCJhc2luIiwiZjIiLCJkZiIsImYyb2xkIiwieDJvbGQiLCJ5Mm9sZCIsImMxIiwiczEiLCJjMiIsInMyIiwidGFuIiwiaHgiLCJoeSIsIm0xIiwibTIiLCJtMyIsIm00IiwibmV3cmVzIiwiZmluZERvdEF0U2VnbWVudCIsImRvdCIsImN1cnZlIiwiYngiLCJieSIsInF4IiwicXkiLCJhdHRyczIiLCJwcm9jZXNzUGF0aCIsInBjb20iLCJ0cSIsIlQiLCJRIiwiZml4QXJjIiwicHAiLCJwY29tczEiLCJwY29tczIiLCJmaXhNIiwiYTEiLCJhMiIsInBmaXJzdCIsInNlZyIsInNlZzIiLCJzZWdsZW4iLCJzZWcybGVuIiwicGFyc2VEb3RzIiwiX3BhcnNlRG90cyIsInBhciIsIm9mZnNldCIsInRlYXIiLCJfdGVhciIsInRvcCIsInByZXYiLCJib3R0b20iLCJuZXh0IiwidG9mcm9udCIsIl90b2Zyb250IiwidG9iYWNrIiwiX3RvYmFjayIsImluc2VydGFmdGVyIiwiX2luc2VydGFmdGVyIiwiZWwyIiwiaW5zZXJ0YmVmb3JlIiwiX2luc2VydGJlZm9yZSIsInRvTWF0cml4IiwiXyIsImdldEJCb3giLCJleHRyYWN0VHJhbnNmb3JtIiwidHJhbnNmb3JtUGF0aCIsIl9leHRyYWN0VHJhbnNmb3JtIiwidHN0ciIsInRkYXRhIiwiZHgiLCJkeSIsInN4Iiwic3kiLCJNYXRyaXgiLCJ0bGVuIiwiY29tbWFuZCIsImFic29sdXRlIiwiaW52ZXIiLCJpbnZlcnQiLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImRpcnR5VCIsImdldEVtcHR5IiwiZXF1YWxpc2VUcmFuc2Zvcm0iLCJfZXF1YWxpc2VUcmFuc2Zvcm0iLCJtYXhsZW5ndGgiLCJmcm9tIiwidG8iLCJ0dDEiLCJ0dDIiLCJfZ2V0Q29udGFpbmVyIiwiY29udGFpbmVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJ0YWdOYW1lIiwicGl4ZWxXaWR0aCIsIm9mZnNldFdpZHRoIiwicGl4ZWxIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJtYXRyaXhwcm90byIsIm91dCIsIm1lIiwiZnJvbUNoYXJDb2RlIiwidG9GaWx0ZXIiLCJub3JtIiwibm9ybWFsaXplIiwibWFnIiwicm93Iiwic2NhbGV4Iiwic2hlYXIiLCJzY2FsZXkiLCJhY29zIiwiaXNTaW1wbGUiLCJpc1N1cGVyU2ltcGxlIiwibm9Sb3RhdGlvbiIsInRvVHJhbnNmb3JtU3RyaW5nIiwic2hvcnRlciIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJwcmV2ZW50VG91Y2giLCJvcmlnaW5hbEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwic3RvcFRvdWNoIiwiZ2V0RXZlbnRQb3NpdGlvbiIsInNjcm9sbFkiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsImNsaWVudFgiLCJjbGllbnRZIiwiYWRkRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZWxlbWVudCIsInBvcyIsIl9mIiwib2xkZSIsInRhcmdldFRvdWNoZXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJldmVudCIsImRldGFjaGVyIiwiZGV0YWNoRXZlbnQiLCJkcmFnIiwiZHJhZ01vdmUiLCJkcmFnaSIsInRvdWNoZXMiLCJ0b3VjaCIsImlkZW50aWZpZXIiLCJfZHJhZyIsImlkIiwibm9kZSIsIm5leHRTaWJsaW5nIiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm9wZXJhIiwiZ2V0RWxlbWVudEJ5UG9pbnQiLCJpbnNlcnRCZWZvcmUiLCJtb3ZlX3Njb3BlIiwiZHJhZ1VwIiwidW5tb3VzZW1vdmUiLCJ1bm1vdXNldXAiLCJlbmRfc2NvcGUiLCJzdGFydF9zY29wZSIsImVscHJvdG8iLCJldmVudE5hbWUiLCJ1bmJpbmQiLCJzaGFwZSIsInJlbW92ZURhdGEiLCJnZXREYXRhIiwiaG92ZXIiLCJmX2luIiwiZl9vdXQiLCJzY29wZV9pbiIsInNjb3BlX291dCIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwidW5ob3ZlciIsInVubW91c2VvdmVyIiwidW5tb3VzZW91dCIsImRyYWdnYWJsZSIsIm9ubW92ZSIsIm9uc3RhcnQiLCJvbmVuZCIsIm9uRHJhZ092ZXIiLCJ1bmRyYWciLCJ1bm1vdXNlZG93biIsIl9fc2V0X18iLCJmb3JtYXQiLCJpdGVtc0FycmF5IiwiU2V0Iiwic2V0U3RhcnQiLCJzZXRGaW5pc2giLCJnZXRTaXplIiwiY2FudmFzIiwic2V0U2l6ZSIsInNldFZpZXdCb3giLCJmaXQiLCJyYXBoYWVsIiwiZ2V0T2Zmc2V0IiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib3duZXJEb2N1bWVudCIsImRvY0VsZW0iLCJjbGllbnRUb3AiLCJjbGllbnRMZWZ0IiwicGFnZVlPZmZzZXQiLCJsZWZ0IiwicGFnZVhPZmZzZXQiLCJlbGVtZW50RnJvbVBvaW50Iiwic28iLCJzciIsImNyZWF0ZVNWR1JlY3QiLCJoaXRzIiwiZ2V0SW50ZXJzZWN0aW9uTGlzdCIsImdldEJ5SWQiLCJyYXBoYWVsaWQiLCJnZXRFbGVtZW50c0J5QkJveCIsImZvckVhY2giLCJib3QiLCJjYWxsYmFjayIsInRoaXNBcmciLCJnZXRFbGVtZW50c0J5UG9pbnQiLCJpc1BvaW50SW5zaWRlIiwieF95IiwieF95X3dfaCIsInJwIiwicmVhbFBhdGgiLCJpc1dpdGhvdXRUcmFuc2Zvcm0iLCJyZW1vdmVkIiwiZGlydHkiLCJiYm94d3QiLCJnbG93Iiwib2Zmc2V0eCIsIm9mZnNldHkiLCJjdXJ2ZXNsZW5ndGhzIiwiZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgiLCJnZXRMZW5ndGhGYWN0b3J5IiwiaXN0b3RhbCIsInN1YnBhdGgiLCJvbmx5c3RhcnQiLCJzcCIsInN1YnBhdGhzIiwicG9pbnQiLCJnZXRUb3RhbExlbmd0aCIsImdldFBvaW50QXRMZW5ndGgiLCJnZXRTdWJwYXRoc0F0TGVuZ3RoIiwiZ2V0U3VicGF0aCIsImVmIiwiZWFzaW5nX2Zvcm11bGFzIiwibGluZWFyIiwiYmFja0luIiwiYmFja091dCIsImVsYXN0aWMiLCJib3VuY2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwiYW5pbWF0aW9uRWxlbWVudHMiLCJyZXF1ZXN0QW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uIiwiTm93IiwiRGF0ZSIsInBhdXNlZCIsInRpbWUiLCJtcyIsImVhc2luZyIsImRpZmYiLCJ0aGF0Iiwibm93IiwiaW5pdCIsImluaXRzdGF0dXMiLCJhbmltIiwicGVyY2VudCIsInN0YXR1cyIsInN0b3AiLCJ1cHRvMjU1IiwicmVhbCIsImZyb20yIiwicmVwZWF0IiwidG90YWxPcmlnaW4iLCJydW5BbmltYXRpb24iLCJwZXJjZW50cyIsImFuaW1hdGVXaXRoIiwiQW5pbWF0aW9uIiwiQ3ViaWNCZXppZXJBdFRpbWUiLCJkdXJhdGlvbiIsInNhbXBsZUN1cnZlWCIsInNvbHZlIiwiZXBzaWxvbiIsInNvbHZlQ3VydmVYIiwidDAiLCJkMiIsIm9uQW5pbWF0aW9uIiwibmV3QW5pbSIsInRpbWVzIiwic29ydCIsImRlbGF5IiwiZGVsIiwiZmxvb3IiLCJpc0luQW5pbSIsImlzSW5BbmltU2V0IiwidGltZXN0YW1wIiwidG9Db2xvdXIiLCJwYXRoZXMiLCJ0b1BhdGgiLCJlcSIsInRvMiIsImVhc3llYXN5Iiwib3JpZ2luIiwianNvbiIsImxhc3RLZXkiLCJhbmltYXRlIiwic2V0VGltZSIsInBhdXNlIiwicmVzdW1lIiwic3RvcEFuaW1hdGlvbiIsIml0ZW1zIiwic2V0cHJvdG8iLCJtZXRob2QiLCJjbGVhciIsImluZGV4IiwiaW5zZXJ0aW9uIiwidGFpbCIsInRvZGVsIiwiYXJnbGVuIiwiZXhjbHVkZSIsImNvbGxlY3RvciIsImluc2VydEFmdGVyIiwiZ2xvd0NvbmZpZyIsInJldCIsInNoYXBlMiIsImluZGV4MiIsInJlZ2lzdGVyRm9udCIsImZhY2UiLCJmb250cyIsImZvbnRjb3B5IiwiZ2x5cGhzIiwiZmFtaWx5IiwicHJvcCIsImdseXBoIiwiZ2V0Rm9udCIsIndlaWdodCIsInN0cmV0Y2giLCJub3JtYWwiLCJib2xkIiwibGlnaHRlciIsImJvbGRlciIsIlJlZ0V4cCIsImZvbnROYW1lIiwidGVzdCIsInRoZWZvbnQiLCJwcmludCIsInNpemUiLCJsZXR0ZXJfc3BhY2luZyIsImxpbmVfc3BhY2luZyIsImxldHRlcnMiLCJub3RmaXJzdCIsImxpbmVIZWlnaHQiLCJzaGlmdHkiLCJkZXNjZW50IiwiY3VyciIsInRva2VuIiwic3RyIiwiZnVsbGZpbGwiLCJ0b2tlblJlZ2V4Iiwib2JqTm90YXRpb25SZWdleCIsInJlcGxhY2VyIiwiYWxsIiwicXVvdGUiLCJxdW90ZWROYW1lIiwiaXNGdW5jIiwibmluamEiLCJzdCIsInJlYWR5U3RhdGUiLCJpc0xvYWRlZCIsInhsaW5rIiwibWFya2VycyIsImJsb2NrIiwiY2xhc3NpYyIsImRpYW1vbmQiLCJvcGVuIiwib3ZhbCIsIm1hcmtlckNvdW50ZXIiLCIkIiwic2V0QXR0cmlidXRlTlMiLCJjcmVhdGVFbGVtZW50TlMiLCJ3ZWJraXRUYXBIaWdobGlnaHRDb2xvciIsImFkZEdyYWRpZW50RmlsbCIsImZ4IiwiZnkiLCJTVkciLCJfZngiLCJfZnkiLCJkaXIiLCJpc05hTiIsInZlY3RvciIsImRlZnMiLCJncmFkaWVudFRyYW5zZm9ybSIsImlzRmluaXRlIiwiZmlsbHVybCIsImZpbGxPcGFjaXR5IiwiaXNJRTlvcjEwIiwiZG9jdW1lbnRNb2RlIiwibG9jYXRpb24iLCJsb2NhdGlvblN0cmluZyIsInByb3RvY29sIiwiaG9zdCIsInBhdGhuYW1lIiwic2VhcmNoIiwidXBkYXRlUG9zaXRpb24iLCJwYXR0ZXJuIiwicGF0dGVyblRyYW5zZm9ybSIsImFkZEFycm93IiwiaXNFbmQiLCJzZSIsInJlZlgiLCJhcnJvd3MiLCJlbmRQYXRoIiwiZW5kTWFya2VyIiwic3RhcnRQYXRoIiwic3RhcnRNYXJrZXIiLCJwYXRoSWQiLCJtYXJrZXJJZCIsIm1hcmtlciIsInVzZSIsIm1hcmtlckhlaWdodCIsIm1hcmtlcldpZHRoIiwib3JpZW50IiwicmVmWSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZGVsdGEiLCJzdGFydGR4IiwiZW5kZHgiLCJkYXNoYXJyYXkiLCJhZGREYXNoZXMiLCJidXR0Iiwic3F1YXJlIiwiZGFzaGVzIiwic2V0RmlsbEFuZFN0cm9rZSIsInZpcyIsInZpc2liaWxpdHkiLCJhdHQiLCJub2RlVmFsdWUiLCJ2YWwiLCJjcmVhdGVUZXh0Tm9kZSIsInBuIiwiaGwiLCJjbGlwIiwicmMiLCJnZXRBdHRyaWJ1dGUiLCJzdGFydFN0cmluZyIsImVuZFN0cmluZyIsImlzVVJMIiwiaWciLCJwYXR0ZXJuVW5pdHMiLCJzdG9wcyIsImNzc3J1bGUiLCJ0dW5lVGV4dCIsImxlYWRpbmciLCJmb250U2l6ZSIsInRleHRzIiwidHNwYW5zIiwidHNwYW4iLCJkaWYiLCJnZXRSZWFsTm9kZSIsIkVsZW1lbnQiLCJndWlkIiwic3ciLCJoaWRlIiwic2hvdyIsInJlbW92ZSIsImNhbnZhc0hpZGRlbiIsImNvbnRhaW5lclN0eWxlIiwicGFyZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibmFtZXMiLCJkZWYiLCJzdWJrZXkiLCJ0b0Zyb250IiwidG9CYWNrIiwiYWZ0ZXJOb2RlIiwiYmVmb3JlTm9kZSIsImZsdHIiLCJzdGREZXZpYXRpb24iLCJfYmx1ciIsImZpbHRlciIsInJlbW92ZUF0dHJpYnV0ZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJfdmlld0JveCIsImNvbiIsIkVycm9yIiwiY252cyIsImNzcyIsImlzRmxvYXRpbmciLCJ4bWxucyIsIl9sZWZ0IiwiX3RvcCIsInJlbmRlcmZpeCIsInBhcGVyU2l6ZSIsImFzcGVjdFJhdGlvIiwidmIiLCJfdmJTaXplIiwidmlld0JveCIsImdldFNjcmVlbkNUTSIsImNyZWF0ZVNWR01hdHJpeCIsImRlc2MiLCJtYXAiLCJaIiwiYml0ZXMiLCJibHVycmVnZXhwIiwiY3NzRG90Iiwiem9vbSIsInBhdGhUeXBlcyIsIm92YWxUeXBlcyIsInBhdGgydm1sIiwidG90YWwiLCJ2YWxzIiwiaXNNb3ZlIiwiY29tcGVuc2F0aW9uIiwic2V0Q29vcmRzIiwiZmlsbHBvcyIsImZsaXAiLCJkeGR5Iiwia3giLCJreSIsImNvb3Jkc2l6ZSIsInJvdGF0aW9uIiwiY29vcmRvcmlnaW4iLCJmaWxsc2l6ZSIsInBvc2l0aW9uIiwibmV3cGF0aCIsImlzT3ZhbCIsImRpdiIsImNsaXBSZWN0IiwiZHN0eWxlIiwidGV4dHBhdGgiLCJ0ZXh0cGF0aFN0eWxlIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJuZXdmaWxsIiwiY3JlYXRlTm9kZSIsIm5ld3N0cm9rZSIsInN0cm9rZUNvbG9yIiwiam9pbnN0eWxlIiwibWl0ZXJsaW1pdCIsImVuZGNhcCIsImRhc2hzdHlsZSIsInNwYW4iLCJicmVjdCIsIlciLCJyaWdodCIsImRpcnR5YXR0cnMiLCJkZCIsImJieCIsIm9pbmRleCIsImZ4ZnkiLCJjb2xvcjIiLCJjbHJzIiwiY29sb3JzIiwiZm9jdXMiLCJmb2N1c3NpemUiLCJmb2N1c3Bvc2l0aW9uIiwiX29pZCIsInZicyIsIl92aWV3Qm94U2hpZnQiLCJ2YnQiLCJvbGR0Iiwic2tldyIsImlzR3JhZCIsImlzUGF0dCIsImJidCIsImF1eEdldEJCb3giLCJydW50aW1lU3R5bGUiLCJtYXJnaW4iLCJQYXRoIiwidGV4dHBhdGhvayIsImNzIiwic3R5bGVTaGVldHMiLCJjcmVhdGVTdHlsZVNoZWV0IiwiYWRkUnVsZSIsIm5hbWVzcGFjZXMiLCJydm1sIiwiZ2xvYiIsImNvbWFzZXBhcmF0b3IiLCJ3aWxkY2FyZCIsIm51bXNvcnQiLCJjdXJyZW50X2V2ZW50IiwiZmlyc3REZWZpbmVkIiwibGFzdERlZmluZWQiLCJvYmp0b3MiLCJhciIsIm9sZHN0b3AiLCJsaXN0ZW5lcnMiLCJpbmRleGVkIiwicXVldWUiLCJjZSIsImVycm9ycyIsInpJbmRleCIsIl9ldmVudHMiLCJuZXMiLCJlcyIsInNlcCIsImV4aXN0IiwibnQiLCJzdWJuYW1lIiwiY3VyIiwibnRzIiwib2ZmIiwiZnVuY3MiLCJvbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/raphael/raphael.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/raphael/raphael.js");
/******/ 	
/******/ })()
;