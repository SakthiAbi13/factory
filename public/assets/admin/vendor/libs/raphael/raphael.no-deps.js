/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/assets/vendor/libs/raphael/raphael.no-deps.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/vendor/libs/raphael/raphael.no-deps.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// ┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐ \\\\\n// │ Raphaël 2.3.0 - JavaScript Vector Library                                                             │ \\\\\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\n// │ Copyright © 2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                       │ \\\\\n// │ Copyright © 2008-2016 Sencha Labs (http://sencha.com)                                                 │ \\\\\n// ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\\\\n// │ Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license.│ \\\\\n// └───────────────────────────────────────────────────────────────────────────────────────────────────────┘ \\\\\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'eve'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'eve'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(window, function (__WEBPACK_EXTERNAL_MODULE_eve__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __nested_webpack_require_2064__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_2064__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __nested_webpack_require_2064__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __nested_webpack_require_2064__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __nested_webpack_require_2064__.d = function (exports, name, getter) {\n        /******/\n        if (!__nested_webpack_require_2064__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __nested_webpack_require_2064__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __nested_webpack_require_2064__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __nested_webpack_require_2064__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __nested_webpack_require_2064__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __nested_webpack_require_2064__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __nested_webpack_require_2064__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __nested_webpack_require_2064__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __nested_webpack_require_2064__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __nested_webpack_require_2064__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __nested_webpack_require_2064__(__nested_webpack_require_2064__.s = \"./dev/raphael.amd.js\");\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ({\n      /***/\n      \"./dev/raphael.amd.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.amd.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelAmdJs(module, exports, __nested_webpack_require_7003__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_7003__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\"), __nested_webpack_require_7003__(\n        /*! ./raphael.svg */\n        \"./dev/raphael.svg.js\"), __nested_webpack_require_7003__(\n        /*! ./raphael.vml */\n        \"./dev/raphael.vml.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          return R;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.core.js\":\n      /*!*****************************!*\\\n        !*** ./dev/raphael.core.js ***!\n        \\*****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelCoreJs(module, exports, __nested_webpack_require_7904__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_7904__(\n        /*! eve */\n        \"eve\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {\n          /*\\\n           * Raphael\n           [ method ]\n           **\n           * Creates a canvas object on which to draw.\n           * You must do this first, as all future calls to drawing methods\n           * from this instance will be bound to this canvas.\n           > Parameters\n           **\n           - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n           - width (number)\n           - height (number)\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - x (number)\n           - y (number)\n           - width (number)\n           - height (number)\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n           - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n           * or\n           - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.\n           = (object) @Paper\n           > Usage\n           | // Each of the following examples create a canvas\n           | // that is 320px wide by 200px high.\n           | // Canvas is created at the viewport’s 10,50 coordinate.\n           | var paper = Raphael(10, 50, 320, 200);\n           | // Canvas is created at the top left corner of the #notepad element\n           | // (or its top right corner in dir=\"rtl\" elements)\n           | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n           | // Same as above\n           | var paper = Raphael(\"notepad\", 320, 200);\n           | // Image dump\n           | var set = Raphael([\"notepad\", 320, 200, {\n           |     type: \"rect\",\n           |     x: 10,\n           |     y: 10,\n           |     width: 25,\n           |     height: 25,\n           |     stroke: \"#f00\"\n           | }, {\n           |     type: \"text\",\n           |     x: 30,\n           |     y: 40,\n           |     text: \"Dump\"\n           | }]);\n          \\*/\n          function R(first) {\n            if (R.is(first, \"function\")) {\n              return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n            } else if (R.is(first, array)) {\n              return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n            } else {\n              var args = Array.prototype.slice.call(arguments, 0);\n\n              if (R.is(args[args.length - 1], \"function\")) {\n                var f = args.pop();\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n                  f.call(R._engine.create[apply](R, args));\n                });\n              } else {\n                return R._engine.create[apply](R, arguments);\n              }\n            }\n          }\n\n          R.version = \"2.3.0\";\n          R.eve = eve;\n\n          var loaded,\n              separator = /[, ]+/,\n              elements = {\n            circle: 1,\n            rect: 1,\n            path: 1,\n            ellipse: 1,\n            text: 1,\n            image: 1\n          },\n              formatrg = /\\{(\\d+)\\}/g,\n              proto = \"prototype\",\n              has = \"hasOwnProperty\",\n              g = {\n            doc: document,\n            win: window\n          },\n              oldRaphael = {\n            was: Object.prototype[has].call(g.win, \"Raphael\"),\n            is: g.win.Raphael\n          },\n              Paper = function Paper() {\n            /*\\\n             * Paper.ca\n             [ property (object) ]\n             **\n             * Shortcut for @Paper.customAttributes\n            \\*/\n\n            /*\\\n             * Paper.customAttributes\n             [ property (object) ]\n             **\n             * If you have a set of attributes that you would like to represent\n             * as a function of some number you can do it easily with custom attributes:\n             > Usage\n             | paper.customAttributes.hue = function (num) {\n             |     num = num % 1;\n             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\n             | };\n             | // Custom attribute “hue” will change fill\n             | // to be given hue with fixed saturation and brightness.\n             | // Now you can use it like this:\n             | var c = paper.circle(10, 10, 10).attr({hue: .45});\n             | // or even like this:\n             | c.animate({hue: 1}, 1e3);\n             |\n             | // You could also create custom attribute\n             | // with multiple parameters:\n             | paper.customAttributes.hsb = function (h, s, b) {\n             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\n             | };\n             | c.attr({hsb: \"0.5 .8 1\"});\n             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\n            \\*/\n            this.ca = this.customAttributes = {};\n          },\n              paperproto,\n              appendChild = \"appendChild\",\n              apply = \"apply\",\n              concat = \"concat\",\n              //taken from Modernizr touch test: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js#L40\n          supportsTouch = 'ontouchstart' in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,\n              E = \"\",\n              S = \" \",\n              Str = String,\n              split = \"split\",\n              events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\n              touchMap = {\n            mousedown: \"touchstart\",\n            mousemove: \"touchmove\",\n            mouseup: \"touchend\"\n          },\n              lowerCase = Str.prototype.toLowerCase,\n              math = Math,\n              mmax = math.max,\n              mmin = math.min,\n              abs = math.abs,\n              pow = math.pow,\n              PI = math.PI,\n              nu = \"number\",\n              string = \"string\",\n              array = \"array\",\n              toString = \"toString\",\n              fillString = \"fill\",\n              objectToString = Object.prototype.toString,\n              paper = {},\n              push = \"push\",\n              ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\n              colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n              isnan = {\n            \"NaN\": 1,\n            \"Infinity\": 1,\n            \"-Infinity\": 1\n          },\n              bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n              round = math.round,\n              setAttribute = \"setAttribute\",\n              toFloat = parseFloat,\n              toInt = parseInt,\n              upperCase = Str.prototype.toUpperCase,\n              availableAttrs = R._availableAttrs = {\n            \"arrow-end\": \"none\",\n            \"arrow-start\": \"none\",\n            blur: 0,\n            \"clip-rect\": \"0 0 1e9 1e9\",\n            cursor: \"default\",\n            cx: 0,\n            cy: 0,\n            fill: \"#fff\",\n            \"fill-opacity\": 1,\n            font: '10px \"Arial\"',\n            \"font-family\": '\"Arial\"',\n            \"font-size\": \"10\",\n            \"font-style\": \"normal\",\n            \"font-weight\": 400,\n            gradient: 0,\n            height: 0,\n            href: \"http://raphaeljs.com/\",\n            \"letter-spacing\": 0,\n            opacity: 1,\n            path: \"M0,0\",\n            r: 0,\n            rx: 0,\n            ry: 0,\n            src: \"\",\n            stroke: \"#000\",\n            \"stroke-dasharray\": \"\",\n            \"stroke-linecap\": \"butt\",\n            \"stroke-linejoin\": \"butt\",\n            \"stroke-miterlimit\": 0,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            target: \"_blank\",\n            \"text-anchor\": \"middle\",\n            title: \"Raphael\",\n            transform: \"\",\n            width: 0,\n            x: 0,\n            y: 0,\n            \"class\": \"\"\n          },\n              availableAnimAttrs = R._availableAnimAttrs = {\n            blur: nu,\n            \"clip-rect\": \"csv\",\n            cx: nu,\n            cy: nu,\n            fill: \"colour\",\n            \"fill-opacity\": nu,\n            \"font-size\": nu,\n            height: nu,\n            opacity: nu,\n            path: \"path\",\n            r: nu,\n            rx: nu,\n            ry: nu,\n            stroke: \"colour\",\n            \"stroke-opacity\": nu,\n            \"stroke-width\": nu,\n            transform: \"transform\",\n            width: nu,\n            x: nu,\n            y: nu\n          },\n              whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\n              commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n              hsrg = {\n            hs: 1,\n            rg: 1\n          },\n              p2s = /,?([achlmqrstvxz]),?/gi,\n              pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n              tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n              pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n              radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\n              eldata = {},\n              sortByKey = function sortByKey(a, b) {\n            return a.key - b.key;\n          },\n              sortByNumber = function sortByNumber(a, b) {\n            return toFloat(a) - toFloat(b);\n          },\n              fun = function fun() {},\n              pipe = function pipe(x) {\n            return x;\n          },\n              rectPath = R._rectPath = function (x, y, w, h, r) {\n            if (r) {\n              return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\n            }\n\n            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n          },\n              ellipsePath = function ellipsePath(x, y, rx, ry) {\n            if (ry == null) {\n              ry = rx;\n            }\n\n            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n          },\n              getPath = R._getPath = {\n            path: function path(el) {\n              return el.attr(\"path\");\n            },\n            circle: function circle(el) {\n              var a = el.attrs;\n              return ellipsePath(a.cx, a.cy, a.r);\n            },\n            ellipse: function ellipse(el) {\n              var a = el.attrs;\n              return ellipsePath(a.cx, a.cy, a.rx, a.ry);\n            },\n            rect: function rect(el) {\n              var a = el.attrs;\n              return rectPath(a.x, a.y, a.width, a.height, a.r);\n            },\n            image: function image(el) {\n              var a = el.attrs;\n              return rectPath(a.x, a.y, a.width, a.height);\n            },\n            text: function text(el) {\n              var bbox = el._getBBox();\n\n              return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            },\n            set: function set(el) {\n              var bbox = el._getBBox();\n\n              return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            }\n          },\n\n          /*\\\n           * Raphael.mapPath\n           [ method ]\n           **\n           * Transform the path string with given matrix.\n           > Parameters\n           - path (string) path string\n           - matrix (object) see @Matrix\n           = (string) transformed path string\n          \\*/\n          mapPath = R.mapPath = function (path, matrix) {\n            if (!matrix) {\n              return path;\n            }\n\n            var x, y, i, j, ii, jj, pathi;\n            path = path2curve(path);\n\n            for (i = 0, ii = path.length; i < ii; i++) {\n              pathi = path[i];\n\n              for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n              }\n            }\n\n            return path;\n          };\n\n          R._g = g;\n          /*\\\n           * Raphael.type\n           [ property (string) ]\n           **\n           * Can be “SVG”, “VML” or empty, depending on browser support.\n          \\*/\n\n          R.type = g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\";\n\n          if (R.type == \"VML\") {\n            var d = g.doc.createElement(\"div\"),\n                b;\n            d.innerHTML = '<v:shape adj=\"1\"/>';\n            b = d.firstChild;\n            b.style.behavior = \"url(#default#VML)\";\n\n            if (!(b && _typeof(b.adj) == \"object\")) {\n              return R.type = E;\n            }\n\n            d = null;\n          }\n          /*\\\n           * Raphael.svg\n           [ property (boolean) ]\n           **\n           * `true` if browser supports SVG.\n          \\*/\n\n          /*\\\n           * Raphael.vml\n           [ property (boolean) ]\n           **\n           * `true` if browser supports VML.\n          \\*/\n\n\n          R.svg = !(R.vml = R.type == \"VML\");\n          R._Paper = Paper;\n          /*\\\n           * Raphael.fn\n           [ property (object) ]\n           **\n           * You can add your own method to the canvas. For example if you want to draw a pie chart,\n           * you can create your own pie chart function and ship it as a Raphaël plugin. To do this\n           * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\n           * Raphaël instance is created, otherwise it will take no effect. Please note that the\n           * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\n           * ensure any namespacing ensures proper context.\n           > Usage\n           | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\n           |     return this.path( ... );\n           | };\n           | // or create namespace\n           | Raphael.fn.mystuff = {\n           |     arrow: function () {…},\n           |     star: function () {…},\n           |     // etc…\n           | };\n           | var paper = Raphael(10, 10, 630, 480);\n           | // then use it\n           | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\n           | paper.mystuff.arrow();\n           | paper.mystuff.star();\n          \\*/\n\n          R.fn = paperproto = Paper.prototype = R.prototype;\n          R._id = 0;\n          /*\\\n           * Raphael.is\n           [ method ]\n           **\n           * Handful of replacements for `typeof` operator.\n           > Parameters\n           - o (…) any object or primitive\n           - type (string) name of the type, i.e. “string”, “function”, “number”, etc.\n           = (boolean) is given value is of given type\n          \\*/\n\n          R.is = function (o, type) {\n            type = lowerCase.call(type);\n\n            if (type == \"finite\") {\n              return !isnan[has](+o);\n            }\n\n            if (type == \"array\") {\n              return o instanceof Array;\n            }\n\n            return type == \"null\" && o === null || type == _typeof(o) && o !== null || type == \"object\" && o === Object(o) || type == \"array\" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;\n          };\n\n          function clone(obj) {\n            if (typeof obj == \"function\" || Object(obj) !== obj) {\n              return obj;\n            }\n\n            var res = new obj.constructor();\n\n            for (var key in obj) {\n              if (obj[has](key)) {\n                res[key] = clone(obj[key]);\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.angle\n           [ method ]\n           **\n           * Returns angle between two or three points\n           > Parameters\n           - x1 (number) x coord of first point\n           - y1 (number) y coord of first point\n           - x2 (number) x coord of second point\n           - y2 (number) y coord of second point\n           - x3 (number) #optional x coord of third point\n           - y3 (number) #optional y coord of third point\n           = (number) angle in degrees.\n          \\*/\n\n\n          R.angle = function (x1, y1, x2, y2, x3, y3) {\n            if (x3 == null) {\n              var x = x1 - x2,\n                  y = y1 - y2;\n\n              if (!x && !y) {\n                return 0;\n              }\n\n              return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n            } else {\n              return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\n            }\n          };\n          /*\\\n           * Raphael.rad\n           [ method ]\n           **\n           * Transform angle to radians\n           > Parameters\n           - deg (number) angle in degrees\n           = (number) angle in radians.\n          \\*/\n\n\n          R.rad = function (deg) {\n            return deg % 360 * PI / 180;\n          };\n          /*\\\n           * Raphael.deg\n           [ method ]\n           **\n           * Transform angle to degrees\n           > Parameters\n           - rad (number) angle in radians\n           = (number) angle in degrees.\n          \\*/\n\n\n          R.deg = function (rad) {\n            return Math.round(rad * 180 / PI % 360 * 1000) / 1000;\n          };\n          /*\\\n           * Raphael.snapTo\n           [ method ]\n           **\n           * Snaps given value to given grid.\n           > Parameters\n           - values (array|number) given array of values or step of the grid\n           - value (number) value to adjust\n           - tolerance (number) #optional tolerance for snapping. Default is `10`.\n           = (number) adjusted value.\n          \\*/\n\n\n          R.snapTo = function (values, value, tolerance) {\n            tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\n\n            if (R.is(values, array)) {\n              var i = values.length;\n\n              while (i--) {\n                if (abs(values[i] - value) <= tolerance) {\n                  return values[i];\n                }\n              }\n            } else {\n              values = +values;\n              var rem = value % values;\n\n              if (rem < tolerance) {\n                return value - rem;\n              }\n\n              if (rem > values - tolerance) {\n                return value - rem + values;\n              }\n            }\n\n            return value;\n          };\n          /*\\\n           * Raphael.createUUID\n           [ method ]\n           **\n           * Returns RFC4122, version 4 ID\n          \\*/\n\n\n          var createUUID = R.createUUID = function (uuidRegEx, uuidReplacer) {\n            return function () {\n              return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\n            };\n          }(/[xy]/g, function (c) {\n            var r = math.random() * 16 | 0,\n                v = c == \"x\" ? r : r & 3 | 8;\n            return v.toString(16);\n          });\n          /*\\\n           * Raphael.setWindow\n           [ method ]\n           **\n           * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\n           > Parameters\n           - newwin (window) new window object\n          \\*/\n\n\n          R.setWindow = function (newwin) {\n            eve(\"raphael.setWindow\", R, g.win, newwin);\n            g.win = newwin;\n            g.doc = g.win.document;\n\n            if (R._engine.initWin) {\n              R._engine.initWin(g.win);\n            }\n          };\n\n          var _toHex = function toHex(color) {\n            if (R.vml) {\n              // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\n              var trim = /^\\s+|\\s+$/g;\n              var bod;\n\n              try {\n                var docum = new ActiveXObject(\"htmlfile\");\n                docum.write(\"<body>\");\n                docum.close();\n                bod = docum.body;\n              } catch (e) {\n                bod = createPopup().document.body;\n              }\n\n              var range = bod.createTextRange();\n              _toHex = cacher(function (color) {\n                try {\n                  bod.style.color = Str(color).replace(trim, E);\n                  var value = range.queryCommandValue(\"ForeColor\");\n                  value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;\n                  return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\n                } catch (e) {\n                  return \"none\";\n                }\n              });\n            } else {\n              var i = g.doc.createElement(\"i\");\n              i.title = \"Rapha\\xebl Colour Picker\";\n              i.style.display = \"none\";\n              g.doc.body.appendChild(i);\n              _toHex = cacher(function (color) {\n                i.style.color = color;\n                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n              });\n            }\n\n            return _toHex(color);\n          },\n              hsbtoString = function hsbtoString() {\n            return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n          },\n              hsltoString = function hsltoString() {\n            return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n          },\n              rgbtoString = function rgbtoString() {\n            return this.hex;\n          },\n              prepareRGB = function prepareRGB(r, g, b) {\n            if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n              b = r.b;\n              g = r.g;\n              r = r.r;\n            }\n\n            if (g == null && R.is(r, string)) {\n              var clr = R.getRGB(r);\n              r = clr.r;\n              g = clr.g;\n              b = clr.b;\n            }\n\n            if (r > 1 || g > 1 || b > 1) {\n              r /= 255;\n              g /= 255;\n              b /= 255;\n            }\n\n            return [r, g, b];\n          },\n              packageRGB = function packageRGB(r, g, b, o) {\n            r *= 255;\n            g *= 255;\n            b *= 255;\n            var rgb = {\n              r: r,\n              g: g,\n              b: b,\n              hex: R.rgb(r, g, b),\n              toString: rgbtoString\n            };\n            R.is(o, \"finite\") && (rgb.opacity = o);\n            return rgb;\n          };\n          /*\\\n           * Raphael.color\n           [ method ]\n           **\n           * Parses the color string and returns object with all values for the given color.\n           > Parameters\n           - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\n           = (object) Combined RGB & HSB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••,\n           o     error (boolean) `true` if string can’t be parsed,\n           o     h (number) hue,\n           o     s (number) saturation,\n           o     v (number) value (brightness),\n           o     l (number) lightness\n           o }\n          \\*/\n\n\n          R.color = function (clr) {\n            var rgb;\n\n            if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n              rgb = R.hsb2rgb(clr);\n              clr.r = rgb.r;\n              clr.g = rgb.g;\n              clr.b = rgb.b;\n              clr.hex = rgb.hex;\n            } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n              rgb = R.hsl2rgb(clr);\n              clr.r = rgb.r;\n              clr.g = rgb.g;\n              clr.b = rgb.b;\n              clr.hex = rgb.hex;\n            } else {\n              if (R.is(clr, \"string\")) {\n                clr = R.getRGB(clr);\n              }\n\n              if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\n                rgb = R.rgb2hsl(clr);\n                clr.h = rgb.h;\n                clr.s = rgb.s;\n                clr.l = rgb.l;\n                rgb = R.rgb2hsb(clr);\n                clr.v = rgb.b;\n              } else {\n                clr = {\n                  hex: \"none\"\n                };\n                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n              }\n            }\n\n            clr.toString = rgbtoString;\n            return clr;\n          };\n          /*\\\n           * Raphael.hsb2rgb\n           [ method ]\n           **\n           * Converts HSB values to RGB object.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - v (number) value or brightness\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••\n           o }\n          \\*/\n\n\n          R.hsb2rgb = function (h, s, v, o) {\n            if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n              v = h.b;\n              s = h.s;\n              o = h.o;\n              h = h.h;\n            }\n\n            h *= 360;\n            var R, G, B, X, C;\n            h = h % 360 / 60;\n            C = v * s;\n            X = C * (1 - abs(h % 2 - 1));\n            R = G = B = v - C;\n            h = ~~h;\n            R += [C, X, 0, 0, X, C][h];\n            G += [X, C, C, X, 0, 0][h];\n            B += [0, 0, X, C, C, X][h];\n            return packageRGB(R, G, B, o);\n          };\n          /*\\\n           * Raphael.hsl2rgb\n           [ method ]\n           **\n           * Converts HSL values to RGB object.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - l (number) luminosity\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue,\n           o     hex (string) color in HTML/CSS format: #••••••\n           o }\n          \\*/\n\n\n          R.hsl2rgb = function (h, s, l, o) {\n            if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n              l = h.l;\n              s = h.s;\n              h = h.h;\n            }\n\n            if (h > 1 || s > 1 || l > 1) {\n              h /= 360;\n              s /= 100;\n              l /= 100;\n            }\n\n            h *= 360;\n            var R, G, B, X, C;\n            h = h % 360 / 60;\n            C = 2 * s * (l < .5 ? l : 1 - l);\n            X = C * (1 - abs(h % 2 - 1));\n            R = G = B = l - C / 2;\n            h = ~~h;\n            R += [C, X, 0, 0, X, C][h];\n            G += [X, C, C, X, 0, 0][h];\n            B += [0, 0, X, C, C, X][h];\n            return packageRGB(R, G, B, o);\n          };\n          /*\\\n           * Raphael.rgb2hsb\n           [ method ]\n           **\n           * Converts RGB values to HSB object.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (object) HSB object in format:\n           o {\n           o     h (number) hue\n           o     s (number) saturation\n           o     b (number) brightness\n           o }\n          \\*/\n\n\n          R.rgb2hsb = function (r, g, b) {\n            b = prepareRGB(r, g, b);\n            r = b[0];\n            g = b[1];\n            b = b[2];\n            var H, S, V, C;\n            V = mmax(r, g, b);\n            C = V - mmin(r, g, b);\n            H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;\n            H = (H + 360) % 6 * 60 / 360;\n            S = C == 0 ? 0 : C / V;\n            return {\n              h: H,\n              s: S,\n              b: V,\n              toString: hsbtoString\n            };\n          };\n          /*\\\n           * Raphael.rgb2hsl\n           [ method ]\n           **\n           * Converts RGB values to HSL object.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (object) HSL object in format:\n           o {\n           o     h (number) hue\n           o     s (number) saturation\n           o     l (number) luminosity\n           o }\n          \\*/\n\n\n          R.rgb2hsl = function (r, g, b) {\n            b = prepareRGB(r, g, b);\n            r = b[0];\n            g = b[1];\n            b = b[2];\n            var H, S, L, M, m, C;\n            M = mmax(r, g, b);\n            m = mmin(r, g, b);\n            C = M - m;\n            H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;\n            H = (H + 360) % 6 * 60 / 360;\n            L = (M + m) / 2;\n            S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);\n            return {\n              h: H,\n              s: S,\n              l: L,\n              toString: hsltoString\n            };\n          };\n\n          R._path2string = function () {\n            return this.join(\",\").replace(p2s, \"$1\");\n          };\n\n          function repush(array, item) {\n            for (var i = 0, ii = array.length; i < ii; i++) {\n              if (array[i] === item) {\n                return array.push(array.splice(i, 1)[0]);\n              }\n            }\n          }\n\n          function cacher(f, scope, postprocessor) {\n            function newf() {\n              var arg = Array.prototype.slice.call(arguments, 0),\n                  args = arg.join(\"\\u2400\"),\n                  cache = newf.cache = newf.cache || {},\n                  count = newf.count = newf.count || [];\n\n              if (cache[has](args)) {\n                repush(count, args);\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\n              }\n\n              count.length >= 1e3 && delete cache[count.shift()];\n              count.push(args);\n              cache[args] = f[apply](scope, arg);\n              return postprocessor ? postprocessor(cache[args]) : cache[args];\n            }\n\n            return newf;\n          }\n\n          var preload = R._preload = function (src, f) {\n            var img = g.doc.createElement(\"img\");\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\n            img.onload = function () {\n              f.call(this);\n              this.onload = null;\n              g.doc.body.removeChild(this);\n            };\n\n            img.onerror = function () {\n              g.doc.body.removeChild(this);\n            };\n\n            g.doc.body.appendChild(img);\n            img.src = src;\n          };\n\n          function clrToString() {\n            return this.hex;\n          }\n          /*\\\n           * Raphael.getRGB\n           [ method ]\n           **\n           * Parses colour string as RGB object\n           > Parameters\n           - colour (string) colour string in one of formats:\n           # <ul>\n           #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\n           #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\n           #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\n           #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\n           #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\n           #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\n           #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsl(•••, •••, •••) — same as hsb</li>\n           #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>\n           # </ul>\n           = (object) RGB object in format:\n           o {\n           o     r (number) red,\n           o     g (number) green,\n           o     b (number) blue\n           o     hex (string) color in HTML/CSS format: #••••••,\n           o     error (boolean) true if string can’t be parsed\n           o }\n          \\*/\n\n\n          R.getRGB = cacher(function (colour) {\n            if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n              return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                error: 1,\n                toString: clrToString\n              };\n            }\n\n            if (colour == \"none\") {\n              return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                toString: clrToString\n              };\n            }\n\n            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = _toHex(colour));\n            var res,\n                red,\n                green,\n                blue,\n                opacity,\n                t,\n                values,\n                rgb = colour.match(colourRegExp);\n\n            if (rgb) {\n              if (rgb[2]) {\n                blue = toInt(rgb[2].substring(5), 16);\n                green = toInt(rgb[2].substring(3, 5), 16);\n                red = toInt(rgb[2].substring(1, 3), 16);\n              }\n\n              if (rgb[3]) {\n                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n              }\n\n              if (rgb[4]) {\n                values = rgb[4][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n              }\n\n              if (rgb[5]) {\n                values = rgb[5][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsb2rgb(red, green, blue, opacity);\n              }\n\n              if (rgb[6]) {\n                values = rgb[6][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsl2rgb(red, green, blue, opacity);\n              }\n\n              rgb = {\n                r: red,\n                g: green,\n                b: blue,\n                toString: clrToString\n              };\n              rgb.hex = \"#\" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);\n              R.is(opacity, \"finite\") && (rgb.opacity = opacity);\n              return rgb;\n            }\n\n            return {\n              r: -1,\n              g: -1,\n              b: -1,\n              hex: \"none\",\n              error: 1,\n              toString: clrToString\n            };\n          }, R);\n          /*\\\n           * Raphael.hsb\n           [ method ]\n           **\n           * Converts HSB values to hex representation of the colour.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - b (number) value or brightness\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.hsb = cacher(function (h, s, b) {\n            return R.hsb2rgb(h, s, b).hex;\n          });\n          /*\\\n           * Raphael.hsl\n           [ method ]\n           **\n           * Converts HSL values to hex representation of the colour.\n           > Parameters\n           - h (number) hue\n           - s (number) saturation\n           - l (number) luminosity\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.hsl = cacher(function (h, s, l) {\n            return R.hsl2rgb(h, s, l).hex;\n          });\n          /*\\\n           * Raphael.rgb\n           [ method ]\n           **\n           * Converts RGB values to hex representation of the colour.\n           > Parameters\n           - r (number) red\n           - g (number) green\n           - b (number) blue\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.rgb = cacher(function (r, g, b) {\n            function round(x) {\n              return x + 0.5 | 0;\n            }\n\n            return \"#\" + (16777216 | round(b) | round(g) << 8 | round(r) << 16).toString(16).slice(1);\n          });\n          /*\\\n           * Raphael.getColor\n           [ method ]\n           **\n           * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\n           > Parameters\n           - value (number) #optional brightness, default is `0.75`\n           = (string) hex representation of the colour.\n          \\*/\n\n          R.getColor = function (value) {\n            var start = this.getColor.start = this.getColor.start || {\n              h: 0,\n              s: 1,\n              b: value || .75\n            },\n                rgb = this.hsb2rgb(start.h, start.s, start.b);\n            start.h += .075;\n\n            if (start.h > 1) {\n              start.h = 0;\n              start.s -= .2;\n              start.s <= 0 && (this.getColor.start = {\n                h: 0,\n                s: 1,\n                b: start.b\n              });\n            }\n\n            return rgb.hex;\n          };\n          /*\\\n           * Raphael.getColor.reset\n           [ method ]\n           **\n           * Resets spectrum position for @Raphael.getColor back to red.\n          \\*/\n\n\n          R.getColor.reset = function () {\n            delete this.start;\n          }; // http://schepers.cc/getting-to-the-point\n\n\n          function catmullRom2bezier(crp, z) {\n            var d = [];\n\n            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n              var p = [{\n                x: +crp[i - 2],\n                y: +crp[i - 1]\n              }, {\n                x: +crp[i],\n                y: +crp[i + 1]\n              }, {\n                x: +crp[i + 2],\n                y: +crp[i + 3]\n              }, {\n                x: +crp[i + 4],\n                y: +crp[i + 5]\n              }];\n\n              if (z) {\n                if (!i) {\n                  p[0] = {\n                    x: +crp[iLen - 2],\n                    y: +crp[iLen - 1]\n                  };\n                } else if (iLen - 4 == i) {\n                  p[3] = {\n                    x: +crp[0],\n                    y: +crp[1]\n                  };\n                } else if (iLen - 2 == i) {\n                  p[2] = {\n                    x: +crp[0],\n                    y: +crp[1]\n                  };\n                  p[3] = {\n                    x: +crp[2],\n                    y: +crp[3]\n                  };\n                }\n              } else {\n                if (iLen - 4 == i) {\n                  p[3] = p[2];\n                } else if (!i) {\n                  p[0] = {\n                    x: +crp[i],\n                    y: +crp[i + 1]\n                  };\n                }\n              }\n\n              d.push([\"C\", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);\n            }\n\n            return d;\n          }\n          /*\\\n           * Raphael.parsePathString\n           [ method ]\n           **\n           * Utility method\n           **\n           * Parses given path string into an array of arrays of path segments.\n           > Parameters\n           - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\n           = (array) array of segments.\n          \\*/\n\n\n          R.parsePathString = function (pathString) {\n            if (!pathString) {\n              return null;\n            }\n\n            var pth = paths(pathString);\n\n            if (pth.arr) {\n              return pathClone(pth.arr);\n            }\n\n            var paramCounts = {\n              a: 7,\n              c: 6,\n              h: 1,\n              l: 2,\n              m: 2,\n              r: 4,\n              q: 4,\n              s: 4,\n              t: 2,\n              v: 1,\n              z: 0\n            },\n                data = [];\n\n            if (R.is(pathString, array) && R.is(pathString[0], array)) {\n              // rough assumption\n              data = pathClone(pathString);\n            }\n\n            if (!data.length) {\n              Str(pathString).replace(pathCommand, function (a, b, c) {\n                var params = [],\n                    name = b.toLowerCase();\n                c.replace(pathValues, function (a, b) {\n                  b && params.push(+b);\n                });\n\n                if (name == \"m\" && params.length > 2) {\n                  data.push([b][concat](params.splice(0, 2)));\n                  name = \"l\";\n                  b = b == \"m\" ? \"l\" : \"L\";\n                }\n\n                if (name == \"r\") {\n                  data.push([b][concat](params));\n                } else while (params.length >= paramCounts[name]) {\n                  data.push([b][concat](params.splice(0, paramCounts[name])));\n\n                  if (!paramCounts[name]) {\n                    break;\n                  }\n                }\n              });\n            }\n\n            data.toString = R._path2string;\n            pth.arr = pathClone(data);\n            return data;\n          };\n          /*\\\n           * Raphael.parseTransformString\n           [ method ]\n           **\n           * Utility method\n           **\n           * Parses given path string into an array of transformations.\n           > Parameters\n           - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\n           = (array) array of transformations.\n          \\*/\n\n\n          R.parseTransformString = cacher(function (TString) {\n            if (!TString) {\n              return null;\n            }\n\n            var paramCounts = {\n              r: 3,\n              s: 4,\n              t: 2,\n              m: 6\n            },\n                data = [];\n\n            if (R.is(TString, array) && R.is(TString[0], array)) {\n              // rough assumption\n              data = pathClone(TString);\n            }\n\n            if (!data.length) {\n              Str(TString).replace(tCommand, function (a, b, c) {\n                var params = [],\n                    name = lowerCase.call(b);\n                c.replace(pathValues, function (a, b) {\n                  b && params.push(+b);\n                });\n                data.push([b][concat](params));\n              });\n            }\n\n            data.toString = R._path2string;\n            return data;\n          }, this, function (elem) {\n            if (!elem) return elem;\n            var newData = [];\n\n            for (var i = 0; i < elem.length; i++) {\n              var newLevel = [];\n\n              for (var j = 0; j < elem[i].length; j++) {\n                newLevel.push(elem[i][j]);\n              }\n\n              newData.push(newLevel);\n            }\n\n            return newData;\n          }); // PATHS\n\n          var paths = function paths(ps) {\n            var p = paths.ps = paths.ps || {};\n\n            if (p[ps]) {\n              p[ps].sleep = 100;\n            } else {\n              p[ps] = {\n                sleep: 100\n              };\n            }\n\n            setTimeout(function () {\n              for (var key in p) {\n                if (p[has](key) && key != ps) {\n                  p[key].sleep--;\n                  !p[key].sleep && delete p[key];\n                }\n              }\n            });\n            return p[ps];\n          };\n          /*\\\n           * Raphael.findDotsAtSegment\n           [ method ]\n           **\n           * Utility method\n           **\n           * Find dot coordinates on the given cubic bezier curve at the given t.\n           > Parameters\n           - p1x (number) x of the first point of the curve\n           - p1y (number) y of the first point of the curve\n           - c1x (number) x of the first anchor of the curve\n           - c1y (number) y of the first anchor of the curve\n           - c2x (number) x of the second anchor of the curve\n           - c2y (number) y of the second anchor of the curve\n           - p2x (number) x of the second point of the curve\n           - p2y (number) y of the second point of the curve\n           - t (number) position on the curve (0..1)\n           = (object) point information in format:\n           o {\n           o     x: (number) x coordinate of the point\n           o     y: (number) y coordinate of the point\n           o     m: {\n           o         x: (number) x coordinate of the left anchor\n           o         y: (number) y coordinate of the left anchor\n           o     }\n           o     n: {\n           o         x: (number) x coordinate of the right anchor\n           o         y: (number) y coordinate of the right anchor\n           o     }\n           o     start: {\n           o         x: (number) x coordinate of the start of the curve\n           o         y: (number) y coordinate of the start of the curve\n           o     }\n           o     end: {\n           o         x: (number) x coordinate of the end of the curve\n           o         y: (number) y coordinate of the end of the curve\n           o     }\n           o     alpha: (number) angle of the curve derivative at the point\n           o }\n          \\*/\n\n\n          R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n            var t1 = 1 - t,\n                t13 = pow(t1, 3),\n                t12 = pow(t1, 2),\n                t2 = t * t,\n                t3 = t2 * t,\n                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n                ax = t1 * p1x + t * c1x,\n                ay = t1 * p1y + t * c1y,\n                cx = t1 * c2x + t * p2x,\n                cy = t1 * c2y + t * p2y,\n                alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;\n            (mx > nx || my < ny) && (alpha += 180);\n            return {\n              x: x,\n              y: y,\n              m: {\n                x: mx,\n                y: my\n              },\n              n: {\n                x: nx,\n                y: ny\n              },\n              start: {\n                x: ax,\n                y: ay\n              },\n              end: {\n                x: cx,\n                y: cy\n              },\n              alpha: alpha\n            };\n          };\n          /*\\\n           * Raphael.bezierBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Return bounding box of a given cubic bezier curve\n           > Parameters\n           - p1x (number) x of the first point of the curve\n           - p1y (number) y of the first point of the curve\n           - c1x (number) x of the first anchor of the curve\n           - c1y (number) y of the first anchor of the curve\n           - c2x (number) x of the second anchor of the curve\n           - c2y (number) y of the second anchor of the curve\n           - p2x (number) x of the second point of the curve\n           - p2y (number) y of the second point of the curve\n           * or\n           - bez (array) array of six points for bezier curve\n           = (object) point information in format:\n           o {\n           o     min: {\n           o         x: (number) x coordinate of the left point\n           o         y: (number) y coordinate of the top point\n           o     }\n           o     max: {\n           o         x: (number) x coordinate of the right point\n           o         y: (number) y coordinate of the bottom point\n           o     }\n           o }\n          \\*/\n\n\n          R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n            if (!R.is(p1x, \"array\")) {\n              p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n            }\n\n            var bbox = curveDim.apply(null, p1x);\n            return {\n              x: bbox.min.x,\n              y: bbox.min.y,\n              x2: bbox.max.x,\n              y2: bbox.max.y,\n              width: bbox.max.x - bbox.min.x,\n              height: bbox.max.y - bbox.min.y\n            };\n          };\n          /*\\\n           * Raphael.isPointInsideBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if given point is inside bounding boxes.\n           > Parameters\n           - bbox (string) bounding box\n           - x (string) x coordinate of the point\n           - y (string) y coordinate of the point\n           = (boolean) `true` if point inside\n          \\*/\n\n\n          R.isPointInsideBBox = function (bbox, x, y) {\n            return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\n          };\n          /*\\\n           * Raphael.isBBoxIntersect\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if two bounding boxes intersect\n           > Parameters\n           - bbox1 (string) first bounding box\n           - bbox2 (string) second bounding box\n           = (boolean) `true` if they intersect\n          \\*/\n\n\n          R.isBBoxIntersect = function (bbox1, bbox2) {\n            var i = R.isPointInsideBBox;\n            return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n          };\n\n          function base3(t, p1, p2, p3, p4) {\n            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n            return t * t2 - 3 * p1 + 3 * p2;\n          }\n\n          function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n            if (z == null) {\n              z = 1;\n            }\n\n            z = z > 1 ? 1 : z < 0 ? 0 : z;\n            var z2 = z / 2,\n                n = 12,\n                Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],\n                Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],\n                sum = 0;\n\n            for (var i = 0; i < n; i++) {\n              var ct = z2 * Tvalues[i] + z2,\n                  xbase = base3(ct, x1, x2, x3, x4),\n                  ybase = base3(ct, y1, y2, y3, y4),\n                  comb = xbase * xbase + ybase * ybase;\n              sum += Cvalues[i] * math.sqrt(comb);\n            }\n\n            return z2 * sum;\n          }\n\n          function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n              return;\n            }\n\n            var t = 1,\n                step = t / 2,\n                t2 = t - step,\n                l,\n                e = .01;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\n            while (abs(l - ll) > e) {\n              step /= 2;\n              t2 += (l < ll ? 1 : -1) * step;\n              l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n            }\n\n            return t2;\n          }\n\n          function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n            if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {\n              return;\n            }\n\n            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n            if (!denominator) {\n              return;\n            }\n\n            var px = nx / denominator,\n                py = ny / denominator,\n                px2 = +px.toFixed(2),\n                py2 = +py.toFixed(2);\n\n            if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {\n              return;\n            }\n\n            return {\n              x: px,\n              y: py\n            };\n          }\n\n          function inter(bez1, bez2) {\n            return interHelper(bez1, bez2);\n          }\n\n          function interCount(bez1, bez2) {\n            return interHelper(bez1, bez2, 1);\n          }\n\n          function interHelper(bez1, bez2, justCount) {\n            var bbox1 = R.bezierBBox(bez1),\n                bbox2 = R.bezierBBox(bez2);\n\n            if (!R.isBBoxIntersect(bbox1, bbox2)) {\n              return justCount ? 0 : [];\n            }\n\n            var l1 = bezlen.apply(0, bez1),\n                l2 = bezlen.apply(0, bez2),\n                n1 = mmax(~~(l1 / 5), 1),\n                n2 = mmax(~~(l2 / 5), 1),\n                dots1 = [],\n                dots2 = [],\n                xy = {},\n                res = justCount ? 0 : [];\n\n            for (var i = 0; i < n1 + 1; i++) {\n              var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\n              dots1.push({\n                x: p.x,\n                y: p.y,\n                t: i / n1\n              });\n            }\n\n            for (i = 0; i < n2 + 1; i++) {\n              p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\n              dots2.push({\n                x: p.x,\n                y: p.y,\n                t: i / n2\n              });\n            }\n\n            for (i = 0; i < n1; i++) {\n              for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\n                if (is) {\n                  if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                    continue;\n                  }\n\n                  xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                  var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                      t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\n                  if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\n                    if (justCount) {\n                      res++;\n                    } else {\n                      res.push({\n                        x: is.x,\n                        y: is.y,\n                        t1: mmin(t1, 1),\n                        t2: mmin(t2, 1)\n                      });\n                    }\n                  }\n                }\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.pathIntersection\n           [ method ]\n           **\n           * Utility method\n           **\n           * Finds intersections of two paths\n           > Parameters\n           - path1 (string) path string\n           - path2 (string) path string\n           = (array) dots of intersection\n           o [\n           o     {\n           o         x: (number) x coordinate of the point\n           o         y: (number) y coordinate of the point\n           o         t1: (number) t value for segment of path1\n           o         t2: (number) t value for segment of path2\n           o         segment1: (number) order number for segment of path1\n           o         segment2: (number) order number for segment of path2\n           o         bez1: (array) eight coordinates representing beziér curve for the segment of path1\n           o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n           o     }\n           o ]\n          \\*/\n\n\n          R.pathIntersection = function (path1, path2) {\n            return interPathHelper(path1, path2);\n          };\n\n          R.pathIntersectionNumber = function (path1, path2) {\n            return interPathHelper(path1, path2, 1);\n          };\n\n          function interPathHelper(path1, path2, justCount) {\n            path1 = R._path2curve(path1);\n            path2 = R._path2curve(path2);\n            var x1,\n                y1,\n                x2,\n                y2,\n                x1m,\n                y1m,\n                x2m,\n                y2m,\n                bez1,\n                bez2,\n                res = justCount ? 0 : [];\n\n            for (var i = 0, ii = path1.length; i < ii; i++) {\n              var pi = path1[i];\n\n              if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n              } else {\n                if (pi[0] == \"C\") {\n                  bez1 = [x1, y1].concat(pi.slice(1));\n                  x1 = bez1[6];\n                  y1 = bez1[7];\n                } else {\n                  bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                  x1 = x1m;\n                  y1 = y1m;\n                }\n\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                  var pj = path2[j];\n\n                  if (pj[0] == \"M\") {\n                    x2 = x2m = pj[1];\n                    y2 = y2m = pj[2];\n                  } else {\n                    if (pj[0] == \"C\") {\n                      bez2 = [x2, y2].concat(pj.slice(1));\n                      x2 = bez2[6];\n                      y2 = bez2[7];\n                    } else {\n                      bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                      x2 = x2m;\n                      y2 = y2m;\n                    }\n\n                    var intr = interHelper(bez1, bez2, justCount);\n\n                    if (justCount) {\n                      res += intr;\n                    } else {\n                      for (var k = 0, kk = intr.length; k < kk; k++) {\n                        intr[k].segment1 = i;\n                        intr[k].segment2 = j;\n                        intr[k].bez1 = bez1;\n                        intr[k].bez2 = bez2;\n                      }\n\n                      res = res.concat(intr);\n                    }\n                  }\n                }\n              }\n            }\n\n            return res;\n          }\n          /*\\\n           * Raphael.isPointInsidePath\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns `true` if given point is inside a given closed path.\n           > Parameters\n           - path (string) path string\n           - x (number) x of the point\n           - y (number) y of the point\n           = (boolean) true, if point is inside the path\n          \\*/\n\n\n          R.isPointInsidePath = function (path, x, y) {\n            var bbox = R.pathBBox(path);\n            return R.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n          };\n\n          R._removedFactory = function (methodname) {\n            return function () {\n              eve(\"raphael.log\", null, \"Rapha\\xEBl: you are calling to method \\u201C\" + methodname + \"\\u201D of removed object\", methodname);\n            };\n          };\n          /*\\\n           * Raphael.pathBBox\n           [ method ]\n           **\n           * Utility method\n           **\n           * Return bounding box of a given path\n           > Parameters\n           - path (string) path string\n           = (object) bounding box\n           o {\n           o     x: (number) x coordinate of the left top point of the box\n           o     y: (number) y coordinate of the left top point of the box\n           o     x2: (number) x coordinate of the right bottom point of the box\n           o     y2: (number) y coordinate of the right bottom point of the box\n           o     width: (number) width of the box\n           o     height: (number) height of the box\n           o     cx: (number) x coordinate of the center of the box\n           o     cy: (number) y coordinate of the center of the box\n           o }\n          \\*/\n\n\n          var pathDimensions = R.pathBBox = function (path) {\n            var pth = paths(path);\n\n            if (pth.bbox) {\n              return clone(pth.bbox);\n            }\n\n            if (!path) {\n              return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n                x2: 0,\n                y2: 0\n              };\n            }\n\n            path = path2curve(path);\n            var x = 0,\n                y = 0,\n                X = [],\n                Y = [],\n                p;\n\n            for (var i = 0, ii = path.length; i < ii; i++) {\n              p = path[i];\n\n              if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n              } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X[concat](dim.min.x, dim.max.x);\n                Y = Y[concat](dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n              }\n            }\n\n            var xmin = mmin[apply](0, X),\n                ymin = mmin[apply](0, Y),\n                xmax = mmax[apply](0, X),\n                ymax = mmax[apply](0, Y),\n                width = xmax - xmin,\n                height = ymax - ymin,\n                bb = {\n              x: xmin,\n              y: ymin,\n              x2: xmax,\n              y2: ymax,\n              width: width,\n              height: height,\n              cx: xmin + width / 2,\n              cy: ymin + height / 2\n            };\n            pth.bbox = clone(bb);\n            return bb;\n          },\n              pathClone = function pathClone(pathArray) {\n            var res = clone(pathArray);\n            res.toString = R._path2string;\n            return res;\n          },\n              pathToRelative = R._pathToRelative = function (pathArray) {\n            var pth = paths(pathArray);\n\n            if (pth.rel) {\n              return pathClone(pth.rel);\n            }\n\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {\n              // rough assumption\n              pathArray = R.parsePathString(pathArray);\n            }\n\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n\n            if (pathArray[0][0] == \"M\") {\n              x = pathArray[0][1];\n              y = pathArray[0][2];\n              mx = x;\n              my = y;\n              start++;\n              res.push([\"M\", x, y]);\n            }\n\n            for (var i = start, ii = pathArray.length; i < ii; i++) {\n              var r = res[i] = [],\n                  pa = pathArray[i];\n\n              if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n\n                switch (r[0]) {\n                  case \"a\":\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +(pa[6] - x).toFixed(3);\n                    r[7] = +(pa[7] - y).toFixed(3);\n                    break;\n\n                  case \"v\":\n                    r[1] = +(pa[1] - y).toFixed(3);\n                    break;\n\n                  case \"m\":\n                    mx = pa[1];\n                    my = pa[2];\n\n                  default:\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\n                      r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);\n                    }\n\n                }\n              } else {\n                r = res[i] = [];\n\n                if (pa[0] == \"m\") {\n                  mx = pa[1] + x;\n                  my = pa[2] + y;\n                }\n\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                  res[i][k] = pa[k];\n                }\n              }\n\n              var len = res[i].length;\n\n              switch (res[i][0]) {\n                case \"z\":\n                  x = mx;\n                  y = my;\n                  break;\n\n                case \"h\":\n                  x += +res[i][len - 1];\n                  break;\n\n                case \"v\":\n                  y += +res[i][len - 1];\n                  break;\n\n                default:\n                  x += +res[i][len - 2];\n                  y += +res[i][len - 1];\n              }\n            }\n\n            res.toString = R._path2string;\n            pth.rel = pathClone(res);\n            return res;\n          },\n              pathToAbsolute = R._pathToAbsolute = function (pathArray) {\n            var pth = paths(pathArray);\n\n            if (pth.abs) {\n              return pathClone(pth.abs);\n            }\n\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {\n              // rough assumption\n              pathArray = R.parsePathString(pathArray);\n            }\n\n            if (!pathArray || !pathArray.length) {\n              return [[\"M\", 0, 0]];\n            }\n\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n\n            if (pathArray[0][0] == \"M\") {\n              x = +pathArray[0][1];\n              y = +pathArray[0][2];\n              mx = x;\n              my = y;\n              start++;\n              res[0] = [\"M\", x, y];\n            }\n\n            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n\n            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n              res.push(r = []);\n              pa = pathArray[i];\n\n              if (pa[0] != upperCase.call(pa[0])) {\n                r[0] = upperCase.call(pa[0]);\n\n                switch (r[0]) {\n                  case \"A\":\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +(pa[6] + x);\n                    r[7] = +(pa[7] + y);\n                    break;\n\n                  case \"V\":\n                    r[1] = +pa[1] + y;\n                    break;\n\n                  case \"H\":\n                    r[1] = +pa[1] + x;\n                    break;\n\n                  case \"R\":\n                    var dots = [x, y][concat](pa.slice(1));\n\n                    for (var j = 2, jj = dots.length; j < jj; j++) {\n                      dots[j] = +dots[j] + x;\n                      dots[++j] = +dots[j] + y;\n                    }\n\n                    res.pop();\n                    res = res[concat](catmullRom2bezier(dots, crz));\n                    break;\n\n                  case \"M\":\n                    mx = +pa[1] + x;\n                    my = +pa[2] + y;\n\n                  default:\n                    for (j = 1, jj = pa.length; j < jj; j++) {\n                      r[j] = +pa[j] + (j % 2 ? x : y);\n                    }\n\n                }\n              } else if (pa[0] == \"R\") {\n                dots = [x, y][concat](pa.slice(1));\n                res.pop();\n                res = res[concat](catmullRom2bezier(dots, crz));\n                r = [\"R\"][concat](pa.slice(-2));\n              } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                  r[k] = pa[k];\n                }\n              }\n\n              switch (r[0]) {\n                case \"Z\":\n                  x = mx;\n                  y = my;\n                  break;\n\n                case \"H\":\n                  x = r[1];\n                  break;\n\n                case \"V\":\n                  y = r[1];\n                  break;\n\n                case \"M\":\n                  mx = r[r.length - 2];\n                  my = r[r.length - 1];\n\n                default:\n                  x = r[r.length - 2];\n                  y = r[r.length - 1];\n              }\n            }\n\n            res.toString = R._path2string;\n            pth.abs = pathClone(res);\n            return res;\n          },\n              l2c = function l2c(x1, y1, x2, y2) {\n            return [x1, y1, x2, y2, x2, y2];\n          },\n              q2c = function q2c(x1, y1, ax, ay, x2, y2) {\n            var _13 = 1 / 3,\n                _23 = 2 / 3;\n\n            return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n          },\n              a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = PI * 120 / 180,\n                rad = PI / 180 * (+angle || 0),\n                res = [],\n                xy,\n                rotate = cacher(function (x, y, rad) {\n              var X = x * math.cos(rad) - y * math.sin(rad),\n                  Y = x * math.sin(rad) + y * math.cos(rad);\n              return {\n                x: X,\n                y: Y\n              };\n            });\n\n            if (!recursive) {\n              xy = rotate(x1, y1, -rad);\n              x1 = xy.x;\n              y1 = xy.y;\n              xy = rotate(x2, y2, -rad);\n              x2 = xy.x;\n              y2 = xy.y;\n              var cos = math.cos(PI / 180 * angle),\n                  sin = math.sin(PI / 180 * angle),\n                  x = (x1 - x2) / 2,\n                  y = (y1 - y2) / 2;\n              var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n              if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n              }\n\n              var rx2 = rx * rx,\n                  ry2 = ry * ry,\n                  k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                  cx = k * rx * y / ry + (x1 + x2) / 2,\n                  cy = k * -ry * x / rx + (y1 + y2) / 2,\n                  f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                  f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n              f1 = x1 < cx ? PI - f1 : f1;\n              f2 = x2 < cx ? PI - f2 : f2;\n              f1 < 0 && (f1 = PI * 2 + f1);\n              f2 < 0 && (f2 = PI * 2 + f2);\n\n              if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n              }\n\n              if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n              }\n            } else {\n              f1 = recursive[0];\n              f2 = recursive[1];\n              cx = recursive[2];\n              cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n\n            if (abs(df) > _120) {\n              var f2old = f2,\n                  x2old = x2,\n                  y2old = y2;\n              f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n              x2 = cx + rx * math.cos(f2);\n              y2 = cy + ry * math.sin(f2);\n              res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n            var c1 = math.cos(f1),\n                s1 = math.sin(f1),\n                c2 = math.cos(f2),\n                s2 = math.sin(f2),\n                t = math.tan(df / 4),\n                hx = 4 / 3 * rx * t,\n                hy = 4 / 3 * ry * t,\n                m1 = [x1, y1],\n                m2 = [x1 + hx * s1, y1 - hy * c1],\n                m3 = [x2 + hx * s2, y2 - hy * c2],\n                m4 = [x2, y2];\n            m2[0] = 2 * m1[0] - m2[0];\n            m2[1] = 2 * m1[1] - m2[1];\n\n            if (recursive) {\n              return [m2, m3, m4][concat](res);\n            } else {\n              res = [m2, m3, m4][concat](res).join()[split](\",\");\n              var newres = [];\n\n              for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n              }\n\n              return newres;\n            }\n          },\n              findDotAtSegment = function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n            var t1 = 1 - t;\n            return {\n              x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n              y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n            };\n          },\n              curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n            var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),\n                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\n                c = p1x - c1x,\n                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                y = [p1y, p2y],\n                x = [p1x, p2x],\n                dot;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n\n            if (t1 > 0 && t1 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            if (t2 > 0 && t2 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);\n            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\n            c = p1y - c1y;\n            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n\n            if (t1 > 0 && t1 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            if (t2 > 0 && t2 < 1) {\n              dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n              x.push(dot.x);\n              y.push(dot.y);\n            }\n\n            return {\n              min: {\n                x: mmin[apply](0, x),\n                y: mmin[apply](0, y)\n              },\n              max: {\n                x: mmax[apply](0, x),\n                y: mmax[apply](0, y)\n              }\n            };\n          }),\n              path2curve = R._path2curve = cacher(function (path, path2) {\n            var pth = !path2 && paths(path);\n\n            if (!path2 && pth.curve) {\n              return pathClone(pth.curve);\n            }\n\n            var p = pathToAbsolute(path),\n                p2 = path2 && pathToAbsolute(path2),\n                attrs = {\n              x: 0,\n              y: 0,\n              bx: 0,\n              by: 0,\n              X: 0,\n              Y: 0,\n              qx: null,\n              qy: null\n            },\n                attrs2 = {\n              x: 0,\n              y: 0,\n              bx: 0,\n              by: 0,\n              X: 0,\n              Y: 0,\n              qx: null,\n              qy: null\n            },\n                processPath = function processPath(path, d, pcom) {\n              var nx,\n                  ny,\n                  tq = {\n                T: 1,\n                Q: 1\n              };\n\n              if (!path) {\n                return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n              }\n\n              !(path[0] in tq) && (d.qx = d.qy = null);\n\n              switch (path[0]) {\n                case \"M\":\n                  d.X = path[1];\n                  d.Y = path[2];\n                  break;\n\n                case \"A\":\n                  path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\n                  break;\n\n                case \"S\":\n                  if (pcom == \"C\" || pcom == \"S\") {\n                    // In \"S\" case we have to take into account, if the previous command is C/S.\n                    nx = d.x * 2 - d.bx; // And reflect the previous\n\n                    ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                  } else {\n                    // or some else or nothing\n                    nx = d.x;\n                    ny = d.y;\n                  }\n\n                  path = [\"C\", nx, ny][concat](path.slice(1));\n                  break;\n\n                case \"T\":\n                  if (pcom == \"Q\" || pcom == \"T\") {\n                    // In \"T\" case we have to take into account, if the previous command is Q/T.\n                    d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n                    d.qy = d.y * 2 - d.qy; // to case \"S\".\n                  } else {\n                    // or something else or nothing\n                    d.qx = d.x;\n                    d.qy = d.y;\n                  }\n\n                  path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                  break;\n\n                case \"Q\":\n                  d.qx = path[1];\n                  d.qy = path[2];\n                  path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                  break;\n\n                case \"L\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\n                  break;\n\n                case \"H\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\n                  break;\n\n                case \"V\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\n                  break;\n\n                case \"Z\":\n                  path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\n                  break;\n              }\n\n              return path;\n            },\n                fixArc = function fixArc(pp, i) {\n              if (pp[i].length > 7) {\n                pp[i].shift();\n                var pi = pp[i];\n\n                while (pi.length) {\n                  pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n\n                  p2 && (pcoms2[i] = \"A\"); // the same as above\n\n                  pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\n                }\n\n                pp.splice(i, 1);\n                ii = mmax(p.length, p2 && p2.length || 0);\n              }\n            },\n                fixM = function fixM(path1, path2, a1, a2, i) {\n              if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                a1.bx = 0;\n                a1.by = 0;\n                a1.x = path1[i][1];\n                a1.y = path1[i][2];\n                ii = mmax(p.length, p2 && p2.length || 0);\n              }\n            },\n                pcoms1 = [],\n                // path commands of original path p\n            pcoms2 = [],\n                // path commands of original path p2\n            pfirst = \"\",\n                // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n\n\n            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n              p[i] && (pfirst = p[i][0]); // save current path command\n\n              if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n                {\n                  pcoms1[i] = pfirst; // Save current path command\n\n                  i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n                }\n\n              p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n              if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n              // which may produce multiple C:s\n              // so we have to make sure that C is also C in original path\n\n              fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n              if (p2) {\n                // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n\n                if (pfirst != \"C\") {\n                  pcoms2[i] = pfirst;\n                  i && (pcom = pcoms2[i - 1]);\n                }\n\n                p2[i] = processPath(p2[i], attrs2, pcom);\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") pcoms2[i] = \"C\";\n                fixArc(p2, i);\n              }\n\n              fixM(p, p2, attrs, attrs2, i);\n              fixM(p2, p, attrs2, attrs, i);\n              var seg = p[i],\n                  seg2 = p2 && p2[i],\n                  seglen = seg.length,\n                  seg2len = p2 && seg2.length;\n              attrs.x = seg[seglen - 2];\n              attrs.y = seg[seglen - 1];\n              attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n              attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n              attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n              attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n              attrs2.x = p2 && seg2[seg2len - 2];\n              attrs2.y = p2 && seg2[seg2len - 1];\n            }\n\n            if (!p2) {\n              pth.curve = pathClone(p);\n            }\n\n            return p2 ? [p, p2] : p;\n          }, null, pathClone),\n              parseDots = R._parseDots = cacher(function (gradient) {\n            var dots = [];\n\n            for (var i = 0, ii = gradient.length; i < ii; i++) {\n              var dot = {},\n                  par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\n              dot.color = R.getRGB(par[1]);\n\n              if (dot.color.error) {\n                return null;\n              }\n\n              dot.opacity = dot.color.opacity;\n              dot.color = dot.color.hex;\n              par[2] && (dot.offset = par[2] + \"%\");\n              dots.push(dot);\n            }\n\n            for (i = 1, ii = dots.length - 1; i < ii; i++) {\n              if (!dots[i].offset) {\n                var start = toFloat(dots[i - 1].offset || 0),\n                    end = 0;\n\n                for (var j = i + 1; j < ii; j++) {\n                  if (dots[j].offset) {\n                    end = dots[j].offset;\n                    break;\n                  }\n                }\n\n                if (!end) {\n                  end = 100;\n                  j = ii;\n                }\n\n                end = toFloat(end);\n                var d = (end - start) / (j - i + 1);\n\n                for (; i < j; i++) {\n                  start += d;\n                  dots[i].offset = start + \"%\";\n                }\n              }\n            }\n\n            return dots;\n          }),\n              tear = R._tear = function (el, paper) {\n            el == paper.top && (paper.top = el.prev);\n            el == paper.bottom && (paper.bottom = el.next);\n            el.next && (el.next.prev = el.prev);\n            el.prev && (el.prev.next = el.next);\n          },\n              tofront = R._tofront = function (el, paper) {\n            if (paper.top === el) {\n              return;\n            }\n\n            tear(el, paper);\n            el.next = null;\n            el.prev = paper.top;\n            paper.top.next = el;\n            paper.top = el;\n          },\n              toback = R._toback = function (el, paper) {\n            if (paper.bottom === el) {\n              return;\n            }\n\n            tear(el, paper);\n            el.next = paper.bottom;\n            el.prev = null;\n            paper.bottom.prev = el;\n            paper.bottom = el;\n          },\n              insertafter = R._insertafter = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.top && (paper.top = el);\n            el2.next && (el2.next.prev = el);\n            el.next = el2.next;\n            el.prev = el2;\n            el2.next = el;\n          },\n              insertbefore = R._insertbefore = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.bottom && (paper.bottom = el);\n            el2.prev && (el2.prev.next = el);\n            el.prev = el2.prev;\n            el2.prev = el;\n            el.next = el2;\n          },\n\n          /*\\\n           * Raphael.toMatrix\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns matrix of transformations applied to a given path\n           > Parameters\n           - path (string) path string\n           - transform (string|array) transformation string\n           = (object) @Matrix\n          \\*/\n          toMatrix = R.toMatrix = function (path, transform) {\n            var bb = pathDimensions(path),\n                el = {\n              _: {\n                transform: E\n              },\n              getBBox: function getBBox() {\n                return bb;\n              }\n            };\n            extractTransform(el, transform);\n            return el.matrix;\n          },\n\n          /*\\\n           * Raphael.transformPath\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns path transformed by a given transformation\n           > Parameters\n           - path (string) path string\n           - transform (string|array) transformation string\n           = (string) path\n          \\*/\n          transformPath = R.transformPath = function (path, transform) {\n            return mapPath(path, toMatrix(path, transform));\n          },\n              extractTransform = R._extractTransform = function (el, tstr) {\n            if (tstr == null) {\n              return el._.transform;\n            }\n\n            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            var tdata = R.parseTransformString(tstr),\n                deg = 0,\n                dx = 0,\n                dy = 0,\n                sx = 1,\n                sy = 1,\n                _ = el._,\n                m = new Matrix();\n            _.transform = tdata || [];\n\n            if (tdata) {\n              for (var i = 0, ii = tdata.length; i < ii; i++) {\n                var t = tdata[i],\n                    tlen = t.length,\n                    command = Str(t[0]).toLowerCase(),\n                    absolute = t[0] != command,\n                    inver = absolute ? m.invert() : 0,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    bb;\n\n                if (command == \"t\" && tlen == 3) {\n                  if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                  } else {\n                    m.translate(t[1], t[2]);\n                  }\n                } else if (command == \"r\") {\n                  if (tlen == 2) {\n                    bb = bb || el.getBBox(1);\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    deg += t[1];\n                  } else if (tlen == 4) {\n                    if (absolute) {\n                      x2 = inver.x(t[2], t[3]);\n                      y2 = inver.y(t[2], t[3]);\n                      m.rotate(t[1], x2, y2);\n                    } else {\n                      m.rotate(t[1], t[2], t[3]);\n                    }\n\n                    deg += t[1];\n                  }\n                } else if (command == \"s\") {\n                  if (tlen == 2 || tlen == 3) {\n                    bb = bb || el.getBBox(1);\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    sx *= t[1];\n                    sy *= t[tlen - 1];\n                  } else if (tlen == 5) {\n                    if (absolute) {\n                      x2 = inver.x(t[3], t[4]);\n                      y2 = inver.y(t[3], t[4]);\n                      m.scale(t[1], t[2], x2, y2);\n                    } else {\n                      m.scale(t[1], t[2], t[3], t[4]);\n                    }\n\n                    sx *= t[1];\n                    sy *= t[2];\n                  }\n                } else if (command == \"m\" && tlen == 7) {\n                  m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n                }\n\n                _.dirtyT = 1;\n                el.matrix = m;\n              }\n            }\n            /*\\\n             * Element.matrix\n             [ property (object) ]\n             **\n             * Keeps @Matrix object, which represents element transformation\n            \\*/\n\n\n            el.matrix = m;\n            _.sx = sx;\n            _.sy = sy;\n            _.deg = deg;\n            _.dx = dx = m.e;\n            _.dy = dy = m.f;\n\n            if (sx == 1 && sy == 1 && !deg && _.bbox) {\n              _.bbox.x += +dx;\n              _.bbox.y += +dy;\n            } else {\n              _.dirtyT = 1;\n            }\n          },\n              getEmpty = function getEmpty(item) {\n            var l = item[0];\n\n            switch (l.toLowerCase()) {\n              case \"t\":\n                return [l, 0, 0];\n\n              case \"m\":\n                return [l, 1, 0, 0, 1, 0, 0];\n\n              case \"r\":\n                if (item.length == 4) {\n                  return [l, 0, item[2], item[3]];\n                } else {\n                  return [l, 0];\n                }\n\n              case \"s\":\n                if (item.length == 5) {\n                  return [l, 1, 1, item[3], item[4]];\n                } else if (item.length == 3) {\n                  return [l, 1, 1];\n                } else {\n                  return [l, 1];\n                }\n\n            }\n          },\n              equaliseTransform = R._equaliseTransform = function (t1, t2) {\n            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n            t1 = R.parseTransformString(t1) || [];\n            t2 = R.parseTransformString(t2) || [];\n            var maxlength = mmax(t1.length, t2.length),\n                from = [],\n                to = [],\n                i = 0,\n                j,\n                jj,\n                tt1,\n                tt2;\n\n            for (; i < maxlength; i++) {\n              tt1 = t1[i] || getEmpty(t2[i]);\n              tt2 = t2[i] || getEmpty(tt1);\n\n              if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {\n                return;\n              }\n\n              from[i] = [];\n              to[i] = [];\n\n              for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n              }\n            }\n\n            return {\n              from: from,\n              to: to\n            };\n          };\n\n          R._getContainer = function (x, y, w, h) {\n            var container;\n            container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\n\n            if (container == null) {\n              return;\n            }\n\n            if (container.tagName) {\n              if (y == null) {\n                return {\n                  container: container,\n                  width: container.style.pixelWidth || container.offsetWidth,\n                  height: container.style.pixelHeight || container.offsetHeight\n                };\n              } else {\n                return {\n                  container: container,\n                  width: y,\n                  height: w\n                };\n              }\n            }\n\n            return {\n              container: 1,\n              x: x,\n              y: y,\n              width: w,\n              height: h\n            };\n          };\n          /*\\\n           * Raphael.pathToRelative\n           [ method ]\n           **\n           * Utility method\n           **\n           * Converts path to relative form\n           > Parameters\n           - pathString (string|array) path string or array of segments\n           = (array) array of segments.\n          \\*/\n\n\n          R.pathToRelative = pathToRelative;\n          R._engine = {};\n          /*\\\n           * Raphael.path2curve\n           [ method ]\n           **\n           * Utility method\n           **\n           * Converts path to a new path where all segments are cubic bezier curves.\n           > Parameters\n           - pathString (string|array) path string or array of segments\n           = (array) array of segments.\n          \\*/\n\n          R.path2curve = path2curve;\n          /*\\\n           * Raphael.matrix\n           [ method ]\n           **\n           * Utility method\n           **\n           * Returns matrix based on given parameters.\n           > Parameters\n           - a (number)\n           - b (number)\n           - c (number)\n           - d (number)\n           - e (number)\n           - f (number)\n           = (object) @Matrix\n          \\*/\n\n          R.matrix = function (a, b, c, d, e, f) {\n            return new Matrix(a, b, c, d, e, f);\n          };\n\n          function Matrix(a, b, c, d, e, f) {\n            if (a != null) {\n              this.a = +a;\n              this.b = +b;\n              this.c = +c;\n              this.d = +d;\n              this.e = +e;\n              this.f = +f;\n            } else {\n              this.a = 1;\n              this.b = 0;\n              this.c = 0;\n              this.d = 1;\n              this.e = 0;\n              this.f = 0;\n            }\n          }\n\n          (function (matrixproto) {\n            /*\\\n             * Matrix.add\n             [ method ]\n             **\n             * Adds given matrix to existing one.\n             > Parameters\n             - a (number)\n             - b (number)\n             - c (number)\n             - d (number)\n             - e (number)\n             - f (number)\n             or\n             - matrix (object) @Matrix\n            \\*/\n            matrixproto.add = function (a, b, c, d, e, f) {\n              var out = [[], [], []],\n                  m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                  matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                  x,\n                  y,\n                  z,\n                  res;\n\n              if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n              }\n\n              for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                  res = 0;\n\n                  for (z = 0; z < 3; z++) {\n                    res += m[x][z] * matrix[z][y];\n                  }\n\n                  out[x][y] = res;\n                }\n              }\n\n              this.a = out[0][0];\n              this.b = out[1][0];\n              this.c = out[0][1];\n              this.d = out[1][1];\n              this.e = out[0][2];\n              this.f = out[1][2];\n            };\n            /*\\\n             * Matrix.invert\n             [ method ]\n             **\n             * Returns inverted version of the matrix\n             = (object) @Matrix\n            \\*/\n\n\n            matrixproto.invert = function () {\n              var me = this,\n                  x = me.a * me.d - me.b * me.c;\n              return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n            };\n            /*\\\n             * Matrix.clone\n             [ method ]\n             **\n             * Returns copy of the matrix\n             = (object) @Matrix\n            \\*/\n\n\n            matrixproto.clone = function () {\n              return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n            };\n            /*\\\n             * Matrix.translate\n             [ method ]\n             **\n             * Translate the matrix\n             > Parameters\n             - x (number)\n             - y (number)\n            \\*/\n\n\n            matrixproto.translate = function (x, y) {\n              this.add(1, 0, 0, 1, x, y);\n            };\n            /*\\\n             * Matrix.scale\n             [ method ]\n             **\n             * Scales the matrix\n             > Parameters\n             - x (number)\n             - y (number) #optional\n             - cx (number) #optional\n             - cy (number) #optional\n            \\*/\n\n\n            matrixproto.scale = function (x, y, cx, cy) {\n              y == null && (y = x);\n              (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n              this.add(x, 0, 0, y, 0, 0);\n              (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            };\n            /*\\\n             * Matrix.rotate\n             [ method ]\n             **\n             * Rotates the matrix\n             > Parameters\n             - a (number)\n             - x (number)\n             - y (number)\n            \\*/\n\n\n            matrixproto.rotate = function (a, x, y) {\n              a = R.rad(a);\n              x = x || 0;\n              y = y || 0;\n              var cos = +math.cos(a).toFixed(9),\n                  sin = +math.sin(a).toFixed(9);\n              this.add(cos, sin, -sin, cos, x, y);\n              this.add(1, 0, 0, 1, -x, -y);\n            };\n            /*\\\n             * Matrix.x\n             [ method ]\n             **\n             * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n             > Parameters\n             - x (number)\n             - y (number)\n             = (number) x\n            \\*/\n\n\n            matrixproto.x = function (x, y) {\n              return x * this.a + y * this.c + this.e;\n            };\n            /*\\\n             * Matrix.y\n             [ method ]\n             **\n             * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n             > Parameters\n             - x (number)\n             - y (number)\n             = (number) y\n            \\*/\n\n\n            matrixproto.y = function (x, y) {\n              return x * this.b + y * this.d + this.f;\n            };\n\n            matrixproto.get = function (i) {\n              return +this[Str.fromCharCode(97 + i)].toFixed(4);\n            };\n\n            matrixproto.toString = function () {\n              return R.svg ? \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n            };\n\n            matrixproto.toFilter = function () {\n              return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) + \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) + \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\n            };\n\n            matrixproto.offset = function () {\n              return [this.e.toFixed(4), this.f.toFixed(4)];\n            };\n\n            function norm(a) {\n              return a[0] * a[0] + a[1] * a[1];\n            }\n\n            function normalize(a) {\n              var mag = math.sqrt(norm(a));\n              a[0] && (a[0] /= mag);\n              a[1] && (a[1] /= mag);\n            }\n            /*\\\n             * Matrix.split\n             [ method ]\n             **\n             * Splits matrix into primitive transformations\n             = (object) in format:\n             o dx (number) translation by x\n             o dy (number) translation by y\n             o scalex (number) scale by x\n             o scaley (number) scale by y\n             o shear (number) shear\n             o rotate (number) rotation in deg\n             o isSimple (boolean) could it be represented via simple transformations\n            \\*/\n\n\n            matrixproto.split = function () {\n              var out = {}; // translation\n\n              out.dx = this.e;\n              out.dy = this.f; // scale and shear\n\n              var row = [[this.a, this.c], [this.b, this.d]];\n              out.scalex = math.sqrt(norm(row[0]));\n              normalize(row[0]);\n              out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n              row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n              out.scaley = math.sqrt(norm(row[1]));\n              normalize(row[1]);\n              out.shear /= out.scaley; // rotation\n\n              var sin = -row[0][1],\n                  cos = row[1][1];\n\n              if (cos < 0) {\n                out.rotate = R.deg(math.acos(cos));\n\n                if (sin < 0) {\n                  out.rotate = 360 - out.rotate;\n                }\n              } else {\n                out.rotate = R.deg(math.asin(sin));\n              }\n\n              out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n              out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n              out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n              return out;\n            };\n            /*\\\n             * Matrix.toTransformString\n             [ method ]\n             **\n             * Return transform string that represents given matrix\n             = (string) transform string\n            \\*/\n\n\n            matrixproto.toTransformString = function (shorter) {\n              var s = shorter || this[split]();\n\n              if (s.isSimple) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) + (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\n              } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n              }\n            };\n          })(Matrix.prototype);\n\n          var preventDefault = function preventDefault() {\n            this.returnValue = false;\n          },\n              preventTouch = function preventTouch() {\n            return this.originalEvent.preventDefault();\n          },\n              stopPropagation = function stopPropagation() {\n            this.cancelBubble = true;\n          },\n              stopTouch = function stopTouch() {\n            return this.originalEvent.stopPropagation();\n          },\n              getEventPosition = function getEventPosition(e) {\n            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n            return {\n              x: e.clientX + scrollX,\n              y: e.clientY + scrollY\n            };\n          },\n              addEvent = function () {\n            if (g.doc.addEventListener) {\n              return function (obj, type, fn, element) {\n                var f = function f(e) {\n                  var pos = getEventPosition(e);\n                  return fn.call(element, e, pos.x, pos.y);\n                };\n\n                obj.addEventListener(type, f, false);\n\n                if (supportsTouch && touchMap[type]) {\n                  var _f = function _f(e) {\n                    var pos = getEventPosition(e),\n                        olde = e;\n\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                      if (e.targetTouches[i].target == obj) {\n                        e = e.targetTouches[i];\n                        e.originalEvent = olde;\n                        e.preventDefault = preventTouch;\n                        e.stopPropagation = stopTouch;\n                        break;\n                      }\n                    }\n\n                    return fn.call(element, e, pos.x, pos.y);\n                  };\n\n                  obj.addEventListener(touchMap[type], _f, false);\n                }\n\n                return function () {\n                  obj.removeEventListener(type, f, false);\n                  if (supportsTouch && touchMap[type]) obj.removeEventListener(touchMap[type], _f, false);\n                  return true;\n                };\n              };\n            } else if (g.doc.attachEvent) {\n              return function (obj, type, fn, element) {\n                var f = function f(e) {\n                  e = e || g.win.event;\n                  var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                      scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                      x = e.clientX + scrollX,\n                      y = e.clientY + scrollY;\n                  e.preventDefault = e.preventDefault || preventDefault;\n                  e.stopPropagation = e.stopPropagation || stopPropagation;\n                  return fn.call(element, e, x, y);\n                };\n\n                obj.attachEvent(\"on\" + type, f);\n\n                var detacher = function detacher() {\n                  obj.detachEvent(\"on\" + type, f);\n                  return true;\n                };\n\n                return detacher;\n              };\n            }\n          }(),\n              drag = [],\n              dragMove = function dragMove(e) {\n            var x = e.clientX,\n                y = e.clientY,\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                dragi,\n                j = drag.length;\n\n            while (j--) {\n              dragi = drag[j];\n\n              if (supportsTouch && e.touches) {\n                var i = e.touches.length,\n                    touch;\n\n                while (i--) {\n                  touch = e.touches[i];\n\n                  if (touch.identifier == dragi.el._drag.id) {\n                    x = touch.clientX;\n                    y = touch.clientY;\n                    (e.originalEvent ? e.originalEvent : e).preventDefault();\n                    break;\n                  }\n                }\n              } else {\n                e.preventDefault();\n              }\n\n              var node = dragi.el.node,\n                  o,\n                  next = node.nextSibling,\n                  parent = node.parentNode,\n                  display = node.style.display;\n              g.win.opera && parent.removeChild(node);\n              node.style.display = \"none\";\n              o = dragi.el.paper.getElementByPoint(x, y);\n              node.style.display = display;\n              g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n              o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\n              x += scrollX;\n              y += scrollY;\n              eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n            }\n          },\n              dragUp = function dragUp(e) {\n            R.unmousemove(dragMove).unmouseup(dragUp);\n            var i = drag.length,\n                dragi;\n\n            while (i--) {\n              dragi = drag[i];\n              dragi.el._drag = {};\n              eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            }\n\n            drag = [];\n          },\n\n          /*\\\n           * Raphael.el\n           [ property (object) ]\n           **\n           * You can add your own method to elements. This is useful when you want to hack default functionality or\n           * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\n           * you can redefine element method at any time. Expending element methods wouldn’t affect set.\n           > Usage\n           | Raphael.el.red = function () {\n           |     this.attr({fill: \"#f00\"});\n           | };\n           | // then use it\n           | paper.circle(100, 100, 20).red();\n          \\*/\n          elproto = R.el = {};\n          /*\\\n           * Element.click\n           [ method ]\n           **\n           * Adds event handler for click for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unclick\n           [ method ]\n           **\n           * Removes event handler for click for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.dblclick\n           [ method ]\n           **\n           * Adds event handler for double click for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.undblclick\n           [ method ]\n           **\n           * Removes event handler for double click for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mousedown\n           [ method ]\n           **\n           * Adds event handler for mousedown for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmousedown\n           [ method ]\n           **\n           * Removes event handler for mousedown for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mousemove\n           [ method ]\n           **\n           * Adds event handler for mousemove for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmousemove\n           [ method ]\n           **\n           * Removes event handler for mousemove for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseout\n           [ method ]\n           **\n           * Adds event handler for mouseout for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseout\n           [ method ]\n           **\n           * Removes event handler for mouseout for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseover\n           [ method ]\n           **\n           * Adds event handler for mouseover for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseover\n           [ method ]\n           **\n           * Removes event handler for mouseover for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.mouseup\n           [ method ]\n           **\n           * Adds event handler for mouseup for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.unmouseup\n           [ method ]\n           **\n           * Removes event handler for mouseup for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchstart\n           [ method ]\n           **\n           * Adds event handler for touchstart for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchstart\n           [ method ]\n           **\n           * Removes event handler for touchstart for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchmove\n           [ method ]\n           **\n           * Adds event handler for touchmove for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchmove\n           [ method ]\n           **\n           * Removes event handler for touchmove for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchend\n           [ method ]\n           **\n           * Adds event handler for touchend for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchend\n           [ method ]\n           **\n           * Removes event handler for touchend for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.touchcancel\n           [ method ]\n           **\n           * Adds event handler for touchcancel for the element.\n           > Parameters\n           - handler (function) handler for the event\n           = (object) @Element\n          \\*/\n\n          /*\\\n           * Element.untouchcancel\n           [ method ]\n           **\n           * Removes event handler for touchcancel for the element.\n           > Parameters\n           - handler (function) #optional handler for the event\n           = (object) @Element\n          \\*/\n\n\n          for (var i = events.length; i--;) {\n            (function (eventName) {\n              R[eventName] = elproto[eventName] = function (fn, scope) {\n                if (R.is(fn, \"function\")) {\n                  this.events = this.events || [];\n                  this.events.push({\n                    name: eventName,\n                    f: fn,\n                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)\n                  });\n                }\n\n                return this;\n              };\n\n              R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n\n                while (l--) {\n                  if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                  }\n                }\n\n                return this;\n              };\n            })(events[i]);\n          }\n          /*\\\n           * Element.data\n           [ method ]\n           **\n           * Adds or retrieves given value associated with given key.\n           **\n           * See also @Element.removeData\n           > Parameters\n           - key (string) key to store data\n           - value (any) #optional value to store\n           = (object) @Element\n           * or, if value is not specified:\n           = (any) value\n           * or, if key and value are not specified:\n           = (object) Key/value pairs for all the data associated with the element.\n           > Usage\n           | for (var i = 0, i < 5, i++) {\n           |     paper.circle(10 + 15 * i, 10, 10)\n           |          .attr({fill: \"#000\"})\n           |          .data(\"i\", i)\n           |          .click(function () {\n           |             alert(this.data(\"i\"));\n           |          });\n           | }\n          \\*/\n\n\n          elproto.data = function (key, value) {\n            var data = eldata[this.id] = eldata[this.id] || {};\n\n            if (arguments.length == 0) {\n              return data;\n            }\n\n            if (arguments.length == 1) {\n              if (R.is(key, \"object\")) {\n                for (var i in key) {\n                  if (key[has](i)) {\n                    this.data(i, key[i]);\n                  }\n                }\n\n                return this;\n              }\n\n              eve(\"raphael.data.get.\" + this.id, this, data[key], key);\n              return data[key];\n            }\n\n            data[key] = value;\n            eve(\"raphael.data.set.\" + this.id, this, value, key);\n            return this;\n          };\n          /*\\\n           * Element.removeData\n           [ method ]\n           **\n           * Removes value associated with an element by given key.\n           * If key is not provided, removes all the data of the element.\n           > Parameters\n           - key (string) #optional key\n           = (object) @Element\n          \\*/\n\n\n          elproto.removeData = function (key) {\n            if (key == null) {\n              delete eldata[this.id];\n            } else {\n              eldata[this.id] && delete eldata[this.id][key];\n            }\n\n            return this;\n          };\n          /*\\\n          * Element.getData\n          [ method ]\n          **\n          * Retrieves the element data\n          = (object) data\n          \\*/\n\n\n          elproto.getData = function () {\n            return clone(eldata[this.id] || {});\n          };\n          /*\\\n           * Element.hover\n           [ method ]\n           **\n           * Adds event handlers for hover for the element.\n           > Parameters\n           - f_in (function) handler for hover in\n           - f_out (function) handler for hover out\n           - icontext (object) #optional context for hover in handler\n           - ocontext (object) #optional context for hover out handler\n           = (object) @Element\n          \\*/\n\n\n          elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n          };\n          /*\\\n           * Element.unhover\n           [ method ]\n           **\n           * Removes event handlers for hover for the element.\n           > Parameters\n           - f_in (function) handler for hover in\n           - f_out (function) handler for hover out\n           = (object) @Element\n          \\*/\n\n\n          elproto.unhover = function (f_in, f_out) {\n            return this.unmouseover(f_in).unmouseout(f_out);\n          };\n\n          var draggable = [];\n          /*\\\n           * Element.drag\n           [ method ]\n           **\n           * Adds event handlers for drag of the element.\n           > Parameters\n           - onmove (function) handler for moving\n           - onstart (function) handler for drag start\n           - onend (function) handler for drag end\n           - mcontext (object) #optional context for moving handler\n           - scontext (object) #optional context for drag start handler\n           - econtext (object) #optional context for drag end handler\n           * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,\n           * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\n           * `drag.over.<id>` will be fired as well.\n           *\n           * Start event and start handler will be called in specified context or in context of the element with following parameters:\n           o x (number) x position of the mouse\n           o y (number) y position of the mouse\n           o event (object) DOM event object\n           * Move event and move handler will be called in specified context or in context of the element with following parameters:\n           o dx (number) shift by x from the start point\n           o dy (number) shift by y from the start point\n           o x (number) x position of the mouse\n           o y (number) y position of the mouse\n           o event (object) DOM event object\n           * End event and end handler will be called in specified context or in context of the element with following parameters:\n           o event (object) DOM event object\n           = (object) @Element\n          \\*/\n\n          elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n            function start(e) {\n              (e.originalEvent || e).preventDefault();\n              var x = e.clientX,\n                  y = e.clientY,\n                  scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                  scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n              this._drag.id = e.identifier;\n\n              if (supportsTouch && e.touches) {\n                var i = e.touches.length,\n                    touch;\n\n                while (i--) {\n                  touch = e.touches[i];\n                  this._drag.id = touch.identifier;\n\n                  if (touch.identifier == this._drag.id) {\n                    x = touch.clientX;\n                    y = touch.clientY;\n                    break;\n                  }\n                }\n              }\n\n              this._drag.x = x + scrollX;\n              this._drag.y = y + scrollY;\n              !drag.length && R.mousemove(dragMove).mouseup(dragUp);\n              drag.push({\n                el: this,\n                move_scope: move_scope,\n                start_scope: start_scope,\n                end_scope: end_scope\n              });\n              onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\n              onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\n              onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\n              eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, this._drag.x, this._drag.y, e);\n            }\n\n            this._drag = {};\n            draggable.push({\n              el: this,\n              start: start\n            });\n            this.mousedown(start);\n            return this;\n          };\n          /*\\\n           * Element.onDragOver\n           [ method ]\n           **\n           * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\n           > Parameters\n           - f (function) handler for event, first argument would be the element you are dragging over\n          \\*/\n\n\n          elproto.onDragOver = function (f) {\n            f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\n          };\n          /*\\\n           * Element.undrag\n           [ method ]\n           **\n           * Removes all drag event handlers from given element.\n          \\*/\n\n\n          elproto.undrag = function () {\n            var i = draggable.length;\n\n            while (i--) {\n              if (draggable[i].el == this) {\n                this.unmousedown(draggable[i].start);\n                draggable.splice(i, 1);\n                eve.unbind(\"raphael.drag.*.\" + this.id);\n              }\n            }\n\n            !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\n            drag = [];\n          };\n          /*\\\n           * Paper.circle\n           [ method ]\n           **\n           * Draws a circle.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the centre\n           - y (number) y coordinate of the centre\n           - r (number) radius\n           = (object) Raphaël element object with type “circle”\n           **\n           > Usage\n           | var c = paper.circle(50, 50, 40);\n          \\*/\n\n\n          paperproto.circle = function (x, y, r) {\n            var out = R._engine.circle(this, x || 0, y || 0, r || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.rect\n           [ method ]\n           *\n           * Draws a rectangle.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the top left corner\n           - y (number) y coordinate of the top left corner\n           - width (number) width\n           - height (number) height\n           - r (number) #optional radius for rounded corners, default is 0\n           = (object) Raphaël element object with type “rect”\n           **\n           > Usage\n           | // regular rectangle\n           | var c = paper.rect(10, 10, 50, 50);\n           | // rectangle with rounded corners\n           | var c = paper.rect(40, 40, 50, 50, 10);\n          \\*/\n\n\n          paperproto.rect = function (x, y, w, h, r) {\n            var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.ellipse\n           [ method ]\n           **\n           * Draws an ellipse.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the centre\n           - y (number) y coordinate of the centre\n           - rx (number) horizontal radius\n           - ry (number) vertical radius\n           = (object) Raphaël element object with type “ellipse”\n           **\n           > Usage\n           | var c = paper.ellipse(50, 50, 40, 20);\n          \\*/\n\n\n          paperproto.ellipse = function (x, y, rx, ry) {\n            var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.path\n           [ method ]\n           **\n           * Creates a path element by given path data string.\n           > Parameters\n           - pathString (string) #optional path string in SVG format.\n           * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\n           | \"M10,20L30,40\"\n           * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.\n           *\n           # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\n           # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n           # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n           # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n           # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n           # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n           # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n           # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n           # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n           # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n           # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n           # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n           # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n           * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.\n           * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.\n           > Usage\n           | var c = paper.path(\"M10 10L90 90\");\n           | // draw a diagonal line:\n           | // move to 10,10, line to 90,90\n           * For example of path strings, check out these icons: http://raphaeljs.com/icons/\n          \\*/\n\n\n          paperproto.path = function (pathString) {\n            pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\n\n            var out = R._engine.path(R.format[apply](R, arguments), this);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.image\n           [ method ]\n           **\n           * Embeds an image into the surface.\n           **\n           > Parameters\n           **\n           - src (string) URI of the source image\n           - x (number) x coordinate position\n           - y (number) y coordinate position\n           - width (number) width of the image\n           - height (number) height of the image\n           = (object) Raphaël element object with type “image”\n           **\n           > Usage\n           | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n          \\*/\n\n\n          paperproto.image = function (src, x, y, w, h) {\n            var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.text\n           [ method ]\n           **\n           * Draws a text string. If you need line breaks, put “\\n” in the string.\n           **\n           > Parameters\n           **\n           - x (number) x coordinate position\n           - y (number) y coordinate position\n           - text (string) The text string to draw\n           = (object) Raphaël element object with type “text”\n           **\n           > Usage\n           | var t = paper.text(50, 50, \"Raphaël\\nkicks\\nbutt!\");\n          \\*/\n\n\n          paperproto.text = function (x, y, text) {\n            var out = R._engine.text(this, x || 0, y || 0, Str(text));\n\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Paper.set\n           [ method ]\n           **\n           * Creates array-like object to keep and operate several elements at once.\n           * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.\n           * Sets act as pseudo elements — all methods available to an element can be used on a set.\n           = (object) array-like object that represents set of elements\n           **\n           > Usage\n           | var st = paper.set();\n           | st.push(\n           |     paper.circle(10, 10, 5),\n           |     paper.circle(30, 10, 5)\n           | );\n           | st.attr({fill: \"red\"}); // changes the fill of both circles\n          \\*/\n\n\n          paperproto.set = function (itemsArray) {\n            !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\n            var out = new Set(itemsArray);\n            this.__set__ && this.__set__.push(out);\n            out[\"paper\"] = this;\n            out[\"type\"] = \"set\";\n            return out;\n          };\n          /*\\\n           * Paper.setStart\n           [ method ]\n           **\n           * Creates @Paper.set. All elements that will be created after calling this method and before calling\n           * @Paper.setFinish will be added to the set.\n           **\n           > Usage\n           | paper.setStart();\n           | paper.circle(10, 10, 5),\n           | paper.circle(30, 10, 5)\n           | var st = paper.setFinish();\n           | st.attr({fill: \"red\"}); // changes the fill of both circles\n          \\*/\n\n\n          paperproto.setStart = function (set) {\n            this.__set__ = set || this.set();\n          };\n          /*\\\n           * Paper.setFinish\n           [ method ]\n           **\n           * See @Paper.setStart. This method finishes catching and returns resulting set.\n           **\n           = (object) set\n          \\*/\n\n\n          paperproto.setFinish = function (set) {\n            var out = this.__set__;\n            delete this.__set__;\n            return out;\n          };\n          /*\\\n           * Paper.getSize\n           [ method ]\n           **\n           * Obtains current paper actual size.\n           **\n           = (object)\n           \\*/\n\n\n          paperproto.getSize = function () {\n            var container = this.canvas.parentNode;\n            return {\n              width: container.offsetWidth,\n              height: container.offsetHeight\n            };\n          };\n          /*\\\n           * Paper.setSize\n           [ method ]\n           **\n           * If you need to change dimensions of the canvas call this method\n           **\n           > Parameters\n           **\n           - width (number) new width of the canvas\n           - height (number) new height of the canvas\n          \\*/\n\n\n          paperproto.setSize = function (width, height) {\n            return R._engine.setSize.call(this, width, height);\n          };\n          /*\\\n           * Paper.setViewBox\n           [ method ]\n           **\n           * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\n           * specifying new boundaries.\n           **\n           > Parameters\n           **\n           - x (number) new x position, default is `0`\n           - y (number) new y position, default is `0`\n           - w (number) new width of the canvas\n           - h (number) new height of the canvas\n           - fit (boolean) `true` if you want graphics to fit into new boundary box\n          \\*/\n\n\n          paperproto.setViewBox = function (x, y, w, h, fit) {\n            return R._engine.setViewBox.call(this, x, y, w, h, fit);\n          };\n          /*\\\n           * Paper.top\n           [ property ]\n           **\n           * Points to the topmost element on the paper\n          \\*/\n\n          /*\\\n           * Paper.bottom\n           [ property ]\n           **\n           * Points to the bottom element on the paper\n          \\*/\n\n\n          paperproto.top = paperproto.bottom = null;\n          /*\\\n           * Paper.raphael\n           [ property ]\n           **\n           * Points to the @Raphael object/function\n          \\*/\n\n          paperproto.raphael = R;\n\n          var getOffset = function getOffset(elem) {\n            var box = elem.getBoundingClientRect(),\n                doc = elem.ownerDocument,\n                body = doc.body,\n                docElem = doc.documentElement,\n                clientTop = docElem.clientTop || body.clientTop || 0,\n                clientLeft = docElem.clientLeft || body.clientLeft || 0,\n                top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,\n                left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n            return {\n              y: top,\n              x: left\n            };\n          };\n          /*\\\n           * Paper.getElementByPoint\n           [ method ]\n           **\n           * Returns you topmost element under given point.\n           **\n           = (object) Raphaël element object\n           > Parameters\n           **\n           - x (number) x coordinate from the top left corner of the window\n           - y (number) y coordinate from the top left corner of the window\n           > Usage\n           | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n          \\*/\n\n\n          paperproto.getElementByPoint = function (x, y) {\n            var paper = this,\n                svg = paper.canvas,\n                target = g.doc.elementFromPoint(x, y);\n\n            if (g.win.opera && target.tagName == \"svg\") {\n              var so = getOffset(svg),\n                  sr = svg.createSVGRect();\n              sr.x = x - so.x;\n              sr.y = y - so.y;\n              sr.width = sr.height = 1;\n              var hits = svg.getIntersectionList(sr, null);\n\n              if (hits.length) {\n                target = hits[hits.length - 1];\n              }\n            }\n\n            if (!target) {\n              return null;\n            }\n\n            while (target.parentNode && target != svg.parentNode && !target.raphael) {\n              target = target.parentNode;\n            }\n\n            target == paper.canvas.parentNode && (target = svg);\n            target = target && target.raphael ? paper.getById(target.raphaelid) : null;\n            return target;\n          };\n          /*\\\n           * Paper.getElementsByBBox\n           [ method ]\n           **\n           * Returns set of elements that have an intersecting bounding box\n           **\n           > Parameters\n           **\n           - bbox (object) bbox to check with\n           = (object) @Set\n           \\*/\n\n\n          paperproto.getElementsByBBox = function (bbox) {\n            var set = this.set();\n            this.forEach(function (el) {\n              if (R.isBBoxIntersect(el.getBBox(), bbox)) {\n                set.push(el);\n              }\n            });\n            return set;\n          };\n          /*\\\n           * Paper.getById\n           [ method ]\n           **\n           * Returns you element by its internal ID.\n           **\n           > Parameters\n           **\n           - id (number) id\n           = (object) Raphaël element object\n          \\*/\n\n\n          paperproto.getById = function (id) {\n            var bot = this.bottom;\n\n            while (bot) {\n              if (bot.id == id) {\n                return bot;\n              }\n\n              bot = bot.next;\n            }\n\n            return null;\n          };\n          /*\\\n           * Paper.forEach\n           [ method ]\n           **\n           * Executes given function for each element on the paper\n           *\n           * If callback function returns `false` it will stop loop running.\n           **\n           > Parameters\n           **\n           - callback (function) function to run\n           - thisArg (object) context object for the callback\n           = (object) Paper object\n           > Usage\n           | paper.forEach(function (el) {\n           |     el.attr({ stroke: \"blue\" });\n           | });\n          \\*/\n\n\n          paperproto.forEach = function (callback, thisArg) {\n            var bot = this.bottom;\n\n            while (bot) {\n              if (callback.call(thisArg, bot) === false) {\n                return this;\n              }\n\n              bot = bot.next;\n            }\n\n            return this;\n          };\n          /*\\\n           * Paper.getElementsByPoint\n           [ method ]\n           **\n           * Returns set of elements that have common point inside\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (object) @Set\n          \\*/\n\n\n          paperproto.getElementsByPoint = function (x, y) {\n            var set = this.set();\n            this.forEach(function (el) {\n              if (el.isPointInside(x, y)) {\n                set.push(el);\n              }\n            });\n            return set;\n          };\n\n          function x_y() {\n            return this.x + S + this.y;\n          }\n\n          function x_y_w_h() {\n            return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n          }\n          /*\\\n           * Element.isPointInside\n           [ method ]\n           **\n           * Determine if given point is inside this element’s shape\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (boolean) `true` if point inside the shape\n          \\*/\n\n\n          elproto.isPointInside = function (x, y) {\n            var rp = this.realPath = getPath[this.type](this);\n\n            if (this.attr('transform') && this.attr('transform').length) {\n              rp = R.transformPath(rp, this.attr('transform'));\n            }\n\n            return R.isPointInsidePath(rp, x, y);\n          };\n          /*\\\n           * Element.getBBox\n           [ method ]\n           **\n           * Return bounding box for a given element\n           **\n           > Parameters\n           **\n           - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\n           = (object) Bounding box object:\n           o {\n           o     x: (number) top left corner x\n           o     y: (number) top left corner y\n           o     x2: (number) bottom right corner x\n           o     y2: (number) bottom right corner y\n           o     width: (number) width\n           o     height: (number) height\n           o }\n          \\*/\n\n\n          elproto.getBBox = function (isWithoutTransform) {\n            if (this.removed) {\n              return {};\n            }\n\n            var _ = this._;\n\n            if (isWithoutTransform) {\n              if (_.dirty || !_.bboxwt) {\n                this.realPath = getPath[this.type](this);\n                _.bboxwt = pathDimensions(this.realPath);\n                _.bboxwt.toString = x_y_w_h;\n                _.dirty = 0;\n              }\n\n              return _.bboxwt;\n            }\n\n            if (_.dirty || _.dirtyT || !_.bbox) {\n              if (_.dirty || !this.realPath) {\n                _.bboxwt = 0;\n                this.realPath = getPath[this.type](this);\n              }\n\n              _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\n              _.bbox.toString = x_y_w_h;\n              _.dirty = _.dirtyT = 0;\n            }\n\n            return _.bbox;\n          };\n          /*\\\n           * Element.clone\n           [ method ]\n           **\n           = (object) clone of a given element\n           **\n          \\*/\n\n\n          elproto.clone = function () {\n            if (this.removed) {\n              return null;\n            }\n\n            var out = this.paper[this.type]().attr(this.attr());\n            this.__set__ && this.__set__.push(out);\n            return out;\n          };\n          /*\\\n           * Element.glow\n           [ method ]\n           **\n           * Return set of elements that create glow-like effect around given element. See @Paper.set.\n           *\n           * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.\n           **\n           > Parameters\n           **\n           - glow (object) #optional parameters object with all properties optional:\n           o {\n           o     width (number) size of the glow, default is `10`\n           o     fill (boolean) will it be filled, default is `false`\n           o     opacity (number) opacity, default is `0.5`\n           o     offsetx (number) horizontal offset, default is `0`\n           o     offsety (number) vertical offset, default is `0`\n           o     color (string) glow colour, default is `black`\n           o }\n           = (object) @Paper.set of elements that represents glow\n          \\*/\n\n\n          elproto.glow = function (glow) {\n            if (this.type == \"text\") {\n              return null;\n            }\n\n            glow = glow || {};\n            var s = {\n              width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\n              fill: glow.fill || false,\n              opacity: glow.opacity == null ? .5 : glow.opacity,\n              offsetx: glow.offsetx || 0,\n              offsety: glow.offsety || 0,\n              color: glow.color || \"#000\"\n            },\n                c = s.width / 2,\n                r = this.paper,\n                out = r.set(),\n                path = this.realPath || getPath[this.type](this);\n            path = this.matrix ? mapPath(path, this.matrix) : path;\n\n            for (var i = 1; i < c + 1; i++) {\n              out.push(r.path(path).attr({\n                stroke: s.color,\n                fill: s.fill ? s.color : \"none\",\n                \"stroke-linejoin\": \"round\",\n                \"stroke-linecap\": \"round\",\n                \"stroke-width\": +(s.width / c * i).toFixed(3),\n                opacity: +(s.opacity / c).toFixed(3)\n              }));\n            }\n\n            return out.insertBefore(this).translate(s.offsetx, s.offsety);\n          };\n\n          var curveslengths = {},\n              getPointAtSegmentLength = function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n            if (length == null) {\n              return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n            } else {\n              return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n            }\n          },\n              getLengthFactory = function getLengthFactory(istotal, subpath) {\n            return function (path, length, onlystart) {\n              path = path2curve(path);\n              var x,\n                  y,\n                  p,\n                  l,\n                  sp = \"\",\n                  subpaths = {},\n                  point,\n                  len = 0;\n\n              for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n\n                if (p[0] == \"M\") {\n                  x = +p[1];\n                  y = +p[2];\n                } else {\n                  l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\n                  if (len + l > length) {\n                    if (subpath && !subpaths.start) {\n                      point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                      sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\n\n                      if (onlystart) {\n                        return sp;\n                      }\n\n                      subpaths.start = sp;\n                      sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\n                      len += l;\n                      x = +p[5];\n                      y = +p[6];\n                      continue;\n                    }\n\n                    if (!istotal && !subpath) {\n                      point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                      return {\n                        x: point.x,\n                        y: point.y,\n                        alpha: point.alpha\n                      };\n                    }\n                  }\n\n                  len += l;\n                  x = +p[5];\n                  y = +p[6];\n                }\n\n                sp += p.shift() + p;\n              }\n\n              subpaths.end = sp;\n              point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n              point.alpha && (point = {\n                x: point.x,\n                y: point.y,\n                alpha: point.alpha\n              });\n              return point;\n            };\n          };\n\n          var getTotalLength = getLengthFactory(1),\n              getPointAtLength = getLengthFactory(),\n              getSubpathsAtLength = getLengthFactory(0, 1);\n          /*\\\n           * Raphael.getTotalLength\n           [ method ]\n           **\n           * Returns length of the given path in pixels.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string.\n           **\n           = (number) length.\n          \\*/\n\n          R.getTotalLength = getTotalLength;\n          /*\\\n           * Raphael.getPointAtLength\n           [ method ]\n           **\n           * Return coordinates of the point located at the given length on the given path.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string\n           - length (number)\n           **\n           = (object) representation of the point:\n           o {\n           o     x: (number) x coordinate\n           o     y: (number) y coordinate\n           o     alpha: (number) angle of derivative\n           o }\n          \\*/\n\n          R.getPointAtLength = getPointAtLength;\n          /*\\\n           * Raphael.getSubpath\n           [ method ]\n           **\n           * Return subpath of a given path from given length to given length.\n           **\n           > Parameters\n           **\n           - path (string) SVG path string\n           - from (number) position of the start of the segment\n           - to (number) position of the end of the segment\n           **\n           = (string) pathstring for the segment\n          \\*/\n\n          R.getSubpath = function (path, from, to) {\n            if (this.getTotalLength(path) - to < 1e-6) {\n              return getSubpathsAtLength(path, from).end;\n            }\n\n            var a = getSubpathsAtLength(path, to, 1);\n            return from ? getSubpathsAtLength(a, from).end : a;\n          };\n          /*\\\n           * Element.getTotalLength\n           [ method ]\n           **\n           * Returns length of the path in pixels. Only works for element of “path” type.\n           = (number) length.\n          \\*/\n\n\n          elproto.getTotalLength = function () {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            if (this.node.getTotalLength) {\n              return this.node.getTotalLength();\n            }\n\n            return getTotalLength(path);\n          };\n          /*\\\n           * Element.getPointAtLength\n           [ method ]\n           **\n           * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.\n           **\n           > Parameters\n           **\n           - length (number)\n           **\n           = (object) representation of the point:\n           o {\n           o     x: (number) x coordinate\n           o     y: (number) y coordinate\n           o     alpha: (number) angle of derivative\n           o }\n          \\*/\n\n\n          elproto.getPointAtLength = function (length) {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            return getPointAtLength(path, length);\n          };\n          /*\\\n           * Element.getPath\n           [ method ]\n           **\n           * Returns path of the element. Only works for elements of “path” type and simple elements like circle.\n           = (object) path\n           **\n          \\*/\n\n\n          elproto.getPath = function () {\n            var path,\n                getPath = R._getPath[this.type];\n\n            if (this.type == \"text\" || this.type == \"set\") {\n              return;\n            }\n\n            if (getPath) {\n              path = getPath(this);\n            }\n\n            return path;\n          };\n          /*\\\n           * Element.getSubpath\n           [ method ]\n           **\n           * Return subpath of a given element from given length to given length. Only works for element of “path” type.\n           **\n           > Parameters\n           **\n           - from (number) position of the start of the segment\n           - to (number) position of the end of the segment\n           **\n           = (string) pathstring for the segment\n          \\*/\n\n\n          elproto.getSubpath = function (from, to) {\n            var path = this.getPath();\n\n            if (!path) {\n              return;\n            }\n\n            return R.getSubpath(path, from, to);\n          };\n          /*\\\n           * Raphael.easing_formulas\n           [ property ]\n           **\n           * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\n           # <ul>\n           #     <li>“linear”</li>\n           #     <li>“&lt;” or “easeIn” or “ease-in”</li>\n           #     <li>“>” or “easeOut” or “ease-out”</li>\n           #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>\n           #     <li>“backIn” or “back-in”</li>\n           #     <li>“backOut” or “back-out”</li>\n           #     <li>“elastic”</li>\n           #     <li>“bounce”</li>\n           # </ul>\n           # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\n          \\*/\n\n\n          var ef = R.easing_formulas = {\n            linear: function linear(n) {\n              return n;\n            },\n            \"<\": function _(n) {\n              return pow(n, 1.7);\n            },\n            \">\": function _(n) {\n              return pow(n, .48);\n            },\n            \"<>\": function _(n) {\n              var q = .48 - n / 1.04,\n                  Q = math.sqrt(.1734 + q * q),\n                  x = Q - q,\n                  X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n                  y = -Q - q,\n                  Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n                  t = X + Y + .5;\n              return (1 - t) * 3 * t * t + t * t * t;\n            },\n            backIn: function backIn(n) {\n              var s = 1.70158;\n              return n * n * ((s + 1) * n - s);\n            },\n            backOut: function backOut(n) {\n              n = n - 1;\n              var s = 1.70158;\n              return n * n * ((s + 1) * n + s) + 1;\n            },\n            elastic: function elastic(n) {\n              if (n == !!n) {\n                return n;\n              }\n\n              return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\n            },\n            bounce: function bounce(n) {\n              var s = 7.5625,\n                  p = 2.75,\n                  l;\n\n              if (n < 1 / p) {\n                l = s * n * n;\n              } else {\n                if (n < 2 / p) {\n                  n -= 1.5 / p;\n                  l = s * n * n + .75;\n                } else {\n                  if (n < 2.5 / p) {\n                    n -= 2.25 / p;\n                    l = s * n * n + .9375;\n                  } else {\n                    n -= 2.625 / p;\n                    l = s * n * n + .984375;\n                  }\n                }\n              }\n\n              return l;\n            }\n          };\n          ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\n          ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\n          ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\n          ef[\"back-in\"] = ef.backIn;\n          ef[\"back-out\"] = ef.backOut;\n\n          var animationElements = [],\n              requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n            setTimeout(callback, 16);\n          },\n              animation = function animation() {\n            var Now = +new Date(),\n                l = 0;\n\n            for (; l < animationElements.length; l++) {\n              var e = animationElements[l];\n\n              if (e.el.removed || e.paused) {\n                continue;\n              }\n\n              var time = Now - e.start,\n                  ms = e.ms,\n                  easing = e.easing,\n                  from = e.from,\n                  diff = e.diff,\n                  to = e.to,\n                  t = e.t,\n                  that = e.el,\n                  set = {},\n                  now,\n                  init = {},\n                  key;\n\n              if (e.initstatus) {\n                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\n                e.status = e.initstatus;\n                delete e.initstatus;\n                e.stop && animationElements.splice(l--, 1);\n              } else {\n                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\n              }\n\n              if (time < 0) {\n                continue;\n              }\n\n              if (time < ms) {\n                var pos = easing(time / ms);\n\n                for (var attr in from) {\n                  if (from[has](attr)) {\n                    switch (availableAnimAttrs[attr]) {\n                      case nu:\n                        now = +from[attr] + pos * ms * diff[attr];\n                        break;\n\n                      case \"colour\":\n                        now = \"rgb(\" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b))].join(\",\") + \")\";\n                        break;\n\n                      case \"path\":\n                        now = [];\n\n                        for (var i = 0, ii = from[attr].length; i < ii; i++) {\n                          now[i] = [from[attr][i][0]];\n\n                          for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                            now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\n                          }\n\n                          now[i] = now[i].join(S);\n                        }\n\n                        now = now.join(S);\n                        break;\n\n                      case \"transform\":\n                        if (diff[attr].real) {\n                          now = [];\n\n                          for (i = 0, ii = from[attr].length; i < ii; i++) {\n                            now[i] = [from[attr][i][0]];\n\n                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                              now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\n                            }\n                          }\n                        } else {\n                          var get = function get(i) {\n                            return +from[attr][i] + pos * ms * diff[attr][i];\n                          }; // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\n\n\n                          now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\n                        }\n\n                        break;\n\n                      case \"csv\":\n                        if (attr == \"clip-rect\") {\n                          now = [];\n                          i = 4;\n\n                          while (i--) {\n                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];\n                          }\n                        }\n\n                        break;\n\n                      default:\n                        var from2 = [][concat](from[attr]);\n                        now = [];\n                        i = that.paper.customAttributes[attr].length;\n\n                        while (i--) {\n                          now[i] = +from2[i] + pos * ms * diff[attr][i];\n                        }\n\n                        break;\n                    }\n\n                    set[attr] = now;\n                  }\n                }\n\n                that.attr(set);\n\n                (function (id, that, anim) {\n                  setTimeout(function () {\n                    eve(\"raphael.anim.frame.\" + id, that, anim);\n                  });\n                })(that.id, that, e.anim);\n              } else {\n                (function (f, el, a) {\n                  setTimeout(function () {\n                    eve(\"raphael.anim.frame.\" + el.id, el, a);\n                    eve(\"raphael.anim.finish.\" + el.id, el, a);\n                    R.is(f, \"function\") && f.call(el);\n                  });\n                })(e.callback, that, e.anim);\n\n                that.attr(to);\n                animationElements.splice(l--, 1);\n\n                if (e.repeat > 1 && !e.next) {\n                  for (key in to) {\n                    if (to[has](key)) {\n                      init[key] = e.totalOrigin[key];\n                    }\n                  }\n\n                  e.el.attr(init);\n                  runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\n                }\n\n                if (e.next && !e.stop) {\n                  runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\n                }\n              }\n            }\n\n            animationElements.length && requestAnimFrame(animation);\n          },\n              upto255 = function upto255(color) {\n            return color > 255 ? 255 : color < 0 ? 0 : color;\n          };\n          /*\\\n           * Element.animateWith\n           [ method ]\n           **\n           * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\n           **\n           > Parameters\n           **\n           - el (object) element to sync with\n           - anim (object) animation to sync with\n           - params (object) #optional final attributes for the element, see also @Element.attr\n           - ms (number) #optional number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           * or\n           - element (object) element to sync with\n           - anim (object) animation to sync with\n           - animation (object) #optional animation object, see @Raphael.animation\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.animateWith = function (el, anim, params, ms, easing, callback) {\n            var element = this;\n\n            if (element.removed) {\n              callback && callback.call(element);\n              return element;\n            }\n\n            var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\n                x,\n                y;\n            runAnimation(a, element, a.percents[0], null, element.attr());\n\n            for (var i = 0, ii = animationElements.length; i < ii; i++) {\n              if (animationElements[i].anim == anim && animationElements[i].el == el) {\n                animationElements[ii - 1].start = animationElements[i].start;\n                break;\n              }\n            }\n\n            return element; //\n            //\n            // var a = params ? R.animation(params, ms, easing, callback) : anim,\n            //     status = element.status(anim);\n            // return this.animate(a).status(a, status * anim.ms / a.ms);\n          };\n\n          function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\n            var cx = 3 * p1x,\n                bx = 3 * (p2x - p1x) - cx,\n                ax = 1 - cx - bx,\n                cy = 3 * p1y,\n                by = 3 * (p2y - p1y) - cy,\n                ay = 1 - cy - by;\n\n            function sampleCurveX(t) {\n              return ((ax * t + bx) * t + cx) * t;\n            }\n\n            function solve(x, epsilon) {\n              var t = solveCurveX(x, epsilon);\n              return ((ay * t + by) * t + cy) * t;\n            }\n\n            function solveCurveX(x, epsilon) {\n              var t0, t1, t2, x2, d2, i;\n\n              for (t2 = x, i = 0; i < 8; i++) {\n                x2 = sampleCurveX(t2) - x;\n\n                if (abs(x2) < epsilon) {\n                  return t2;\n                }\n\n                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\n\n                if (abs(d2) < 1e-6) {\n                  break;\n                }\n\n                t2 = t2 - x2 / d2;\n              }\n\n              t0 = 0;\n              t1 = 1;\n              t2 = x;\n\n              if (t2 < t0) {\n                return t0;\n              }\n\n              if (t2 > t1) {\n                return t1;\n              }\n\n              while (t0 < t1) {\n                x2 = sampleCurveX(t2);\n\n                if (abs(x2 - x) < epsilon) {\n                  return t2;\n                }\n\n                if (x > x2) {\n                  t0 = t2;\n                } else {\n                  t1 = t2;\n                }\n\n                t2 = (t1 - t0) / 2 + t0;\n              }\n\n              return t2;\n            }\n\n            return solve(t, 1 / (200 * duration));\n          }\n\n          elproto.onAnimation = function (f) {\n            f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\n            return this;\n          };\n\n          function Animation(anim, ms) {\n            var percents = [],\n                newAnim = {};\n            this.ms = ms;\n            this.times = 1;\n\n            if (anim) {\n              for (var attr in anim) {\n                if (anim[has](attr)) {\n                  newAnim[toFloat(attr)] = anim[attr];\n                  percents.push(toFloat(attr));\n                }\n              }\n\n              percents.sort(sortByNumber);\n            }\n\n            this.anim = newAnim;\n            this.top = percents[percents.length - 1];\n            this.percents = percents;\n          }\n          /*\\\n           * Animation.delay\n           [ method ]\n           **\n           * Creates a copy of existing animation object with given delay.\n           **\n           > Parameters\n           **\n           - delay (number) number of ms to pass between animation start and actual animation\n           **\n           = (object) new altered Animation object\n           | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\n           | circle1.animate(anim); // run the given animation immediately\n           | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\n          \\*/\n\n\n          Animation.prototype.delay = function (delay) {\n            var a = new Animation(this.anim, this.ms);\n            a.times = this.times;\n            a.del = +delay || 0;\n            return a;\n          };\n          /*\\\n           * Animation.repeat\n           [ method ]\n           **\n           * Creates a copy of existing animation object with given repetition.\n           **\n           > Parameters\n           **\n           - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\n           **\n           = (object) new altered Animation object\n          \\*/\n\n\n          Animation.prototype.repeat = function (times) {\n            var a = new Animation(this.anim, this.ms);\n            a.del = this.del;\n            a.times = math.floor(mmax(times, 0)) || 1;\n            return a;\n          };\n\n          function runAnimation(anim, element, percent, status, totalOrigin, times) {\n            percent = toFloat(percent);\n            var params,\n                isInAnim,\n                isInAnimSet,\n                percents = [],\n                next,\n                prev,\n                timestamp,\n                ms = anim.ms,\n                from = {},\n                to = {},\n                diff = {};\n\n            if (status) {\n              for (i = 0, ii = animationElements.length; i < ii; i++) {\n                var e = animationElements[i];\n\n                if (e.el.id == element.id && e.anim == anim) {\n                  if (e.percent != percent) {\n                    animationElements.splice(i, 1);\n                    isInAnimSet = 1;\n                  } else {\n                    isInAnim = e;\n                  }\n\n                  element.attr(e.totalOrigin);\n                  break;\n                }\n              }\n            } else {\n              status = +to; // NaN\n            }\n\n            for (var i = 0, ii = anim.percents.length; i < ii; i++) {\n              if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\n                percent = anim.percents[i];\n                prev = anim.percents[i - 1] || 0;\n                ms = ms / anim.top * (percent - prev);\n                next = anim.percents[i + 1];\n                params = anim.anim[percent];\n                break;\n              } else if (status) {\n                element.attr(anim.anim[anim.percents[i]]);\n              }\n            }\n\n            if (!params) {\n              return;\n            }\n\n            if (!isInAnim) {\n              for (var attr in params) {\n                if (params[has](attr)) {\n                  if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\n                    from[attr] = element.attr(attr);\n                    from[attr] == null && (from[attr] = availableAttrs[attr]);\n                    to[attr] = params[attr];\n\n                    switch (availableAnimAttrs[attr]) {\n                      case nu:\n                        diff[attr] = (to[attr] - from[attr]) / ms;\n                        break;\n\n                      case \"colour\":\n                        from[attr] = R.getRGB(from[attr]);\n                        var toColour = R.getRGB(to[attr]);\n                        diff[attr] = {\n                          r: (toColour.r - from[attr].r) / ms,\n                          g: (toColour.g - from[attr].g) / ms,\n                          b: (toColour.b - from[attr].b) / ms\n                        };\n                        break;\n\n                      case \"path\":\n                        var pathes = path2curve(from[attr], to[attr]),\n                            toPath = pathes[1];\n                        from[attr] = pathes[0];\n                        diff[attr] = [];\n\n                        for (i = 0, ii = from[attr].length; i < ii; i++) {\n                          diff[attr][i] = [0];\n\n                          for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                            diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\n                          }\n                        }\n\n                        break;\n\n                      case \"transform\":\n                        var _ = element._,\n                            eq = equaliseTransform(_[attr], to[attr]);\n\n                        if (eq) {\n                          from[attr] = eq.from;\n                          to[attr] = eq.to;\n                          diff[attr] = [];\n                          diff[attr].real = true;\n\n                          for (i = 0, ii = from[attr].length; i < ii; i++) {\n                            diff[attr][i] = [from[attr][i][0]];\n\n                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                              diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\n                            }\n                          }\n                        } else {\n                          var m = element.matrix || new Matrix(),\n                              to2 = {\n                            _: {\n                              transform: _.transform\n                            },\n                            getBBox: function getBBox() {\n                              return element.getBBox(1);\n                            }\n                          };\n                          from[attr] = [m.a, m.b, m.c, m.d, m.e, m.f];\n                          extractTransform(to2, to[attr]);\n                          to[attr] = to2._.transform;\n                          diff[attr] = [(to2.matrix.a - m.a) / ms, (to2.matrix.b - m.b) / ms, (to2.matrix.c - m.c) / ms, (to2.matrix.d - m.d) / ms, (to2.matrix.e - m.e) / ms, (to2.matrix.f - m.f) / ms]; // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\n                          // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\n                          // extractTransform(to2, to[attr]);\n                          // diff[attr] = [\n                          //     (to2._.sx - _.sx) / ms,\n                          //     (to2._.sy - _.sy) / ms,\n                          //     (to2._.deg - _.deg) / ms,\n                          //     (to2._.dx - _.dx) / ms,\n                          //     (to2._.dy - _.dy) / ms\n                          // ];\n                        }\n\n                        break;\n\n                      case \"csv\":\n                        var values = Str(params[attr])[split](separator),\n                            from2 = Str(from[attr])[split](separator);\n\n                        if (attr == \"clip-rect\") {\n                          from[attr] = from2;\n                          diff[attr] = [];\n                          i = from2.length;\n\n                          while (i--) {\n                            diff[attr][i] = (values[i] - from[attr][i]) / ms;\n                          }\n                        }\n\n                        to[attr] = values;\n                        break;\n\n                      default:\n                        values = [][concat](params[attr]);\n                        from2 = [][concat](from[attr]);\n                        diff[attr] = [];\n                        i = element.paper.customAttributes[attr].length;\n\n                        while (i--) {\n                          diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\n                        }\n\n                        break;\n                    }\n                  }\n                }\n              }\n\n              var easing = params.easing,\n                  easyeasy = R.easing_formulas[easing];\n\n              if (!easyeasy) {\n                easyeasy = Str(easing).match(bezierrg);\n\n                if (easyeasy && easyeasy.length == 5) {\n                  var curve = easyeasy;\n\n                  easyeasy = function easyeasy(t) {\n                    return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\n                  };\n                } else {\n                  easyeasy = pipe;\n                }\n              }\n\n              timestamp = params.start || anim.start || +new Date();\n              e = {\n                anim: anim,\n                percent: percent,\n                timestamp: timestamp,\n                start: timestamp + (anim.del || 0),\n                status: 0,\n                initstatus: status || 0,\n                stop: false,\n                ms: ms,\n                easing: easyeasy,\n                from: from,\n                diff: diff,\n                to: to,\n                el: element,\n                callback: params.callback,\n                prev: prev,\n                next: next,\n                repeat: times || anim.times,\n                origin: element.attr(),\n                totalOrigin: totalOrigin\n              };\n              animationElements.push(e);\n\n              if (status && !isInAnim && !isInAnimSet) {\n                e.stop = true;\n                e.start = new Date() - ms * status;\n\n                if (animationElements.length == 1) {\n                  return animation();\n                }\n              }\n\n              if (isInAnimSet) {\n                e.start = new Date() - e.ms * status;\n              }\n\n              animationElements.length == 1 && requestAnimFrame(animation);\n            } else {\n              isInAnim.initstatus = status;\n              isInAnim.start = new Date() - isInAnim.ms * status;\n            }\n\n            eve(\"raphael.anim.start.\" + element.id, element, anim);\n          }\n          /*\\\n           * Raphael.animation\n           [ method ]\n           **\n           * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\n           * See also @Animation.delay and @Animation.repeat methods.\n           **\n           > Parameters\n           **\n           - params (object) final attributes for the element, see also @Element.attr\n           - ms (number) number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           **\n           = (object) @Animation\n          \\*/\n\n\n          R.animation = function (params, ms, easing, callback) {\n            if (params instanceof Animation) {\n              return params;\n            }\n\n            if (R.is(easing, \"function\") || !easing) {\n              callback = callback || easing || null;\n              easing = null;\n            }\n\n            params = Object(params);\n            ms = +ms || 0;\n            var p = {},\n                json,\n                attr;\n\n            for (attr in params) {\n              if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\n                json = true;\n                p[attr] = params[attr];\n              }\n            }\n\n            if (!json) {\n              // if percent-like syntax is used and end-of-all animation callback used\n              if (callback) {\n                // find the last one\n                var lastKey = 0;\n\n                for (var i in params) {\n                  var percent = toInt(i);\n\n                  if (params[has](i) && percent > lastKey) {\n                    lastKey = percent;\n                  }\n                }\n\n                lastKey += '%'; // if already defined callback in the last keyframe, skip\n\n                !params[lastKey].callback && (params[lastKey].callback = callback);\n              }\n\n              return new Animation(params, ms);\n            } else {\n              easing && (p.easing = easing);\n              callback && (p.callback = callback);\n              return new Animation({\n                100: p\n              }, ms);\n            }\n          };\n          /*\\\n           * Element.animate\n           [ method ]\n           **\n           * Creates and starts animation for given element.\n           **\n           > Parameters\n           **\n           - params (object) final attributes for the element, see also @Element.attr\n           - ms (number) number of milliseconds for animation to run\n           - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n           - callback (function) #optional callback function. Will be called at the end of animation.\n           * or\n           - animation (object) animation object, see @Raphael.animation\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.animate = function (params, ms, easing, callback) {\n            var element = this;\n\n            if (element.removed) {\n              callback && callback.call(element);\n              return element;\n            }\n\n            var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\n            runAnimation(anim, element, anim.percents[0], null, element.attr());\n            return element;\n          };\n          /*\\\n           * Element.setTime\n           [ method ]\n           **\n           * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\n           **\n           > Parameters\n           **\n           - anim (object) animation object\n           - value (number) number of milliseconds from the beginning of the animation\n           **\n           = (object) original element if `value` is specified\n           * Note, that during animation following events are triggered:\n           *\n           * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\n          \\*/\n\n\n          elproto.setTime = function (anim, value) {\n            if (anim && value != null) {\n              this.status(anim, mmin(value, anim.ms) / anim.ms);\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.status\n           [ method ]\n           **\n           * Gets or sets the status of animation of the element.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\n           **\n           = (number) status\n           * or\n           = (array) status if `anim` is not specified. Array of objects in format:\n           o {\n           o     anim: (object) animation object\n           o     status: (number) status\n           o }\n           * or\n           = (object) original element if `value` is specified\n          \\*/\n\n\n          elproto.status = function (anim, value) {\n            var out = [],\n                i = 0,\n                len,\n                e;\n\n            if (value != null) {\n              runAnimation(anim, this, -1, mmin(value, 1));\n              return this;\n            } else {\n              len = animationElements.length;\n\n              for (; i < len; i++) {\n                e = animationElements[i];\n\n                if (e.el.id == this.id && (!anim || e.anim == anim)) {\n                  if (anim) {\n                    return e.status;\n                  }\n\n                  out.push({\n                    anim: e.anim,\n                    status: e.status\n                  });\n                }\n              }\n\n              if (anim) {\n                return 0;\n              }\n\n              return out;\n            }\n          };\n          /*\\\n           * Element.pause\n           [ method ]\n           **\n           * Stops animation of the element with ability to resume it later on.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.pause = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\n                  animationElements[i].paused = true;\n                }\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.resume\n           [ method ]\n           **\n           * Resumes animation if it was paused with @Element.pause method.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.resume = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                var e = animationElements[i];\n\n                if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\n                  delete e.paused;\n                  this.status(e.anim, e.status);\n                }\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.stop\n           [ method ]\n           **\n           * Stops animation of the element.\n           **\n           > Parameters\n           **\n           - anim (object) #optional animation object\n           **\n           = (object) original element\n          \\*/\n\n\n          elproto.stop = function (anim) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n                if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\n                  animationElements.splice(i--, 1);\n                }\n              }\n            }\n\n            return this;\n          };\n\n          function stopAnimation(paper) {\n            for (var i = 0; i < animationElements.length; i++) {\n              if (animationElements[i].el.paper == paper) {\n                animationElements.splice(i--, 1);\n              }\n            }\n          }\n\n          eve.on(\"raphael.remove\", stopAnimation);\n          eve.on(\"raphael.clear\", stopAnimation);\n\n          elproto.toString = function () {\n            return \"Rapha\\xEBl\\u2019s object\";\n          }; // Set\n\n\n          var Set = function Set(items) {\n            this.items = [];\n            this.length = 0;\n            this.type = \"set\";\n\n            if (items) {\n              for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\n                  this[this.items.length] = this.items[this.items.length] = items[i];\n                  this.length++;\n                }\n              }\n            }\n          },\n              setproto = Set.prototype;\n          /*\\\n           * Set.push\n           [ method ]\n           **\n           * Adds each argument to the current set.\n           = (object) original element\n          \\*/\n\n\n          setproto.push = function () {\n            var item, len;\n\n            for (var i = 0, ii = arguments.length; i < ii; i++) {\n              item = arguments[i];\n\n              if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Set.pop\n           [ method ]\n           **\n           * Removes last element and returns it.\n           = (object) element\n          \\*/\n\n\n          setproto.pop = function () {\n            this.length && delete this[this.length--];\n            return this.items.pop();\n          };\n          /*\\\n           * Set.forEach\n           [ method ]\n           **\n           * Executes given function for each element in the set.\n           *\n           * If function returns `false` it will stop loop running.\n           **\n           > Parameters\n           **\n           - callback (function) function to run\n           - thisArg (object) context object for the callback\n           = (object) Set object\n          \\*/\n\n\n          setproto.forEach = function (callback, thisArg) {\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\n              if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n              }\n            }\n\n            return this;\n          };\n\n          for (var method in elproto) {\n            if (elproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname][apply](el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n\n          setproto.attr = function (name, value) {\n            if (name && R.is(name, array) && R.is(name[0], \"object\")) {\n              for (var j = 0, jj = name.length; j < jj; j++) {\n                this.items[j].attr(name[j]);\n              }\n            } else {\n              for (var i = 0, ii = this.items.length; i < ii; i++) {\n                this.items[i].attr(name, value);\n              }\n            }\n\n            return this;\n          };\n          /*\\\n           * Set.clear\n           [ method ]\n           **\n           * Removes all elements from the set\n          \\*/\n\n\n          setproto.clear = function () {\n            while (this.length) {\n              this.pop();\n            }\n          };\n          /*\\\n           * Set.splice\n           [ method ]\n           **\n           * Removes given element from the set\n           **\n           > Parameters\n           **\n           - index (number) position of the deletion\n           - count (number) number of element to remove\n           - insertion… (object) #optional elements to insert\n           = (object) set elements that were deleted\n          \\*/\n\n\n          setproto.splice = function (index, count, insertion) {\n            index = index < 0 ? mmax(this.length + index, 0) : index;\n            count = mmax(0, mmin(this.length - index, count));\n            var tail = [],\n                todel = [],\n                args = [],\n                i;\n\n            for (i = 2; i < arguments.length; i++) {\n              args.push(arguments[i]);\n            }\n\n            for (i = 0; i < count; i++) {\n              todel.push(this[index + i]);\n            }\n\n            for (; i < this.length - index; i++) {\n              tail.push(this[index + i]);\n            }\n\n            var arglen = args.length;\n\n            for (i = 0; i < arglen + tail.length; i++) {\n              this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n            }\n\n            i = this.items.length = this.length -= count - arglen;\n\n            while (this[i]) {\n              delete this[i++];\n            }\n\n            return new Set(todel);\n          };\n          /*\\\n           * Set.exclude\n           [ method ]\n           **\n           * Removes given element from the set\n           **\n           > Parameters\n           **\n           - element (object) element to remove\n           = (boolean) `true` if object was found & removed from the set\n          \\*/\n\n\n          setproto.exclude = function (el) {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n              if (this[i] == el) {\n                this.splice(i, 1);\n                return true;\n              }\n            }\n          };\n\n          setproto.animate = function (params, ms, easing, callback) {\n            (R.is(easing, \"function\") || !easing) && (callback = easing || null);\n            var len = this.items.length,\n                i = len,\n                item,\n                set = this,\n                collector;\n\n            if (!len) {\n              return this;\n            }\n\n            callback && (collector = function collector() {\n              ! --len && callback.call(set);\n            });\n            easing = R.is(easing, string) ? easing : collector;\n            var anim = R.animation(params, ms, easing, collector);\n            item = this.items[--i].animate(anim);\n\n            while (i--) {\n              this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\n              this.items[i] && !this.items[i].removed || len--;\n            }\n\n            return this;\n          };\n\n          setproto.insertAfter = function (el) {\n            var i = this.items.length;\n\n            while (i--) {\n              this.items[i].insertAfter(el);\n            }\n\n            return this;\n          };\n\n          setproto.getBBox = function () {\n            var x = [],\n                y = [],\n                x2 = [],\n                y2 = [];\n\n            for (var i = this.items.length; i--;) {\n              if (!this.items[i].removed) {\n                var box = this.items[i].getBBox();\n                x.push(box.x);\n                y.push(box.y);\n                x2.push(box.x + box.width);\n                y2.push(box.y + box.height);\n              }\n            }\n\n            x = mmin[apply](0, x);\n            y = mmin[apply](0, y);\n            x2 = mmax[apply](0, x2);\n            y2 = mmax[apply](0, y2);\n            return {\n              x: x,\n              y: y,\n              x2: x2,\n              y2: y2,\n              width: x2 - x,\n              height: y2 - y\n            };\n          };\n\n          setproto.clone = function (s) {\n            s = this.paper.set();\n\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\n              s.push(this.items[i].clone());\n            }\n\n            return s;\n          };\n\n          setproto.toString = function () {\n            return \"Rapha\\xEBl\\u2018s set\";\n          };\n\n          setproto.glow = function (glowConfig) {\n            var ret = this.paper.set();\n            this.forEach(function (shape, index) {\n              var g = shape.glow(glowConfig);\n\n              if (g != null) {\n                g.forEach(function (shape2, index2) {\n                  ret.push(shape2);\n                });\n              }\n            });\n            return ret;\n          };\n          /*\\\n           * Set.isPointInside\n           [ method ]\n           **\n           * Determine if given point is inside this set’s elements\n           **\n           > Parameters\n           **\n           - x (number) x coordinate of the point\n           - y (number) y coordinate of the point\n           = (boolean) `true` if point is inside any of the set's elements\n           \\*/\n\n\n          setproto.isPointInside = function (x, y) {\n            var isPointInside = false;\n            this.forEach(function (el) {\n              if (el.isPointInside(x, y)) {\n                isPointInside = true;\n                return false; // stop loop\n              }\n            });\n            return isPointInside;\n          };\n          /*\\\n           * Raphael.registerFont\n           [ method ]\n           **\n           * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.\n           * Returns original parameter, so it could be used with chaining.\n           # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\n           **\n           > Parameters\n           **\n           - font (object) the font to register\n           = (object) the font you passed in\n           > Usage\n           | Cufon.registerFont(Raphael.registerFont({…}));\n          \\*/\n\n\n          R.registerFont = function (font) {\n            if (!font.face) {\n              return font;\n            }\n\n            this.fonts = this.fonts || {};\n            var fontcopy = {\n              w: font.w,\n              face: {},\n              glyphs: {}\n            },\n                family = font.face[\"font-family\"];\n\n            for (var prop in font.face) {\n              if (font.face[has](prop)) {\n                fontcopy.face[prop] = font.face[prop];\n              }\n            }\n\n            if (this.fonts[family]) {\n              this.fonts[family].push(fontcopy);\n            } else {\n              this.fonts[family] = [fontcopy];\n            }\n\n            if (!font.svg) {\n              fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\n\n              for (var glyph in font.glyphs) {\n                if (font.glyphs[has](glyph)) {\n                  var path = font.glyphs[glyph];\n                  fontcopy.glyphs[glyph] = {\n                    w: path.w,\n                    k: {},\n                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\n                      return {\n                        l: \"L\",\n                        c: \"C\",\n                        x: \"z\",\n                        t: \"m\",\n                        r: \"l\",\n                        v: \"c\"\n                      }[command] || \"M\";\n                    }) + \"z\"\n                  };\n\n                  if (path.k) {\n                    for (var k in path.k) {\n                      if (path[has](k)) {\n                        fontcopy.glyphs[glyph].k[k] = path.k[k];\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            return font;\n          };\n          /*\\\n           * Paper.getFont\n           [ method ]\n           **\n           * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.\n           **\n           > Parameters\n           **\n           - family (string) font family name or any word from it\n           - weight (string) #optional font weight\n           - style (string) #optional font style\n           - stretch (string) #optional font stretch\n           = (object) the font object\n           > Usage\n           | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\n          \\*/\n\n\n          paperproto.getFont = function (family, weight, style, stretch) {\n            stretch = stretch || \"normal\";\n            style = style || \"normal\";\n            weight = +weight || {\n              normal: 400,\n              bold: 700,\n              lighter: 300,\n              bolder: 800\n            }[weight] || 400;\n\n            if (!R.fonts) {\n              return;\n            }\n\n            var font = R.fonts[family];\n\n            if (!font) {\n              var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\n\n              for (var fontName in R.fonts) {\n                if (R.fonts[has](fontName)) {\n                  if (name.test(fontName)) {\n                    font = R.fonts[fontName];\n                    break;\n                  }\n                }\n              }\n            }\n\n            var thefont;\n\n            if (font) {\n              for (var i = 0, ii = font.length; i < ii; i++) {\n                thefont = font[i];\n\n                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\n                  break;\n                }\n              }\n            }\n\n            return thefont;\n          };\n          /*\\\n           * Paper.print\n           [ method ]\n           **\n           * Creates path that represent given text written using given font at given position with given size.\n           * Result of the method is path element that contains whole text as a separate path.\n           **\n           > Parameters\n           **\n           - x (number) x position of the text\n           - y (number) y position of the text\n           - string (string) text to print\n           - font (object) font object, see @Paper.getFont\n           - size (number) #optional size of the font, default is `16`\n           - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\n           - letter_spacing (number) #optional number in range `-1..1`, default is `0`\n           - line_spacing (number) #optional number in range `1..3`, default is `1`\n           = (object) resulting path element, which consist of all letters\n           > Usage\n           | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\n          \\*/\n\n\n          paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\n            origin = origin || \"middle\"; // baseline|middle\n\n            letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\n            line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\n            var letters = Str(string)[split](E),\n                shift = 0,\n                notfirst = 0,\n                path = E,\n                scale;\n            R.is(font, \"string\") && (font = this.getFont(font));\n\n            if (font) {\n              scale = (size || 16) / font.face[\"units-per-em\"];\n              var bb = font.face.bbox[split](separator),\n                  top = +bb[0],\n                  lineHeight = bb[3] - bb[1],\n                  shifty = 0,\n                  height = +bb[1] + (origin == \"baseline\" ? lineHeight + +font.face.descent : lineHeight / 2);\n\n              for (var i = 0, ii = letters.length; i < ii; i++) {\n                if (letters[i] == \"\\n\") {\n                  shift = 0;\n                  curr = 0;\n                  notfirst = 0;\n                  shifty += lineHeight * line_spacing;\n                } else {\n                  var prev = notfirst && font.glyphs[letters[i - 1]] || {},\n                      curr = font.glyphs[letters[i]];\n                  shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;\n                  notfirst = 1;\n                }\n\n                if (curr && curr.d) {\n                  path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\n                }\n              }\n            }\n\n            return this.path(path).attr({\n              fill: \"#000\",\n              stroke: \"none\"\n            });\n          };\n          /*\\\n           * Paper.add\n           [ method ]\n           **\n           * Imports elements in JSON array in format `{type: type, <attributes>}`\n           **\n           > Parameters\n           **\n           - json (array)\n           = (object) resulting set of imported elements\n           > Usage\n           | paper.add([\n           |     {\n           |         type: \"circle\",\n           |         cx: 10,\n           |         cy: 10,\n           |         r: 5\n           |     },\n           |     {\n           |         type: \"rect\",\n           |         x: 10,\n           |         y: 10,\n           |         width: 10,\n           |         height: 10,\n           |         fill: \"#fc0\"\n           |     }\n           | ]);\n          \\*/\n\n\n          paperproto.add = function (json) {\n            if (R.is(json, \"array\")) {\n              var res = this.set(),\n                  i = 0,\n                  ii = json.length,\n                  j;\n\n              for (; i < ii; i++) {\n                j = json[i] || {};\n                elements[has](j.type) && res.push(this[j.type]().attr(j));\n              }\n            }\n\n            return res;\n          };\n          /*\\\n           * Raphael.format\n           [ method ]\n           **\n           * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.\n           **\n           > Parameters\n           **\n           - token (string) string to format\n           - … (string) rest of arguments will be treated as parameters for replacement\n           = (string) formated string\n           > Usage\n           | var x = 10,\n           |     y = 20,\n           |     width = 40,\n           |     height = 50;\n           | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n           | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\n          \\*/\n\n\n          R.format = function (token, params) {\n            var args = R.is(params, array) ? [0][concat](params) : arguments;\n            token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\n              return args[++i] == null ? E : args[i];\n            }));\n            return token || E;\n          };\n          /*\\\n           * Raphael.fullfill\n           [ method ]\n           **\n           * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.\n           **\n           > Parameters\n           **\n           - token (string) string to format\n           - json (object) object which properties will be used as a replacement\n           = (string) formated string\n           > Usage\n           | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n           | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n           |     x: 10,\n           |     y: 20,\n           |     dim: {\n           |         width: 40,\n           |         height: 50,\n           |         \"negative width\": -40\n           |     }\n           | }));\n          \\*/\n\n\n          R.fullfill = function () {\n            var tokenRegex = /\\{([^\\}]+)\\}/g,\n                objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g,\n                // matches .xxxxx or [\"xxxxx\"] to run over object properties\n            replacer = function replacer(all, key, obj) {\n              var res = obj;\n              key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n\n                if (res) {\n                  if (name in res) {\n                    res = res[name];\n                  }\n\n                  typeof res == \"function\" && isFunc && (res = res());\n                }\n              });\n              res = (res == null || res == obj ? all : res) + \"\";\n              return res;\n            };\n\n            return function (str, obj) {\n              return String(str).replace(tokenRegex, function (all, key) {\n                return replacer(all, key, obj);\n              });\n            };\n          }();\n          /*\\\n           * Raphael.ninja\n           [ method ]\n           **\n           * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\n           * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\n           **\n           = (object) Raphael object\n           > Usage\n           | (function (local_raphael) {\n           |     var paper = local_raphael(10, 10, 320, 200);\n           |     …\n           | })(Raphael.ninja());\n          \\*/\n\n\n          R.ninja = function () {\n            if (oldRaphael.was) {\n              g.win.Raphael = oldRaphael.is;\n            } else {\n              // IE8 raises an error when deleting window property\n              window.Raphael = undefined;\n\n              try {\n                delete window.Raphael;\n              } catch (e) {}\n            }\n\n            return R;\n          };\n          /*\\\n           * Raphael.st\n           [ property (object) ]\n           **\n           * You can add your own method to elements and sets. It is wise to add a set method for each element method\n           * you added, so you will be able to call the same method on sets too.\n           **\n           * See also @Raphael.el.\n           > Usage\n           | Raphael.el.red = function () {\n           |     this.attr({fill: \"#f00\"});\n           | };\n           | Raphael.st.red = function () {\n           |     this.forEach(function (el) {\n           |         el.red();\n           |     });\n           | };\n           | // then use it\n           | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\n          \\*/\n\n\n          R.st = setproto;\n          eve.on(\"raphael.DOMload\", function () {\n            loaded = true;\n          }); // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\n          (function (doc, loaded, _f2) {\n            if (doc.readyState == null && doc.addEventListener) {\n              doc.addEventListener(loaded, _f2 = function f() {\n                doc.removeEventListener(loaded, _f2, false);\n                doc.readyState = \"complete\";\n              }, false);\n              doc.readyState = \"loading\";\n            }\n\n            function isLoaded() {\n              /in/.test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\n            }\n\n            isLoaded();\n          })(document, \"DOMContentLoaded\");\n\n          return R;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.svg.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.svg.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelSvgJs(module, exports, __nested_webpack_require_218809__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_218809__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          if (R && !R.svg) {\n            return;\n          }\n\n          var has = \"hasOwnProperty\",\n              Str = String,\n              toFloat = parseFloat,\n              toInt = parseInt,\n              math = Math,\n              mmax = math.max,\n              abs = math.abs,\n              pow = math.pow,\n              separator = /[, ]+/,\n              eve = R.eve,\n              E = \"\",\n              S = \" \";\n          var xlink = \"http://www.w3.org/1999/xlink\",\n              markers = {\n            block: \"M5,0 0,2.5 5,5z\",\n            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\n            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\n            open: \"M6,1 1,3.5 6,6\",\n            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\n          },\n              markerCounter = {};\n\n          R.toString = function () {\n            return \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\n          };\n\n          var $ = function $(el, attr) {\n            if (attr) {\n              if (typeof el == \"string\") {\n                el = $(el);\n              }\n\n              for (var key in attr) {\n                if (attr[has](key)) {\n                  if (key.substring(0, 6) == \"xlink:\") {\n                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\n                  } else {\n                    el.setAttribute(key, Str(attr[key]));\n                  }\n                }\n              }\n            } else {\n              el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\n              el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\n            }\n\n            return el;\n          },\n              addGradientFill = function addGradientFill(element, gradient) {\n            var type = \"linear\",\n                id = element.id + gradient,\n                fx = .5,\n                fy = .5,\n                o = element.node,\n                SVG = element.paper,\n                s = o.style,\n                el = R._g.doc.getElementById(id);\n\n            if (!el) {\n              gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\n                type = \"radial\";\n\n                if (_fx && _fy) {\n                  fx = toFloat(_fx);\n                  fy = toFloat(_fy);\n                  var dir = (fy > .5) * 2 - 1;\n                  pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) && fy != .5 && (fy = fy.toFixed(5) - 1e-5 * dir);\n                }\n\n                return E;\n              });\n              gradient = gradient.split(/\\s*\\-\\s*/);\n\n              if (type == \"linear\") {\n                var angle = gradient.shift();\n                angle = -toFloat(angle);\n\n                if (isNaN(angle)) {\n                  return null;\n                }\n\n                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\n                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\n                vector[2] *= max;\n                vector[3] *= max;\n\n                if (vector[2] < 0) {\n                  vector[0] = -vector[2];\n                  vector[2] = 0;\n                }\n\n                if (vector[3] < 0) {\n                  vector[1] = -vector[3];\n                  vector[3] = 0;\n                }\n              }\n\n              var dots = R._parseDots(gradient);\n\n              if (!dots) {\n                return null;\n              }\n\n              id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\n\n              if (element.gradient && id != element.gradient.id) {\n                SVG.defs.removeChild(element.gradient);\n                delete element.gradient;\n              }\n\n              if (!element.gradient) {\n                el = $(type + \"Gradient\", {\n                  id: id\n                });\n                element.gradient = el;\n                $(el, type == \"radial\" ? {\n                  fx: fx,\n                  fy: fy\n                } : {\n                  x1: vector[0],\n                  y1: vector[1],\n                  x2: vector[2],\n                  y2: vector[3],\n                  gradientTransform: element.matrix.invert()\n                });\n                SVG.defs.appendChild(el);\n\n                for (var i = 0, ii = dots.length; i < ii; i++) {\n                  el.appendChild($(\"stop\", {\n                    offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\n                    \"stop-color\": dots[i].color || \"#fff\",\n                    \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\n                  }));\n                }\n              }\n            }\n\n            $(o, {\n              fill: fillurl(id),\n              opacity: 1,\n              \"fill-opacity\": 1\n            });\n            s.fill = E;\n            s.opacity = 1;\n            s.fillOpacity = 1;\n            return 1;\n          },\n              isIE9or10 = function isIE9or10() {\n            var mode = document.documentMode;\n            return mode && (mode === 9 || mode === 10);\n          },\n              fillurl = function fillurl(id) {\n            if (isIE9or10()) {\n              return \"url('#\" + id + \"')\";\n            }\n\n            var location = document.location;\n            var locationString = location.protocol + '//' + location.host + location.pathname + location.search;\n            return \"url('\" + locationString + \"#\" + id + \"')\";\n          },\n              updatePosition = function updatePosition(o) {\n            var bbox = o.getBBox(1);\n            $(o.pattern, {\n              patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"\n            });\n          },\n              addArrow = function addArrow(o, value, isEnd) {\n            if (o.type == \"path\") {\n              var values = Str(value).toLowerCase().split(\"-\"),\n                  p = o.paper,\n                  se = isEnd ? \"end\" : \"start\",\n                  node = o.node,\n                  attrs = o.attrs,\n                  stroke = attrs[\"stroke-width\"],\n                  i = values.length,\n                  type = \"classic\",\n                  from,\n                  to,\n                  dx,\n                  refX,\n                  attr,\n                  w = 3,\n                  h = 3,\n                  t = 5;\n\n              while (i--) {\n                switch (values[i]) {\n                  case \"block\":\n                  case \"classic\":\n                  case \"oval\":\n                  case \"diamond\":\n                  case \"open\":\n                  case \"none\":\n                    type = values[i];\n                    break;\n\n                  case \"wide\":\n                    h = 5;\n                    break;\n\n                  case \"narrow\":\n                    h = 2;\n                    break;\n\n                  case \"long\":\n                    w = 5;\n                    break;\n\n                  case \"short\":\n                    w = 2;\n                    break;\n                }\n              }\n\n              if (type == \"open\") {\n                w += 2;\n                h += 2;\n                t += 2;\n                dx = 1;\n                refX = isEnd ? 4 : 1;\n                attr = {\n                  fill: \"none\",\n                  stroke: attrs.stroke\n                };\n              } else {\n                refX = dx = w / 2;\n                attr = {\n                  fill: attrs.stroke,\n                  stroke: \"none\"\n                };\n              }\n\n              if (o._.arrows) {\n                if (isEnd) {\n                  o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\n                  o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\n                } else {\n                  o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\n                  o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\n                }\n              } else {\n                o._.arrows = {};\n              }\n\n              if (type != \"none\") {\n                var pathId = \"raphael-marker-\" + type,\n                    markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\n\n                if (!R._g.doc.getElementById(pathId)) {\n                  p.defs.appendChild($($(\"path\"), {\n                    \"stroke-linecap\": \"round\",\n                    d: markers[type],\n                    id: pathId\n                  }));\n                  markerCounter[pathId] = 1;\n                } else {\n                  markerCounter[pathId]++;\n                }\n\n                var marker = R._g.doc.getElementById(markerId),\n                    use;\n\n                if (!marker) {\n                  marker = $($(\"marker\"), {\n                    id: markerId,\n                    markerHeight: h,\n                    markerWidth: w,\n                    orient: \"auto\",\n                    refX: refX,\n                    refY: h / 2\n                  });\n                  use = $($(\"use\"), {\n                    \"xlink:href\": \"#\" + pathId,\n                    transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\n                    \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\n                  });\n                  marker.appendChild(use);\n                  p.defs.appendChild(marker);\n                  markerCounter[markerId] = 1;\n                } else {\n                  markerCounter[markerId]++;\n                  use = marker.getElementsByTagName(\"use\")[0];\n                }\n\n                $(use, attr);\n                var delta = dx * (type != \"diamond\" && type != \"oval\");\n\n                if (isEnd) {\n                  from = o._.arrows.startdx * stroke || 0;\n                  to = R.getTotalLength(attrs.path) - delta * stroke;\n                } else {\n                  from = delta * stroke;\n                  to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                }\n\n                attr = {};\n                attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\n\n                if (to || from) {\n                  attr.d = R.getSubpath(attrs.path, from, to);\n                }\n\n                $(node, attr);\n                o._.arrows[se + \"Path\"] = pathId;\n                o._.arrows[se + \"Marker\"] = markerId;\n                o._.arrows[se + \"dx\"] = delta;\n                o._.arrows[se + \"Type\"] = type;\n                o._.arrows[se + \"String\"] = value;\n              } else {\n                if (isEnd) {\n                  from = o._.arrows.startdx * stroke || 0;\n                  to = R.getTotalLength(attrs.path) - from;\n                } else {\n                  from = 0;\n                  to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                }\n\n                o._.arrows[se + \"Path\"] && $(node, {\n                  d: R.getSubpath(attrs.path, from, to)\n                });\n                delete o._.arrows[se + \"Path\"];\n                delete o._.arrows[se + \"Marker\"];\n                delete o._.arrows[se + \"dx\"];\n                delete o._.arrows[se + \"Type\"];\n                delete o._.arrows[se + \"String\"];\n              }\n\n              for (attr in markerCounter) {\n                if (markerCounter[has](attr) && !markerCounter[attr]) {\n                  var item = R._g.doc.getElementById(attr);\n\n                  item && item.parentNode.removeChild(item);\n                }\n              }\n            }\n          },\n              dasharray = {\n            \"-\": [3, 1],\n            \".\": [1, 1],\n            \"-.\": [3, 1, 1, 1],\n            \"-..\": [3, 1, 1, 1, 1, 1],\n            \". \": [1, 3],\n            \"- \": [4, 3],\n            \"--\": [8, 3],\n            \"- .\": [4, 3, 1, 3],\n            \"--.\": [8, 3, 1, 3],\n            \"--..\": [8, 3, 1, 3, 1, 3]\n          },\n              addDashes = function addDashes(o, value, params) {\n            value = dasharray[Str(value).toLowerCase()];\n\n            if (value) {\n              var width = o.attrs[\"stroke-width\"] || \"1\",\n                  butt = {\n                round: width,\n                square: width,\n                butt: 0\n              }[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\n                  dashes = [],\n                  i = value.length;\n\n              while (i--) {\n                dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;\n              }\n\n              $(o.node, {\n                \"stroke-dasharray\": dashes.join(\",\")\n              });\n            } else {\n              $(o.node, {\n                \"stroke-dasharray\": \"none\"\n              });\n            }\n          },\n              setFillAndStroke = function setFillAndStroke(o, params) {\n            var node = o.node,\n                attrs = o.attrs,\n                vis = node.style.visibility;\n            node.style.visibility = \"hidden\";\n\n            for (var att in params) {\n              if (params[has](att)) {\n                if (!R._availableAttrs[has](att)) {\n                  continue;\n                }\n\n                var value = params[att];\n                attrs[att] = value;\n\n                switch (att) {\n                  case \"blur\":\n                    o.blur(value);\n                    break;\n\n                  case \"title\":\n                    var title = node.getElementsByTagName(\"title\"); // Use the existing <title>.\n\n                    if (title.length && (title = title[0])) {\n                      title.firstChild.nodeValue = value;\n                    } else {\n                      title = $(\"title\");\n\n                      var val = R._g.doc.createTextNode(value);\n\n                      title.appendChild(val);\n                      node.appendChild(title);\n                    }\n\n                    break;\n\n                  case \"href\":\n                  case \"target\":\n                    var pn = node.parentNode;\n\n                    if (pn.tagName.toLowerCase() != \"a\") {\n                      var hl = $(\"a\");\n                      pn.insertBefore(hl, node);\n                      hl.appendChild(node);\n                      pn = hl;\n                    }\n\n                    if (att == \"target\") {\n                      pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\n                    } else {\n                      pn.setAttributeNS(xlink, att, value);\n                    }\n\n                    break;\n\n                  case \"cursor\":\n                    node.style.cursor = value;\n                    break;\n\n                  case \"transform\":\n                    o.transform(value);\n                    break;\n\n                  case \"arrow-start\":\n                    addArrow(o, value);\n                    break;\n\n                  case \"arrow-end\":\n                    addArrow(o, value, 1);\n                    break;\n\n                  case \"clip-rect\":\n                    var rect = Str(value).split(separator);\n\n                    if (rect.length == 4) {\n                      o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\n                      var el = $(\"clipPath\"),\n                          rc = $(\"rect\");\n                      el.id = R.createUUID();\n                      $(rc, {\n                        x: rect[0],\n                        y: rect[1],\n                        width: rect[2],\n                        height: rect[3]\n                      });\n                      el.appendChild(rc);\n                      o.paper.defs.appendChild(el);\n                      $(node, {\n                        \"clip-path\": \"url(#\" + el.id + \")\"\n                      });\n                      o.clip = rc;\n                    }\n\n                    if (!value) {\n                      var path = node.getAttribute(\"clip-path\");\n\n                      if (path) {\n                        var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\n\n                        clip && clip.parentNode.removeChild(clip);\n                        $(node, {\n                          \"clip-path\": E\n                        });\n                        delete o.clip;\n                      }\n                    }\n\n                    break;\n\n                  case \"path\":\n                    if (o.type == \"path\") {\n                      $(node, {\n                        d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"\n                      });\n                      o._.dirty = 1;\n\n                      if (o._.arrows) {\n                        \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                        \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                      }\n                    }\n\n                    break;\n\n                  case \"width\":\n                    node.setAttribute(att, value);\n                    o._.dirty = 1;\n\n                    if (attrs.fx) {\n                      att = \"x\";\n                      value = attrs.x;\n                    } else {\n                      break;\n                    }\n\n                  case \"x\":\n                    if (attrs.fx) {\n                      value = -attrs.x - (attrs.width || 0);\n                    }\n\n                  case \"rx\":\n                    if (att == \"rx\" && o.type == \"rect\") {\n                      break;\n                    }\n\n                  case \"cx\":\n                    node.setAttribute(att, value);\n                    o.pattern && updatePosition(o);\n                    o._.dirty = 1;\n                    break;\n\n                  case \"height\":\n                    node.setAttribute(att, value);\n                    o._.dirty = 1;\n\n                    if (attrs.fy) {\n                      att = \"y\";\n                      value = attrs.y;\n                    } else {\n                      break;\n                    }\n\n                  case \"y\":\n                    if (attrs.fy) {\n                      value = -attrs.y - (attrs.height || 0);\n                    }\n\n                  case \"ry\":\n                    if (att == \"ry\" && o.type == \"rect\") {\n                      break;\n                    }\n\n                  case \"cy\":\n                    node.setAttribute(att, value);\n                    o.pattern && updatePosition(o);\n                    o._.dirty = 1;\n                    break;\n\n                  case \"r\":\n                    if (o.type == \"rect\") {\n                      $(node, {\n                        rx: value,\n                        ry: value\n                      });\n                    } else {\n                      node.setAttribute(att, value);\n                    }\n\n                    o._.dirty = 1;\n                    break;\n\n                  case \"src\":\n                    if (o.type == \"image\") {\n                      node.setAttributeNS(xlink, \"href\", value);\n                    }\n\n                    break;\n\n                  case \"stroke-width\":\n                    if (o._.sx != 1 || o._.sy != 1) {\n                      value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\n                    }\n\n                    node.setAttribute(att, value);\n\n                    if (attrs[\"stroke-dasharray\"]) {\n                      addDashes(o, attrs[\"stroke-dasharray\"], params);\n                    }\n\n                    if (o._.arrows) {\n                      \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                      \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                    }\n\n                    break;\n\n                  case \"stroke-dasharray\":\n                    addDashes(o, value, params);\n                    break;\n\n                  case \"fill\":\n                    var isURL = Str(value).match(R._ISURL);\n\n                    if (isURL) {\n                      el = $(\"pattern\");\n                      var ig = $(\"image\");\n                      el.id = R.createUUID();\n                      $(el, {\n                        x: 0,\n                        y: 0,\n                        patternUnits: \"userSpaceOnUse\",\n                        height: 1,\n                        width: 1\n                      });\n                      $(ig, {\n                        x: 0,\n                        y: 0,\n                        \"xlink:href\": isURL[1]\n                      });\n                      el.appendChild(ig);\n\n                      (function (el) {\n                        R._preload(isURL[1], function () {\n                          var w = this.offsetWidth,\n                              h = this.offsetHeight;\n                          $(el, {\n                            width: w,\n                            height: h\n                          });\n                          $(ig, {\n                            width: w,\n                            height: h\n                          });\n                        });\n                      })(el);\n\n                      o.paper.defs.appendChild(el);\n                      $(node, {\n                        fill: \"url(#\" + el.id + \")\"\n                      });\n                      o.pattern = el;\n                      o.pattern && updatePosition(o);\n                      break;\n                    }\n\n                    var clr = R.getRGB(value);\n\n                    if (!clr.error) {\n                      delete params.gradient;\n                      delete attrs.gradient;\n                      !R.is(attrs.opacity, \"undefined\") && R.is(params.opacity, \"undefined\") && $(node, {\n                        opacity: attrs.opacity\n                      });\n                      !R.is(attrs[\"fill-opacity\"], \"undefined\") && R.is(params[\"fill-opacity\"], \"undefined\") && $(node, {\n                        \"fill-opacity\": attrs[\"fill-opacity\"]\n                      });\n                    } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\n                      if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\n                        var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\n                        if (gradient) {\n                          var stops = gradient.getElementsByTagName(\"stop\");\n                          $(stops[stops.length - 1], {\n                            \"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)\n                          });\n                        }\n                      }\n\n                      attrs.gradient = value;\n                      attrs.fill = \"none\";\n                      break;\n                    }\n\n                    clr[has](\"opacity\") && $(node, {\n                      \"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity\n                    });\n\n                  case \"stroke\":\n                    clr = R.getRGB(value);\n                    node.setAttribute(att, clr.hex);\n                    att == \"stroke\" && clr[has](\"opacity\") && $(node, {\n                      \"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity\n                    });\n\n                    if (att == \"stroke\" && o._.arrows) {\n                      \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                      \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                    }\n\n                    break;\n\n                  case \"gradient\":\n                    (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\n                    break;\n\n                  case \"opacity\":\n                    if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\n                      $(node, {\n                        \"stroke-opacity\": value > 1 ? value / 100 : value\n                      });\n                    }\n\n                  // fall\n\n                  case \"fill-opacity\":\n                    if (attrs.gradient) {\n                      gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\n                      if (gradient) {\n                        stops = gradient.getElementsByTagName(\"stop\");\n                        $(stops[stops.length - 1], {\n                          \"stop-opacity\": value\n                        });\n                      }\n\n                      break;\n                    }\n\n                  default:\n                    att == \"font-size\" && (value = toInt(value, 10) + \"px\");\n                    var cssrule = att.replace(/(\\-.)/g, function (w) {\n                      return w.substring(1).toUpperCase();\n                    });\n                    node.style[cssrule] = value;\n                    o._.dirty = 1;\n                    node.setAttribute(att, value);\n                    break;\n                }\n              }\n            }\n\n            tuneText(o, params);\n            node.style.visibility = vis;\n          },\n              leading = 1.2,\n              tuneText = function tuneText(el, params) {\n            if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\n              return;\n            }\n\n            var a = el.attrs,\n                node = el.node,\n                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\n\n            if (params[has](\"text\")) {\n              a.text = params.text;\n\n              while (node.firstChild) {\n                node.removeChild(node.firstChild);\n              }\n\n              var texts = Str(params.text).split(\"\\n\"),\n                  tspans = [],\n                  tspan;\n\n              for (var i = 0, ii = texts.length; i < ii; i++) {\n                tspan = $(\"tspan\");\n                i && $(tspan, {\n                  dy: fontSize * leading,\n                  x: a.x\n                });\n                tspan.appendChild(R._g.doc.createTextNode(texts[i]));\n                node.appendChild(tspan);\n                tspans[i] = tspan;\n              }\n            } else {\n              tspans = node.getElementsByTagName(\"tspan\");\n\n              for (i = 0, ii = tspans.length; i < ii; i++) {\n                if (i) {\n                  $(tspans[i], {\n                    dy: fontSize * leading,\n                    x: a.x\n                  });\n                } else {\n                  $(tspans[0], {\n                    dy: 0\n                  });\n                }\n              }\n            }\n\n            $(node, {\n              x: a.x,\n              y: a.y\n            });\n            el._.dirty = 1;\n\n            var bb = el._getBBox(),\n                dif = a.y - (bb.y + bb.height / 2);\n\n            dif && R.is(dif, \"finite\") && $(tspans[0], {\n              dy: dif\n            });\n          },\n              getRealNode = function getRealNode(node) {\n            if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\n              return node.parentNode;\n            } else {\n              return node;\n            }\n          },\n              Element = function Element(node, svg) {\n            var X = 0,\n                Y = 0;\n            /*\\\n             * Element.node\n             [ property (object) ]\n             **\n             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n             **\n             * Note: Don’t mess with it.\n             > Usage\n             | // draw a circle at coordinate 10,10 with radius of 10\n             | var c = paper.circle(10, 10, 10);\n             | c.node.onclick = function () {\n             |     c.attr(\"fill\", \"red\");\n             | };\n            \\*/\n\n            this[0] = this.node = node;\n            /*\\\n             * Element.raphael\n             [ property (object) ]\n             **\n             * Internal reference to @Raphael object. In case it is not available.\n             > Usage\n             | Raphael.el.red = function () {\n             |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\n             |     hsb.h = 1;\n             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\n             | }\n            \\*/\n\n            node.raphael = true;\n            /*\\\n             * Element.id\n             [ property (number) ]\n             **\n             * Unique id of the element. Especially useful when you want to listen to events of the element,\n             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\n            \\*/\n\n            this.id = guid();\n            node.raphaelid = this.id;\n            /**\n            * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements\n            * @returns {string} id\n            */\n\n            function guid() {\n              return (\"0000\" + (Math.random() * Math.pow(36, 5) << 0).toString(36)).slice(-5);\n            }\n\n            this.matrix = R.matrix();\n            this.realPath = null;\n            /*\\\n             * Element.paper\n             [ property (object) ]\n             **\n             * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.\n             > Usage\n             | Raphael.el.cross = function () {\n             |     this.attr({fill: \"red\"});\n             |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\n             |         .attr({stroke: \"red\"});\n             | }\n            \\*/\n\n            this.paper = svg;\n            this.attrs = this.attrs || {};\n            this._ = {\n              transform: [],\n              sx: 1,\n              sy: 1,\n              deg: 0,\n              dx: 0,\n              dy: 0,\n              dirty: 1\n            };\n            !svg.bottom && (svg.bottom = this);\n            /*\\\n             * Element.prev\n             [ property (object) ]\n             **\n             * Reference to the previous element in the hierarchy.\n            \\*/\n\n            this.prev = svg.top;\n            svg.top && (svg.top.next = this);\n            svg.top = this;\n            /*\\\n             * Element.next\n             [ property (object) ]\n             **\n             * Reference to the next element in the hierarchy.\n            \\*/\n\n            this.next = null;\n          },\n              elproto = R.el;\n\n          Element.prototype = elproto;\n          elproto.constructor = Element;\n\n          R._engine.path = function (pathString, SVG) {\n            var el = $(\"path\");\n            SVG.canvas && SVG.canvas.appendChild(el);\n            var p = new Element(el, SVG);\n            p.type = \"path\";\n            setFillAndStroke(p, {\n              fill: \"none\",\n              stroke: \"#000\",\n              path: pathString\n            });\n            return p;\n          };\n          /*\\\n           * Element.rotate\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds rotation by given angle around given point to the list of\n           * transformations of the element.\n           > Parameters\n           - deg (number) angle in degrees\n           - cx (number) #optional x coordinate of the centre of rotation\n           - cy (number) #optional y coordinate of the centre of rotation\n           * If cx & cy aren’t specified centre of the shape is used as a point of rotation.\n           = (object) @Element\n          \\*/\n\n\n          elproto.rotate = function (deg, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            deg = Str(deg).split(separator);\n\n            if (deg.length - 1) {\n              cx = toFloat(deg[1]);\n              cy = toFloat(deg[2]);\n            }\n\n            deg = toFloat(deg[0]);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n              cx = bbox.x + bbox.width / 2;\n              cy = bbox.y + bbox.height / 2;\n            }\n\n            this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n            return this;\n          };\n          /*\\\n           * Element.scale\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds scale by given amount relative to given point to the list of\n           * transformations of the element.\n           > Parameters\n           - sx (number) horisontal scale amount\n           - sy (number) vertical scale amount\n           - cx (number) #optional x coordinate of the centre of scale\n           - cy (number) #optional y coordinate of the centre of scale\n           * If cx & cy aren’t specified centre of the shape is used instead.\n           = (object) @Element\n          \\*/\n\n\n          elproto.scale = function (sx, sy, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            sx = Str(sx).split(separator);\n\n            if (sx.length - 1) {\n              sy = toFloat(sx[1]);\n              cx = toFloat(sx[2]);\n              cy = toFloat(sx[3]);\n            }\n\n            sx = toFloat(sx[0]);\n            sy == null && (sy = sx);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n            }\n\n            cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n            cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n            this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n            return this;\n          };\n          /*\\\n           * Element.translate\n           [ method ]\n           **\n           * Deprecated! Use @Element.transform instead.\n           * Adds translation by given amount to the list of transformations of the element.\n           > Parameters\n           - dx (number) horisontal shift\n           - dy (number) vertical shift\n           = (object) @Element\n          \\*/\n\n\n          elproto.translate = function (dx, dy) {\n            if (this.removed) {\n              return this;\n            }\n\n            dx = Str(dx).split(separator);\n\n            if (dx.length - 1) {\n              dy = toFloat(dx[1]);\n            }\n\n            dx = toFloat(dx[0]) || 0;\n            dy = +dy || 0;\n            this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n            return this;\n          };\n          /*\\\n           * Element.transform\n           [ method ]\n           **\n           * Adds transformation to the element which is separate to other attributes,\n           * i.e. translation doesn’t change `x` or `y` of the rectange. The format\n           * of transformation string is similar to the path string syntax:\n           | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\n           * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\n           * scale and `m` is for matrix.\n           *\n           * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\n           *\n           * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;\n           * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin\n           * coordinates as optional parameters, the default is the centre point of the element.\n           * Matrix accepts six parameters.\n           > Usage\n           | var el = paper.rect(10, 20, 300, 200);\n           | // translate 100, 100, rotate 45°, translate -100, 0\n           | el.transform(\"t100,100r45t-100,0\");\n           | // if you want you can append or prepend transformations\n           | el.transform(\"...t50,50\");\n           | el.transform(\"s2...\");\n           | // or even wrap\n           | el.transform(\"t50,50...t-50-50\");\n           | // to reset transformation call method with empty string\n           | el.transform(\"\");\n           | // to get current value call it without parameters\n           | console.log(el.transform());\n           > Parameters\n           - tstr (string) #optional transformation string\n           * If tstr isn’t specified\n           = (string) current transformation string\n           * else\n           = (object) @Element\n          \\*/\n\n\n          elproto.transform = function (tstr) {\n            var _ = this._;\n\n            if (tstr == null) {\n              return _.transform;\n            }\n\n            R._extractTransform(this, tstr);\n\n            this.clip && $(this.clip, {\n              transform: this.matrix.invert()\n            });\n            this.pattern && updatePosition(this);\n            this.node && $(this.node, {\n              transform: this.matrix\n            });\n\n            if (_.sx != 1 || _.sy != 1) {\n              var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\n              this.attr({\n                \"stroke-width\": sw\n              });\n            }\n\n            return this;\n          };\n          /*\\\n           * Element.hide\n           [ method ]\n           **\n           * Makes element invisible. See @Element.show.\n           = (object) @Element\n          \\*/\n\n\n          elproto.hide = function () {\n            if (!this.removed) this.node.style.display = \"none\";\n            return this;\n          };\n          /*\\\n           * Element.show\n           [ method ]\n           **\n           * Makes element visible. See @Element.hide.\n           = (object) @Element\n          \\*/\n\n\n          elproto.show = function () {\n            if (!this.removed) this.node.style.display = \"\";\n            return this;\n          };\n          /*\\\n           * Element.remove\n           [ method ]\n           **\n           * Removes element from the paper.\n          \\*/\n\n\n          elproto.remove = function () {\n            var node = getRealNode(this.node);\n\n            if (this.removed || !node.parentNode) {\n              return;\n            }\n\n            var paper = this.paper;\n            paper.__set__ && paper.__set__.exclude(this);\n            eve.unbind(\"raphael.*.*.\" + this.id);\n\n            if (this.gradient) {\n              paper.defs.removeChild(this.gradient);\n            }\n\n            R._tear(this, paper);\n\n            node.parentNode.removeChild(node); // Remove custom data for element\n\n            this.removeData();\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            this.removed = true;\n          };\n\n          elproto._getBBox = function () {\n            if (this.node.style.display == \"none\") {\n              this.show();\n              var hide = true;\n            }\n\n            var canvasHidden = false,\n                containerStyle;\n\n            if (this.paper.canvas.parentElement) {\n              containerStyle = this.paper.canvas.parentElement.style;\n            } //IE10+ can't find parentElement\n            else if (this.paper.canvas.parentNode) {\n              containerStyle = this.paper.canvas.parentNode.style;\n            }\n\n            if (containerStyle && containerStyle.display == \"none\") {\n              canvasHidden = true;\n              containerStyle.display = \"\";\n            }\n\n            var bbox = {};\n\n            try {\n              bbox = this.node.getBBox();\n            } catch (e) {\n              // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\n              bbox = {\n                x: this.node.clientLeft,\n                y: this.node.clientTop,\n                width: this.node.clientWidth,\n                height: this.node.clientHeight\n              };\n            } finally {\n              bbox = bbox || {};\n\n              if (canvasHidden) {\n                containerStyle.display = \"none\";\n              }\n            }\n\n            hide && this.hide();\n            return bbox;\n          };\n          /*\\\n           * Element.attr\n           [ method ]\n           **\n           * Sets the attributes of the element.\n           > Parameters\n           - attrName (string) attribute’s name\n           - value (string) value\n           * or\n           - params (object) object of name/value pairs\n           * or\n           - attrName (string) attribute’s name\n           * or\n           - attrNames (array) in this case method returns array of current values for given attribute names\n           = (object) @Element if attrsName & value or params are passed in.\n           = (...) value of the attribute if only attrsName is passed in.\n           = (array) array of values of the attribute if attrsNames is passed in.\n           = (object) object of attributes if nothing is passed in.\n           > Possible parameters\n           # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\n           o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\n           o clip-rect (string) comma or space separated values: x, y, width and height\n           o cursor (string) CSS type of the cursor\n           o cx (number) the x-axis coordinate of the center of the circle, or ellipse\n           o cy (number) the y-axis coordinate of the center of the circle, or ellipse\n           o fill (string) colour, gradient or image\n           o fill-opacity (number)\n           o font (string)\n           o font-family (string)\n           o font-size (number) font size in pixels\n           o font-weight (string)\n           o height (number)\n           o href (string) URL, if specified element behaves as hyperlink\n           o opacity (number)\n           o path (string) SVG path string format\n           o r (number) radius of the circle, ellipse or rounded corner on the rect\n           o rx (number) horisontal radius of the ellipse\n           o ry (number) vertical radius of the ellipse\n           o src (string) image URL, only works for @Element.image element\n           o stroke (string) stroke colour\n           o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]\n           o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]\n           o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]\n           o stroke-miterlimit (number)\n           o stroke-opacity (number)\n           o stroke-width (number) stroke width in pixels, default is '1'\n           o target (string) used with href\n           o text (string) contents of the text element. Use `\\n` for multiline text\n           o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”\n           o title (string) will create tooltip with a given text\n           o transform (string) see @Element.transform\n           o width (number)\n           o x (number)\n           o y (number)\n           > Gradients\n           * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°\n           * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.\n           *\n           * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –\n           * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point\n           * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\n           > Path String\n           # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path’s data attribute’s format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>\n           > Colour Parsing\n           # <ul>\n           #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\n           #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\n           #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\n           #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\n           #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\n           #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>\n           #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>\n           #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\n           #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>\n           #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\n           #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n           #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>\n           #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>\n           # </ul>\n          \\*/\n\n\n          elproto.attr = function (name, value) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (name == null) {\n              var res = {};\n\n              for (var a in this.attrs) {\n                if (this.attrs[has](a)) {\n                  res[a] = this.attrs[a];\n                }\n              }\n\n              res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n              res.transform = this._.transform;\n              return res;\n            }\n\n            if (value == null && R.is(name, \"string\")) {\n              if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n              }\n\n              if (name == \"transform\") {\n                return this._.transform;\n              }\n\n              var names = name.split(separator),\n                  out = {};\n\n              for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n\n                if (name in this.attrs) {\n                  out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                  out[name] = this.paper.customAttributes[name].def;\n                } else {\n                  out[name] = R._availableAttrs[name];\n                }\n              }\n\n              return ii - 1 ? out : out[names[0]];\n            }\n\n            if (value == null && R.is(name, \"array\")) {\n              out = {};\n\n              for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n              }\n\n              return out;\n            }\n\n            if (value != null) {\n              var params = {};\n              params[name] = value;\n            } else if (name != null && R.is(name, \"object\")) {\n              params = name;\n            }\n\n            for (var key in params) {\n              eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n            }\n\n            for (key in this.paper.customAttributes) {\n              if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n                this.attrs[key] = params[key];\n\n                for (var subkey in par) {\n                  if (par[has](subkey)) {\n                    params[subkey] = par[subkey];\n                  }\n                }\n              }\n            }\n\n            setFillAndStroke(this, params);\n            return this;\n          };\n          /*\\\n           * Element.toFront\n           [ method ]\n           **\n           * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.\n           = (object) @Element\n          \\*/\n\n\n          elproto.toFront = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            node.parentNode.appendChild(node);\n            var svg = this.paper;\n            svg.top != this && R._tofront(this, svg);\n            return this;\n          };\n          /*\\\n           * Element.toBack\n           [ method ]\n           **\n           * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.\n           = (object) @Element\n          \\*/\n\n\n          elproto.toBack = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var parentNode = node.parentNode;\n            parentNode.insertBefore(node, parentNode.firstChild);\n\n            R._toback(this, this.paper);\n\n            var svg = this.paper;\n            return this;\n          };\n          /*\\\n           * Element.insertAfter\n           [ method ]\n           **\n           * Inserts current object after the given one.\n           = (object) @Element\n          \\*/\n\n\n          elproto.insertAfter = function (element) {\n            if (this.removed || !element) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var afterNode = getRealNode(element.node || element[element.length - 1].node);\n\n            if (afterNode.nextSibling) {\n              afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\n            } else {\n              afterNode.parentNode.appendChild(node);\n            }\n\n            R._insertafter(this, element, this.paper);\n\n            return this;\n          };\n          /*\\\n           * Element.insertBefore\n           [ method ]\n           **\n           * Inserts current object before the given one.\n           = (object) @Element\n          \\*/\n\n\n          elproto.insertBefore = function (element) {\n            if (this.removed || !element) {\n              return this;\n            }\n\n            var node = getRealNode(this.node);\n            var beforeNode = getRealNode(element.node || element[0].node);\n            beforeNode.parentNode.insertBefore(node, beforeNode);\n\n            R._insertbefore(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.blur = function (size) {\n            // Experimental. No Safari support. Use it on your own risk.\n            var t = this;\n\n            if (+size !== 0) {\n              var fltr = $(\"filter\"),\n                  blur = $(\"feGaussianBlur\");\n              t.attrs.blur = size;\n              fltr.id = R.createUUID();\n              $(blur, {\n                stdDeviation: +size || 1.5\n              });\n              fltr.appendChild(blur);\n              t.paper.defs.appendChild(fltr);\n              t._blur = fltr;\n              $(t.node, {\n                filter: \"url(#\" + fltr.id + \")\"\n              });\n            } else {\n              if (t._blur) {\n                t._blur.parentNode.removeChild(t._blur);\n\n                delete t._blur;\n                delete t.attrs.blur;\n              }\n\n              t.node.removeAttribute(\"filter\");\n            }\n\n            return t;\n          };\n\n          R._engine.circle = function (svg, x, y, r) {\n            var el = $(\"circle\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              cx: x,\n              cy: y,\n              r: r,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"circle\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.rect = function (svg, x, y, w, h, r) {\n            var el = $(\"rect\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              rx: r || 0,\n              ry: r || 0,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"rect\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.ellipse = function (svg, x, y, rx, ry) {\n            var el = $(\"ellipse\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              cx: x,\n              cy: y,\n              rx: rx,\n              ry: ry,\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            res.type = \"ellipse\";\n            $(el, res.attrs);\n            return res;\n          };\n\n          R._engine.image = function (svg, src, x, y, w, h) {\n            var el = $(\"image\");\n            $(el, {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              preserveAspectRatio: \"none\"\n            });\n            el.setAttributeNS(xlink, \"href\", src);\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              width: w,\n              height: h,\n              src: src\n            };\n            res.type = \"image\";\n            return res;\n          };\n\n          R._engine.text = function (svg, x, y, text) {\n            var el = $(\"text\");\n            svg.canvas && svg.canvas.appendChild(el);\n            var res = new Element(el, svg);\n            res.attrs = {\n              x: x,\n              y: y,\n              \"text-anchor\": \"middle\",\n              text: text,\n              \"font-family\": R._availableAttrs[\"font-family\"],\n              \"font-size\": R._availableAttrs[\"font-size\"],\n              stroke: \"none\",\n              fill: \"#000\"\n            };\n            res.type = \"text\";\n            setFillAndStroke(res, res.attrs);\n            return res;\n          };\n\n          R._engine.setSize = function (width, height) {\n            this.width = width || this.width;\n            this.height = height || this.height;\n            this.canvas.setAttribute(\"width\", this.width);\n            this.canvas.setAttribute(\"height\", this.height);\n\n            if (this._viewBox) {\n              this.setViewBox.apply(this, this._viewBox);\n            }\n\n            return this;\n          };\n\n          R._engine.create = function () {\n            var con = R._getContainer.apply(0, arguments),\n                container = con && con.container;\n\n            if (!container) {\n              throw new Error(\"SVG container not found.\");\n            }\n\n            var x = con.x,\n                y = con.y,\n                width = con.width,\n                height = con.height,\n                cnvs = $(\"svg\"),\n                css = \"overflow:hidden;\",\n                isFloating;\n            x = x || 0;\n            y = y || 0;\n            width = width || 512;\n            height = height || 342;\n            $(cnvs, {\n              height: height,\n              version: 1.1,\n              width: width,\n              xmlns: \"http://www.w3.org/2000/svg\",\n              \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n            });\n\n            if (container == 1) {\n              cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\n\n              R._g.doc.body.appendChild(cnvs);\n\n              isFloating = 1;\n            } else {\n              cnvs.style.cssText = css + \"position:relative\";\n\n              if (container.firstChild) {\n                container.insertBefore(cnvs, container.firstChild);\n              } else {\n                container.appendChild(cnvs);\n              }\n            }\n\n            container = new R._Paper();\n            container.width = width;\n            container.height = height;\n            container.canvas = cnvs;\n            container.clear();\n            container._left = container._top = 0;\n            isFloating && (container.renderfix = function () {});\n            container.renderfix();\n            return container;\n          };\n\n          R._engine.setViewBox = function (x, y, w, h, fit) {\n            eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n            var paperSize = this.getSize(),\n                size = mmax(w / paperSize.width, h / paperSize.height),\n                top = this.top,\n                aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\n                vb,\n                sw;\n\n            if (x == null) {\n              if (this._vbSize) {\n                size = 1;\n              }\n\n              delete this._vbSize;\n              vb = \"0 0 \" + this.width + S + this.height;\n            } else {\n              this._vbSize = size;\n              vb = x + S + y + S + w + S + h;\n            }\n\n            $(this.canvas, {\n              viewBox: vb,\n              preserveAspectRatio: aspectRatio\n            });\n\n            while (size && top) {\n              sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\n              top.attr({\n                \"stroke-width\": sw\n              });\n              top._.dirty = 1;\n              top._.dirtyT = 1;\n              top = top.prev;\n            }\n\n            this._viewBox = [x, y, w, h, !!fit];\n            return this;\n          };\n          /*\\\n           * Paper.renderfix\n           [ method ]\n           **\n           * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent\n           * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\n           * This method fixes the issue.\n           **\n             Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\n          \\*/\n\n\n          R.prototype.renderfix = function () {\n            var cnvs = this.canvas,\n                s = cnvs.style,\n                pos;\n\n            try {\n              pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\n            } catch (e) {\n              pos = cnvs.createSVGMatrix();\n            }\n\n            var left = -pos.e % 1,\n                top = -pos.f % 1;\n\n            if (left || top) {\n              if (left) {\n                this._left = (this._left + left) % 1;\n                s.left = this._left + \"px\";\n              }\n\n              if (top) {\n                this._top = (this._top + top) % 1;\n                s.top = this._top + \"px\";\n              }\n            }\n          };\n          /*\\\n           * Paper.clear\n           [ method ]\n           **\n           * Clears the paper, i.e. removes all the elements.\n          \\*/\n\n\n          R.prototype.clear = function () {\n            R.eve(\"raphael.clear\", this);\n            var c = this.canvas;\n\n            while (c.firstChild) {\n              c.removeChild(c.firstChild);\n            }\n\n            this.bottom = this.top = null;\n            (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\n            c.appendChild(this.desc);\n            c.appendChild(this.defs = $(\"defs\"));\n          };\n          /*\\\n           * Paper.remove\n           [ method ]\n           **\n           * Removes the paper from the DOM.\n          \\*/\n\n\n          R.prototype.remove = function () {\n            eve(\"raphael.remove\", this);\n            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n          };\n\n          var setproto = R.st;\n\n          for (var method in elproto) {\n            if (elproto[has](method) && !setproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"./dev/raphael.vml.js\":\n      /*!****************************!*\\\n        !*** ./dev/raphael.vml.js ***!\n        \\****************************/\n\n      /*! no static exports found */\n\n      /***/\n      function devRaphaelVmlJs(module, exports, __nested_webpack_require_280492__) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_280492__(\n        /*! ./raphael.core */\n        \"./dev/raphael.core.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {\n          if (R && !R.vml) {\n            return;\n          }\n\n          var has = \"hasOwnProperty\",\n              Str = String,\n              toFloat = parseFloat,\n              math = Math,\n              round = math.round,\n              mmax = math.max,\n              mmin = math.min,\n              abs = math.abs,\n              fillString = \"fill\",\n              separator = /[, ]+/,\n              eve = R.eve,\n              ms = \" progid:DXImageTransform.Microsoft\",\n              S = \" \",\n              E = \"\",\n              map = {\n            M: \"m\",\n            L: \"l\",\n            C: \"c\",\n            Z: \"x\",\n            m: \"t\",\n            l: \"r\",\n            c: \"v\",\n            z: \"x\"\n          },\n              bites = /([clmz]),?([^clmz]*)/gi,\n              blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\n              val = /-?[^,\\s-]+/g,\n              cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\n              zoom = 21600,\n              pathTypes = {\n            path: 1,\n            rect: 1,\n            image: 1\n          },\n              ovalTypes = {\n            circle: 1,\n            ellipse: 1\n          },\n              path2vml = function path2vml(path) {\n            var total = /[ahqstv]/ig,\n                command = R._pathToAbsolute;\n            Str(path).match(total) && (command = R._path2curve);\n            total = /[clmz]/g;\n\n            if (command == R._pathToAbsolute && !Str(path).match(total)) {\n              var res = Str(path).replace(bites, function (all, command, args) {\n                var vals = [],\n                    isMove = command.toLowerCase() == \"m\",\n                    res = map[command];\n                args.replace(val, function (value) {\n                  if (isMove && vals.length == 2) {\n                    res += vals + map[command == \"m\" ? \"l\" : \"L\"];\n                    vals = [];\n                  }\n\n                  vals.push(round(value * zoom));\n                });\n                return res + vals;\n              });\n              return res;\n            }\n\n            var pa = command(path),\n                p,\n                r;\n            res = [];\n\n            for (var i = 0, ii = pa.length; i < ii; i++) {\n              p = pa[i];\n              r = pa[i][0].toLowerCase();\n              r == \"z\" && (r = \"x\");\n\n              for (var j = 1, jj = p.length; j < jj; j++) {\n                r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\n              }\n\n              res.push(r);\n            }\n\n            return res.join(S);\n          },\n              compensation = function compensation(deg, dx, dy) {\n            var m = R.matrix();\n            m.rotate(-deg, .5, .5);\n            return {\n              dx: m.x(dx, dy),\n              dy: m.y(dx, dy)\n            };\n          },\n              setCoords = function setCoords(p, sx, sy, dx, dy, deg) {\n            var _ = p._,\n                m = p.matrix,\n                fillpos = _.fillpos,\n                o = p.node,\n                s = o.style,\n                y = 1,\n                flip = \"\",\n                dxdy,\n                kx = zoom / sx,\n                ky = zoom / sy;\n            s.visibility = \"hidden\";\n\n            if (!sx || !sy) {\n              return;\n            }\n\n            o.coordsize = abs(kx) + S + abs(ky);\n            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\n\n            if (deg) {\n              var c = compensation(deg, dx, dy);\n              dx = c.dx;\n              dy = c.dy;\n            }\n\n            sx < 0 && (flip += \"x\");\n            sy < 0 && (flip += \" y\") && (y = -1);\n            s.flip = flip;\n            o.coordorigin = dx * -kx + S + dy * -ky;\n\n            if (fillpos || _.fillsize) {\n              var fill = o.getElementsByTagName(fillString);\n              fill = fill && fill[0];\n              o.removeChild(fill);\n\n              if (fillpos) {\n                c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\n                fill.position = c.dx * y + S + c.dy * y;\n              }\n\n              if (_.fillsize) {\n                fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\n              }\n\n              o.appendChild(fill);\n            }\n\n            s.visibility = \"visible\";\n          };\n\n          R.toString = function () {\n            return \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xEBl \" + this.version;\n          };\n\n          var addArrow = function addArrow(o, value, isEnd) {\n            var values = Str(value).toLowerCase().split(\"-\"),\n                se = isEnd ? \"end\" : \"start\",\n                i = values.length,\n                type = \"classic\",\n                w = \"medium\",\n                h = \"medium\";\n\n            while (i--) {\n              switch (values[i]) {\n                case \"block\":\n                case \"classic\":\n                case \"oval\":\n                case \"diamond\":\n                case \"open\":\n                case \"none\":\n                  type = values[i];\n                  break;\n\n                case \"wide\":\n                case \"narrow\":\n                  h = values[i];\n                  break;\n\n                case \"long\":\n                case \"short\":\n                  w = values[i];\n                  break;\n              }\n            }\n\n            var stroke = o.node.getElementsByTagName(\"stroke\")[0];\n            stroke[se + \"arrow\"] = type;\n            stroke[se + \"arrowlength\"] = w;\n            stroke[se + \"arrowwidth\"] = h;\n          },\n              setFillAndStroke = function setFillAndStroke(o, params) {\n            // o.paper.canvas.style.display = \"none\";\n            o.attrs = o.attrs || {};\n            var node = o.node,\n                a = o.attrs,\n                s = node.style,\n                xy,\n                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\n                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\n                res = o;\n\n            for (var par in params) {\n              if (params[has](par)) {\n                a[par] = params[par];\n              }\n            }\n\n            if (newpath) {\n              a.path = R._getPath[o.type](o);\n              o._.dirty = 1;\n            }\n\n            params.href && (node.href = params.href);\n            params.title && (node.title = params.title);\n            params.target && (node.target = params.target);\n            params.cursor && (s.cursor = params.cursor);\n            \"blur\" in params && o.blur(params.blur);\n\n            if (params.path && o.type == \"path\" || newpath) {\n              node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\n              o._.dirty = 1;\n\n              if (o.type == \"image\") {\n                o._.fillpos = [a.x, a.y];\n                o._.fillsize = [a.width, a.height];\n                setCoords(o, 1, 1, 0, 0, 0);\n              }\n            }\n\n            \"transform\" in params && o.transform(params.transform);\n\n            if (isOval) {\n              var cx = +a.cx,\n                  cy = +a.cy,\n                  rx = +a.rx || +a.r || 0,\n                  ry = +a.ry || +a.r || 0;\n              node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\n              o._.dirty = 1;\n            }\n\n            if (\"clip-rect\" in params) {\n              var rect = Str(params[\"clip-rect\"]).split(separator);\n\n              if (rect.length == 4) {\n                rect[2] = +rect[2] + +rect[0];\n                rect[3] = +rect[3] + +rect[1];\n\n                var div = node.clipRect || R._g.doc.createElement(\"div\"),\n                    dstyle = div.style;\n\n                dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\n\n                if (!node.clipRect) {\n                  dstyle.position = \"absolute\";\n                  dstyle.top = 0;\n                  dstyle.left = 0;\n                  dstyle.width = o.paper.width + \"px\";\n                  dstyle.height = o.paper.height + \"px\";\n                  node.parentNode.insertBefore(div, node);\n                  div.appendChild(node);\n                  node.clipRect = div;\n                }\n              }\n\n              if (!params[\"clip-rect\"]) {\n                node.clipRect && (node.clipRect.style.clip = \"auto\");\n              }\n            }\n\n            if (o.textpath) {\n              var textpathStyle = o.textpath.style;\n              params.font && (textpathStyle.font = params.font);\n              params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\n              params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\n              params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\n              params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\n            }\n\n            if (\"arrow-start\" in params) {\n              addArrow(res, params[\"arrow-start\"]);\n            }\n\n            if (\"arrow-end\" in params) {\n              addArrow(res, params[\"arrow-end\"], 1);\n            }\n\n            if (params.opacity != null || params.fill != null || params.src != null || params.stroke != null || params[\"stroke-width\"] != null || params[\"stroke-opacity\"] != null || params[\"fill-opacity\"] != null || params[\"stroke-dasharray\"] != null || params[\"stroke-miterlimit\"] != null || params[\"stroke-linejoin\"] != null || params[\"stroke-linecap\"] != null) {\n              var fill = node.getElementsByTagName(fillString),\n                  newfill = false;\n              fill = fill && fill[0];\n              !fill && (newfill = fill = createNode(fillString));\n\n              if (o.type == \"image\" && params.src) {\n                fill.src = params.src;\n              }\n\n              params.fill && (fill.on = true);\n\n              if (fill.on == null || params.fill == \"none\" || params.fill === null) {\n                fill.on = false;\n              }\n\n              if (fill.on && params.fill) {\n                var isURL = Str(params.fill).match(R._ISURL);\n\n                if (isURL) {\n                  fill.parentNode == node && node.removeChild(fill);\n                  fill.rotate = true;\n                  fill.src = isURL[1];\n                  fill.type = \"tile\";\n                  var bbox = o.getBBox(1);\n                  fill.position = bbox.x + S + bbox.y;\n                  o._.fillpos = [bbox.x, bbox.y];\n\n                  R._preload(isURL[1], function () {\n                    o._.fillsize = [this.offsetWidth, this.offsetHeight];\n                  });\n                } else {\n                  fill.color = R.getRGB(params.fill).hex;\n                  fill.src = E;\n                  fill.type = \"solid\";\n\n                  if (R.getRGB(params.fill).error && (res.type in {\n                    circle: 1,\n                    ellipse: 1\n                  } || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\n                    a.fill = \"none\";\n                    a.gradient = params.fill;\n                    fill.rotate = false;\n                  }\n                }\n              }\n\n              if (\"fill-opacity\" in params || \"opacity\" in params) {\n                var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\n                opacity = mmin(mmax(opacity, 0), 1);\n                fill.opacity = opacity;\n\n                if (fill.src) {\n                  fill.color = \"none\";\n                }\n              }\n\n              node.appendChild(fill);\n              var stroke = node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0],\n                  newstroke = false;\n              !stroke && (newstroke = stroke = createNode(\"stroke\"));\n\n              if (params.stroke && params.stroke != \"none\" || params[\"stroke-width\"] || params[\"stroke-opacity\"] != null || params[\"stroke-dasharray\"] || params[\"stroke-miterlimit\"] || params[\"stroke-linejoin\"] || params[\"stroke-linecap\"]) {\n                stroke.on = true;\n              }\n\n              (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\n              var strokeColor = R.getRGB(params.stroke);\n              stroke.on && params.stroke && (stroke.color = strokeColor.hex);\n              opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\n              var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\n              opacity = mmin(mmax(opacity, 0), 1);\n              params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\n              params[\"stroke-width\"] && (stroke.weight = width);\n              width && width < 1 && (opacity *= width) && (stroke.weight = 1);\n              stroke.opacity = opacity;\n              params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\n              stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\n              params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\n\n              if (\"stroke-dasharray\" in params) {\n                var dasharray = {\n                  \"-\": \"shortdash\",\n                  \".\": \"shortdot\",\n                  \"-.\": \"shortdashdot\",\n                  \"-..\": \"shortdashdotdot\",\n                  \". \": \"dot\",\n                  \"- \": \"dash\",\n                  \"--\": \"longdash\",\n                  \"- .\": \"dashdot\",\n                  \"--.\": \"longdashdot\",\n                  \"--..\": \"longdashdotdot\"\n                };\n                stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\n              }\n\n              newstroke && node.appendChild(stroke);\n            }\n\n            if (res.type == \"text\") {\n              res.paper.canvas.style.display = E;\n              var span = res.paper.span,\n                  m = 100,\n                  fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\n              s = span.style;\n              a.font && (s.font = a.font);\n              a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\n              a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\n              a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\n              fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\n              s.fontSize = fontSize * m + \"px\";\n              res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\n              var brect = span.getBoundingClientRect();\n              res.W = a.w = (brect.right - brect.left) / m;\n              res.H = a.h = (brect.bottom - brect.top) / m; // res.paper.canvas.style.display = \"none\";\n\n              res.X = a.x;\n              res.Y = a.y + res.H / 2;\n              (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\n              var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\n\n              for (var d = 0, dd = dirtyattrs.length; d < dd; d++) {\n                if (dirtyattrs[d] in params) {\n                  res._.dirty = 1;\n                  break;\n                }\n              } // text-anchor emulation\n\n\n              switch (a[\"text-anchor\"]) {\n                case \"start\":\n                  res.textpath.style[\"v-text-align\"] = \"left\";\n                  res.bbx = res.W / 2;\n                  break;\n\n                case \"end\":\n                  res.textpath.style[\"v-text-align\"] = \"right\";\n                  res.bbx = -res.W / 2;\n                  break;\n\n                default:\n                  res.textpath.style[\"v-text-align\"] = \"center\";\n                  res.bbx = 0;\n                  break;\n              }\n\n              res.textpath.style[\"v-text-kern\"] = true;\n            } // res.paper.canvas.style.display = E;\n\n          },\n              addGradientFill = function addGradientFill(o, gradient, fill) {\n            o.attrs = o.attrs || {};\n            var attrs = o.attrs,\n                pow = Math.pow,\n                opacity,\n                oindex,\n                type = \"linear\",\n                fxfy = \".5 .5\";\n            o.attrs.gradient = gradient;\n            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\n              type = \"radial\";\n\n              if (fx && fy) {\n                fx = toFloat(fx);\n                fy = toFloat(fy);\n                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\n                fxfy = fx + S + fy;\n              }\n\n              return E;\n            });\n            gradient = gradient.split(/\\s*\\-\\s*/);\n\n            if (type == \"linear\") {\n              var angle = gradient.shift();\n              angle = -toFloat(angle);\n\n              if (isNaN(angle)) {\n                return null;\n              }\n            }\n\n            var dots = R._parseDots(gradient);\n\n            if (!dots) {\n              return null;\n            }\n\n            o = o.shape || o.node;\n\n            if (dots.length) {\n              o.removeChild(fill);\n              fill.on = true;\n              fill.method = \"none\";\n              fill.color = dots[0].color;\n              fill.color2 = dots[dots.length - 1].color;\n              var clrs = [];\n\n              for (var i = 0, ii = dots.length; i < ii; i++) {\n                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\n              }\n\n              fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\n\n              if (type == \"radial\") {\n                fill.type = \"gradientTitle\";\n                fill.focus = \"100%\";\n                fill.focussize = \"0 0\";\n                fill.focusposition = fxfy;\n                fill.angle = 0;\n              } else {\n                // fill.rotate= true;\n                fill.type = \"gradient\";\n                fill.angle = (270 - angle) % 360;\n              }\n\n              o.appendChild(fill);\n            }\n\n            return 1;\n          },\n              Element = function Element(node, vml) {\n            this[0] = this.node = node;\n            node.raphael = true;\n            this.id = R._oid++;\n            node.raphaelid = this.id;\n            this.X = 0;\n            this.Y = 0;\n            this.attrs = {};\n            this.paper = vml;\n            this.matrix = R.matrix();\n            this._ = {\n              transform: [],\n              sx: 1,\n              sy: 1,\n              dx: 0,\n              dy: 0,\n              deg: 0,\n              dirty: 1,\n              dirtyT: 1\n            };\n            !vml.bottom && (vml.bottom = this);\n            this.prev = vml.top;\n            vml.top && (vml.top.next = this);\n            vml.top = this;\n            this.next = null;\n          };\n\n          var elproto = R.el;\n          Element.prototype = elproto;\n          elproto.constructor = Element;\n\n          elproto.transform = function (tstr) {\n            if (tstr == null) {\n              return this._.transform;\n            }\n\n            var vbs = this.paper._viewBoxShift,\n                vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\n                oldt;\n\n            if (vbs) {\n              oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\n            }\n\n            R._extractTransform(this, vbt + tstr);\n\n            var matrix = this.matrix.clone(),\n                skew = this.skew,\n                o = this.node,\n                split,\n                isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\n                isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\n            matrix.translate(1, 1);\n\n            if (isPatt || isGrad || this.type == \"image\") {\n              skew.matrix = \"1 0 0 1\";\n              skew.offset = \"0 0\";\n              split = matrix.split();\n\n              if (isGrad && split.noRotation || !split.isSimple) {\n                o.style.filter = matrix.toFilter();\n                var bb = this.getBBox(),\n                    bbt = this.getBBox(1),\n                    dx = bb.x - bbt.x,\n                    dy = bb.y - bbt.y;\n                o.coordorigin = dx * -zoom + S + dy * -zoom;\n                setCoords(this, 1, 1, dx, dy, 0);\n              } else {\n                o.style.filter = E;\n                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\n              }\n            } else {\n              o.style.filter = E;\n              skew.matrix = Str(matrix);\n              skew.offset = matrix.offset();\n            }\n\n            if (oldt !== null) {\n              // empty string value is true as well\n              this._.transform = oldt;\n\n              R._extractTransform(this, oldt);\n            }\n\n            return this;\n          };\n\n          elproto.rotate = function (deg, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (deg == null) {\n              return;\n            }\n\n            deg = Str(deg).split(separator);\n\n            if (deg.length - 1) {\n              cx = toFloat(deg[1]);\n              cy = toFloat(deg[2]);\n            }\n\n            deg = toFloat(deg[0]);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n              cx = bbox.x + bbox.width / 2;\n              cy = bbox.y + bbox.height / 2;\n            }\n\n            this._.dirtyT = 1;\n            this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n            return this;\n          };\n\n          elproto.translate = function (dx, dy) {\n            if (this.removed) {\n              return this;\n            }\n\n            dx = Str(dx).split(separator);\n\n            if (dx.length - 1) {\n              dy = toFloat(dx[1]);\n            }\n\n            dx = toFloat(dx[0]) || 0;\n            dy = +dy || 0;\n\n            if (this._.bbox) {\n              this._.bbox.x += dx;\n              this._.bbox.y += dy;\n            }\n\n            this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n            return this;\n          };\n\n          elproto.scale = function (sx, sy, cx, cy) {\n            if (this.removed) {\n              return this;\n            }\n\n            sx = Str(sx).split(separator);\n\n            if (sx.length - 1) {\n              sy = toFloat(sx[1]);\n              cx = toFloat(sx[2]);\n              cy = toFloat(sx[3]);\n              isNaN(cx) && (cx = null);\n              isNaN(cy) && (cy = null);\n            }\n\n            sx = toFloat(sx[0]);\n            sy == null && (sy = sx);\n            cy == null && (cx = cy);\n\n            if (cx == null || cy == null) {\n              var bbox = this.getBBox(1);\n            }\n\n            cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n            cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n            this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n            this._.dirtyT = 1;\n            return this;\n          };\n\n          elproto.hide = function () {\n            !this.removed && (this.node.style.display = \"none\");\n            return this;\n          };\n\n          elproto.show = function () {\n            !this.removed && (this.node.style.display = E);\n            return this;\n          }; // Needed to fix the vml setViewBox issues\n\n\n          elproto.auxGetBBox = R.el.getBBox;\n\n          elproto.getBBox = function () {\n            var b = this.auxGetBBox();\n\n            if (this.paper && this.paper._viewBoxShift) {\n              var c = {};\n              var z = 1 / this.paper._viewBoxShift.scale;\n              c.x = b.x - this.paper._viewBoxShift.dx;\n              c.x *= z;\n              c.y = b.y - this.paper._viewBoxShift.dy;\n              c.y *= z;\n              c.width = b.width * z;\n              c.height = b.height * z;\n              c.x2 = c.x + c.width;\n              c.y2 = c.y + c.height;\n              return c;\n            }\n\n            return b;\n          };\n\n          elproto._getBBox = function () {\n            if (this.removed) {\n              return {};\n            }\n\n            return {\n              x: this.X + (this.bbx || 0) - this.W / 2,\n              y: this.Y - this.H,\n              width: this.W,\n              height: this.H\n            };\n          };\n\n          elproto.remove = function () {\n            if (this.removed || !this.node.parentNode) {\n              return;\n            }\n\n            this.paper.__set__ && this.paper.__set__.exclude(this);\n            R.eve.unbind(\"raphael.*.*.\" + this.id);\n\n            R._tear(this, this.paper);\n\n            this.node.parentNode.removeChild(this.node);\n            this.shape && this.shape.parentNode.removeChild(this.shape);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            this.removed = true;\n          };\n\n          elproto.attr = function (name, value) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (name == null) {\n              var res = {};\n\n              for (var a in this.attrs) {\n                if (this.attrs[has](a)) {\n                  res[a] = this.attrs[a];\n                }\n              }\n\n              res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n              res.transform = this._.transform;\n              return res;\n            }\n\n            if (value == null && R.is(name, \"string\")) {\n              if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n              }\n\n              var names = name.split(separator),\n                  out = {};\n\n              for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n\n                if (name in this.attrs) {\n                  out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                  out[name] = this.paper.customAttributes[name].def;\n                } else {\n                  out[name] = R._availableAttrs[name];\n                }\n              }\n\n              return ii - 1 ? out : out[names[0]];\n            }\n\n            if (this.attrs && value == null && R.is(name, \"array\")) {\n              out = {};\n\n              for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n              }\n\n              return out;\n            }\n\n            var params;\n\n            if (value != null) {\n              params = {};\n              params[name] = value;\n            }\n\n            value == null && R.is(name, \"object\") && (params = name);\n\n            for (var key in params) {\n              eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n            }\n\n            if (params) {\n              for (key in this.paper.customAttributes) {\n                if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n                  var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n                  this.attrs[key] = params[key];\n\n                  for (var subkey in par) {\n                    if (par[has](subkey)) {\n                      params[subkey] = par[subkey];\n                    }\n                  }\n                }\n              } // this.paper.canvas.style.display = \"none\";\n\n\n              if (params.text && this.type == \"text\") {\n                this.textpath.string = params.text;\n              }\n\n              setFillAndStroke(this, params); // this.paper.canvas.style.display = E;\n            }\n\n            return this;\n          };\n\n          elproto.toFront = function () {\n            !this.removed && this.node.parentNode.appendChild(this.node);\n            this.paper && this.paper.top != this && R._tofront(this, this.paper);\n            return this;\n          };\n\n          elproto.toBack = function () {\n            if (this.removed) {\n              return this;\n            }\n\n            if (this.node.parentNode.firstChild != this.node) {\n              this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\n\n              R._toback(this, this.paper);\n            }\n\n            return this;\n          };\n\n          elproto.insertAfter = function (element) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (element.constructor == R.st.constructor) {\n              element = element[element.length - 1];\n            }\n\n            if (element.node.nextSibling) {\n              element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\n            } else {\n              element.node.parentNode.appendChild(this.node);\n            }\n\n            R._insertafter(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.insertBefore = function (element) {\n            if (this.removed) {\n              return this;\n            }\n\n            if (element.constructor == R.st.constructor) {\n              element = element[0];\n            }\n\n            element.node.parentNode.insertBefore(this.node, element.node);\n\n            R._insertbefore(this, element, this.paper);\n\n            return this;\n          };\n\n          elproto.blur = function (size) {\n            var s = this.node.runtimeStyle,\n                f = s.filter;\n            f = f.replace(blurregexp, E);\n\n            if (+size !== 0) {\n              this.attrs.blur = size;\n              s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\n              s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\n            } else {\n              s.filter = f;\n              s.margin = 0;\n              delete this.attrs.blur;\n            }\n\n            return this;\n          };\n\n          R._engine.path = function (pathString, vml) {\n            var el = createNode(\"shape\");\n            el.style.cssText = cssDot;\n            el.coordsize = zoom + S + zoom;\n            el.coordorigin = vml.coordorigin;\n            var p = new Element(el, vml),\n                attr = {\n              fill: \"none\",\n              stroke: \"#000\"\n            };\n            pathString && (attr.path = pathString);\n            p.type = \"path\";\n            p.path = [];\n            p.Path = E;\n            setFillAndStroke(p, attr);\n            vml.canvas && vml.canvas.appendChild(el);\n            var skew = createNode(\"skew\");\n            skew.on = true;\n            el.appendChild(skew);\n            p.skew = skew;\n            p.transform(E);\n            return p;\n          };\n\n          R._engine.rect = function (vml, x, y, w, h, r) {\n            var path = R._rectPath(x, y, w, h, r),\n                res = vml.path(path),\n                a = res.attrs;\n\n            res.X = a.x = x;\n            res.Y = a.y = y;\n            res.W = a.width = w;\n            res.H = a.height = h;\n            a.r = r;\n            a.path = path;\n            res.type = \"rect\";\n            return res;\n          };\n\n          R._engine.ellipse = function (vml, x, y, rx, ry) {\n            var res = vml.path(),\n                a = res.attrs;\n            res.X = x - rx;\n            res.Y = y - ry;\n            res.W = rx * 2;\n            res.H = ry * 2;\n            res.type = \"ellipse\";\n            setFillAndStroke(res, {\n              cx: x,\n              cy: y,\n              rx: rx,\n              ry: ry\n            });\n            return res;\n          };\n\n          R._engine.circle = function (vml, x, y, r) {\n            var res = vml.path(),\n                a = res.attrs;\n            res.X = x - r;\n            res.Y = y - r;\n            res.W = res.H = r * 2;\n            res.type = \"circle\";\n            setFillAndStroke(res, {\n              cx: x,\n              cy: y,\n              r: r\n            });\n            return res;\n          };\n\n          R._engine.image = function (vml, src, x, y, w, h) {\n            var path = R._rectPath(x, y, w, h),\n                res = vml.path(path).attr({\n              stroke: \"none\"\n            }),\n                a = res.attrs,\n                node = res.node,\n                fill = node.getElementsByTagName(fillString)[0];\n\n            a.src = src;\n            res.X = a.x = x;\n            res.Y = a.y = y;\n            res.W = a.width = w;\n            res.H = a.height = h;\n            a.path = path;\n            res.type = \"image\";\n            fill.parentNode == node && node.removeChild(fill);\n            fill.rotate = true;\n            fill.src = src;\n            fill.type = \"tile\";\n            res._.fillpos = [x, y];\n            res._.fillsize = [w, h];\n            node.appendChild(fill);\n            setCoords(res, 1, 1, 0, 0, 0);\n            return res;\n          };\n\n          R._engine.text = function (vml, x, y, text) {\n            var el = createNode(\"shape\"),\n                path = createNode(\"path\"),\n                o = createNode(\"textpath\");\n            x = x || 0;\n            y = y || 0;\n            text = text || \"\";\n            path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\n            path.textpathok = true;\n            o.string = Str(text);\n            o.on = true;\n            el.style.cssText = cssDot;\n            el.coordsize = zoom + S + zoom;\n            el.coordorigin = \"0 0\";\n            var p = new Element(el, vml),\n                attr = {\n              fill: \"#000\",\n              stroke: \"none\",\n              font: R._availableAttrs.font,\n              text: text\n            };\n            p.shape = el;\n            p.path = path;\n            p.textpath = o;\n            p.type = \"text\";\n            p.attrs.text = Str(text);\n            p.attrs.x = x;\n            p.attrs.y = y;\n            p.attrs.w = 1;\n            p.attrs.h = 1;\n            setFillAndStroke(p, attr);\n            el.appendChild(o);\n            el.appendChild(path);\n            vml.canvas.appendChild(el);\n            var skew = createNode(\"skew\");\n            skew.on = true;\n            el.appendChild(skew);\n            p.skew = skew;\n            p.transform(E);\n            return p;\n          };\n\n          R._engine.setSize = function (width, height) {\n            var cs = this.canvas.style;\n            this.width = width;\n            this.height = height;\n            width == +width && (width += \"px\");\n            height == +height && (height += \"px\");\n            cs.width = width;\n            cs.height = height;\n            cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\n\n            if (this._viewBox) {\n              R._engine.setViewBox.apply(this, this._viewBox);\n            }\n\n            return this;\n          };\n\n          R._engine.setViewBox = function (x, y, w, h, fit) {\n            R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n            var paperSize = this.getSize(),\n                width = paperSize.width,\n                height = paperSize.height,\n                H,\n                W;\n\n            if (fit) {\n              H = height / h;\n              W = width / w;\n\n              if (w * H < width) {\n                x -= (width - w * H) / 2 / H;\n              }\n\n              if (h * W < height) {\n                y -= (height - h * W) / 2 / W;\n              }\n            }\n\n            this._viewBox = [x, y, w, h, !!fit];\n            this._viewBoxShift = {\n              dx: -x,\n              dy: -y,\n              scale: paperSize\n            };\n            this.forEach(function (el) {\n              el.transform(\"...\");\n            });\n            return this;\n          };\n\n          var createNode;\n\n          R._engine.initWin = function (win) {\n            var doc = win.document;\n\n            if (doc.styleSheets.length < 31) {\n              doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\n            } else {\n              // no more room, add to the existing one\n              // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n              doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\n            }\n\n            try {\n              !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\n\n              createNode = function createNode(tagName) {\n                return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\n              };\n            } catch (e) {\n              createNode = function createNode(tagName) {\n                return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\n              };\n            }\n          };\n\n          R._engine.initWin(R._g.win);\n\n          R._engine.create = function () {\n            var con = R._getContainer.apply(0, arguments),\n                container = con.container,\n                height = con.height,\n                s,\n                width = con.width,\n                x = con.x,\n                y = con.y;\n\n            if (!container) {\n              throw new Error(\"VML container not found.\");\n            }\n\n            var res = new R._Paper(),\n                c = res.canvas = R._g.doc.createElement(\"div\"),\n                cs = c.style;\n\n            x = x || 0;\n            y = y || 0;\n            width = width || 512;\n            height = height || 342;\n            res.width = width;\n            res.height = height;\n            width == +width && (width += \"px\");\n            height == +height && (height += \"px\");\n            res.coordsize = zoom * 1e3 + S + zoom * 1e3;\n            res.coordorigin = \"0 0\";\n            res.span = R._g.doc.createElement(\"span\");\n            res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\n            c.appendChild(res.span);\n            cs.cssText = R.format(\"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden\", width, height);\n\n            if (container == 1) {\n              R._g.doc.body.appendChild(c);\n\n              cs.left = x + \"px\";\n              cs.top = y + \"px\";\n              cs.position = \"absolute\";\n            } else {\n              if (container.firstChild) {\n                container.insertBefore(c, container.firstChild);\n              } else {\n                container.appendChild(c);\n              }\n            }\n\n            res.renderfix = function () {};\n\n            return res;\n          };\n\n          R.prototype.clear = function () {\n            R.eve(\"raphael.clear\", this);\n            this.canvas.innerHTML = E;\n            this.span = R._g.doc.createElement(\"span\");\n            this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\n            this.canvas.appendChild(this.span);\n            this.bottom = this.top = null;\n          };\n\n          R.prototype.remove = function () {\n            R.eve(\"raphael.remove\", this);\n            this.canvas.parentNode.removeChild(this.canvas);\n\n            for (var i in this) {\n              this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n            }\n\n            return true;\n          };\n\n          var setproto = R.st;\n\n          for (var method in elproto) {\n            if (elproto[has](method) && !setproto[has](method)) {\n              setproto[method] = function (methodname) {\n                return function () {\n                  var arg = arguments;\n                  return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                  });\n                };\n              }(method);\n            }\n          }\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        /***/\n      },\n\n      /***/\n      \"eve\":\n      /*!**********************!*\\\n        !*** external \"eve\" ***!\n        \\**********************/\n\n      /*! no static exports found */\n\n      /***/\n      function eve(module, exports) {\n        module.exports = __WEBPACK_EXTERNAL_MODULE_eve__;\n        /***/\n      }\n      /******/\n\n    })\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL3JhcGhhZWwvcmFwaGFlbC5uby1kZXBzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFNBQVNBLGdDQUFULENBQTBDQyxJQUExQyxFQUFnREMsT0FBaEQsRUFBeUQ7RUFDekQsSUFBRyxzQkFBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQixzQkFBT0MsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxNQUFNLENBQUNELE9BQVAsR0FBaUJELE9BQU8sQ0FBQ0csbUJBQU8sQ0FBQyxrSUFBRCxDQUFSLENBQXhCLENBREQsS0FFSyxJQUFHLElBQUgsRUFDSkMsaUNBQU8sQ0FBQyxrSUFBRCxDQUFELG9DQUFVSixPQUFWO0FBQUE7QUFBQTtBQUFBLGtHQUFOLENBREksS0FFQSxFQUdKO0FBQ0QsQ0FURCxFQVNHTSxNQVRILEVBU1csVUFBU0MsK0JBQVQsRUFBMEM7RUFDckQ7SUFBTztJQUFVLFVBQVNDLE9BQVQsRUFBa0I7TUFBRTs7TUFDckM7TUFBVTs7TUFDVjtNQUFVLElBQUlDLGdCQUFnQixHQUFHLEVBQXZCO01BQ1Y7O01BQ0E7TUFBVTs7TUFDVjs7TUFBVSxTQUFTQywrQkFBVCxDQUE2QkMsUUFBN0IsRUFBdUM7UUFDakQ7O1FBQ0E7UUFBVzs7UUFDWDtRQUFXLElBQUdGLGdCQUFnQixDQUFDRSxRQUFELENBQW5CLEVBQStCO1VBQzFDO1VBQVksT0FBT0YsZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsQ0FBMkJWLE9BQWxDO1VBQ1o7UUFBWTtRQUNaO1FBQVc7O1FBQ1g7OztRQUFXLElBQUlDLE1BQU0sR0FBR08sZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsR0FBNkI7VUFDckQ7VUFBWUMsQ0FBQyxFQUFFRCxRQURzQzs7VUFFckQ7VUFBWUUsQ0FBQyxFQUFFLEtBRnNDOztVQUdyRDtVQUFZWixPQUFPLEVBQUU7VUFDckI7O1FBSnFE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a0IsQ0FBQyxDQUFDeUksRUFBRixHQUFPLEVBbEpqQjtVQW1KQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1VBRUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztVQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7VUFFSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBdXpQQyxDQWowUEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3ZlbmRvci9saWJzL3JhcGhhZWwvcmFwaGFlbC5uby1kZXBzLmpzP2UwY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIFxcXFxcbi8vIOKUgiBSYXBoYcOrbCAyLjMuMCAtIEphdmFTY3JpcHQgVmVjdG9yIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQ29weXJpZ2h0IMKpIDIwMDgtMjAxNiBEbWl0cnkgQmFyYW5vdnNraXkgKGh0dHA6Ly9yYXBoYWVsanMuY29tKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBcXFxcXG4vLyDilIIgQ29weXJpZ2h0IMKpIDIwMDgtMjAxNiBTZW5jaGEgTGFicyAoaHR0cDovL3NlbmNoYS5jb20pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBcXFxcXG4vLyDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKQgXFxcXFxuLy8g4pSCIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9EbWl0cnlCYXJhbm92c2tpeS9yYXBoYWVsL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0KSBsaWNlbnNlLuKUgiBcXFxcXG4vLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggXFxcXFxuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJldmVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiZXZlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJhcGhhZWxcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJldmVcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJhcGhhZWxcIl0gPSBmYWN0b3J5KHJvb3RbXCJldmVcIl0pO1xufSkod2luZG93LCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2V2ZV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZGV2L3JhcGhhZWwuYW1kLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vZGV2L3JhcGhhZWwuYW1kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vZGV2L3JhcGhhZWwuYW1kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYXBoYWVsLmNvcmUgKi8gXCIuL2Rldi9yYXBoYWVsLmNvcmUuanNcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmFwaGFlbC5zdmcgKi8gXCIuL2Rldi9yYXBoYWVsLnN2Zy5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYXBoYWVsLnZtbCAqLyBcIi4vZGV2L3JhcGhhZWwudm1sLmpzXCIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oUikge1xuXG4gICAgcmV0dXJuIFI7XG5cbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vZGV2L3JhcGhhZWwuY29yZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9kZXYvcmFwaGFlbC5jb3JlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZSAqLyBcImV2ZVwiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGV2ZSkge1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgb2JqZWN0IG9uIHdoaWNoIHRvIGRyYXcuXG4gICAgICogWW91IG11c3QgZG8gdGhpcyBmaXJzdCwgYXMgYWxsIGZ1dHVyZSBjYWxscyB0byBkcmF3aW5nIG1ldGhvZHNcbiAgICAgKiBmcm9tIHRoaXMgaW5zdGFuY2Ugd2lsbCBiZSBib3VuZCB0byB0aGlzIGNhbnZhcy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gY29udGFpbmVyIChIVE1MRWxlbWVudHxzdHJpbmcpIERPTSBlbGVtZW50IG9yIGl0cyBJRCB3aGljaCBpcyBnb2luZyB0byBiZSBhIHBhcmVudCBmb3IgZHJhd2luZyBzdXJmYWNlXG4gICAgIC0gd2lkdGggKG51bWJlcilcbiAgICAgLSBoZWlnaHQgKG51bWJlcilcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pICNvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnb2luZyB0byBiZSBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiBuZXdseSBjcmVhdGVkIHBhcGVyXG4gICAgICogb3JcbiAgICAgLSB4IChudW1iZXIpXG4gICAgIC0geSAobnVtYmVyKVxuICAgICAtIHdpZHRoIChudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ29pbmcgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgbmV3bHkgY3JlYXRlZCBwYXBlclxuICAgICAqIG9yXG4gICAgIC0gYWxsIChhcnJheSkgKGZpcnN0IDMgb3IgNCBlbGVtZW50cyBpbiB0aGUgYXJyYXkgYXJlIGVxdWFsIHRvIFtjb250YWluZXJJRCwgd2lkdGgsIGhlaWdodF0gb3IgW3gsIHksIHdpZHRoLCBoZWlnaHRdLiBUaGUgcmVzdCBhcmUgZWxlbWVudCBkZXNjcmlwdGlvbnMgaW4gZm9ybWF0IHt0eXBlOiB0eXBlLCA8YXR0cmlidXRlcz59KS4gU2VlIEBQYXBlci5hZGQuXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ29pbmcgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgbmV3bHkgY3JlYXRlZCBwYXBlclxuICAgICAqIG9yXG4gICAgIC0gb25SZWFkeUNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdGhhdCBpcyBnb2luZyB0byBiZSBjYWxsZWQgb24gRE9NIHJlYWR5IGV2ZW50LiBZb3UgY2FuIGFsc28gc3Vic2NyaWJlIHRvIHRoaXMgZXZlbnQgdmlhIEV2ZeKAmXMg4oCcRE9NTG9hZOKAnSBldmVudC4gSW4gdGhpcyBjYXNlIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICA9IChvYmplY3QpIEBQYXBlclxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gRWFjaCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIGNyZWF0ZSBhIGNhbnZhc1xuICAgICB8IC8vIHRoYXQgaXMgMzIwcHggd2lkZSBieSAyMDBweCBoaWdoLlxuICAgICB8IC8vIENhbnZhcyBpcyBjcmVhdGVkIGF0IHRoZSB2aWV3cG9ydOKAmXMgMTAsNTAgY29vcmRpbmF0ZS5cbiAgICAgfCB2YXIgcGFwZXIgPSBSYXBoYWVsKDEwLCA1MCwgMzIwLCAyMDApO1xuICAgICB8IC8vIENhbnZhcyBpcyBjcmVhdGVkIGF0IHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlICNub3RlcGFkIGVsZW1lbnRcbiAgICAgfCAvLyAob3IgaXRzIHRvcCByaWdodCBjb3JuZXIgaW4gZGlyPVwicnRsXCIgZWxlbWVudHMpXG4gICAgIHwgdmFyIHBhcGVyID0gUmFwaGFlbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vdGVwYWRcIiksIDMyMCwgMjAwKTtcbiAgICAgfCAvLyBTYW1lIGFzIGFib3ZlXG4gICAgIHwgdmFyIHBhcGVyID0gUmFwaGFlbChcIm5vdGVwYWRcIiwgMzIwLCAyMDApO1xuICAgICB8IC8vIEltYWdlIGR1bXBcbiAgICAgfCB2YXIgc2V0ID0gUmFwaGFlbChbXCJub3RlcGFkXCIsIDMyMCwgMjAwLCB7XG4gICAgIHwgICAgIHR5cGU6IFwicmVjdFwiLFxuICAgICB8ICAgICB4OiAxMCxcbiAgICAgfCAgICAgeTogMTAsXG4gICAgIHwgICAgIHdpZHRoOiAyNSxcbiAgICAgfCAgICAgaGVpZ2h0OiAyNSxcbiAgICAgfCAgICAgc3Ryb2tlOiBcIiNmMDBcIlxuICAgICB8IH0sIHtcbiAgICAgfCAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgIHwgICAgIHg6IDMwLFxuICAgICB8ICAgICB5OiA0MCxcbiAgICAgfCAgICAgdGV4dDogXCJEdW1wXCJcbiAgICAgfCB9XSk7XG4gICAgXFwqL1xuICAgIGZ1bmN0aW9uIFIoZmlyc3QpIHtcbiAgICAgICAgaWYgKFIuaXMoZmlyc3QsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZWQgPyBmaXJzdCgpIDogZXZlLm9uKFwicmFwaGFlbC5ET01sb2FkXCIsIGZpcnN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChSLmlzKGZpcnN0LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBSLl9lbmdpbmUuY3JlYXRlW2FwcGx5XShSLCBmaXJzdC5zcGxpY2UoMCwgMyArIFIuaXMoZmlyc3RbMF0sIG51KSkpLmFkZChmaXJzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICBpZiAoUi5pcyhhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZCA/IGYuY2FsbChSLl9lbmdpbmUuY3JlYXRlW2FwcGx5XShSLCBhcmdzKSkgOiBldmUub24oXCJyYXBoYWVsLkRPTWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmLmNhbGwoUi5fZW5naW5lLmNyZWF0ZVthcHBseV0oUiwgYXJncykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUi5fZW5naW5lLmNyZWF0ZVthcHBseV0oUiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSLnZlcnNpb24gPSBcIjIuMy4wXCI7XG4gICAgUi5ldmUgPSBldmU7XG4gICAgdmFyIGxvYWRlZCxcbiAgICAgICAgc2VwYXJhdG9yID0gL1ssIF0rLyxcbiAgICAgICAgZWxlbWVudHMgPSB7Y2lyY2xlOiAxLCByZWN0OiAxLCBwYXRoOiAxLCBlbGxpcHNlOiAxLCB0ZXh0OiAxLCBpbWFnZTogMX0sXG4gICAgICAgIGZvcm1hdHJnID0gL1xceyhcXGQrKVxcfS9nLFxuICAgICAgICBwcm90byA9IFwicHJvdG90eXBlXCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgZyA9IHtcbiAgICAgICAgICAgIGRvYzogZG9jdW1lbnQsXG4gICAgICAgICAgICB3aW46IHdpbmRvd1xuICAgICAgICB9LFxuICAgICAgICBvbGRSYXBoYWVsID0ge1xuICAgICAgICAgICAgd2FzOiBPYmplY3QucHJvdG90eXBlW2hhc10uY2FsbChnLndpbiwgXCJSYXBoYWVsXCIpLFxuICAgICAgICAgICAgaXM6IGcud2luLlJhcGhhZWxcbiAgICAgICAgfSxcbiAgICAgICAgUGFwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKlxcXG4gICAgICAgICAgICAgKiBQYXBlci5jYVxuICAgICAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgICAgICoqXG4gICAgICAgICAgICAgKiBTaG9ydGN1dCBmb3IgQFBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNcbiAgICAgICAgICAgIFxcKi9cbiAgICAgICAgICAgIC8qXFxcbiAgICAgICAgICAgICAqIFBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNcbiAgICAgICAgICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgICAgICAgICAqKlxuICAgICAgICAgICAgICogSWYgeW91IGhhdmUgYSBzZXQgb2YgYXR0cmlidXRlcyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlcHJlc2VudFxuICAgICAgICAgICAgICogYXMgYSBmdW5jdGlvbiBvZiBzb21lIG51bWJlciB5b3UgY2FuIGRvIGl0IGVhc2lseSB3aXRoIGN1c3RvbSBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgID4gVXNhZ2VcbiAgICAgICAgICAgICB8IHBhcGVyLmN1c3RvbUF0dHJpYnV0ZXMuaHVlID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgIHwgICAgIG51bSA9IG51bSAlIDE7XG4gICAgICAgICAgICAgfCAgICAgcmV0dXJuIHtmaWxsOiBcImhzYihcIiArIG51bSArIFwiLCAwLjc1LCAxKVwifTtcbiAgICAgICAgICAgICB8IH07XG4gICAgICAgICAgICAgfCAvLyBDdXN0b20gYXR0cmlidXRlIOKAnGh1ZeKAnSB3aWxsIGNoYW5nZSBmaWxsXG4gICAgICAgICAgICAgfCAvLyB0byBiZSBnaXZlbiBodWUgd2l0aCBmaXhlZCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzLlxuICAgICAgICAgICAgIHwgLy8gTm93IHlvdSBjYW4gdXNlIGl0IGxpa2UgdGhpczpcbiAgICAgICAgICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe2h1ZTogLjQ1fSk7XG4gICAgICAgICAgICAgfCAvLyBvciBldmVuIGxpa2UgdGhpczpcbiAgICAgICAgICAgICB8IGMuYW5pbWF0ZSh7aHVlOiAxfSwgMWUzKTtcbiAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgfCAvLyBZb3UgY291bGQgYWxzbyBjcmVhdGUgY3VzdG9tIGF0dHJpYnV0ZVxuICAgICAgICAgICAgIHwgLy8gd2l0aCBtdWx0aXBsZSBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgIHwgcGFwZXIuY3VzdG9tQXR0cmlidXRlcy5oc2IgPSBmdW5jdGlvbiAoaCwgcywgYikge1xuICAgICAgICAgICAgIHwgICAgIHJldHVybiB7ZmlsbDogXCJoc2IoXCIgKyBbaCwgcywgYl0uam9pbihcIixcIikgKyBcIilcIn07XG4gICAgICAgICAgICAgfCB9O1xuICAgICAgICAgICAgIHwgYy5hdHRyKHtoc2I6IFwiMC41IC44IDFcIn0pO1xuICAgICAgICAgICAgIHwgYy5hbmltYXRlKHtoc2I6IFsxLCAwLCAwLjVdfSwgMWUzKTtcbiAgICAgICAgICAgIFxcKi9cbiAgICAgICAgICAgIHRoaXMuY2EgPSB0aGlzLmN1c3RvbUF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFwZXJwcm90byxcbiAgICAgICAgYXBwZW5kQ2hpbGQgPSBcImFwcGVuZENoaWxkXCIsXG4gICAgICAgIGFwcGx5ID0gXCJhcHBseVwiLFxuICAgICAgICBjb25jYXQgPSBcImNvbmNhdFwiLFxuICAgICAgICAvL3Rha2VuIGZyb20gTW9kZXJuaXpyIHRvdWNoIHRlc3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy90b3VjaGV2ZW50cy5qcyNMNDBcbiAgICAgICAgc3VwcG9ydHNUb3VjaCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Ub3VjaEV2ZW50IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCxcbiAgICAgICAgRSA9IFwiXCIsXG4gICAgICAgIFMgPSBcIiBcIixcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBzcGxpdCA9IFwic3BsaXRcIixcbiAgICAgICAgZXZlbnRzID0gXCJjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2Vtb3ZlIG1vdXNlb3V0IG1vdXNlb3ZlciBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsXCJbc3BsaXRdKFMpLFxuICAgICAgICB0b3VjaE1hcCA9IHtcbiAgICAgICAgICAgIG1vdXNlZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgICAgICBtb3VzZW1vdmU6IFwidG91Y2htb3ZlXCIsXG4gICAgICAgICAgICBtb3VzZXVwOiBcInRvdWNoZW5kXCJcbiAgICAgICAgfSxcbiAgICAgICAgbG93ZXJDYXNlID0gU3RyLnByb3RvdHlwZS50b0xvd2VyQ2FzZSxcbiAgICAgICAgbWF0aCA9IE1hdGgsXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgbW1pbiA9IG1hdGgubWluLFxuICAgICAgICBhYnMgPSBtYXRoLmFicyxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIFBJID0gbWF0aC5QSSxcbiAgICAgICAgbnUgPSBcIm51bWJlclwiLFxuICAgICAgICBzdHJpbmcgPSBcInN0cmluZ1wiLFxuICAgICAgICBhcnJheSA9IFwiYXJyYXlcIixcbiAgICAgICAgdG9TdHJpbmcgPSBcInRvU3RyaW5nXCIsXG4gICAgICAgIGZpbGxTdHJpbmcgPSBcImZpbGxcIixcbiAgICAgICAgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBwYXBlciA9IHt9LFxuICAgICAgICBwdXNoID0gXCJwdXNoXCIsXG4gICAgICAgIElTVVJMID0gUi5fSVNVUkwgPSAvXnVybFxcKFsnXCJdPyguKz8pWydcIl0/XFwpJC9pLFxuICAgICAgICBjb2xvdXJSZWdFeHAgPSAvXlxccyooKCNbYS1mXFxkXXs2fSl8KCNbYS1mXFxkXXszfSl8cmdiYT9cXChcXHMqKFtcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslPyg/OlxccyosXFxzKltcXGRcXC5dKyU/KT8pXFxzKlxcKXxoc2JhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyklP1xccypcXCl8aHNsYT9cXChcXHMqKFtcXGRcXC5dKyg/OmRlZ3xcXHhiMHwlKT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyg/OiU/XFxzKixcXHMqW1xcZFxcLl0rKT8pJT9cXHMqXFwpKVxccyokL2ksXG4gICAgICAgIGlzbmFuID0ge1wiTmFOXCI6IDEsIFwiSW5maW5pdHlcIjogMSwgXCItSW5maW5pdHlcIjogMX0sXG4gICAgICAgIGJlemllcnJnID0gL14oPzpjdWJpYy0pP2JlemllclxcKChbXixdKyksKFteLF0rKSwoW14sXSspLChbXlxcKV0rKVxcKS8sXG4gICAgICAgIHJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICAgICAgc2V0QXR0cmlidXRlID0gXCJzZXRBdHRyaWJ1dGVcIixcbiAgICAgICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICAgIHRvSW50ID0gcGFyc2VJbnQsXG4gICAgICAgIHVwcGVyQ2FzZSA9IFN0ci5wcm90b3R5cGUudG9VcHBlckNhc2UsXG4gICAgICAgIGF2YWlsYWJsZUF0dHJzID0gUi5fYXZhaWxhYmxlQXR0cnMgPSB7XG4gICAgICAgICAgICBcImFycm93LWVuZFwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgIFwiYXJyb3ctc3RhcnRcIjogXCJub25lXCIsXG4gICAgICAgICAgICBibHVyOiAwLFxuICAgICAgICAgICAgXCJjbGlwLXJlY3RcIjogXCIwIDAgMWU5IDFlOVwiLFxuICAgICAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICBmaWxsOiBcIiNmZmZcIixcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDEsXG4gICAgICAgICAgICBmb250OiAnMTBweCBcIkFyaWFsXCInLFxuICAgICAgICAgICAgXCJmb250LWZhbWlseVwiOiAnXCJBcmlhbFwiJyxcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBcIixcbiAgICAgICAgICAgIFwiZm9udC1zdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgXCJmb250LXdlaWdodFwiOiA0MDAsXG4gICAgICAgICAgICBncmFkaWVudDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGhyZWY6IFwiaHR0cDovL3JhcGhhZWxqcy5jb20vXCIsXG4gICAgICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgcGF0aDogXCJNMCwwXCIsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcng6IDAsXG4gICAgICAgICAgICByeTogMCxcbiAgICAgICAgICAgIHNyYzogXCJcIixcbiAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwXCIsXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJidXR0XCIsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcImJ1dHRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogMSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwibWlkZGxlXCIsXG4gICAgICAgICAgICB0aXRsZTogXCJSYXBoYWVsXCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIGF2YWlsYWJsZUFuaW1BdHRycyA9IFIuX2F2YWlsYWJsZUFuaW1BdHRycyA9IHtcbiAgICAgICAgICAgIGJsdXI6IG51LFxuICAgICAgICAgICAgXCJjbGlwLXJlY3RcIjogXCJjc3ZcIixcbiAgICAgICAgICAgIGN4OiBudSxcbiAgICAgICAgICAgIGN5OiBudSxcbiAgICAgICAgICAgIGZpbGw6IFwiY29sb3VyXCIsXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBudSxcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IG51LFxuICAgICAgICAgICAgaGVpZ2h0OiBudSxcbiAgICAgICAgICAgIG9wYWNpdHk6IG51LFxuICAgICAgICAgICAgcGF0aDogXCJwYXRoXCIsXG4gICAgICAgICAgICByOiBudSxcbiAgICAgICAgICAgIHJ4OiBudSxcbiAgICAgICAgICAgIHJ5OiBudSxcbiAgICAgICAgICAgIHN0cm9rZTogXCJjb2xvdXJcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogbnUsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBudSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIHdpZHRoOiBudSxcbiAgICAgICAgICAgIHg6IG51LFxuICAgICAgICAgICAgeTogbnVcbiAgICAgICAgfSxcbiAgICAgICAgd2hpdGVzcGFjZSA9IC9bXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldL2csXG4gICAgICAgIGNvbW1hU3BhY2VzID0gL1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLFtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLyxcbiAgICAgICAgaHNyZyA9IHtoczogMSwgcmc6IDF9LFxuICAgICAgICBwMnMgPSAvLD8oW2FjaGxtcXJzdHZ4el0pLD8vZ2ksXG4gICAgICAgIHBhdGhDb21tYW5kID0gLyhbYWNobG1ycXN0dnpdKVtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOSxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLD9bXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKikrKS9pZyxcbiAgICAgICAgdENvbW1hbmQgPSAvKFtyc3RtXSlbXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjksXSooKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT9bXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKiw/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSopKykvaWcsXG4gICAgICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosP1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qL2lnLFxuICAgICAgICByYWRpYWxfZ3JhZGllbnQgPSBSLl9yYWRpYWxfZ3JhZGllbnQgPSAvXnIoPzpcXCgoW14sXSs/KVtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLFtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qKFteXFwpXSs/KVxcKSk/LyxcbiAgICAgICAgZWxkYXRhID0ge30sXG4gICAgICAgIHNvcnRCeUtleSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5rZXkgLSBiLmtleTtcbiAgICAgICAgfSxcbiAgICAgICAgc29ydEJ5TnVtYmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0Zsb2F0KGEpIC0gdG9GbG9hdChiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHBpcGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3RQYXRoID0gUi5fcmVjdFBhdGggPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tcIk1cIiwgeCArIHIsIHldLCBbXCJsXCIsIHcgLSByICogMiwgMF0sIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sIFtcImxcIiwgMCwgaCAtIHIgKiAyXSwgW1wiYVwiLCByLCByLCAwLCAwLCAxLCAtciwgcl0sIFtcImxcIiwgciAqIDIgLSB3LCAwXSwgW1wiYVwiLCByLCByLCAwLCAwLCAxLCAtciwgLXJdLCBbXCJsXCIsIDAsIHIgKiAyIC0gaF0sIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLCBbXCJ6XCJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbW1wiTVwiLCB4LCB5XSwgW1wibFwiLCB3LCAwXSwgW1wibFwiLCAwLCBoXSwgW1wibFwiLCAtdywgMF0sIFtcInpcIl1dO1xuICAgICAgICB9LFxuICAgICAgICBlbGxpcHNlUGF0aCA9IGZ1bmN0aW9uICh4LCB5LCByeCwgcnkpIHtcbiAgICAgICAgICAgIGlmIChyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcnkgPSByeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbW1wiTVwiLCB4LCB5XSwgW1wibVwiLCAwLCAtcnldLCBbXCJhXCIsIHJ4LCByeSwgMCwgMSwgMSwgMCwgMiAqIHJ5XSwgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLCBbXCJ6XCJdXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGF0aCA9IFIuX2dldFBhdGggPSB7XG4gICAgICAgICAgICBwYXRoOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGVsLmF0dHJzO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhLmN4LCBhLmN5LCBhLnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZWwuYXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGEuY3gsIGEuY3ksIGEucngsIGEucnkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZWwuYXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGEueCwgYS55LCBhLndpZHRoLCBhLmhlaWdodCwgYS5yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbC5hdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFBhdGgoYS54LCBhLnksIGEud2lkdGgsIGEuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmJveCA9IGVsLl9nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmJveCA9IGVsLl9nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUmFwaGFlbC5tYXBQYXRoXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggc3RyaW5nIHdpdGggZ2l2ZW4gbWF0cml4LlxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgICAgIC0gbWF0cml4IChvYmplY3QpIHNlZSBATWF0cml4XG4gICAgICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWFwUGF0aCA9IFIubWFwUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCwgeSwgaSwgaiwgaWksIGpqLCBwYXRoaTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoMmN1cnZlKHBhdGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoaSA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYXRoaS5sZW5ndGg7IGogPCBqajsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtYXRyaXgueChwYXRoaVtqXSwgcGF0aGlbaiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG1hdHJpeC55KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYXRoaVtqXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhpW2ogKyAxXSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICBSLl9nID0gZztcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC50eXBlXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIENhbiBiZSDigJxTVkfigJ0sIOKAnFZNTOKAnSBvciBlbXB0eSwgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cbiAgICBcXCovXG4gICAgUi50eXBlID0gKGcud2luLlNWR0FuZ2xlIHx8IGcuZG9jLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpID8gXCJTVkdcIiA6IFwiVk1MXCIpO1xuICAgIGlmIChSLnR5cGUgPT0gXCJWTUxcIikge1xuICAgICAgICB2YXIgZCA9IGcuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBiO1xuICAgICAgICBkLmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XG4gICAgICAgIGIgPSBkLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGIuc3R5bGUuYmVoYXZpb3IgPSBcInVybCgjZGVmYXVsdCNWTUwpXCI7XG4gICAgICAgIGlmICghKGIgJiYgdHlwZW9mIGIuYWRqID09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFIudHlwZSA9IEUpO1xuICAgICAgICB9XG4gICAgICAgIGQgPSBudWxsO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5zdmdcbiAgICAgWyBwcm9wZXJ0eSAoYm9vbGVhbikgXVxuICAgICAqKlxuICAgICAqIGB0cnVlYCBpZiBicm93c2VyIHN1cHBvcnRzIFNWRy5cbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwudm1sXG4gICAgIFsgcHJvcGVydHkgKGJvb2xlYW4pIF1cbiAgICAgKipcbiAgICAgKiBgdHJ1ZWAgaWYgYnJvd3NlciBzdXBwb3J0cyBWTUwuXG4gICAgXFwqL1xuICAgIFIuc3ZnID0gIShSLnZtbCA9IFIudHlwZSA9PSBcIlZNTFwiKTtcbiAgICBSLl9QYXBlciA9IFBhcGVyO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmZuXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG1ldGhvZCB0byB0aGUgY2FudmFzLiBGb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCB0byBkcmF3IGEgcGllIGNoYXJ0LFxuICAgICAqIHlvdSBjYW4gY3JlYXRlIHlvdXIgb3duIHBpZSBjaGFydCBmdW5jdGlvbiBhbmQgc2hpcCBpdCBhcyBhIFJhcGhhw6tsIHBsdWdpbi4gVG8gZG8gdGhpc1xuICAgICAqIHlvdSBuZWVkIHRvIGV4dGVuZCB0aGUgYFJhcGhhZWwuZm5gIG9iamVjdC4gWW91IHNob3VsZCBtb2RpZnkgdGhlIGBmbmAgb2JqZWN0IGJlZm9yZSBhXG4gICAgICogUmFwaGHDq2wgaW5zdGFuY2UgaXMgY3JlYXRlZCwgb3RoZXJ3aXNlIGl0IHdpbGwgdGFrZSBubyBlZmZlY3QuIFBsZWFzZSBub3RlIHRoYXQgdGhlXG4gICAgICogYWJpbGl0eSBmb3IgbmFtZXNwYWNlZCBwbHVnaW5zIHdhcyByZW1vdmVkIGluIFJhcGhhZWwgMi4wLiBJdCBpcyB1cCB0byB0aGUgcGx1Z2luIHRvXG4gICAgICogZW5zdXJlIGFueSBuYW1lc3BhY2luZyBlbnN1cmVzIHByb3BlciBjb250ZXh0LlxuICAgICA+IFVzYWdlXG4gICAgIHwgUmFwaGFlbC5mbi5hcnJvdyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Miwgc2l6ZSkge1xuICAgICB8ICAgICByZXR1cm4gdGhpcy5wYXRoKCAuLi4gKTtcbiAgICAgfCB9O1xuICAgICB8IC8vIG9yIGNyZWF0ZSBuYW1lc3BhY2VcbiAgICAgfCBSYXBoYWVsLmZuLm15c3R1ZmYgPSB7XG4gICAgIHwgICAgIGFycm93OiBmdW5jdGlvbiAoKSB74oCmfSxcbiAgICAgfCAgICAgc3RhcjogZnVuY3Rpb24gKCkge+KApn0sXG4gICAgIHwgICAgIC8vIGV0Y+KAplxuICAgICB8IH07XG4gICAgIHwgdmFyIHBhcGVyID0gUmFwaGFlbCgxMCwgMTAsIDYzMCwgNDgwKTtcbiAgICAgfCAvLyB0aGVuIHVzZSBpdFxuICAgICB8IHBhcGVyLmFycm93KDEwLCAxMCwgMzAsIDMwLCA1KS5hdHRyKHtmaWxsOiBcIiNmMDBcIn0pO1xuICAgICB8IHBhcGVyLm15c3R1ZmYuYXJyb3coKTtcbiAgICAgfCBwYXBlci5teXN0dWZmLnN0YXIoKTtcbiAgICBcXCovXG4gICAgUi5mbiA9IHBhcGVycHJvdG8gPSBQYXBlci5wcm90b3R5cGUgPSBSLnByb3RvdHlwZTtcbiAgICBSLl9pZCA9IDA7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaXNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEhhbmRmdWwgb2YgcmVwbGFjZW1lbnRzIGZvciBgdHlwZW9mYCBvcGVyYXRvci5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gbyAo4oCmKSBhbnkgb2JqZWN0IG9yIHByaW1pdGl2ZVxuICAgICAtIHR5cGUgKHN0cmluZykgbmFtZSBvZiB0aGUgdHlwZSwgaS5lLiDigJxzdHJpbmfigJ0sIOKAnGZ1bmN0aW9u4oCdLCDigJxudW1iZXLigJ0sIGV0Yy5cbiAgICAgPSAoYm9vbGVhbikgaXMgZ2l2ZW4gdmFsdWUgaXMgb2YgZ2l2ZW4gdHlwZVxuICAgIFxcKi9cbiAgICBSLmlzID0gZnVuY3Rpb24gKG8sIHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGxvd2VyQ2FzZS5jYWxsKHR5cGUpO1xuICAgICAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzbmFuW2hhc10oK28pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gICh0eXBlID09IFwibnVsbFwiICYmIG8gPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PSBcIm9iamVjdFwiICYmIG8gPT09IE9iamVjdChvKSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSB8fFxuICAgICAgICAgICAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkgPT0gdHlwZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBjbG9uZShvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5hbmdsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbmdsZSBiZXR3ZWVuIHR3byBvciB0aHJlZSBwb2ludHNcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuICAgICAtIHkxIChudW1iZXIpIHkgY29vcmQgb2YgZmlyc3QgcG9pbnRcbiAgICAgLSB4MiAobnVtYmVyKSB4IGNvb3JkIG9mIHNlY29uZCBwb2ludFxuICAgICAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gICAgIC0geDMgKG51bWJlcikgI29wdGlvbmFsIHggY29vcmQgb2YgdGhpcmQgcG9pbnRcbiAgICAgLSB5MyAobnVtYmVyKSAjb3B0aW9uYWwgeSBjb29yZCBvZiB0aGlyZCBwb2ludFxuICAgICA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgXFwqL1xuICAgIFIuYW5nbGUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICBpZiAoeDMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHggPSB4MSAtIHgyLFxuICAgICAgICAgICAgICAgIHkgPSB5MSAtIHkyO1xuICAgICAgICAgICAgaWYgKCF4ICYmICF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDE4MCArIG1hdGguYXRhbjIoLXksIC14KSAqIDE4MCAvIFBJICsgMzYwKSAlIDM2MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSLmFuZ2xlKHgxLCB5MSwgeDMsIHkzKSAtIFIuYW5nbGUoeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5yYWRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSBhbmdsZSB0byByYWRpYW5zXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGRlZyAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gICAgID0gKG51bWJlcikgYW5nbGUgaW4gcmFkaWFucy5cbiAgICBcXCovXG4gICAgUi5yYWQgPSBmdW5jdGlvbiAoZGVnKSB7XG4gICAgICAgIHJldHVybiBkZWcgJSAzNjAgKiBQSSAvIDE4MDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmRlZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVHJhbnNmb3JtIGFuZ2xlIHRvIGRlZ3JlZXNcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcmFkIChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgPSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzLlxuICAgIFxcKi9cbiAgICBSLmRlZyA9IGZ1bmN0aW9uIChyYWQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQgKChyYWQgKiAxODAgLyBQSSUgMzYwKSogMTAwMCkgLyAxMDAwO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuc25hcFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTbmFwcyBnaXZlbiB2YWx1ZSB0byBnaXZlbiBncmlkLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSB2YWx1ZXMgKGFycmF5fG51bWJlcikgZ2l2ZW4gYXJyYXkgb2YgdmFsdWVzIG9yIHN0ZXAgb2YgdGhlIGdyaWRcbiAgICAgLSB2YWx1ZSAobnVtYmVyKSB2YWx1ZSB0byBhZGp1c3RcbiAgICAgLSB0b2xlcmFuY2UgKG51bWJlcikgI29wdGlvbmFsIHRvbGVyYW5jZSBmb3Igc25hcHBpbmcuIERlZmF1bHQgaXMgYDEwYC5cbiAgICAgPSAobnVtYmVyKSBhZGp1c3RlZCB2YWx1ZS5cbiAgICBcXCovXG4gICAgUi5zbmFwVG8gPSBmdW5jdGlvbiAodmFsdWVzLCB2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gICAgICAgIHRvbGVyYW5jZSA9IFIuaXModG9sZXJhbmNlLCBcImZpbml0ZVwiKSA/IHRvbGVyYW5jZSA6IDEwO1xuICAgICAgICBpZiAoUi5pcyh2YWx1ZXMsIGFycmF5KSkge1xuICAgICAgICAgICAgdmFyIGkgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkgaWYgKGFicyh2YWx1ZXNbaV0gLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcyA9ICt2YWx1ZXM7XG4gICAgICAgICAgICB2YXIgcmVtID0gdmFsdWUgJSB2YWx1ZXM7XG4gICAgICAgICAgICBpZiAocmVtIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAtIHJlbSArIHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmNyZWF0ZVVVSURcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgUkZDNDEyMiwgdmVyc2lvbiA0IElEXG4gICAgXFwqL1xuICAgIHZhciBjcmVhdGVVVUlEID0gUi5jcmVhdGVVVUlEID0gKGZ1bmN0aW9uICh1dWlkUmVnRXgsIHV1aWRSZXBsYWNlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSh1dWlkUmVnRXgsIHV1aWRSZXBsYWNlcikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICB9KSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IG1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgICAgICB2ID0gYyA9PSBcInhcIiA/IHIgOiAociAmIDMgfCA4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuXG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuc2V0V2luZG93XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVc2VkIHdoZW4geW91IG5lZWQgdG8gZHJhdyBpbiBgJmx0O2lmcmFtZT5gLiBTd2l0Y2hlZCB3aW5kb3cgdG8gdGhlIGlmcmFtZSBvbmUuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIG5ld3dpbiAod2luZG93KSBuZXcgd2luZG93IG9iamVjdFxuICAgIFxcKi9cbiAgICBSLnNldFdpbmRvdyA9IGZ1bmN0aW9uIChuZXd3aW4pIHtcbiAgICAgICAgZXZlKFwicmFwaGFlbC5zZXRXaW5kb3dcIiwgUiwgZy53aW4sIG5ld3dpbik7XG4gICAgICAgIGcud2luID0gbmV3d2luO1xuICAgICAgICBnLmRvYyA9IGcud2luLmRvY3VtZW50O1xuICAgICAgICBpZiAoUi5fZW5naW5lLmluaXRXaW4pIHtcbiAgICAgICAgICAgIFIuX2VuZ2luZS5pbml0V2luKGcud2luKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHRvSGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChSLnZtbCkge1xuICAgICAgICAgICAgLy8gaHR0cDovL2RlYW4uZWR3YXJkcy5uYW1lL3dlYmxvZy8yMDA5LzEwL2NvbnZlcnQtYW55LWNvbG91ci12YWx1ZS10by1oZXgtaW4tbXNpZS9cbiAgICAgICAgICAgIHZhciB0cmltID0gL15cXHMrfFxccyskL2c7XG4gICAgICAgICAgICB2YXIgYm9kO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW0gPSBuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpO1xuICAgICAgICAgICAgICAgIGRvY3VtLndyaXRlKFwiPGJvZHk+XCIpO1xuICAgICAgICAgICAgICAgIGRvY3VtLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgYm9kID0gZG9jdW0uYm9keTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGJvZCA9IGNyZWF0ZVBvcHVwKCkuZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGJvZC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHRvSGV4ID0gY2FjaGVyKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZC5zdHlsZS5jb2xvciA9IFN0cihjb2xvcikucmVwbGFjZSh0cmltLCBFKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmFuZ2UucXVlcnlDb21tYW5kVmFsdWUoXCJGb3JlQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKCh2YWx1ZSAmIDI1NSkgPDwgMTYpIHwgKHZhbHVlICYgNjUyODApIHwgKCh2YWx1ZSAmIDE2NzExNjgwKSA+Pj4gMTYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCIgKyAoXCIwMDAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IGcuZG9jLmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuICAgICAgICAgICAgaS50aXRsZSA9IFwiUmFwaGFcXHhlYmwgQ29sb3VyIFBpY2tlclwiO1xuICAgICAgICAgICAgaS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBnLmRvYy5ib2R5LmFwcGVuZENoaWxkKGkpO1xuICAgICAgICAgICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBnLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGksIEUpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0hleChjb2xvcik7XG4gICAgfSxcbiAgICBoc2J0b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHNiKFwiICsgW3RoaXMuaCwgdGhpcy5zLCB0aGlzLmJdICsgXCIpXCI7XG4gICAgfSxcbiAgICBoc2x0b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHNsKFwiICsgW3RoaXMuaCwgdGhpcy5zLCB0aGlzLmxdICsgXCIpXCI7XG4gICAgfSxcbiAgICByZ2J0b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4O1xuICAgIH0sXG4gICAgcHJlcGFyZVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIGlmIChnID09IG51bGwgJiYgUi5pcyhyLCBcIm9iamVjdFwiKSAmJiBcInJcIiBpbiByICYmIFwiZ1wiIGluIHIgJiYgXCJiXCIgaW4gcikge1xuICAgICAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgICAgIGcgPSByLmc7XG4gICAgICAgICAgICByID0gci5yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnID09IG51bGwgJiYgUi5pcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgY2xyID0gUi5nZXRSR0Iocik7XG4gICAgICAgICAgICByID0gY2xyLnI7XG4gICAgICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgICAgICBiID0gY2xyLmI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgICAgICByIC89IDI1NTtcbiAgICAgICAgICAgIGcgLz0gMjU1O1xuICAgICAgICAgICAgYiAvPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG4gICAgcGFja2FnZVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBvKSB7XG4gICAgICAgIHIgKj0gMjU1O1xuICAgICAgICBnICo9IDI1NTtcbiAgICAgICAgYiAqPSAyNTU7XG4gICAgICAgIHZhciByZ2IgPSB7XG4gICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgIGI6IGIsXG4gICAgICAgICAgICBoZXg6IFIucmdiKHIsIGcsIGIpLFxuICAgICAgICAgICAgdG9TdHJpbmc6IHJnYnRvU3RyaW5nXG4gICAgICAgIH07XG4gICAgICAgIFIuaXMobywgXCJmaW5pdGVcIikgJiYgKHJnYi5vcGFjaXR5ID0gbyk7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmNvbG9yXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQYXJzZXMgdGhlIGNvbG9yIHN0cmluZyBhbmQgcmV0dXJucyBvYmplY3Qgd2l0aCBhbGwgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gY29sb3IuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGNsciAoc3RyaW5nKSBjb2xvciBzdHJpbmcgaW4gb25lIG9mIHRoZSBzdXBwb3J0ZWQgZm9ybWF0cyAoc2VlIEBSYXBoYWVsLmdldFJHQilcbiAgICAgPSAob2JqZWN0KSBDb21iaW5lZCBSR0IgJiBIU0Igb2JqZWN0IGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHIgKG51bWJlcikgcmVkLFxuICAgICBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuICAgICBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gICAgIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKIsXG4gICAgIG8gICAgIGVycm9yIChib29sZWFuKSBgdHJ1ZWAgaWYgc3RyaW5nIGNhbuKAmXQgYmUgcGFyc2VkLFxuICAgICBvICAgICBoIChudW1iZXIpIGh1ZSxcbiAgICAgbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuICAgICBvICAgICB2IChudW1iZXIpIHZhbHVlIChicmlnaHRuZXNzKSxcbiAgICAgbyAgICAgbCAobnVtYmVyKSBsaWdodG5lc3NcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuY29sb3IgPSBmdW5jdGlvbiAoY2xyKSB7XG4gICAgICAgIHZhciByZ2I7XG4gICAgICAgIGlmIChSLmlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIpIHtcbiAgICAgICAgICAgIHJnYiA9IFIuaHNiMnJnYihjbHIpO1xuICAgICAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgICAgICBjbHIuYiA9IHJnYi5iO1xuICAgICAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoUi5pcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGNsciAmJiBcInNcIiBpbiBjbHIgJiYgXCJsXCIgaW4gY2xyKSB7XG4gICAgICAgICAgICByZ2IgPSBSLmhzbDJyZ2IoY2xyKTtcbiAgICAgICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgICAgICBjbHIuZyA9IHJnYi5nO1xuICAgICAgICAgICAgY2xyLmIgPSByZ2IuYjtcbiAgICAgICAgICAgIGNsci5oZXggPSByZ2IuaGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFIuaXMoY2xyLCBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIGNsciA9IFIuZ2V0UkdCKGNscik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUi5pcyhjbHIsIFwib2JqZWN0XCIpICYmIFwiclwiIGluIGNsciAmJiBcImdcIiBpbiBjbHIgJiYgXCJiXCIgaW4gY2xyKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gUi5yZ2IyaHNsKGNscik7XG4gICAgICAgICAgICAgICAgY2xyLmggPSByZ2IuaDtcbiAgICAgICAgICAgICAgICBjbHIucyA9IHJnYi5zO1xuICAgICAgICAgICAgICAgIGNsci5sID0gcmdiLmw7XG4gICAgICAgICAgICAgICAgcmdiID0gUi5yZ2IyaHNiKGNscik7XG4gICAgICAgICAgICAgICAgY2xyLnYgPSByZ2IuYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xyID0ge2hleDogXCJub25lXCJ9O1xuICAgICAgICAgICAgICAgIGNsci5yID0gY2xyLmcgPSBjbHIuYiA9IGNsci5oID0gY2xyLnMgPSBjbHIudiA9IGNsci5sID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xyLnRvU3RyaW5nID0gcmdidG9TdHJpbmc7XG4gICAgICAgIHJldHVybiBjbHI7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5oc2IycmdiXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBIU0IgdmFsdWVzIHRvIFJHQiBvYmplY3QuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGggKG51bWJlcikgaHVlXG4gICAgIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gICAgIC0gdiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gICAgID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICByIChudW1iZXIpIHJlZCxcbiAgICAgbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiAgICAgbyAgICAgYiAobnVtYmVyKSBibHVlLFxuICAgICBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLmhzYjJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgdiwgbykge1xuICAgICAgICBpZiAodGhpcy5pcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJiXCIgaW4gaCkge1xuICAgICAgICAgICAgdiA9IGguYjtcbiAgICAgICAgICAgIHMgPSBoLnM7XG4gICAgICAgICAgICBvID0gaC5vO1xuICAgICAgICAgICAgaCA9IGguaDtcbiAgICAgICAgfVxuICAgICAgICBoICo9IDM2MDtcbiAgICAgICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgICAgIGggPSAoaCAlIDM2MCkgLyA2MDtcbiAgICAgICAgQyA9IHYgKiBzO1xuICAgICAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgICAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgICAgICBoID0gfn5oO1xuICAgICAgICBSICs9IFtDLCBYLCAwLCAwLCBYLCBDXVtoXTtcbiAgICAgICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgICAgIEIgKz0gWzAsIDAsIFgsIEMsIEMsIFhdW2hdO1xuICAgICAgICByZXR1cm4gcGFja2FnZVJHQihSLCBHLCBCLCBvKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmhzbDJyZ2JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIEhTTCB2YWx1ZXMgdG8gUkdCIG9iamVjdC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaCAobnVtYmVyKSBodWVcbiAgICAgLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAgICAgLSBsIChudW1iZXIpIGx1bWlub3NpdHlcbiAgICAgPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHIgKG51bWJlcikgcmVkLFxuICAgICBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuICAgICBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gICAgIG8gICAgIGhleCAoc3RyaW5nKSBjb2xvciBpbiBIVE1ML0NTUyBmb3JtYXQ6ICPigKLigKLigKLigKLigKLigKJcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuaHNsMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCBsLCBvKSB7XG4gICAgICAgIGlmICh0aGlzLmlzKGgsIFwib2JqZWN0XCIpICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImxcIiBpbiBoKSB7XG4gICAgICAgICAgICBsID0gaC5sO1xuICAgICAgICAgICAgcyA9IGgucztcbiAgICAgICAgICAgIGggPSBoLmg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggPiAxIHx8IHMgPiAxIHx8IGwgPiAxKSB7XG4gICAgICAgICAgICBoIC89IDM2MDtcbiAgICAgICAgICAgIHMgLz0gMTAwO1xuICAgICAgICAgICAgbCAvPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaCAqPSAzNjA7XG4gICAgICAgIHZhciBSLCBHLCBCLCBYLCBDO1xuICAgICAgICBoID0gKGggJSAzNjApIC8gNjA7XG4gICAgICAgIEMgPSAyICogcyAqIChsIDwgLjUgPyBsIDogMSAtIGwpO1xuICAgICAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgICAgICBSID0gRyA9IEIgPSBsIC0gQyAvIDI7XG5cbiAgICAgICAgaCA9IH5+aDtcbiAgICAgICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgICAgIEcgKz0gW1gsIEMsIEMsIFgsIDAsIDBdW2hdO1xuICAgICAgICBCICs9IFswLCAwLCBYLCBDLCBDLCBYXVtoXTtcbiAgICAgICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5yZ2IyaHNiXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIEhTQiBvYmplY3QuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHIgKG51bWJlcikgcmVkXG4gICAgIC0gZyAobnVtYmVyKSBncmVlblxuICAgICAtIGIgKG51bWJlcikgYmx1ZVxuICAgICA9IChvYmplY3QpIEhTQiBvYmplY3QgaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgaCAobnVtYmVyKSBodWVcbiAgICAgbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gICAgIG8gICAgIGIgKG51bWJlcikgYnJpZ2h0bmVzc1xuICAgICBvIH1cbiAgICBcXCovXG4gICAgUi5yZ2IyaHNiID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgYiA9IHByZXBhcmVSR0IociwgZywgYik7XG4gICAgICAgIHIgPSBiWzBdO1xuICAgICAgICBnID0gYlsxXTtcbiAgICAgICAgYiA9IGJbMl07XG5cbiAgICAgICAgdmFyIEgsIFMsIFYsIEM7XG4gICAgICAgIFYgPSBtbWF4KHIsIGcsIGIpO1xuICAgICAgICBDID0gViAtIG1taW4ociwgZywgYik7XG4gICAgICAgIEggPSAoQyA9PSAwID8gbnVsbCA6XG4gICAgICAgICAgICAgViA9PSByID8gKGcgLSBiKSAvIEMgOlxuICAgICAgICAgICAgIFYgPT0gZyA/IChiIC0gcikgLyBDICsgMiA6XG4gICAgICAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0XG4gICAgICAgICAgICApO1xuICAgICAgICBIID0gKChIICsgMzYwKSAlIDYpICogNjAgLyAzNjA7XG4gICAgICAgIFMgPSBDID09IDAgPyAwIDogQyAvIFY7XG4gICAgICAgIHJldHVybiB7aDogSCwgczogUywgYjogViwgdG9TdHJpbmc6IGhzYnRvU3RyaW5nfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnJnYjJoc2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gSFNMIG9iamVjdC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gciAobnVtYmVyKSByZWRcbiAgICAgLSBnIChudW1iZXIpIGdyZWVuXG4gICAgIC0gYiAobnVtYmVyKSBibHVlXG4gICAgID0gKG9iamVjdCkgSFNMIG9iamVjdCBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBoIChudW1iZXIpIGh1ZVxuICAgICBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAgICAgbyAgICAgbCAobnVtYmVyKSBsdW1pbm9zaXR5XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLnJnYjJoc2wgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICAgICAgciA9IGJbMF07XG4gICAgICAgIGcgPSBiWzFdO1xuICAgICAgICBiID0gYlsyXTtcblxuICAgICAgICB2YXIgSCwgUywgTCwgTSwgbSwgQztcbiAgICAgICAgTSA9IG1tYXgociwgZywgYik7XG4gICAgICAgIG0gPSBtbWluKHIsIGcsIGIpO1xuICAgICAgICBDID0gTSAtIG07XG4gICAgICAgIEggPSAoQyA9PSAwID8gbnVsbCA6XG4gICAgICAgICAgICAgTSA9PSByID8gKGcgLSBiKSAvIEMgOlxuICAgICAgICAgICAgIE0gPT0gZyA/IChiIC0gcikgLyBDICsgMiA6XG4gICAgICAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0KTtcbiAgICAgICAgSCA9ICgoSCArIDM2MCkgJSA2KSAqIDYwIC8gMzYwO1xuICAgICAgICBMID0gKE0gKyBtKSAvIDI7XG4gICAgICAgIFMgPSAoQyA9PSAwID8gMCA6XG4gICAgICAgICAgICAgTCA8IC41ID8gQyAvICgyICogTCkgOlxuICAgICAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKSk7XG4gICAgICAgIHJldHVybiB7aDogSCwgczogUywgbDogTCwgdG9TdHJpbmc6IGhzbHRvU3RyaW5nfTtcbiAgICB9O1xuICAgIFIuX3BhdGgyc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlcHVzaChhcnJheSwgaXRlbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5wdXNoKGFycmF5LnNwbGljZShpLCAxKVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FjaGVyKGYsIHNjb3BlLCBwb3N0cHJvY2Vzc29yKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5ld2YoKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJnLmpvaW4oXCJcXHUyNDAwXCIpLFxuICAgICAgICAgICAgICAgIGNhY2hlID0gbmV3Zi5jYWNoZSA9IG5ld2YuY2FjaGUgfHwge30sXG4gICAgICAgICAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcbiAgICAgICAgICAgIGlmIChjYWNoZVtoYXNdKGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmVwdXNoKGNvdW50LCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudC5sZW5ndGggPj0gMWUzICYmIGRlbGV0ZSBjYWNoZVtjb3VudC5zaGlmdCgpXTtcbiAgICAgICAgICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgICAgICAgICBjYWNoZVthcmdzXSA9IGZbYXBwbHldKHNjb3BlLCBhcmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdmO1xuICAgIH1cblxuICAgIHZhciBwcmVsb2FkID0gUi5fcHJlbG9hZCA9IGZ1bmN0aW9uIChzcmMsIGYpIHtcbiAgICAgICAgdmFyIGltZyA9IGcuZG9jLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGYuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIGcuZG9jLmJvZHkucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZy5kb2MuYm9keS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZy5kb2MuYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbHJUb1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4O1xuICAgIH1cblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmdldFJHQlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUGFyc2VzIGNvbG91ciBzdHJpbmcgYXMgUkdCIG9iamVjdFxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBjb2xvdXIgKHN0cmluZykgY29sb3VyIHN0cmluZyBpbiBvbmUgb2YgZm9ybWF0czpcbiAgICAgIyA8dWw+XG4gICAgICMgICAgIDxsaT5Db2xvdXIgbmFtZSAo4oCcPGNvZGU+cmVkPC9jb2RlPuKAnSwg4oCcPGNvZGU+Z3JlZW48L2NvZGU+4oCdLCDigJw8Y29kZT5jb3JuZmxvd2VyYmx1ZTwvY29kZT7igJ0sIGV0Yyk8L2xpPlxuICAgICAjICAgICA8bGk+I+KAouKAouKAoiDigJQgc2hvcnRlbmVkIEhUTUwgY29sb3VyOiAo4oCcPGNvZGU+IzAwMDwvY29kZT7igJ0sIOKAnDxjb2RlPiNmYzA8L2NvZGU+4oCdLCBldGMpPC9saT5cbiAgICAgIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3VyOiAo4oCcPGNvZGU+IzAwMDAwMDwvY29kZT7igJ0sIOKAnDxjb2RlPiNiZDIzMDA8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHPigJkgdmFsdWVzOiAo4oCcPGNvZGU+cmdiKDIwMCwmbmJzcDsxMDAsJm5ic3A7MCk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlOiAo4oCcPGNvZGU+cmdiKDEwMCUsJm5ic3A7MTc1JSwmbmJzcDswJSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGh1ZSwgc2F0dXJhdGlvbiBhbmQgYnJpZ2h0bmVzcyB2YWx1ZXM6ICjigJw8Y29kZT5oc2IoMC41LCZuYnNwOzAuMjUsJm5ic3A7MSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2Io4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCBpbiAlPC9saT5cbiAgICAgIyAgICAgPGxpPmhzbCjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgc2FtZSBhcyBoc2I8L2xpPlxuICAgICAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGhzYjwvbGk+XG4gICAgICMgPC91bD5cbiAgICAgPSAob2JqZWN0KSBSR0Igb2JqZWN0IGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHIgKG51bWJlcikgcmVkLFxuICAgICBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuICAgICBvICAgICBiIChudW1iZXIpIGJsdWVcbiAgICAgbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiAgICAgbyAgICAgZXJyb3IgKGJvb2xlYW4pIHRydWUgaWYgc3RyaW5nIGNhbuKAmXQgYmUgcGFyc2VkXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLmdldFJHQiA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3VyKSB7XG4gICAgICAgIGlmICghY29sb3VyIHx8ICEhKChjb2xvdXIgPSBTdHIoY29sb3VyKSkuaW5kZXhPZihcIi1cIikgKyAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCBlcnJvcjogMSwgdG9TdHJpbmc6IGNsclRvU3RyaW5nfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3VyID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIHRvU3RyaW5nOiBjbHJUb1N0cmluZ307XG4gICAgICAgIH1cbiAgICAgICAgIShoc3JnW2hhc10oY29sb3VyLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDIpKSB8fCBjb2xvdXIuY2hhckF0KCkgPT0gXCIjXCIpICYmIChjb2xvdXIgPSB0b0hleChjb2xvdXIpKTtcbiAgICAgICAgdmFyIHJlcyxcbiAgICAgICAgICAgIHJlZCxcbiAgICAgICAgICAgIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSxcbiAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICB0LFxuICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgcmdiID0gY29sb3VyLm1hdGNoKGNvbG91clJlZ0V4cCk7XG4gICAgICAgIGlmIChyZ2IpIHtcbiAgICAgICAgICAgIGlmIChyZ2JbMl0pIHtcbiAgICAgICAgICAgICAgICBibHVlID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZyg1KSwgMTYpO1xuICAgICAgICAgICAgICAgIGdyZWVuID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZygzLCA1KSwgMTYpO1xuICAgICAgICAgICAgICAgIHJlZCA9IHRvSW50KHJnYlsyXS5zdWJzdHJpbmcoMSwgMyksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZ2JbM10pIHtcbiAgICAgICAgICAgICAgICBibHVlID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDMpKSArIHQsIDE2KTtcbiAgICAgICAgICAgICAgICBncmVlbiA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgyKSkgKyB0LCAxNik7XG4gICAgICAgICAgICAgICAgcmVkID0gdG9JbnQoKHQgPSByZ2JbM10uY2hhckF0KDEpKSArIHQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZ2JbNF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNF1bc3BsaXRdKGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAqPSAyLjU1KTtcbiAgICAgICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcInJnYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZ2JbNV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNV1bc3BsaXRdKGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAqPSAyLjU1KTtcbiAgICAgICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2JhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFIuaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZ2JbNl0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl1bc3BsaXRdKGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAqPSAyLjU1KTtcbiAgICAgICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFIuaHNsMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYiA9IHtyOiByZWQsIGc6IGdyZWVuLCBiOiBibHVlLCB0b1N0cmluZzogY2xyVG9TdHJpbmd9O1xuICAgICAgICAgICAgcmdiLmhleCA9IFwiI1wiICsgKDE2Nzc3MjE2IHwgYmx1ZSB8IChncmVlbiA8PCA4KSB8IChyZWQgPDwgMTYpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgICAgICBSLmlzKG9wYWNpdHksIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG9wYWNpdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJnYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3I6IC0xLCBnOiAtMSwgYjogLTEsIGhleDogXCJub25lXCIsIGVycm9yOiAxLCB0b1N0cmluZzogY2xyVG9TdHJpbmd9O1xuICAgIH0sIFIpO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmhzYlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG91ci5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaCAobnVtYmVyKSBodWVcbiAgICAgLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAgICAgLSBiIChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiAgICAgPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG91ci5cbiAgICBcXCovXG4gICAgUi5oc2IgPSBjYWNoZXIoZnVuY3Rpb24gKGgsIHMsIGIpIHtcbiAgICAgICAgcmV0dXJuIFIuaHNiMnJnYihoLCBzLCBiKS5oZXg7XG4gICAgfSk7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaHNsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3VyLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoIChudW1iZXIpIGh1ZVxuICAgICAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuICAgICAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuICAgICA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3VyLlxuICAgIFxcKi9cbiAgICBSLmhzbCA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgICAgICByZXR1cm4gUi5oc2wycmdiKGgsIHMsIGwpLmhleDtcbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5yZ2JcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvdXIuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHIgKG51bWJlcikgcmVkXG4gICAgIC0gZyAobnVtYmVyKSBncmVlblxuICAgICAtIGIgKG51bWJlcikgYmx1ZVxuICAgICA9IChzdHJpbmcpIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3VyLlxuICAgIFxcKi9cbiAgICBSLnJnYiA9IGNhY2hlcihmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICBmdW5jdGlvbiByb3VuZCh4KSB7IHJldHVybiAoeCArIDAuNSkgfCAwOyB9XG4gICAgICAgIHJldHVybiBcIiNcIiArICgxNjc3NzIxNiB8IHJvdW5kKGIpIHwgKHJvdW5kKGcpIDw8IDgpIHwgKHJvdW5kKHIpIDw8IDE2KSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgIH0pO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmdldENvbG9yXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBPbiBlYWNoIGNhbGwgcmV0dXJucyBuZXh0IGNvbG91ciBpbiB0aGUgc3BlY3RydW0uIFRvIHJlc2V0IGl0IGJhY2sgdG8gcmVkIGNhbGwgQFJhcGhhZWwuZ2V0Q29sb3IucmVzZXRcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gdmFsdWUgKG51bWJlcikgI29wdGlvbmFsIGJyaWdodG5lc3MsIGRlZmF1bHQgaXMgYDAuNzVgXG4gICAgID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvdXIuXG4gICAgXFwqL1xuICAgIFIuZ2V0Q29sb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDb2xvci5zdGFydCA9IHRoaXMuZ2V0Q29sb3Iuc3RhcnQgfHwge2g6IDAsIHM6IDEsIGI6IHZhbHVlIHx8IC43NX0sXG4gICAgICAgICAgICByZ2IgPSB0aGlzLmhzYjJyZ2Ioc3RhcnQuaCwgc3RhcnQucywgc3RhcnQuYik7XG4gICAgICAgIHN0YXJ0LmggKz0gLjA3NTtcbiAgICAgICAgaWYgKHN0YXJ0LmggPiAxKSB7XG4gICAgICAgICAgICBzdGFydC5oID0gMDtcbiAgICAgICAgICAgIHN0YXJ0LnMgLT0gLjI7XG4gICAgICAgICAgICBzdGFydC5zIDw9IDAgJiYgKHRoaXMuZ2V0Q29sb3Iuc3RhcnQgPSB7aDogMCwgczogMSwgYjogc3RhcnQuYn0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2IuaGV4O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuZ2V0Q29sb3IucmVzZXRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlc2V0cyBzcGVjdHJ1bSBwb3NpdGlvbiBmb3IgQFJhcGhhZWwuZ2V0Q29sb3IgYmFjayB0byByZWQuXG4gICAgXFwqL1xuICAgIFIuZ2V0Q29sb3IucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0YXJ0O1xuICAgIH07XG5cbiAgICAvLyBodHRwOi8vc2NoZXBlcnMuY2MvZ2V0dGluZy10by10aGUtcG9pbnRcbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihjcnAsIHopIHtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjcnAubGVuZ3RoOyBpTGVuIC0gMiAqICF6ID4gaTsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgLSAyXSwgeTogK2NycFtpIC0gMV19LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaV0sICAgICB5OiArY3JwW2kgKyAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpICsgMl0sIHk6ICtjcnBbaSArIDNdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyA0XSwgeTogK2NycFtpICsgNV19XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzBdID0ge3g6ICtjcnBbaUxlbiAtIDJdLCB5OiArY3JwW2lMZW4gLSAxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gMiA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSB7eDogK2NycFsyXSwgeTogK2NycFszXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaUxlbiAtIDQgPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBwWzNdID0gcFsyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpXSwgeTogK2NycFtpICsgMV19O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQucHVzaChbXCJDXCIsXG4gICAgICAgICAgICAgICAgICAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgICgtcFswXS55ICsgNiAqIHBbMV0ueSArIHBbMl0ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueCArIDYgKiBwWzJdLnggLSBwWzNdLngpIC8gNixcbiAgICAgICAgICAgICAgICAgIChwWzFdLnkgKyA2KnBbMl0ueSAtIHBbM10ueSkgLyA2LFxuICAgICAgICAgICAgICAgICAgcFsyXS54LFxuICAgICAgICAgICAgICAgICAgcFsyXS55XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5wYXJzZVBhdGhTdHJpbmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUGFyc2VzIGdpdmVuIHBhdGggc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBhdGggc2VnbWVudHMuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZ3xhcnJheSkgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2Ygc2VnbWVudHMgKGluIHRoZSBsYXN0IGNhc2UgaXQgd2lsbCBiZSByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuICAgICA9IChhcnJheSkgYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgXFwqL1xuICAgIFIucGFyc2VQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFwYXRoU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aFN0cmluZyk7XG4gICAgICAgIGlmIChwdGguYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmFtQ291bnRzID0ge2E6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHI6IDQsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDB9LFxuICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBpZiAoUi5pcyhwYXRoU3RyaW5nLCBhcnJheSkgJiYgUi5pcyhwYXRoU3RyaW5nWzBdLCBhcnJheSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgZGF0YSA9IHBhdGhDbG9uZShwYXRoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBTdHIocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgYy5yZXBsYWNlKHBhdGhWYWx1ZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwibVwiICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl1bY29uY2F0XShwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImxcIjtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGIgPT0gXCJtXCIgPyBcImxcIiA6IFwiTFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdW2NvbmNhdF0ocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl1bY29uY2F0XShwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW25hbWVdKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEudG9TdHJpbmcgPSBSLl9wYXRoMnN0cmluZztcbiAgICAgICAgcHRoLmFyciA9IHBhdGhDbG9uZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5wYXJzZVRyYW5zZm9ybVN0cmluZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIFRTdHJpbmcgKHN0cmluZ3xhcnJheSkgdHJhbnNmb3JtIHN0cmluZyBvciBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnMgKGluIHRoZSBsYXN0IGNhc2UgaXQgd2lsbCBiZSByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuICAgICA9IChhcnJheSkgYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zLlxuICAgIFxcKi9cbiAgICBSLnBhcnNlVHJhbnNmb3JtU3RyaW5nID0gY2FjaGVyKGZ1bmN0aW9uIChUU3RyaW5nKSB7XG4gICAgICAgIGlmICghVFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtQ291bnRzID0ge3I6IDMsIHM6IDQsIHQ6IDIsIG06IDZ9LFxuICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBpZiAoUi5pcyhUU3RyaW5nLCBhcnJheSkgJiYgUi5pcyhUU3RyaW5nWzBdLCBhcnJheSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgZGF0YSA9IHBhdGhDbG9uZShUU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBTdHIoVFN0cmluZykucmVwbGFjZSh0Q29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBsb3dlckNhc2UuY2FsbChiKTtcbiAgICAgICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXVtjb25jYXRdKHBhcmFtcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS50b1N0cmluZyA9IFIuX3BhdGgyc3RyaW5nO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LCB0aGlzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIGlmICghZWxlbSkgcmV0dXJuIGVsZW07XG4gICAgICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5ld0xldmVsID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1baV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdMZXZlbC5wdXNoKGVsZW1baV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGF0YS5wdXNoKG5ld0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7IH0gKTtcbiAgICAvLyBQQVRIU1xuICAgIHZhciBwYXRocyA9IGZ1bmN0aW9uIChwcykge1xuICAgICAgICB2YXIgcCA9IHBhdGhzLnBzID0gcGF0aHMucHMgfHwge307XG4gICAgICAgIGlmIChwW3BzXSkge1xuICAgICAgICAgICAgcFtwc10uc2xlZXAgPSAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwW3BzXSA9IHtcbiAgICAgICAgICAgICAgICBzbGVlcDogMTAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHApIGlmIChwW2hhc10oa2V5KSAmJiBrZXkgIT0gcHMpIHtcbiAgICAgICAgICAgICAgICBwW2tleV0uc2xlZXAtLTtcbiAgICAgICAgICAgICAgICAhcFtrZXldLnNsZWVwICYmIGRlbGV0ZSBwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcFtwc107XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5maW5kRG90c0F0U2VnbWVudFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kIGRvdCBjb29yZGluYXRlcyBvbiB0aGUgZ2l2ZW4gY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHRoZSBnaXZlbiB0LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gdCAobnVtYmVyKSBwb3NpdGlvbiBvbiB0aGUgY3VydmUgKDAuLjEpXG4gICAgID0gKG9iamVjdCkgcG9pbnQgaW5mb3JtYXRpb24gaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIG8gICAgIG06IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3JcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3JcbiAgICAgbyAgICAgfVxuICAgICBvICAgICBuOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGFuY2hvclxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBhbmNob3JcbiAgICAgbyAgICAgfVxuICAgICBvICAgICBzdGFydDoge1xuICAgICBvICAgICAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlXG4gICAgIG8gICAgIH1cbiAgICAgbyAgICAgZW5kOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZVxuICAgICBvICAgICB9XG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiB0aGUgY3VydmUgZGVyaXZhdGl2ZSBhdCB0aGUgcG9pbnRcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFIuZmluZERvdHNBdFNlZ21lbnQgPSBmdW5jdGlvbiAocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gKDkwIC0gbWF0aC5hdGFuMihteCAtIG54LCBteSAtIG55KSAqIDE4MCAvIFBJKTtcbiAgICAgICAgKG14ID4gbnggfHwgbXkgPCBueSkgJiYgKGFscGhhICs9IDE4MCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIG06IHt4OiBteCwgeTogbXl9LFxuICAgICAgICAgICAgbjoge3g6IG54LCB5OiBueX0sXG4gICAgICAgICAgICBzdGFydDoge3g6IGF4LCB5OiBheX0sXG4gICAgICAgICAgICBlbmQ6IHt4OiBjeCwgeTogY3l9LFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5iZXppZXJCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybiBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBjdWJpYyBiZXppZXIgY3VydmVcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAqIG9yXG4gICAgIC0gYmV6IChhcnJheSkgYXJyYXkgb2Ygc2l4IHBvaW50cyBmb3IgYmV6aWVyIGN1cnZlXG4gICAgID0gKG9iamVjdCkgcG9pbnQgaW5mb3JtYXRpb24gaW4gZm9ybWF0OlxuICAgICBvIHtcbiAgICAgbyAgICAgbWluOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgcG9pbnRcbiAgICAgbyAgICAgICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHBvaW50XG4gICAgIG8gICAgIH1cbiAgICAgbyAgICAgbWF4OiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBvaW50XG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwb2ludFxuICAgICBvICAgICB9XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLmJlemllckJCb3ggPSBmdW5jdGlvbiAocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnkpIHtcbiAgICAgICAgaWYgKCFSLmlzKHAxeCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcDF4ID0gW3AxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmJveCA9IGN1cnZlRGltLmFwcGx5KG51bGwsIHAxeCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBiYm94Lm1pbi54LFxuICAgICAgICAgICAgeTogYmJveC5taW4ueSxcbiAgICAgICAgICAgIHgyOiBiYm94Lm1heC54LFxuICAgICAgICAgICAgeTI6IGJib3gubWF4LnksXG4gICAgICAgICAgICB3aWR0aDogYmJveC5tYXgueCAtIGJib3gubWluLngsXG4gICAgICAgICAgICBoZWlnaHQ6IGJib3gubWF4LnkgLSBiYm94Lm1pbi55XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5pc1BvaW50SW5zaWRlQkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBnaXZlbiBwb2ludCBpcyBpbnNpZGUgYm91bmRpbmcgYm94ZXMuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGJib3ggKHN0cmluZykgYm91bmRpbmcgYm94XG4gICAgIC0geCAoc3RyaW5nKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAoc3RyaW5nKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpbnNpZGVcbiAgICBcXCovXG4gICAgUi5pc1BvaW50SW5zaWRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCB4LCB5KSB7XG4gICAgICAgIHJldHVybiB4ID49IGJib3gueCAmJiB4IDw9IGJib3gueDIgJiYgeSA+PSBiYm94LnkgJiYgeSA8PSBiYm94LnkyO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwuaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gYmJveDEgKHN0cmluZykgZmlyc3QgYm91bmRpbmcgYm94XG4gICAgIC0gYmJveDIgKHN0cmluZykgc2Vjb25kIGJvdW5kaW5nIGJveFxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAgaWYgdGhleSBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgUi5pc0JCb3hJbnRlcnNlY3QgPSBmdW5jdGlvbiAoYmJveDEsIGJib3gyKSB7XG4gICAgICAgIHZhciBpID0gUi5pc1BvaW50SW5zaWRlQkJveDtcbiAgICAgICAgcmV0dXJuIGkoYmJveDIsIGJib3gxLngsIGJib3gxLnkpXG4gICAgICAgICAgICB8fCBpKGJib3gyLCBiYm94MS54MiwgYmJveDEueSlcbiAgICAgICAgICAgIHx8IGkoYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaShiYm94MiwgYmJveDEueDIsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaShiYm94MSwgYmJveDIueCwgYmJveDIueSlcbiAgICAgICAgICAgIHx8IGkoYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaShiYm94MSwgYmJveDIueCwgYmJveDIueTIpXG4gICAgICAgICAgICB8fCBpKGJib3gxLCBiYm94Mi54MiwgYmJveDIueTIpXG4gICAgICAgICAgICB8fCAoYmJveDEueCA8IGJib3gyLngyICYmIGJib3gxLnggPiBiYm94Mi54IHx8IGJib3gyLnggPCBiYm94MS54MiAmJiBiYm94Mi54ID4gYmJveDEueClcbiAgICAgICAgICAgICYmIChiYm94MS55IDwgYmJveDIueTIgJiYgYmJveDEueSA+IGJib3gyLnkgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJhc2UzKHQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIHZhciB0MSA9IC0zICogcDEgKyA5ICogcDIgLSA5ICogcDMgKyAzICogcDQsXG4gICAgICAgICAgICB0MiA9IHQgKiB0MSArIDYgKiBwMSAtIDEyICogcDIgKyA2ICogcDM7XG4gICAgICAgIHJldHVybiB0ICogdDIgLSAzICogcDEgKyAzICogcDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHopIHtcbiAgICAgICAgaWYgKHogPT0gbnVsbCkge1xuICAgICAgICAgICAgeiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgeiA9IHogPiAxID8gMSA6IHogPCAwID8gMCA6IHo7XG4gICAgICAgIHZhciB6MiA9IHogLyAyLFxuICAgICAgICAgICAgbiA9IDEyLFxuICAgICAgICAgICAgVHZhbHVlcyA9IFstMC4xMjUyLDAuMTI1MiwtMC4zNjc4LDAuMzY3OCwtMC41ODczLDAuNTg3MywtMC43Njk5LDAuNzY5OSwtMC45MDQxLDAuOTA0MSwtMC45ODE2LDAuOTgxNl0sXG4gICAgICAgICAgICBDdmFsdWVzID0gWzAuMjQ5MSwwLjI0OTEsMC4yMzM1LDAuMjMzNSwwLjIwMzIsMC4yMDMyLDAuMTYwMSwwLjE2MDEsMC4xMDY5LDAuMTA2OSwwLjA0NzIsMC4wNDcyXSxcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3QgPSB6MiAqIFR2YWx1ZXNbaV0gKyB6MixcbiAgICAgICAgICAgICAgICB4YmFzZSA9IGJhc2UzKGN0LCB4MSwgeDIsIHgzLCB4NCksXG4gICAgICAgICAgICAgICAgeWJhc2UgPSBiYXNlMyhjdCwgeTEsIHkyLCB5MywgeTQpLFxuICAgICAgICAgICAgICAgIGNvbWIgPSB4YmFzZSAqIHhiYXNlICsgeWJhc2UgKiB5YmFzZTtcbiAgICAgICAgICAgIHN1bSArPSBDdmFsdWVzW2ldICogbWF0aC5zcXJ0KGNvbWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6MiAqIHN1bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGF0TGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGwpIHtcbiAgICAgICAgaWYgKGxsIDwgMCB8fCBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSA8IGxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSAxLFxuICAgICAgICAgICAgc3RlcCA9IHQgLyAyLFxuICAgICAgICAgICAgdDIgPSB0IC0gc3RlcCxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlID0gLjAxO1xuICAgICAgICBsID0gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdDIpO1xuICAgICAgICB3aGlsZSAoYWJzKGwgLSBsbCkgPiBlKSB7XG4gICAgICAgICAgICBzdGVwIC89IDI7XG4gICAgICAgICAgICB0MiArPSAobCA8IGxsID8gMSA6IC0xKSAqIHN0ZXA7XG4gICAgICAgICAgICBsID0gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0MjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtbWF4KHgxLCB4MikgPCBtbWluKHgzLCB4NCkgfHxcbiAgICAgICAgICAgIG1taW4oeDEsIHgyKSA+IG1tYXgoeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1heCh5MSwgeTIpIDwgbW1pbih5MywgeTQpIHx8XG4gICAgICAgICAgICBtbWluKHkxLCB5MikgPiBtbWF4KHkzLCB5NClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG54ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh4MyAtIHg0KSAtICh4MSAtIHgyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBueSA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgICAgICAgICAgZGVub21pbmF0b3IgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG5cbiAgICAgICAgaWYgKCFkZW5vbWluYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBweCA9IG54IC8gZGVub21pbmF0b3IsXG4gICAgICAgICAgICBweSA9IG55IC8gZGVub21pbmF0b3IsXG4gICAgICAgICAgICBweDIgPSArcHgudG9GaXhlZCgyKSxcbiAgICAgICAgICAgIHB5MiA9ICtweS50b0ZpeGVkKDIpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBweDIgPCArbW1pbih4MSwgeDIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyIDwgK21taW4oeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPiArbW1heCh4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPCArbW1pbih5MywgeTQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA+ICttbWF4KHkzLCB5NCkudG9GaXhlZCgyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3g6IHB4LCB5OiBweX07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyKGJlejEsIGJlejIpIHtcbiAgICAgICAgcmV0dXJuIGludGVySGVscGVyKGJlejEsIGJlejIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlckNvdW50KGJlejEsIGJlejIpIHtcbiAgICAgICAgcmV0dXJuIGludGVySGVscGVyKGJlejEsIGJlejIsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlckhlbHBlcihiZXoxLCBiZXoyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgdmFyIGJib3gxID0gUi5iZXppZXJCQm94KGJlejEpLFxuICAgICAgICAgICAgYmJveDIgPSBSLmJlemllckJCb3goYmV6Mik7XG4gICAgICAgIGlmICghUi5pc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbDEgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MSksXG4gICAgICAgICAgICBsMiA9IGJlemxlbi5hcHBseSgwLCBiZXoyKSxcbiAgICAgICAgICAgIG4xID0gbW1heCh+fihsMSAvIDUpLCAxKSxcbiAgICAgICAgICAgIG4yID0gbW1heCh+fihsMiAvIDUpLCAxKSxcbiAgICAgICAgICAgIGRvdHMxID0gW10sXG4gICAgICAgICAgICBkb3RzMiA9IFtdLFxuICAgICAgICAgICAgeHkgPSB7fSxcbiAgICAgICAgICAgIHJlcyA9IGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMSArIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBSLmZpbmREb3RzQXRTZWdtZW50LmFwcGx5KFIsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgICAgICAgICAgZG90czEucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgICAgICAgICAgcCA9IFIuZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoUiwgYmV6Mi5jb25jYXQoaSAvIG4yKSk7XG4gICAgICAgICAgICBkb3RzMi5wdXNoKHt4OiBwLngsIHk6IHAueSwgdDogaSAvIG4yfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4xOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkaSA9IGRvdHMxW2ldLFxuICAgICAgICAgICAgICAgICAgICBkaTEgPSBkb3RzMVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRqID0gZG90czJbal0sXG4gICAgICAgICAgICAgICAgICAgIGRqMSA9IGRvdHMyW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgY2kgPSBhYnMoZGkxLnggLSBkaS54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBjaiA9IGFicyhkajEueCAtIGRqLngpIDwgLjAwMSA/IFwieVwiIDogXCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcbiAgICAgICAgICAgICAgICBpZiAoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh5W2lzLngudG9GaXhlZCg0KV0gPT0gaXMueS50b0ZpeGVkKDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4eVtpcy54LnRvRml4ZWQoNCldID0gaXMueS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSBkaS50ICsgYWJzKChpc1tjaV0gLSBkaVtjaV0pIC8gKGRpMVtjaV0gLSBkaVtjaV0pKSAqIChkaTEudCAtIGRpLnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBkai50ICsgYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxLjAwMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEuMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaXMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDE6IG1taW4odDEsIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MjogbW1pbih0MiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5wYXRoSW50ZXJzZWN0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIEZpbmRzIGludGVyc2VjdGlvbnMgb2YgdHdvIHBhdGhzXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIG8gICAgICAgICB0MTogKG51bWJlcikgdCB2YWx1ZSBmb3Igc2VnbWVudCBvZiBwYXRoMVxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgICAgIHNlZ21lbnQxOiAobnVtYmVyKSBvcmRlciBudW1iZXIgZm9yIHNlZ21lbnQgb2YgcGF0aDFcbiAgICAgbyAgICAgICAgIHNlZ21lbnQyOiAobnVtYmVyKSBvcmRlciBudW1iZXIgZm9yIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxXG4gICAgIG8gICAgICAgICBiZXoyOiAoYXJyYXkpIGVpZ2h0IGNvb3JkaW5hdGVzIHJlcHJlc2VudGluZyBiZXppw6lyIGN1cnZlIGZvciB0aGUgc2VnbWVudCBvZiBwYXRoMlxuICAgICBvICAgICB9XG4gICAgIG8gXVxuICAgIFxcKi9cbiAgICBSLnBhdGhJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIHJldHVybiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyKTtcbiAgICB9O1xuICAgIFIucGF0aEludGVyc2VjdGlvbk51bWJlciA9IGZ1bmN0aW9uIChwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIDEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwganVzdENvdW50KSB7XG4gICAgICAgIHBhdGgxID0gUi5fcGF0aDJjdXJ2ZShwYXRoMSk7XG4gICAgICAgIHBhdGgyID0gUi5fcGF0aDJjdXJ2ZShwYXRoMik7XG4gICAgICAgIHZhciB4MSwgeTEsIHgyLCB5MiwgeDFtLCB5MW0sIHgybSwgeTJtLCBiZXoxLCBiZXoyLFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGkgPSBwYXRoMVtpXTtcbiAgICAgICAgICAgIGlmIChwaVswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgICAgIHgxID0geDFtID0gcGlbMV07XG4gICAgICAgICAgICAgICAgeTEgPSB5MW0gPSBwaVsyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxXS5jb25jYXQocGkuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IGJlejFbNl07XG4gICAgICAgICAgICAgICAgICAgIHkxID0gYmV6MVs3XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZXoxID0gW3gxLCB5MSwgeDEsIHkxLCB4MW0sIHkxbSwgeDFtLCB5MW1dO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHgxbTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHBhdGgyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBqID0gcGF0aDJbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIk1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm0gPSBwalsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTJtID0gcGpbMl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGpbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXoyID0gW3gyLCB5Ml0uY29uY2F0KHBqLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGJlejJbNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBiZXoyWzddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXoyID0gW3gyLCB5MiwgeDIsIHkyLCB4Mm0sIHkybSwgeDJtLCB5Mm1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geDJtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTJtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludHIgPSBpbnRlckhlbHBlcihiZXoxLCBiZXoyLCBqdXN0Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBpbnRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBpbnRyLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uc2VnbWVudDIgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLmJlejEgPSBiZXoxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLmJlejIgPSBiZXoyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGludHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmlzUG9pbnRJbnNpZGVQYXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgdHJ1ZSwgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBwYXRoXG4gICAgXFwqL1xuICAgIFIuaXNQb2ludEluc2lkZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgeCwgeSkge1xuICAgICAgICB2YXIgYmJveCA9IFIucGF0aEJCb3gocGF0aCk7XG4gICAgICAgIHJldHVybiBSLmlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpICYmXG4gICAgICAgICAgICAgICBpbnRlclBhdGhIZWxwZXIocGF0aCwgW1tcIk1cIiwgeCwgeV0sIFtcIkhcIiwgYmJveC54MiArIDEwXV0sIDEpICUgMiA9PSAxO1xuICAgIH07XG4gICAgUi5fcmVtb3ZlZEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5sb2dcIiwgbnVsbCwgXCJSYXBoYVxceGVibDogeW91IGFyZSBjYWxsaW5nIHRvIG1ldGhvZCBcXHUyMDFjXCIgKyBtZXRob2RuYW1lICsgXCJcXHUyMDFkIG9mIHJlbW92ZWQgb2JqZWN0XCIsIG1ldGhvZG5hbWUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwucGF0aEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJuIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIHBhdGhcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94XG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveFxuICAgICBvICAgICB4MjogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGggb2YgdGhlIGJveFxuICAgICBvICAgICBoZWlnaHQ6IChudW1iZXIpIGhlaWdodCBvZiB0aGUgYm94XG4gICAgIG8gICAgIGN4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgYm94XG4gICAgIG8gICAgIGN5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgYm94XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICB2YXIgcGF0aERpbWVuc2lvbnMgPSBSLnBhdGhCQm94ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuICAgICAgICBpZiAocHRoLmJib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4ge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHgyOiAwLCB5MjogMH07XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgWCA9IFtdLFxuICAgICAgICAgICAgWSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBbMV07XG4gICAgICAgICAgICAgICAgeSA9IHBbMl07XG4gICAgICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIFkucHVzaCh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgIFggPSBYW2NvbmNhdF0oZGltLm1pbi54LCBkaW0ubWF4LngpO1xuICAgICAgICAgICAgICAgIFkgPSBZW2NvbmNhdF0oZGltLm1pbi55LCBkaW0ubWF4LnkpO1xuICAgICAgICAgICAgICAgIHggPSBwWzVdO1xuICAgICAgICAgICAgICAgIHkgPSBwWzZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB4bWluID0gbW1pblthcHBseV0oMCwgWCksXG4gICAgICAgICAgICB5bWluID0gbW1pblthcHBseV0oMCwgWSksXG4gICAgICAgICAgICB4bWF4ID0gbW1heFthcHBseV0oMCwgWCksXG4gICAgICAgICAgICB5bWF4ID0gbW1heFthcHBseV0oMCwgWSksXG4gICAgICAgICAgICB3aWR0aCA9IHhtYXggLSB4bWluLFxuICAgICAgICAgICAgaGVpZ2h0ID0geW1heCAtIHltaW4sXG4gICAgICAgICAgICAgICAgYmIgPSB7XG4gICAgICAgICAgICAgICAgeDogeG1pbixcbiAgICAgICAgICAgICAgICB5OiB5bWluLFxuICAgICAgICAgICAgICAgIHgyOiB4bWF4LFxuICAgICAgICAgICAgICAgIHkyOiB5bWF4LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICBjeDogeG1pbiArIHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICBjeTogeW1pbiArIGhlaWdodCAvIDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIHB0aC5iYm94ID0gY2xvbmUoYmIpO1xuICAgICAgICByZXR1cm4gYmI7XG4gICAgfSxcbiAgICAgICAgcGF0aENsb25lID0gZnVuY3Rpb24gKHBhdGhBcnJheSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGNsb25lKHBhdGhBcnJheSk7XG4gICAgICAgICAgICByZXMudG9TdHJpbmcgPSBSLl9wYXRoMnN0cmluZztcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGhUb1JlbGF0aXZlID0gUi5fcGF0aFRvUmVsYXRpdmUgPSBmdW5jdGlvbiAocGF0aEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcbiAgICAgICAgICAgIGlmIChwdGgucmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDbG9uZShwdGgucmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUi5pcyhwYXRoQXJyYXksIGFycmF5KSB8fCAhUi5pcyhwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdLCBhcnJheSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgICAgIHBhdGhBcnJheSA9IFIucGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgICAgIG15ID0gMCxcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBhdGhBcnJheVswXVsxXTtcbiAgICAgICAgICAgICAgICB5ID0gcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgICAgICBteSA9IHk7XG4gICAgICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgICAgICByZXMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmVzW2ldID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYVswXSAhPSBsb3dlckNhc2UuY2FsbChwYVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgclswXSA9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls2XSA9ICsocGFbNl0gLSB4KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddIC0geSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICsocGFbMV0gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICsocGFbal0gLSAoKGogJSAyKSA/IHggOiB5KSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByID0gcmVzW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYVswXSA9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSBwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHBhWzJdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaV1ba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gcmVzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc1tpXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG14O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG15O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gK3Jlc1tpXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSArcmVzW2ldW2xlbiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy50b1N0cmluZyA9IFIuX3BhdGgyc3RyaW5nO1xuICAgICAgICAgICAgcHRoLnJlbCA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aFRvQWJzb2x1dGUgPSBSLl9wYXRoVG9BYnNvbHV0ZSA9IGZ1bmN0aW9uIChwYXRoQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBwdGggPSBwYXRocyhwYXRoQXJyYXkpO1xuICAgICAgICAgICAgaWYgKHB0aC5hYnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSLmlzKHBhdGhBcnJheSwgYXJyYXkpIHx8ICFSLmlzKHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0sIGFycmF5KSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5ID0gUi5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIDAsIDBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgICAgICBteCA9IDAsXG4gICAgICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmIChwYXRoQXJyYXlbMF1bMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICAgICAgICAgICAgICB5ID0gK3BhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgICAgICBteCA9IHg7XG4gICAgICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgcmVzWzBdID0gW1wiTVwiLCB4LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcnogPSBwYXRoQXJyYXkubGVuZ3RoID09IDMgJiYgcGF0aEFycmF5WzBdWzBdID09IFwiTVwiICYmIHBhdGhBcnJheVsxXVswXS50b1VwcGVyQ2FzZSgpID09IFwiUlwiICYmIHBhdGhBcnJheVsyXVswXS50b1VwcGVyQ2FzZSgpID09IFwiWlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgciwgcGEsIGkgPSBzdGFydCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhWzBdICE9IHVwcGVyQ2FzZS5jYWxsKHBhWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByWzBdID0gdXBwZXJDYXNlLmNhbGwocGFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzZdID0gKyhwYVs2XSArIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddICsgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdHMgPSBbeCwgeV1bY29uY2F0XShwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDIsIGpqID0gZG90cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbal0gPSArZG90c1tqXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbKytqXSA9ICtkb3RzW2pdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlc1tjb25jYXRdKGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteCA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFbMF0gPT0gXCJSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90cyA9IFt4LCB5XVtjb25jYXRdKHBhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbY29uY2F0XShjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICAgICAgICAgICAgciA9IFtcIlJcIl1bY29uY2F0XShwYS5zbGljZSgtMikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBteTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnRvU3RyaW5nID0gUi5fcGF0aDJzdHJpbmc7XG4gICAgICAgICAgICBwdGguYWJzID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBsMmMgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml07XG4gICAgICAgIH0sXG4gICAgICAgIHEyYyA9IGZ1bmN0aW9uICh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG4gICAgICAgICAgICB2YXIgXzEzID0gMSAvIDMsXG4gICAgICAgICAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBfMTMgKiB4MSArIF8yMyAqIGF4LFxuICAgICAgICAgICAgICAgICAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgICAgICBfMTMgKiB4MiArIF8yMyAqIGF4LFxuICAgICAgICAgICAgICAgICAgICBfMTMgKiB5MiArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICAgICAgeTJcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBhMmMgPSBmdW5jdGlvbiAoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgICAgIHZhciBfMTIwID0gUEkgKiAxMjAgLyAxODAsXG4gICAgICAgICAgICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHh5LFxuICAgICAgICAgICAgICAgIHJvdGF0ZSA9IGNhY2hlcihmdW5jdGlvbiAoeCwgeSwgcmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFkgPSB4ICogbWF0aC5zaW4ocmFkKSArIHkgKiBtYXRoLmNvcyhyYWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3g6IFgsIHk6IFl9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICB4eSA9IHJvdGF0ZSh4MSwgeTEsIC1yYWQpO1xuICAgICAgICAgICAgICAgIHgxID0geHkueDtcbiAgICAgICAgICAgICAgICB5MSA9IHh5Lnk7XG4gICAgICAgICAgICAgICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICAgICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICAgICAgeTIgPSB4eS55O1xuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBtYXRoLmNvcyhQSSAvIDE4MCAqIGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgc2luID0gbWF0aC5zaW4oUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHggPSAoeDEgLSB4MikgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9ICh4ICogeCkgLyAocnggKiByeCkgKyAoeSAqIHkpIC8gKHJ5ICogcnkpO1xuICAgICAgICAgICAgICAgIGlmIChoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgICAgICAgICByeCA9IGggKiByeDtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBoICogcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByeDIgPSByeCAqIHJ4LFxuICAgICAgICAgICAgICAgICAgICByeTIgPSByeSAqIHJ5LFxuICAgICAgICAgICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGguc3FydChhYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSksXG4gICAgICAgICAgICAgICAgICAgIGN4ID0gayAqIHJ4ICogeSAvIHJ5ICsgKHgxICsgeDIpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgZjEgPSBtYXRoLmFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKSxcbiAgICAgICAgICAgICAgICAgICAgZjIgPSBtYXRoLmFzaW4oKCh5MiAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcblxuICAgICAgICAgICAgICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICAgICAgICAgICAgICBmMiA9IHgyIDwgY3ggPyBQSSAtIGYyIDogZjI7XG4gICAgICAgICAgICAgICAgZjEgPCAwICYmIChmMSA9IFBJICogMiArIGYxKTtcbiAgICAgICAgICAgICAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuICAgICAgICAgICAgICAgIGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgZjEgPSBmMSAtIFBJICogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzd2VlcF9mbGFnICYmIGYyID4gZjEpIHtcbiAgICAgICAgICAgICAgICAgICAgZjIgPSBmMiAtIFBJICogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGYxID0gcmVjdXJzaXZlWzBdO1xuICAgICAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgICAgIGN4ID0gcmVjdXJzaXZlWzJdO1xuICAgICAgICAgICAgICAgIGN5ID0gcmVjdXJzaXZlWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRmID0gZjIgLSBmMTtcbiAgICAgICAgICAgIGlmIChhYnMoZGYpID4gXzEyMCkge1xuICAgICAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICAgICAgICAgICAgICB4Mm9sZCA9IHgyLFxuICAgICAgICAgICAgICAgICAgICB5Mm9sZCA9IHkyO1xuICAgICAgICAgICAgICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgeDIgPSBjeCArIHJ4ICogbWF0aC5jb3MoZjIpO1xuICAgICAgICAgICAgICAgIHkyID0gY3kgKyByeSAqIG1hdGguc2luKGYyKTtcbiAgICAgICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGYgPSBmMiAtIGYxO1xuICAgICAgICAgICAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgICAgICAgICAgIHMxID0gbWF0aC5zaW4oZjEpLFxuICAgICAgICAgICAgICAgIGMyID0gbWF0aC5jb3MoZjIpLFxuICAgICAgICAgICAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgICAgICAgICAgIHQgPSBtYXRoLnRhbihkZiAvIDQpLFxuICAgICAgICAgICAgICAgIGh4ID0gNCAvIDMgKiByeCAqIHQsXG4gICAgICAgICAgICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgICAgICAgICAgICBtMSA9IFt4MSwgeTFdLFxuICAgICAgICAgICAgICAgIG0yID0gW3gxICsgaHggKiBzMSwgeTEgLSBoeSAqIGMxXSxcbiAgICAgICAgICAgICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICAgICAgICAgICAgbTQgPSBbeDIsIHkyXTtcbiAgICAgICAgICAgIG0yWzBdID0gMiAqIG0xWzBdIC0gbTJbMF07XG4gICAgICAgICAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbTIsIG0zLCBtNF1bY29uY2F0XShyZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBbbTIsIG0zLCBtNF1bY29uY2F0XShyZXMpLmpvaW4oKVtzcGxpdF0oXCIsXCIpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZERvdEF0U2VnbWVudCA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdCkge1xuICAgICAgICAgICAgdmFyIHQxID0gMSAtIHQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvdyh0MSwgMykgKiBwMXggKyBwb3codDEsIDIpICogMyAqIHQgKiBjMXggKyB0MSAqIDMgKiB0ICogdCAqIGMyeCArIHBvdyh0LCAzKSAqIHAyeCxcbiAgICAgICAgICAgICAgICB5OiBwb3codDEsIDMpICogcDF5ICsgcG93KHQxLCAyKSAqIDMgKiB0ICogYzF5ICsgdDEgKiAzICogdCAqIHQgKiBjMnkgKyBwb3codCwgMykgKiBwMnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnZlRGltID0gY2FjaGVyKGZ1bmN0aW9uIChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSkge1xuICAgICAgICAgICAgdmFyIGEgPSAoYzJ4IC0gMiAqIGMxeCArIHAxeCkgLSAocDJ4IC0gMiAqIGMyeCArIGMxeCksXG4gICAgICAgICAgICAgICAgYiA9IDIgKiAoYzF4IC0gcDF4KSAtIDIgKiAoYzJ4IC0gYzF4KSxcbiAgICAgICAgICAgICAgICBjID0gcDF4IC0gYzF4LFxuICAgICAgICAgICAgICAgIHQxID0gKC1iICsgbWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAyIC8gYSxcbiAgICAgICAgICAgICAgICB0MiA9ICgtYiAtIG1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gMiAvIGEsXG4gICAgICAgICAgICAgICAgeSA9IFtwMXksIHAyeV0sXG4gICAgICAgICAgICAgICAgeCA9IFtwMXgsIHAyeF0sXG4gICAgICAgICAgICAgICAgZG90O1xuICAgICAgICAgICAgYWJzKHQxKSA+IFwiMWUxMlwiICYmICh0MSA9IC41KTtcbiAgICAgICAgICAgIGFicyh0MikgPiBcIjFlMTJcIiAmJiAodDIgPSAuNSk7XG4gICAgICAgICAgICBpZiAodDEgPiAwICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgICAgIGRvdCA9IGZpbmREb3RBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQxKTtcbiAgICAgICAgICAgICAgICB4LnB1c2goZG90LngpO1xuICAgICAgICAgICAgICAgIHkucHVzaChkb3QueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkge1xuICAgICAgICAgICAgICAgIGRvdCA9IGZpbmREb3RBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQyKTtcbiAgICAgICAgICAgICAgICB4LnB1c2goZG90LngpO1xuICAgICAgICAgICAgICAgIHkucHVzaChkb3QueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gKGMyeSAtIDIgKiBjMXkgKyBwMXkpIC0gKHAyeSAtIDIgKiBjMnkgKyBjMXkpO1xuICAgICAgICAgICAgYiA9IDIgKiAoYzF5IC0gcDF5KSAtIDIgKiAoYzJ5IC0gYzF5KTtcbiAgICAgICAgICAgIGMgPSBwMXkgLSBjMXk7XG4gICAgICAgICAgICB0MSA9ICgtYiArIG1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gMiAvIGE7XG4gICAgICAgICAgICB0MiA9ICgtYiAtIG1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gMiAvIGE7XG4gICAgICAgICAgICBhYnModDEpID4gXCIxZTEyXCIgJiYgKHQxID0gLjUpO1xuICAgICAgICAgICAgYWJzKHQyKSA+IFwiMWUxMlwiICYmICh0MiA9IC41KTtcbiAgICAgICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDEpO1xuICAgICAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICAgICAgeS5wdXNoKGRvdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+IDAgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICAgICAgZG90ID0gZmluZERvdEF0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgdDIpO1xuICAgICAgICAgICAgICAgIHgucHVzaChkb3QueCk7XG4gICAgICAgICAgICAgICAgeS5wdXNoKGRvdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiB7eDogbW1pblthcHBseV0oMCwgeCksIHk6IG1taW5bYXBwbHldKDAsIHkpfSxcbiAgICAgICAgICAgICAgICBtYXg6IHt4OiBtbWF4W2FwcGx5XSgwLCB4KSwgeTogbW1heFthcHBseV0oMCwgeSl9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcGF0aDJjdXJ2ZSA9IFIuX3BhdGgyY3VydmUgPSBjYWNoZXIoZnVuY3Rpb24gKHBhdGgsIHBhdGgyKSB7XG4gICAgICAgICAgICB2YXIgcHRoID0gIXBhdGgyICYmIHBhdGhzKHBhdGgpO1xuICAgICAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5jdXJ2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgICAgIHAyID0gcGF0aDIgJiYgcGF0aFRvQWJzb2x1dGUocGF0aDIpLFxuICAgICAgICAgICAgICAgIGF0dHJzID0ge3g6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsfSxcbiAgICAgICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgICAgIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGQsIHBjb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54LCBueSwgdHEgPSB7VDoxLCBROjF9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICEocGF0aFswXSBpbiB0cSkgJiYgKGQucXggPSBkLnF5ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0oYTJjW2FwcGx5XSgwLCBbZC54LCBkLnldW2NvbmNhdF0ocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjb20gPT0gXCJDXCIgfHwgcGNvbSA9PSBcIlNcIikgeyAvLyBJbiBcIlNcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIEMvUy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gZC55ICogMiAtIGQuYnk7ICAgICAgICAgIC8vIGNvbW1hbmQncyBjb250cm9sIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiLCBueCwgbnldW2NvbmNhdF0ocGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09IFwiUVwiIHx8IHBjb20gPT0gXCJUXCIpIHsgLy8gSW4gXCJUXCIgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBRL1QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgICAgICAgIC8vIHRvIGNhc2UgXCJTXCIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0ocTJjKGQueCwgZC55LCBkLnF4LCBkLnF5LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0ocTJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdLCBwYXRoWzNdLCBwYXRoWzRdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0obDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdW2NvbmNhdF0obDJjKGQueCwgZC55LCBwYXRoWzFdLCBkLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl1bY29uY2F0XShsMmMoZC54LCBkLnksIGQueCwgcGF0aFsxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXVtjb25jYXRdKGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpeEFyYyA9IGZ1bmN0aW9uIChwcCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHBbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IHBwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjb21zMVtpXT1cIkFcIjsgLy8gaWYgY3JlYXRlZCBtdWx0aXBsZSBDOnMsIHRoZWlyIG9yaWdpbmFsIHNlZyBpcyBzYXZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyICYmIChwY29tczJbaV09XCJBXCIpOyAvLyB0aGUgc2FtZSBhcyBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLnNwbGljZShpKyssIDAsIFtcIkNcIl1bY29uY2F0XShwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoMSAmJiBwYXRoMiAmJiBwYXRoMVtpXVswXSA9PSBcIk1cIiAmJiBwYXRoMltpXVswXSAhPSBcIk1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDIuc3BsaWNlKGksIDAsIFtcIk1cIiwgYTIueCwgYTIueV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYTEuYnggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYTEuYnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYTEueCA9IHBhdGgxW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYTEueSA9IHBhdGgxW2ldWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWkgPSBtbWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBjb21zMSA9IFtdLCAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcFxuICAgICAgICAgICAgICAgIHBjb21zMiA9IFtdLCAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcDJcbiAgICAgICAgICAgICAgICBwZmlyc3QgPSBcIlwiLCAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBwY29tID0gXCJcIjsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gJiYgKHBmaXJzdCA9IHBbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgaSAmJiAoIHBjb20gPSBwY29tczFbaS0xXSk7IC8vIEdldCBwcmV2aW91cyBwYXRoIGNvbW1hbmQgcGNvbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgICAgICAgICAgICAgIGlmIChwY29tczFbaV0gIT0gXCJBXCIgJiYgcGZpcnN0ID09IFwiQ1wiKSBwY29tczFbaV0gPSBcIkNcIjsgLy8gQSBpcyB0aGUgb25seSBjb21tYW5kXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBDIGlzIGFsc28gQyBpbiBvcmlnaW5hbCBwYXRoXG5cbiAgICAgICAgICAgICAgICBmaXhBcmMocCwgaSk7IC8vIGZpeEFyYyBhZGRzIGFsc28gdGhlIHJpZ2h0IGFtb3VudCBvZiBBOnMgdG8gcGNvbXMxXG5cbiAgICAgICAgICAgICAgICBpZiAocDIpIHsgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICAgICAgICAgIHAyW2ldICYmIChwZmlyc3QgPSBwMltpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgJiYgKHBjb20gPSBwY29tczJbaS0xXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcDJbaV0gPSBwcm9jZXNzUGF0aChwMltpXSwgYXR0cnMyLCBwY29tKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGNvbXMyW2ldIT1cIkFcIiAmJiBwZmlyc3Q9PVwiQ1wiKSBwY29tczJbaV09XCJDXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgZml4QXJjKHAyLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZml4TShwLCBwMiwgYXR0cnMsIGF0dHJzMiwgaSk7XG4gICAgICAgICAgICAgICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHBbaV0sXG4gICAgICAgICAgICAgICAgICAgIHNlZzIgPSBwMiAmJiBwMltpXSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGF0dHJzLnggPSBzZWdbc2VnbGVuIC0gMl07XG4gICAgICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBhdHRycy5ieCA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgICAgICAgICAgICAgIGF0dHJzLmJ5ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gM10pIHx8IGF0dHJzLnk7XG4gICAgICAgICAgICAgICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHRvRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICAgICAgICAgICAgICBhdHRyczIuYnkgPSBwMiAmJiAodG9GbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgICAgICAgICAgICAgIGF0dHJzMi54ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMl07XG4gICAgICAgICAgICAgICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcDIpIHtcbiAgICAgICAgICAgICAgICBwdGguY3VydmUgPSBwYXRoQ2xvbmUocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDIgPyBbcCwgcDJdIDogcDtcbiAgICAgICAgfSwgbnVsbCwgcGF0aENsb25lKSxcbiAgICAgICAgcGFyc2VEb3RzID0gUi5fcGFyc2VEb3RzID0gY2FjaGVyKGZ1bmN0aW9uIChncmFkaWVudCkge1xuICAgICAgICAgICAgdmFyIGRvdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGdyYWRpZW50Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90ID0ge30sXG4gICAgICAgICAgICAgICAgICAgIHBhciA9IGdyYWRpZW50W2ldLm1hdGNoKC9eKFteOl0qKTo/KFtcXGRcXC5dKikvKTtcbiAgICAgICAgICAgICAgICBkb3QuY29sb3IgPSBSLmdldFJHQihwYXJbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChkb3QuY29sb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvdC5vcGFjaXR5ID0gZG90LmNvbG9yLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgZG90LmNvbG9yID0gZG90LmNvbG9yLmhleDtcbiAgICAgICAgICAgICAgICBwYXJbMl0gJiYgKGRvdC5vZmZzZXQgPSBwYXJbMl0gKyBcIiVcIik7XG4gICAgICAgICAgICAgICAgZG90cy5wdXNoKGRvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBpaSA9IGRvdHMubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvdHNbaV0ub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRvRmxvYXQoZG90c1tpIC0gMV0ub2Zmc2V0IHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgaWk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvdHNbal0ub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gZG90c1tqXS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0b0Zsb2F0KGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gKGVuZCAtIHN0YXJ0KSAvIChqIC0gaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbaV0ub2Zmc2V0ID0gc3RhcnQgKyBcIiVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb3RzO1xuICAgICAgICB9KSxcbiAgICAgICAgdGVhciA9IFIuX3RlYXIgPSBmdW5jdGlvbiAoZWwsIHBhcGVyKSB7XG4gICAgICAgICAgICBlbCA9PSBwYXBlci50b3AgJiYgKHBhcGVyLnRvcCA9IGVsLnByZXYpO1xuICAgICAgICAgICAgZWwgPT0gcGFwZXIuYm90dG9tICYmIChwYXBlci5ib3R0b20gPSBlbC5uZXh0KTtcbiAgICAgICAgICAgIGVsLm5leHQgJiYgKGVsLm5leHQucHJldiA9IGVsLnByZXYpO1xuICAgICAgICAgICAgZWwucHJldiAmJiAoZWwucHJldi5uZXh0ID0gZWwubmV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZnJvbnQgPSBSLl90b2Zyb250ID0gZnVuY3Rpb24gKGVsLCBwYXBlcikge1xuICAgICAgICAgICAgaWYgKHBhcGVyLnRvcCA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZWFyKGVsLCBwYXBlcik7XG4gICAgICAgICAgICBlbC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGVsLnByZXYgPSBwYXBlci50b3A7XG4gICAgICAgICAgICBwYXBlci50b3AubmV4dCA9IGVsO1xuICAgICAgICAgICAgcGFwZXIudG9wID0gZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHRvYmFjayA9IFIuX3RvYmFjayA9IGZ1bmN0aW9uIChlbCwgcGFwZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXBlci5ib3R0b20gPT09IGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVhcihlbCwgcGFwZXIpO1xuICAgICAgICAgICAgZWwubmV4dCA9IHBhcGVyLmJvdHRvbTtcbiAgICAgICAgICAgIGVsLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgcGFwZXIuYm90dG9tLnByZXYgPSBlbDtcbiAgICAgICAgICAgIHBhcGVyLmJvdHRvbSA9IGVsO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRhZnRlciA9IFIuX2luc2VydGFmdGVyID0gZnVuY3Rpb24gKGVsLCBlbDIsIHBhcGVyKSB7XG4gICAgICAgICAgICB0ZWFyKGVsLCBwYXBlcik7XG4gICAgICAgICAgICBlbDIgPT0gcGFwZXIudG9wICYmIChwYXBlci50b3AgPSBlbCk7XG4gICAgICAgICAgICBlbDIubmV4dCAmJiAoZWwyLm5leHQucHJldiA9IGVsKTtcbiAgICAgICAgICAgIGVsLm5leHQgPSBlbDIubmV4dDtcbiAgICAgICAgICAgIGVsLnByZXYgPSBlbDI7XG4gICAgICAgICAgICBlbDIubmV4dCA9IGVsO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRiZWZvcmUgPSBSLl9pbnNlcnRiZWZvcmUgPSBmdW5jdGlvbiAoZWwsIGVsMiwgcGFwZXIpIHtcbiAgICAgICAgICAgIHRlYXIoZWwsIHBhcGVyKTtcbiAgICAgICAgICAgIGVsMiA9PSBwYXBlci5ib3R0b20gJiYgKHBhcGVyLmJvdHRvbSA9IGVsKTtcbiAgICAgICAgICAgIGVsMi5wcmV2ICYmIChlbDIucHJldi5uZXh0ID0gZWwpO1xuICAgICAgICAgICAgZWwucHJldiA9IGVsMi5wcmV2O1xuICAgICAgICAgICAgZWwyLnByZXYgPSBlbDtcbiAgICAgICAgICAgIGVsLm5leHQgPSBlbDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUmFwaGFlbC50b01hdHJpeFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIHRvIGEgZ2l2ZW4gcGF0aFxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHBhdGggKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgICAgIC0gdHJhbnNmb3JtIChzdHJpbmd8YXJyYXkpIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICAgICAgPSAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgdG9NYXRyaXggPSBSLnRvTWF0cml4ID0gZnVuY3Rpb24gKHBhdGgsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIGJiID0gcGF0aERpbWVuc2lvbnMocGF0aCksXG4gICAgICAgICAgICAgICAgZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIF86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogRVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRCQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXh0cmFjdFRyYW5zZm9ybShlbCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHJldHVybiBlbC5tYXRyaXg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUmFwaGFlbC50cmFuc2Zvcm1QYXRoXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBwYXRoIHRyYW5zZm9ybWVkIGJ5IGEgZ2l2ZW4gdHJhbnNmb3JtYXRpb25cbiAgICAgICAgID4gUGFyYW1ldGVyc1xuICAgICAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgICAgICAtIHRyYW5zZm9ybSAoc3RyaW5nfGFycmF5KSB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdcbiAgICAgICAgID0gKHN0cmluZykgcGF0aFxuICAgICAgICBcXCovXG4gICAgICAgIHRyYW5zZm9ybVBhdGggPSBSLnRyYW5zZm9ybVBhdGggPSBmdW5jdGlvbiAocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwUGF0aChwYXRoLCB0b01hdHJpeChwYXRoLCB0cmFuc2Zvcm0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFjdFRyYW5zZm9ybSA9IFIuX2V4dHJhY3RUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZWwsIHRzdHIpIHtcbiAgICAgICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuXy50cmFuc2Zvcm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGVsLl8udHJhbnNmb3JtIHx8IEUpO1xuICAgICAgICAgICAgdmFyIHRkYXRhID0gUi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0c3RyKSxcbiAgICAgICAgICAgICAgICBkZWcgPSAwLFxuICAgICAgICAgICAgICAgIGR4ID0gMCxcbiAgICAgICAgICAgICAgICBkeSA9IDAsXG4gICAgICAgICAgICAgICAgc3ggPSAxLFxuICAgICAgICAgICAgICAgIHN5ID0gMSxcbiAgICAgICAgICAgICAgICBfID0gZWwuXyxcbiAgICAgICAgICAgICAgICBtID0gbmV3IE1hdHJpeDtcbiAgICAgICAgICAgIF8udHJhbnNmb3JtID0gdGRhdGEgfHwgW107XG4gICAgICAgICAgICBpZiAodGRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bGVuID0gdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gU3RyKHRbMF0pLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZSA9IHRbMF0gIT0gY29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmVyID0gYWJzb2x1dGUgPyBtLmludmVydCgpIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09IFwidFwiICYmIHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBpbnZlci54KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gaW52ZXIueSgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsxXSwgdFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwiclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBlbC5nZXRCQm94KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIGJiLnggKyBiYi53aWR0aCAvIDIsIGJiLnkgKyBiYi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWcgKz0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzJdLCB0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnJvdGF0ZSh0WzFdLCB4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWcgKz0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwic1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyIHx8IHRsZW4gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiID0gYmIgfHwgZWwuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbdGxlbiAtIDFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ggKj0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeSAqPSB0W3RsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zY2FsZSh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ggKj0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeSAqPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJtXCIgJiYgdGxlbiA9PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmFkZCh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdLCB0WzZdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfLmRpcnR5VCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxcXG4gICAgICAgICAgICAgKiBFbGVtZW50Lm1hdHJpeFxuICAgICAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgICAgICoqXG4gICAgICAgICAgICAgKiBLZWVwcyBATWF0cml4IG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyBlbGVtZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICBcXCovXG4gICAgICAgICAgICBlbC5tYXRyaXggPSBtO1xuXG4gICAgICAgICAgICBfLnN4ID0gc3g7XG4gICAgICAgICAgICBfLnN5ID0gc3k7XG4gICAgICAgICAgICBfLmRlZyA9IGRlZztcbiAgICAgICAgICAgIF8uZHggPSBkeCA9IG0uZTtcbiAgICAgICAgICAgIF8uZHkgPSBkeSA9IG0uZjtcblxuICAgICAgICAgICAgaWYgKHN4ID09IDEgJiYgc3kgPT0gMSAmJiAhZGVnICYmIF8uYmJveCkge1xuICAgICAgICAgICAgICAgIF8uYmJveC54ICs9ICtkeDtcbiAgICAgICAgICAgICAgICBfLmJib3gueSArPSArZHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uZGlydHlUID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RW1wdHkgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGwgPSBpdGVtWzBdO1xuICAgICAgICAgICAgc3dpdGNoIChsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOiByZXR1cm4gW2wsIDAsIDBdO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiBbbCwgMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICAgICAgY2FzZSBcInJcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAwLCBpdGVtWzJdLCBpdGVtWzNdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOiBpZiAoaXRlbS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDEsIGl0ZW1bM10sIGl0ZW1bNF1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbCwgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcXVhbGlzZVRyYW5zZm9ybSA9IFIuX2VxdWFsaXNlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHQxLCB0Mikge1xuICAgICAgICAgICAgdDIgPSBTdHIodDIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIHQxKTtcbiAgICAgICAgICAgIHQxID0gUi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0MSkgfHwgW107XG4gICAgICAgICAgICB0MiA9IFIucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDIpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG1heGxlbmd0aCA9IG1tYXgodDEubGVuZ3RoLCB0Mi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIGZyb20gPSBbXSxcbiAgICAgICAgICAgICAgICB0byA9IFtdLFxuICAgICAgICAgICAgICAgIGkgPSAwLCBqLCBqaixcbiAgICAgICAgICAgICAgICB0dDEsIHR0MjtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbWF4bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0dDEgPSB0MVtpXSB8fCBnZXRFbXB0eSh0MltpXSk7XG4gICAgICAgICAgICAgICAgdHQyID0gdDJbaV0gfHwgZ2V0RW1wdHkodHQxKTtcbiAgICAgICAgICAgICAgICBpZiAoKHR0MVswXSAhPSB0dDJbMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICh0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInJcIiAmJiAodHQxWzJdICE9IHR0MlsyXSB8fCB0dDFbM10gIT0gdHQyWzNdKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR0MVswXS50b0xvd2VyQ2FzZSgpID09IFwic1wiICYmICh0dDFbM10gIT0gdHQyWzNdIHx8IHR0MVs0XSAhPSB0dDJbNF0pKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tW2ldID0gW107XG4gICAgICAgICAgICAgICAgdG9baV0gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IG1tYXgodHQxLmxlbmd0aCwgdHQyLmxlbmd0aCk7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGogaW4gdHQxICYmIChmcm9tW2ldW2pdID0gdHQxW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaiBpbiB0dDIgJiYgKHRvW2ldW2pdID0gdHQyW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgdG86IHRvXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIFIuX2dldENvbnRhaW5lciA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgIHZhciBjb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lciA9IGggPT0gbnVsbCAmJiAhUi5pcyh4LCBcIm9iamVjdFwiKSA/IGcuZG9jLmdldEVsZW1lbnRCeUlkKHgpIDogeDtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb250YWluZXIuc3R5bGUucGl4ZWxXaWR0aCB8fCBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyLnN0eWxlLnBpeGVsSGVpZ2h0IHx8IGNvbnRhaW5lci5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogd1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogMSxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnBhdGhUb1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggdG8gcmVsYXRpdmUgZm9ybVxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50cy5cbiAgICBcXCovXG4gICAgUi5wYXRoVG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIFIuX2VuZ2luZSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnBhdGgyY3VydmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6aWVyIGN1cnZlcy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50c1xuICAgICA9IChhcnJheSkgYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgXFwqL1xuICAgIFIucGF0aDJjdXJ2ZSA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwubWF0cml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgbWF0cml4IGJhc2VkIG9uIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGEgKG51bWJlcilcbiAgICAgLSBiIChudW1iZXIpXG4gICAgIC0gYyAobnVtYmVyKVxuICAgICAtIGQgKG51bWJlcilcbiAgICAgLSBlIChudW1iZXIpXG4gICAgIC0gZiAobnVtYmVyKVxuICAgICA9IChvYmplY3QpIEBNYXRyaXhcbiAgICBcXCovXG4gICAgUi5tYXRyaXggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9ICthO1xuICAgICAgICAgICAgdGhpcy5iID0gK2I7XG4gICAgICAgICAgICB0aGlzLmMgPSArYztcbiAgICAgICAgICAgIHRoaXMuZCA9ICtkO1xuICAgICAgICAgICAgdGhpcy5lID0gK2U7XG4gICAgICAgICAgICB0aGlzLmYgPSArZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IDE7XG4gICAgICAgICAgICB0aGlzLmIgPSAwO1xuICAgICAgICAgICAgdGhpcy5jID0gMDtcbiAgICAgICAgICAgIHRoaXMuZCA9IDE7XG4gICAgICAgICAgICB0aGlzLmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5mID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoZnVuY3Rpb24gKG1hdHJpeHByb3RvKSB7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmFkZFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQWRkcyBnaXZlbiBtYXRyaXggdG8gZXhpc3Rpbmcgb25lLlxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0gYiAobnVtYmVyKVxuICAgICAgICAgLSBjIChudW1iZXIpXG4gICAgICAgICAtIGQgKG51bWJlcilcbiAgICAgICAgIC0gZSAobnVtYmVyKVxuICAgICAgICAgLSBmIChudW1iZXIpXG4gICAgICAgICBvclxuICAgICAgICAgLSBtYXRyaXggKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmFkZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW1tdLCBbXSwgW11dLFxuICAgICAgICAgICAgICAgIG0gPSBbW3RoaXMuYSwgdGhpcy5jLCB0aGlzLmVdLCBbdGhpcy5iLCB0aGlzLmQsIHRoaXMuZl0sIFswLCAwLCAxXV0sXG4gICAgICAgICAgICAgICAgbWF0cml4ID0gW1thLCBjLCBlXSwgW2IsIGQsIGZdLCBbMCwgMCwgMV1dLFxuICAgICAgICAgICAgICAgIHgsIHksIHosIHJlcztcblxuICAgICAgICAgICAgaWYgKGEgJiYgYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtbYS5hLCBhLmMsIGEuZV0sIFthLmIsIGEuZCwgYS5mXSwgWzAsIDAsIDFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IDM7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCAzOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IDM7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IG1beF1bel0gKiBtYXRyaXhbel1beV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0W3hdW3ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYSA9IG91dFswXVswXTtcbiAgICAgICAgICAgIHRoaXMuYiA9IG91dFsxXVswXTtcbiAgICAgICAgICAgIHRoaXMuYyA9IG91dFswXVsxXTtcbiAgICAgICAgICAgIHRoaXMuZCA9IG91dFsxXVsxXTtcbiAgICAgICAgICAgIHRoaXMuZSA9IG91dFswXVsyXTtcbiAgICAgICAgICAgIHRoaXMuZiA9IG91dFsxXVsyXTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguaW52ZXJ0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIGludmVydGVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeFxuICAgICAgICAgPSAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICB4ID0gbWUuYSAqIG1lLmQgLSBtZS5iICogbWUuYztcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KG1lLmQgLyB4LCAtbWUuYiAvIHgsIC1tZS5jIC8geCwgbWUuYSAvIHgsIChtZS5jICogbWUuZiAtIG1lLmQgKiBtZS5lKSAvIHgsIChtZS5iICogbWUuZSAtIG1lLmEgKiBtZS5mKSAvIHgpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5jbG9uZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBjb3B5IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRyYW5zbGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICAgICAgID4gUGFyYW1ldGVyc1xuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoMSwgMCwgMCwgMSwgeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNjYWxlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTY2FsZXMgdGhlIG1hdHJpeFxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHggKG51bWJlcilcbiAgICAgICAgIC0geSAobnVtYmVyKSAjb3B0aW9uYWxcbiAgICAgICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsXG4gICAgICAgICAtIGN5IChudW1iZXIpICNvcHRpb25hbFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNjYWxlID0gZnVuY3Rpb24gKHgsIHksIGN4LCBjeSkge1xuICAgICAgICAgICAgeSA9PSBudWxsICYmICh5ID0geCk7XG4gICAgICAgICAgICAoY3ggfHwgY3kpICYmIHRoaXMuYWRkKDEsIDAsIDAsIDEsIGN4LCBjeSk7XG4gICAgICAgICAgICB0aGlzLmFkZCh4LCAwLCAwLCB5LCAwLCAwKTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy5hZGQoMSwgMCwgMCwgMSwgLWN4LCAtY3kpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5yb3RhdGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJvdGF0ZXMgdGhlIG1hdHJpeFxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0geCAobnVtYmVyKVxuICAgICAgICAgLSB5IChudW1iZXIpXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ucm90YXRlID0gZnVuY3Rpb24gKGEsIHgsIHkpIHtcbiAgICAgICAgICAgIGEgPSBSLnJhZChhKTtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgdmFyIGNvcyA9ICttYXRoLmNvcyhhKS50b0ZpeGVkKDkpLFxuICAgICAgICAgICAgICAgIHNpbiA9ICttYXRoLnNpbihhKS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoY29zLCBzaW4sIC1zaW4sIGNvcywgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLmFkZCgxLCAwLCAwLCAxLCAteCwgLXkpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC54XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm4geCBjb29yZGluYXRlIGZvciBnaXZlbiBwb2ludCBhZnRlciB0cmFuc2Zvcm1hdGlvbiBkZXNjcmliZWQgYnkgdGhlIG1hdHJpeC4gU2VlIGFsc28gQE1hdHJpeC55XG4gICAgICAgICA+IFBhcmFtZXRlcnNcbiAgICAgICAgIC0geCAobnVtYmVyKVxuICAgICAgICAgLSB5IChudW1iZXIpXG4gICAgICAgICA9IChudW1iZXIpIHhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by54ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICogdGhpcy5hICsgeSAqIHRoaXMuYyArIHRoaXMuZTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgueVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJuIHkgY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueFxuICAgICAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICAgICAtIHggKG51bWJlcilcbiAgICAgICAgIC0geSAobnVtYmVyKVxuICAgICAgICAgPSAobnVtYmVyKSB5XG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ueSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQgKyB0aGlzLmY7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXNbU3RyLmZyb21DaGFyQ29kZSg5NyArIGkpXS50b0ZpeGVkKDQpO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBSLnN2ZyA/XG4gICAgICAgICAgICAgICAgXCJtYXRyaXgoXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV0uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgICAgIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMiksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgzKSwgMCwgMF0uam9pbigpO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by50b0ZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiICsgdGhpcy5nZXQoMCkgK1xuICAgICAgICAgICAgICAgIFwiLCBNMTI9XCIgKyB0aGlzLmdldCgyKSArIFwiLCBNMjE9XCIgKyB0aGlzLmdldCgxKSArIFwiLCBNMjI9XCIgKyB0aGlzLmdldCgzKSArXG4gICAgICAgICAgICAgICAgXCIsIER4PVwiICsgdGhpcy5nZXQoNCkgKyBcIiwgRHk9XCIgKyB0aGlzLmdldCg1KSArIFwiLCBzaXppbmdtZXRob2Q9J2F1dG8gZXhwYW5kJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmUudG9GaXhlZCg0KSwgdGhpcy5mLnRvRml4ZWQoNCldO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBub3JtKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShhKSB7XG4gICAgICAgICAgICB2YXIgbWFnID0gbWF0aC5zcXJ0KG5vcm0oYSkpO1xuICAgICAgICAgICAgYVswXSAmJiAoYVswXSAvPSBtYWcpO1xuICAgICAgICAgICAgYVsxXSAmJiAoYVsxXSAvPSBtYWcpO1xuICAgICAgICB9XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNwbGl0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTcGxpdHMgbWF0cml4IGludG8gcHJpbWl0aXZlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgICAgICBvIGR4IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHhcbiAgICAgICAgIG8gZHkgKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeVxuICAgICAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICAgICAgbyBzY2FsZXkgKG51bWJlcikgc2NhbGUgYnkgeVxuICAgICAgICAgbyBzaGVhciAobnVtYmVyKSBzaGVhclxuICAgICAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgICAgICBvIGlzU2ltcGxlIChib29sZWFuKSBjb3VsZCBpdCBiZSByZXByZXNlbnRlZCB2aWEgc2ltcGxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgICAgIG91dC5keSA9IHRoaXMuZjtcblxuICAgICAgICAgICAgLy8gc2NhbGUgYW5kIHNoZWFyXG4gICAgICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuY10sIFt0aGlzLmIsIHRoaXMuZF1dO1xuICAgICAgICAgICAgb3V0LnNjYWxleCA9IG1hdGguc3FydChub3JtKHJvd1swXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1swXSk7XG5cbiAgICAgICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgICAgIHJvd1sxXSA9IFtyb3dbMV1bMF0gLSByb3dbMF1bMF0gKiBvdXQuc2hlYXIsIHJvd1sxXVsxXSAtIHJvd1swXVsxXSAqIG91dC5zaGVhcl07XG5cbiAgICAgICAgICAgIG91dC5zY2FsZXkgPSBtYXRoLnNxcnQobm9ybShyb3dbMV0pKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICAgICAgb3V0LnNoZWFyIC89IG91dC5zY2FsZXk7XG5cbiAgICAgICAgICAgIC8vIHJvdGF0aW9uXG4gICAgICAgICAgICB2YXIgc2luID0gLXJvd1swXVsxXSxcbiAgICAgICAgICAgICAgICBjb3MgPSByb3dbMV1bMV07XG4gICAgICAgICAgICBpZiAoY29zIDwgMCkge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBSLmRlZyhtYXRoLmFjb3MoY29zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IDM2MCAtIG91dC5yb3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gUi5kZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQuaXNTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIChvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpIHx8ICFvdXQucm90YXRlKTtcbiAgICAgICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgb3V0Lm5vUm90YXRpb24gPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudG9UcmFuc2Zvcm1TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybiB0cmFuc2Zvcm0gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBnaXZlbiBtYXRyaXhcbiAgICAgICAgID0gKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZ1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRvVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24gKHNob3J0ZXIpIHtcbiAgICAgICAgICAgIHZhciBzID0gc2hvcnRlciB8fCB0aGlzW3NwbGl0XSgpO1xuICAgICAgICAgICAgaWYgKHMuaXNTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICBzLnNjYWxleCA9ICtzLnNjYWxleC50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHMuc2NhbGV5ID0gK3Muc2NhbGV5LnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcy5yb3RhdGUgPSArcy5yb3RhdGUudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIChzLmR4IHx8IHMuZHkgPyBcInRcIiArIFtzLmR4LCBzLmR5XSA6IEUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzLnNjYWxleCAhPSAxIHx8IHMuc2NhbGV5ICE9IDEgPyBcInNcIiArIFtzLnNjYWxleCwgcy5zY2FsZXksIDAsIDBdIDogRSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHMucm90YXRlID8gXCJyXCIgKyBbcy5yb3RhdGUsIDAsIDBdIDogRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm1cIiArIFt0aGlzLmdldCgwKSwgdGhpcy5nZXQoMSksIHRoaXMuZ2V0KDIpLCB0aGlzLmdldCgzKSwgdGhpcy5nZXQoNCksIHRoaXMuZ2V0KDUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KShNYXRyaXgucHJvdG90eXBlKTtcblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgcHJldmVudFRvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGdldEV2ZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2Nyb2xsWSA9IGcuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZy5kb2MuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxYID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZy5kb2MuYm9keS5zY3JvbGxMZWZ0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBlLmNsaWVudFggKyBzY3JvbGxYLFxuICAgICAgICAgICAgeTogZS5jbGllbnRZICsgc2Nyb2xsWVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZy5kb2MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZ2V0RXZlbnRQb3NpdGlvbihlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRlID0gZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQgPT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRhcmdldFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudCA9IG9sZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50VG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1lbnQsIGUsIHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoTWFwW3R5cGVdLCBfZiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNUb3VjaCAmJiB0b3VjaE1hcFt0eXBlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoTWFwW3R5cGVdLCBfZiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGcuZG9jLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlIHx8IGcud2luLmV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IGcuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZy5kb2MuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZy5kb2MuYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGUuY2xpZW50WCArIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgc2Nyb2xsWTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGUucHJldmVudERlZmF1bHQgfHwgcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb24gfHwgc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChlbGVtZW50LCBlLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICAgICAgICAgICAgICB2YXIgZGV0YWNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWNoZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKSxcbiAgICBkcmFnID0gW10sXG4gICAgZHJhZ01vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgICBzY3JvbGxZID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBnLmRvYy5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFggPSBnLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBnLmRvYy5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBkcmFnaSxcbiAgICAgICAgICAgIGogPSBkcmFnLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgZHJhZ2kgPSBkcmFnW2pdO1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgZS50b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoID0gZS50b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PSBkcmFnaS5lbC5fZHJhZy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQgPyBlLm9yaWdpbmFsRXZlbnQgOiBlKS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gZHJhZ2kuZWwubm9kZSxcbiAgICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gbm9kZS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgZy53aW4ub3BlcmEgJiYgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBvID0gZHJhZ2kuZWwucGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICAgICAgZy53aW4ub3BlcmEgJiYgKG5leHQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpIDogcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpKTtcbiAgICAgICAgICAgIG8gJiYgZXZlKFwicmFwaGFlbC5kcmFnLm92ZXIuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kuZWwsIG8pO1xuICAgICAgICAgICAgeCArPSBzY3JvbGxYO1xuICAgICAgICAgICAgeSArPSBzY3JvbGxZO1xuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5kcmFnLm1vdmUuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgeCAtIGRyYWdpLmVsLl9kcmFnLngsIHkgLSBkcmFnaS5lbC5fZHJhZy55LCB4LCB5LCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ1VwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgUi51bm1vdXNlbW92ZShkcmFnTW92ZSkudW5tb3VzZXVwKGRyYWdVcCk7XG4gICAgICAgIHZhciBpID0gZHJhZy5sZW5ndGgsXG4gICAgICAgICAgICBkcmFnaTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgZHJhZ2kgPSBkcmFnW2ldO1xuICAgICAgICAgICAgZHJhZ2kuZWwuX2RyYWcgPSB7fTtcbiAgICAgICAgICAgIGV2ZShcInJhcGhhZWwuZHJhZy5lbmQuXCIgKyBkcmFnaS5lbC5pZCwgZHJhZ2kuZW5kX3Njb3BlIHx8IGRyYWdpLnN0YXJ0X3Njb3BlIHx8IGRyYWdpLm1vdmVfc2NvcGUgfHwgZHJhZ2kuZWwsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGRyYWcgPSBbXTtcbiAgICB9LFxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmVsXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG1ldGhvZCB0byBlbGVtZW50cy4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBoYWNrIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBvclxuICAgICAqIHdhbnQgdG8gd3JhcCBzb21lIGNvbW1vbiB0cmFuc2Zvcm1hdGlvbiBvciBhdHRyaWJ1dGVzIGluIG9uZSBtZXRob2QuIEluIGRpZmZlcmVuY2UgdG8gY2FudmFzIG1ldGhvZHMsXG4gICAgICogeW91IGNhbiByZWRlZmluZSBlbGVtZW50IG1ldGhvZCBhdCBhbnkgdGltZS4gRXhwZW5kaW5nIGVsZW1lbnQgbWV0aG9kcyB3b3VsZG7igJl0IGFmZmVjdCBzZXQuXG4gICAgID4gVXNhZ2VcbiAgICAgfCBSYXBoYWVsLmVsLnJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgdGhpcy5hdHRyKHtmaWxsOiBcIiNmMDBcIn0pO1xuICAgICB8IH07XG4gICAgIHwgLy8gdGhlbiB1c2UgaXRcbiAgICAgfCBwYXBlci5jaXJjbGUoMTAwLCAxMDAsIDIwKS5yZWQoKTtcbiAgICBcXCovXG4gICAgZWxwcm90byA9IFIuZWwgPSB7fTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5jbGlja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBjbGljayBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIGRvdWJsZSBjbGljayBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIGRvdWJsZSBjbGljayBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2Vkb3duIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2Vkb3duXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlZG93biBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2Vtb3ZlIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlbW92ZSBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZW91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZW91dCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlb3V0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciBtb3VzZW92ZXIgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2VvdmVyIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cblxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNldXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2V1cCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNldXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2V1cCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoc3RhcnQgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoc3RhcnQgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNobW92ZSBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNobW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVyIGZvciB0b3VjaG1vdmUgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgI29wdGlvbmFsIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2hlbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlciBmb3IgdG91Y2hlbmQgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaGVuZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVyIGZvciB0b3VjaGVuZCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG5cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b3VjaGNhbmNlbFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVyIGZvciB0b3VjaGNhbmNlbCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoY2FuY2VsIGZvciB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pICNvcHRpb25hbCBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBmb3IgKHZhciBpID0gZXZlbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAoZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgUltldmVudE5hbWVdID0gZWxwcm90b1tldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuICAgICAgICAgICAgICAgIGlmIChSLmlzKGZuLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe25hbWU6IGV2ZW50TmFtZSwgZjogZm4sIHVuYmluZDogYWRkRXZlbnQodGhpcy5zaGFwZSB8fCB0aGlzLm5vZGUgfHwgZy5kb2MsIGV2ZW50TmFtZSwgZm4sIHNjb3BlIHx8IHRoaXMpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJbXCJ1blwiICsgZXZlbnROYW1lXSA9IGVscHJvdG9bXCJ1blwiICsgZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudHNbbF0ubmFtZSA9PSBldmVudE5hbWUgJiYgKFIuaXMoZm4sIFwidW5kZWZpbmVkXCIpIHx8IGV2ZW50c1tsXS5mID09IGZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzW2xdLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGljZShsLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICFldmVudHMubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50c1tpXSk7XG4gICAgfVxuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGF0YVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBvciByZXRyaWV2ZXMgZ2l2ZW4gdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGdpdmVuIGtleS5cbiAgICAgKipcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5yZW1vdmVEYXRhXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGtleSAoc3RyaW5nKSBrZXkgdG8gc3RvcmUgZGF0YVxuICAgICAtIHZhbHVlIChhbnkpICNvcHRpb25hbCB2YWx1ZSB0byBzdG9yZVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgICogb3IsIGlmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQ6XG4gICAgID0gKGFueSkgdmFsdWVcbiAgICAgKiBvciwgaWYga2V5IGFuZCB2YWx1ZSBhcmUgbm90IHNwZWNpZmllZDpcbiAgICAgPSAob2JqZWN0KSBLZXkvdmFsdWUgcGFpcnMgZm9yIGFsbCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgID4gVXNhZ2VcbiAgICAgfCBmb3IgKHZhciBpID0gMCwgaSA8IDUsIGkrKykge1xuICAgICB8ICAgICBwYXBlci5jaXJjbGUoMTAgKyAxNSAqIGksIDEwLCAxMClcbiAgICAgfCAgICAgICAgICAuYXR0cih7ZmlsbDogXCIjMDAwXCJ9KVxuICAgICB8ICAgICAgICAgIC5kYXRhKFwiaVwiLCBpKVxuICAgICB8ICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgIHwgICAgICAgICAgICAgYWxlcnQodGhpcy5kYXRhKFwiaVwiKSk7XG4gICAgIHwgICAgICAgICAgfSk7XG4gICAgIHwgfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmRhdGEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IGVsZGF0YVt0aGlzLmlkXSA9IGVsZGF0YVt0aGlzLmlkXSB8fCB7fTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKFIuaXMoa2V5LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4ga2V5KSBpZiAoa2V5W2hhc10oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKGksIGtleVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGFba2V5XSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgIGV2ZShcInJhcGhhZWwuZGF0YS5zZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbGVtZW50IGJ5IGdpdmVuIGtleS5cbiAgICAgKiBJZiBrZXkgaXMgbm90IHByb3ZpZGVkLCByZW1vdmVzIGFsbCB0aGUgZGF0YSBvZiB0aGUgZWxlbWVudC5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0ga2V5IChzdHJpbmcpICNvcHRpb25hbCBrZXlcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnJlbW92ZURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZGF0YVt0aGlzLmlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSAmJiBkZWxldGUgZWxkYXRhW3RoaXMuaWRdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0RGF0YVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IGRhdGFcbiAgICAgPSAob2JqZWN0KSBkYXRhXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKGVsZGF0YVt0aGlzLmlkXSB8fCB7fSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ob3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaG92ZXIgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBmX2luIChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgaW5cbiAgICAgLSBmX291dCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIG91dFxuICAgICAtIGljb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBpbiBoYW5kbGVyXG4gICAgIC0gb2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGhvdmVyIG91dCBoYW5kbGVyXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5ob3ZlciA9IGZ1bmN0aW9uIChmX2luLCBmX291dCwgc2NvcGVfaW4sIHNjb3BlX291dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZW92ZXIoZl9pbiwgc2NvcGVfaW4pLm1vdXNlb3V0KGZfb3V0LCBzY29wZV9vdXQgfHwgc2NvcGVfaW4pO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5ob3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVycyBmb3IgaG92ZXIgZm9yIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBmX2luIChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgaW5cbiAgICAgLSBmX291dCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIG91dFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5ob3ZlciA9IGZ1bmN0aW9uIChmX2luLCBmX291dCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bm1vdXNlb3ZlcihmX2luKS51bm1vdXNlb3V0KGZfb3V0KTtcbiAgICB9O1xuICAgIHZhciBkcmFnZ2FibGUgPSBbXTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBkcmFnIG9mIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBvbm1vdmUgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBtb3ZpbmdcbiAgICAgLSBvbnN0YXJ0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBzdGFydFxuICAgICAtIG9uZW5kIChmdW5jdGlvbikgaGFuZGxlciBmb3IgZHJhZyBlbmRcbiAgICAgLSBtY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgbW92aW5nIGhhbmRsZXJcbiAgICAgLSBzY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgZHJhZyBzdGFydCBoYW5kbGVyXG4gICAgIC0gZWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgZW5kIGhhbmRsZXJcbiAgICAgKiBBZGRpdGlvbmFsbHkgZm9sbG93aW5nIGBkcmFnYCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQ6IGBkcmFnLnN0YXJ0LjxpZD5gIG9uIHN0YXJ0LFxuICAgICAqIGBkcmFnLmVuZC48aWQ+YCBvbiBlbmQgYW5kIGBkcmFnLm1vdmUuPGlkPmAgb24gZXZlcnkgbW92ZS4gV2hlbiBlbGVtZW50IHdpbGwgYmUgZHJhZ2dlZCBvdmVyIGFub3RoZXIgZWxlbWVudFxuICAgICAqIGBkcmFnLm92ZXIuPGlkPmAgd2lsbCBiZSBmaXJlZCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogU3RhcnQgZXZlbnQgYW5kIHN0YXJ0IGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIHggKG51bWJlcikgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyB5IChudW1iZXIpIHkgcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8gZXZlbnQgKG9iamVjdCkgRE9NIGV2ZW50IG9iamVjdFxuICAgICAqIE1vdmUgZXZlbnQgYW5kIG1vdmUgaGFuZGxlciB3aWxsIGJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8gZHggKG51bWJlcikgc2hpZnQgYnkgeCBmcm9tIHRoZSBzdGFydCBwb2ludFxuICAgICBvIGR5IChudW1iZXIpIHNoaWZ0IGJ5IHkgZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyB4IChudW1iZXIpIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgIG8geSAobnVtYmVyKSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIGV2ZW50IChvYmplY3QpIERPTSBldmVudCBvYmplY3RcbiAgICAgKiBFbmQgZXZlbnQgYW5kIGVuZCBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5kcmFnID0gZnVuY3Rpb24gKG9ubW92ZSwgb25zdGFydCwgb25lbmQsIG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGUpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoZSkge1xuICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCB8fCBlKS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICAgICAgICBzY3JvbGxZID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBnLmRvYy5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBzY3JvbGxYID0gZy5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZy5kb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fZHJhZy5pZCA9IGUuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIGUudG91Y2hlcykge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZS50b3VjaGVzLmxlbmd0aCwgdG91Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUudG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZy5pZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09IHRoaXMuX2RyYWcuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYWcueCA9IHggKyBzY3JvbGxYO1xuICAgICAgICAgICAgdGhpcy5fZHJhZy55ID0geSArIHNjcm9sbFk7XG4gICAgICAgICAgICAhZHJhZy5sZW5ndGggJiYgUi5tb3VzZW1vdmUoZHJhZ01vdmUpLm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgICAgIGRyYWcucHVzaCh7ZWw6IHRoaXMsIG1vdmVfc2NvcGU6IG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlOiBzdGFydF9zY29wZSwgZW5kX3Njb3BlOiBlbmRfc2NvcGV9KTtcbiAgICAgICAgICAgIG9uc3RhcnQgJiYgZXZlLm9uKFwicmFwaGFlbC5kcmFnLnN0YXJ0LlwiICsgdGhpcy5pZCwgb25zdGFydCk7XG4gICAgICAgICAgICBvbm1vdmUgJiYgZXZlLm9uKFwicmFwaGFlbC5kcmFnLm1vdmUuXCIgKyB0aGlzLmlkLCBvbm1vdmUpO1xuICAgICAgICAgICAgb25lbmQgJiYgZXZlLm9uKFwicmFwaGFlbC5kcmFnLmVuZC5cIiArIHRoaXMuaWQsIG9uZW5kKTtcbiAgICAgICAgICAgIGV2ZShcInJhcGhhZWwuZHJhZy5zdGFydC5cIiArIHRoaXMuaWQsIHN0YXJ0X3Njb3BlIHx8IG1vdmVfc2NvcGUgfHwgdGhpcywgdGhpcy5fZHJhZy54LCB0aGlzLl9kcmFnLnksIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYWcgPSB7fTtcbiAgICAgICAgZHJhZ2dhYmxlLnB1c2goe2VsOiB0aGlzLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd24oc3RhcnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm9uRHJhZ092ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNob3J0Y3V0IGZvciBhc3NpZ25pbmcgZXZlbnQgaGFuZGxlciBmb3IgYGRyYWcub3Zlci48aWQ+YCBldmVudCwgd2hlcmUgaWQgaXMgaWQgb2YgdGhlIGVsZW1lbnQgKHNlZSBARWxlbWVudC5pZCkuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBldmVudCwgZmlyc3QgYXJndW1lbnQgd291bGQgYmUgdGhlIGVsZW1lbnQgeW91IGFyZSBkcmFnZ2luZyBvdmVyXG4gICAgXFwqL1xuICAgIGVscHJvdG8ub25EcmFnT3ZlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGYgPyBldmUub24oXCJyYXBoYWVsLmRyYWcub3Zlci5cIiArIHRoaXMuaWQsIGYpIDogZXZlLnVuYmluZChcInJhcGhhZWwuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRyYWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGRyYWcgZXZlbnQgaGFuZGxlcnMgZnJvbSBnaXZlbiBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBlbHByb3RvLnVuZHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBkcmFnZ2FibGUubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBpZiAoZHJhZ2dhYmxlW2ldLmVsID09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VzZWRvd24oZHJhZ2dhYmxlW2ldLnN0YXJ0KTtcbiAgICAgICAgICAgIGRyYWdnYWJsZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBldmUudW5iaW5kKFwicmFwaGFlbC5kcmFnLiouXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAhZHJhZ2dhYmxlLmxlbmd0aCAmJiBSLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGUuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gciAobnVtYmVyKSByYWRpdXNcbiAgICAgPSAob2JqZWN0KSBSYXBoYcOrbCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUg4oCcY2lyY2xl4oCdXG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSg1MCwgNTAsIDQwKTtcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICB2YXIgb3V0ID0gUi5fZW5naW5lLmNpcmNsZSh0aGlzLCB4IHx8IDAsIHkgfHwgMCwgciB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmVjdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZS5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXJcbiAgICAgLSB3aWR0aCAobnVtYmVyKSB3aWR0aFxuICAgICAtIGhlaWdodCAobnVtYmVyKSBoZWlnaHRcbiAgICAgLSByIChudW1iZXIpICNvcHRpb25hbCByYWRpdXMgZm9yIHJvdW5kZWQgY29ybmVycywgZGVmYXVsdCBpcyAwXG4gICAgID0gKG9iamVjdCkgUmFwaGHDq2wgZWxlbWVudCBvYmplY3Qgd2l0aCB0eXBlIOKAnHJlY3TigJ1cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIHJlZ3VsYXIgcmVjdGFuZ2xlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5yZWN0KDEwLCAxMCwgNTAsIDUwKTtcbiAgICAgfCAvLyByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnNcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoNDAsIDQwLCA1MCwgNTAsIDEwKTtcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHIpIHtcbiAgICAgICAgdmFyIG91dCA9IFIuX2VuZ2luZS5yZWN0KHRoaXMsIHggfHwgMCwgeSB8fCAwLCB3IHx8IDAsIGggfHwgMCwgciB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZWxsaXBzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYW4gZWxsaXBzZS5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSByeCAobnVtYmVyKSBob3Jpem9udGFsIHJhZGl1c1xuICAgICAtIHJ5IChudW1iZXIpIHZlcnRpY2FsIHJhZGl1c1xuICAgICA9IChvYmplY3QpIFJhcGhhw6tsIGVsZW1lbnQgb2JqZWN0IHdpdGggdHlwZSDigJxlbGxpcHNl4oCdXG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYyA9IHBhcGVyLmVsbGlwc2UoNTAsIDUwLCA0MCwgMjApO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5KSB7XG4gICAgICAgIHZhciBvdXQgPSBSLl9lbmdpbmUuZWxsaXBzZSh0aGlzLCB4IHx8IDAsIHkgfHwgMCwgcnggfHwgMCwgcnkgfHwgMCk7XG4gICAgICAgIHRoaXMuX19zZXRfXyAmJiB0aGlzLl9fc2V0X18ucHVzaChvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBwYXRoIGVsZW1lbnQgYnkgZ2l2ZW4gcGF0aCBkYXRhIHN0cmluZy5cbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gcGF0aFN0cmluZyAoc3RyaW5nKSAjb3B0aW9uYWwgcGF0aCBzdHJpbmcgaW4gU1ZHIGZvcm1hdC5cbiAgICAgKiBQYXRoIHN0cmluZyBjb25zaXN0cyBvZiBvbmUtbGV0dGVyIGNvbW1hbmRzLCBmb2xsb3dlZCBieSBjb21tYSBzZXByYXJhdGVkIGFyZ3VtZW50cyBpbiBudW1lcmNhbCBmb3JtLiBFeGFtcGxlOlxuICAgICB8IFwiTTEwLDIwTDMwLDQwXCJcbiAgICAgKiBIZXJlIHdlIGNhbiBzZWUgdHdvIGNvbW1hbmRzOiDigJxN4oCdLCB3aXRoIGFyZ3VtZW50cyBgKDEwLCAyMClgIGFuZCDigJxM4oCdIHdpdGggYXJndW1lbnRzIGAoMzAsIDQwKWAuIFVwcGVyIGNhc2UgbGV0dGVyIG1lYW4gY29tbWFuZCBpcyBhYnNvbHV0ZSwgbG93ZXIgY2FzZeKAlHJlbGF0aXZlLlxuICAgICAqXG4gICAgICMgPHA+SGVyZSBpcyBzaG9ydCBsaXN0IG9mIGNvbW1hbmRzIGF2YWlsYWJsZSwgZm9yIG1vcmUgZGV0YWlscyBzZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXCIgdGl0bGU9XCJEZXRhaWxzIG9mIGEgcGF0aCdzIGRhdGEgYXR0cmlidXRlJ3MgZm9ybWF0IGFyZSBkZXNjcmliZWQgaW4gdGhlIFNWRyBzcGVjaWZpY2F0aW9uLlwiPlNWRyBwYXRoIHN0cmluZyBmb3JtYXQ8L2E+LjwvcD5cbiAgICAgIyA8dGFibGU+PHRoZWFkPjx0cj48dGg+Q29tbWFuZDwvdGg+PHRoPk5hbWU8L3RoPjx0aD5QYXJhbWV0ZXJzPC90aD48L3RyPjwvdGhlYWQ+PHRib2R5PlxuICAgICAjIDx0cj48dGQ+TTwvdGQ+PHRkPm1vdmV0bzwvdGQ+PHRkPih4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlo8L3RkPjx0ZD5jbG9zZXBhdGg8L3RkPjx0ZD4obm9uZSk8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5MPC90ZD48dGQ+bGluZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+SDwvdGQ+PHRkPmhvcml6b250YWwgbGluZXRvPC90ZD48dGQ+eCs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5WPC90ZD48dGQ+dmVydGljYWwgbGluZXRvPC90ZD48dGQ+eSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5DPC90ZD48dGQ+Y3VydmV0bzwvdGQ+PHRkPih4MSB5MSB4MiB5MiB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlM8L3RkPjx0ZD5zbW9vdGggY3VydmV0bzwvdGQ+PHRkPih4MiB5MiB4IHkpKzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlE8L3RkPjx0ZD5xdWFkcmF0aWMgQsOpemllciBjdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+VDwvdGQ+PHRkPnNtb290aCBxdWFkcmF0aWMgQsOpemllciBjdXJ2ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+QTwvdGQ+PHRkPmVsbGlwdGljYWwgYXJjPC90ZD48dGQ+KHJ4IHJ5IHgtYXhpcy1yb3RhdGlvbiBsYXJnZS1hcmMtZmxhZyBzd2VlcC1mbGFnIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UjwvdGQ+PHRkPjxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhdG11bGzigJNSb21fc3BsaW5lI0NhdG11bGwuRTIuODAuOTNSb21fc3BsaW5lXCI+Q2F0bXVsbC1Sb20gY3VydmV0bzwvYT4qPC90ZD48dGQ+eDEgeTEgKHggeSkrPC90ZD48L3RyPjwvdGJvZHk+PC90YWJsZT5cbiAgICAgKiAqIOKAnENhdG11bGwtUm9tIGN1cnZldG/igJ0gaXMgYSBub3Qgc3RhbmRhcmQgU1ZHIGNvbW1hbmQgYW5kIGFkZGVkIGluIDIuMCB0byBtYWtlIGxpZmUgZWFzaWVyLlxuICAgICAqIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gcGF0aCBjb25zaXN0IG9mIGp1c3QgdGhyZWUgY29tbWFuZHM6IOKAnE0xMCwxMFLigKZ64oCdLiBJbiB0aGlzIGNhc2UgcGF0aCB3aWxsIHNtb290aGx5IGNvbm5lY3RzIHRvIGl0cyBiZWdpbm5pbmcuXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnBhdGgoXCJNMTAgMTBMOTAgOTBcIik7XG4gICAgIHwgLy8gZHJhdyBhIGRpYWdvbmFsIGxpbmU6XG4gICAgIHwgLy8gbW92ZSB0byAxMCwxMCwgbGluZSB0byA5MCw5MFxuICAgICAqIEZvciBleGFtcGxlIG9mIHBhdGggc3RyaW5ncywgY2hlY2sgb3V0IHRoZXNlIGljb25zOiBodHRwOi8vcmFwaGFlbGpzLmNvbS9pY29ucy9cbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5wYXRoID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgcGF0aFN0cmluZyAmJiAhUi5pcyhwYXRoU3RyaW5nLCBzdHJpbmcpICYmICFSLmlzKHBhdGhTdHJpbmdbMF0sIGFycmF5KSAmJiAocGF0aFN0cmluZyArPSBFKTtcbiAgICAgICAgdmFyIG91dCA9IFIuX2VuZ2luZS5wYXRoKFIuZm9ybWF0W2FwcGx5XShSLCBhcmd1bWVudHMpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fX3NldF9fICYmIHRoaXMuX19zZXRfXy5wdXNoKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuaW1hZ2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEVtYmVkcyBhbiBpbWFnZSBpbnRvIHRoZSBzdXJmYWNlLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBzcmMgKHN0cmluZykgVVJJIG9mIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvblxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0gd2lkdGggKG51bWJlcikgd2lkdGggb2YgdGhlIGltYWdlXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICAgPSAob2JqZWN0KSBSYXBoYcOrbCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUg4oCcaW1hZ2XigJ1cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuaW1hZ2UoXCJhcHBsZS5wbmdcIiwgMTAsIDEwLCA4MCwgODApO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmltYWdlID0gZnVuY3Rpb24gKHNyYywgeCwgeSwgdywgaCkge1xuICAgICAgICB2YXIgb3V0ID0gUi5fZW5naW5lLmltYWdlKHRoaXMsIHNyYyB8fCBcImFib3V0OmJsYW5rXCIsIHggfHwgMCwgeSB8fCAwLCB3IHx8IDAsIGggfHwgMCk7XG4gICAgICAgIHRoaXMuX19zZXRfXyAmJiB0aGlzLl9fc2V0X18ucHVzaChvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnRleHRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgdGV4dCBzdHJpbmcuIElmIHlvdSBuZWVkIGxpbmUgYnJlYWtzLCBwdXQg4oCcXFxu4oCdIGluIHRoZSBzdHJpbmcuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmcpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3XG4gICAgID0gKG9iamVjdCkgUmFwaGHDq2wgZWxlbWVudCBvYmplY3Qgd2l0aCB0eXBlIOKAnHRleHTigJ1cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciB0ID0gcGFwZXIudGV4dCg1MCwgNTAsIFwiUmFwaGHDq2xcXG5raWNrc1xcbmJ1dHQhXCIpO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnRleHQgPSBmdW5jdGlvbiAoeCwgeSwgdGV4dCkge1xuICAgICAgICB2YXIgb3V0ID0gUi5fZW5naW5lLnRleHQodGhpcywgeCB8fCAwLCB5IHx8IDAsIFN0cih0ZXh0KSk7XG4gICAgICAgIHRoaXMuX19zZXRfXyAmJiB0aGlzLl9fc2V0X18ucHVzaChvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnNldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhcnJheS1saWtlIG9iamVjdCB0byBrZWVwIGFuZCBvcGVyYXRlIHNldmVyYWwgZWxlbWVudHMgYXQgb25jZS5cbiAgICAgKiBXYXJuaW5nOiBpdCBkb2VzbuKAmXQgY3JlYXRlIGFueSBlbGVtZW50cyBmb3IgaXRzZWxmIGluIHRoZSBwYWdlLCBpdCBqdXN0IGdyb3VwcyBleGlzdGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIGFjdCBhcyBwc2V1ZG8gZWxlbWVudHMg4oCUIGFsbCBtZXRob2RzIGF2YWlsYWJsZSB0byBhbiBlbGVtZW50IGNhbiBiZSB1c2VkIG9uIGEgc2V0LlxuICAgICA9IChvYmplY3QpIGFycmF5LWxpa2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBzZXQgb2YgZWxlbWVudHNcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBzdCA9IHBhcGVyLnNldCgpO1xuICAgICB8IHN0LnB1c2goXG4gICAgIHwgICAgIHBhcGVyLmNpcmNsZSgxMCwgMTAsIDUpLFxuICAgICB8ICAgICBwYXBlci5jaXJjbGUoMzAsIDEwLCA1KVxuICAgICB8ICk7XG4gICAgIHwgc3QuYXR0cih7ZmlsbDogXCJyZWRcIn0pOyAvLyBjaGFuZ2VzIHRoZSBmaWxsIG9mIGJvdGggY2lyY2xlc1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnNldCA9IGZ1bmN0aW9uIChpdGVtc0FycmF5KSB7XG4gICAgICAgICFSLmlzKGl0ZW1zQXJyYXksIFwiYXJyYXlcIikgJiYgKGl0ZW1zQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcmd1bWVudHMubGVuZ3RoKSk7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgU2V0KGl0ZW1zQXJyYXkpO1xuICAgICAgICB0aGlzLl9fc2V0X18gJiYgdGhpcy5fX3NldF9fLnB1c2gob3V0KTtcbiAgICAgICAgb3V0W1wicGFwZXJcIl0gPSB0aGlzO1xuICAgICAgICBvdXRbXCJ0eXBlXCJdID0gXCJzZXRcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zZXRTdGFydFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBAUGFwZXIuc2V0LiBBbGwgZWxlbWVudHMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBhbmQgYmVmb3JlIGNhbGxpbmdcbiAgICAgKiBAUGFwZXIuc2V0RmluaXNoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldC5cbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHBhcGVyLnNldFN0YXJ0KCk7XG4gICAgIHwgcGFwZXIuY2lyY2xlKDEwLCAxMCwgNSksXG4gICAgIHwgcGFwZXIuY2lyY2xlKDMwLCAxMCwgNSlcbiAgICAgfCB2YXIgc3QgPSBwYXBlci5zZXRGaW5pc2goKTtcbiAgICAgfCBzdC5hdHRyKHtmaWxsOiBcInJlZFwifSk7IC8vIGNoYW5nZXMgdGhlIGZpbGwgb2YgYm90aCBjaXJjbGVzXG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uc2V0U3RhcnQgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHRoaXMuX19zZXRfXyA9IHNldCB8fCB0aGlzLnNldCgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnNldEZpbmlzaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBQYXBlci5zZXRTdGFydC4gVGhpcyBtZXRob2QgZmluaXNoZXMgY2F0Y2hpbmcgYW5kIHJldHVybnMgcmVzdWx0aW5nIHNldC5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBzZXRcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5zZXRGaW5pc2ggPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9fc2V0X187XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9fc2V0X187XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZ2V0U2l6ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogT2J0YWlucyBjdXJyZW50IHBhcGVyIGFjdHVhbCBzaXplLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpXG4gICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnNldFNpemVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIElmIHlvdSBuZWVkIHRvIGNoYW5nZSBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMgY2FsbCB0aGlzIG1ldGhvZFxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xuICAgICAtIGhlaWdodCAobnVtYmVyKSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5zZXRTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFIuX2VuZ2luZS5zZXRTaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc2V0Vmlld0JveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2V0cyB0aGUgdmlldyBib3ggb2YgdGhlIHBhcGVyLiBQcmFjdGljYWxseSBpdCBnaXZlcyB5b3UgYWJpbGl0eSB0byB6b29tIGFuZCBwYW4gd2hvbGUgcGFwZXIgc3VyZmFjZSBieVxuICAgICAqIHNwZWNpZnlpbmcgbmV3IGJvdW5kYXJpZXMuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgbmV3IHggcG9zaXRpb24sIGRlZmF1bHQgaXMgYDBgXG4gICAgIC0geSAobnVtYmVyKSBuZXcgeSBwb3NpdGlvbiwgZGVmYXVsdCBpcyBgMGBcbiAgICAgLSB3IChudW1iZXIpIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAgIC0gaCAobnVtYmVyKSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgLSBmaXQgKGJvb2xlYW4pIGB0cnVlYCBpZiB5b3Ugd2FudCBncmFwaGljcyB0byBmaXQgaW50byBuZXcgYm91bmRhcnkgYm94XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uc2V0Vmlld0JveCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBmaXQpIHtcbiAgICAgICAgcmV0dXJuIFIuX2VuZ2luZS5zZXRWaWV3Qm94LmNhbGwodGhpcywgeCwgeSwgdywgaCwgZml0KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci50b3BcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogUG9pbnRzIHRvIHRoZSB0b3Btb3N0IGVsZW1lbnQgb24gdGhlIHBhcGVyXG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5ib3R0b21cbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogUG9pbnRzIHRvIHRoZSBib3R0b20gZWxlbWVudCBvbiB0aGUgcGFwZXJcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by50b3AgPSBwYXBlcnByb3RvLmJvdHRvbSA9IG51bGw7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnJhcGhhZWxcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogUG9pbnRzIHRvIHRoZSBAUmFwaGFlbCBvYmplY3QvZnVuY3Rpb25cbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5yYXBoYWVsID0gUjtcbiAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDAsIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDAsXG4gICAgICAgICAgICB0b3AgID0gYm94LnRvcCAgKyAoZy53aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBib3gubGVmdCArIChnLndpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0KSAtIGNsaWVudExlZnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiB0b3AsXG4gICAgICAgICAgICB4OiBsZWZ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZ2V0RWxlbWVudEJ5UG9pbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgeW91IHRvcG1vc3QgZWxlbWVudCB1bmRlciBnaXZlbiBwb2ludC5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBSYXBoYcOrbCBlbGVtZW50IG9iamVjdFxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHdpbmRvd1xuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gICAgID4gVXNhZ2VcbiAgICAgfCBwYXBlci5nZXRFbGVtZW50QnlQb2ludChtb3VzZVgsIG1vdXNlWSkuYXR0cih7c3Ryb2tlOiBcIiNmMDBcIn0pO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmdldEVsZW1lbnRCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcyxcbiAgICAgICAgICAgIHN2ZyA9IHBhcGVyLmNhbnZhcyxcbiAgICAgICAgICAgIHRhcmdldCA9IGcuZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChnLndpbi5vcGVyYSAmJiB0YXJnZXQudGFnTmFtZSA9PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICB2YXIgc28gPSBnZXRPZmZzZXQoc3ZnKSxcbiAgICAgICAgICAgICAgICBzciA9IHN2Zy5jcmVhdGVTVkdSZWN0KCk7XG4gICAgICAgICAgICBzci54ID0geCAtIHNvLng7XG4gICAgICAgICAgICBzci55ID0geSAtIHNvLnk7XG4gICAgICAgICAgICBzci53aWR0aCA9IHNyLmhlaWdodCA9IDE7XG4gICAgICAgICAgICB2YXIgaGl0cyA9IHN2Zy5nZXRJbnRlcnNlY3Rpb25MaXN0KHNyLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChoaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGhpdHNbaGl0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICYmIHRhcmdldCAhPSBzdmcucGFyZW50Tm9kZSAmJiAhdGFyZ2V0LnJhcGhhZWwpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9PSBwYXBlci5jYW52YXMucGFyZW50Tm9kZSAmJiAodGFyZ2V0ID0gc3ZnKTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0ICYmIHRhcmdldC5yYXBoYWVsID8gcGFwZXIuZ2V0QnlJZCh0YXJnZXQucmFwaGFlbGlkKSA6IG51bGw7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nZXRFbGVtZW50c0J5QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzZXQgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGFuIGludGVyc2VjdGluZyBib3VuZGluZyBib3hcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gYmJveCAob2JqZWN0KSBiYm94IHRvIGNoZWNrIHdpdGhcbiAgICAgPSAob2JqZWN0KSBAU2V0XG4gICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLmdldEVsZW1lbnRzQnlCQm94ID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICAgICAgdmFyIHNldCA9IHRoaXMuc2V0KCk7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChSLmlzQkJveEludGVyc2VjdChlbC5nZXRCQm94KCksIGJib3gpKSB7XG4gICAgICAgICAgICAgICAgc2V0LnB1c2goZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmdldEJ5SWRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgeW91IGVsZW1lbnQgYnkgaXRzIGludGVybmFsIElELlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBpZCAobnVtYmVyKSBpZFxuICAgICA9IChvYmplY3QpIFJhcGhhw6tsIGVsZW1lbnQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYm90ID0gdGhpcy5ib3R0b207XG4gICAgICAgIHdoaWxlIChib3QpIHtcbiAgICAgICAgICAgIGlmIChib3QuaWQgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm90ID0gYm90Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZm9yRWFjaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBvbiB0aGUgcGFwZXJcbiAgICAgKlxuICAgICAqIElmIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCBpdCB3aWxsIHN0b3AgbG9vcCBydW5uaW5nLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pIGZ1bmN0aW9uIHRvIHJ1blxuICAgICAtIHRoaXNBcmcgKG9iamVjdCkgY29udGV4dCBvYmplY3QgZm9yIHRoZSBjYWxsYmFja1xuICAgICA9IChvYmplY3QpIFBhcGVyIG9iamVjdFxuICAgICA+IFVzYWdlXG4gICAgIHwgcGFwZXIuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgfCAgICAgZWwuYXR0cih7IHN0cm9rZTogXCJibHVlXCIgfSk7XG4gICAgIHwgfSk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgYm90ID0gdGhpcy5ib3R0b207XG4gICAgICAgIHdoaWxlIChib3QpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGJvdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3QgPSBib3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nZXRFbGVtZW50c0J5UG9pbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgc2V0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBjb21tb24gcG9pbnQgaW5zaWRlXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICA9IChvYmplY3QpIEBTZXRcbiAgICBcXCovXG4gICAgcGFwZXJwcm90by5nZXRFbGVtZW50c0J5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgc2V0ID0gdGhpcy5zZXQoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLmlzUG9pbnRJbnNpZGUoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBzZXQucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH07XG4gICAgZnVuY3Rpb24geF95KCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueTtcbiAgICB9XG4gICAgZnVuY3Rpb24geF95X3dfaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnkgKyBTICsgdGhpcy53aWR0aCArIFwiIFxceGQ3IFwiICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmlzUG9pbnRJbnNpZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERldGVybWluZSBpZiBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhpcyBlbGVtZW504oCZcyBzaGFwZVxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGluc2lkZSB0aGUgc2hhcGVcbiAgICBcXCovXG4gICAgZWxwcm90by5pc1BvaW50SW5zaWRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHJwID0gdGhpcy5yZWFsUGF0aCA9IGdldFBhdGhbdGhpcy50eXBlXSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cigndHJhbnNmb3JtJykgJiYgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJwID0gUi50cmFuc2Zvcm1QYXRoKHJwLCB0aGlzLmF0dHIoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUi5pc1BvaW50SW5zaWRlUGF0aChycCwgeCwgeSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm4gYm91bmRpbmcgYm94IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gaXNXaXRob3V0VHJhbnNmb3JtIChib29sZWFuKSBmbGFnLCBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gaGF2ZSBib3VuZGluZyBib3ggYmVmb3JlIHRyYW5zZm9ybWF0aW9ucy4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICA9IChvYmplY3QpIEJvdW5kaW5nIGJveCBvYmplY3Q6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB0b3AgbGVmdCBjb3JuZXIgeFxuICAgICBvICAgICB5OiAobnVtYmVyKSB0b3AgbGVmdCBjb3JuZXIgeVxuICAgICBvICAgICB4MjogKG51bWJlcikgYm90dG9tIHJpZ2h0IGNvcm5lciB4XG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSBib3R0b20gcmlnaHQgY29ybmVyIHlcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldEJCb3ggPSBmdW5jdGlvbiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgXyA9IHRoaXMuXztcbiAgICAgICAgaWYgKGlzV2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKF8uZGlydHkgfHwgIV8uYmJveHd0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsUGF0aCA9IGdldFBhdGhbdGhpcy50eXBlXSh0aGlzKTtcbiAgICAgICAgICAgICAgICBfLmJib3h3dCA9IHBhdGhEaW1lbnNpb25zKHRoaXMucmVhbFBhdGgpO1xuICAgICAgICAgICAgICAgIF8uYmJveHd0LnRvU3RyaW5nID0geF95X3dfaDtcbiAgICAgICAgICAgICAgICBfLmRpcnR5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfLmJib3h3dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5kaXJ0eSB8fCBfLmRpcnR5VCB8fCAhXy5iYm94KSB7XG4gICAgICAgICAgICBpZiAoXy5kaXJ0eSB8fCAhdGhpcy5yZWFsUGF0aCkge1xuICAgICAgICAgICAgICAgIF8uYmJveHd0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWxQYXRoID0gZ2V0UGF0aFt0aGlzLnR5cGVdKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5iYm94ID0gcGF0aERpbWVuc2lvbnMobWFwUGF0aCh0aGlzLnJlYWxQYXRoLCB0aGlzLm1hdHJpeCkpO1xuICAgICAgICAgICAgXy5iYm94LnRvU3RyaW5nID0geF95X3dfaDtcbiAgICAgICAgICAgIF8uZGlydHkgPSBfLmRpcnR5VCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uYmJveDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmNsb25lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBjbG9uZSBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgZWxwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IHRoaXMucGFwZXJbdGhpcy50eXBlXSgpLmF0dHIodGhpcy5hdHRyKCkpO1xuICAgICAgICB0aGlzLl9fc2V0X18gJiYgdGhpcy5fX3NldF9fLnB1c2gob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmdsb3dcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybiBzZXQgb2YgZWxlbWVudHMgdGhhdCBjcmVhdGUgZ2xvdy1saWtlIGVmZmVjdCBhcm91bmQgZ2l2ZW4gZWxlbWVudC4gU2VlIEBQYXBlci5zZXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBHbG93IGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIGVsZW1lbnQuIElmIHlvdSBjaGFuZ2UgZWxlbWVudCBhdHRyaWJ1dGVzIGl0IHdvbuKAmXQgYWRqdXN0IGl0c2VsZi5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gZ2xvdyAob2JqZWN0KSAjb3B0aW9uYWwgcGFyYW1ldGVycyBvYmplY3Qgd2l0aCBhbGwgcHJvcGVydGllcyBvcHRpb25hbDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHdpZHRoIChudW1iZXIpIHNpemUgb2YgdGhlIGdsb3csIGRlZmF1bHQgaXMgYDEwYFxuICAgICBvICAgICBmaWxsIChib29sZWFuKSB3aWxsIGl0IGJlIGZpbGxlZCwgZGVmYXVsdCBpcyBgZmFsc2VgXG4gICAgIG8gICAgIG9wYWNpdHkgKG51bWJlcikgb3BhY2l0eSwgZGVmYXVsdCBpcyBgMC41YFxuICAgICBvICAgICBvZmZzZXR4IChudW1iZXIpIGhvcml6b250YWwgb2Zmc2V0LCBkZWZhdWx0IGlzIGAwYFxuICAgICBvICAgICBvZmZzZXR5IChudW1iZXIpIHZlcnRpY2FsIG9mZnNldCwgZGVmYXVsdCBpcyBgMGBcbiAgICAgbyAgICAgY29sb3IgKHN0cmluZykgZ2xvdyBjb2xvdXIsIGRlZmF1bHQgaXMgYGJsYWNrYFxuICAgICBvIH1cbiAgICAgPSAob2JqZWN0KSBAUGFwZXIuc2V0IG9mIGVsZW1lbnRzIHRoYXQgcmVwcmVzZW50cyBnbG93XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2xvdyA9IGZ1bmN0aW9uIChnbG93KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGdsb3cgPSBnbG93IHx8IHt9O1xuICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAoZ2xvdy53aWR0aCB8fCAxMCkgKyAoK3RoaXMuYXR0cihcInN0cm9rZS13aWR0aFwiKSB8fCAxKSxcbiAgICAgICAgICAgIGZpbGw6IGdsb3cuZmlsbCB8fCBmYWxzZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGdsb3cub3BhY2l0eSA9PSBudWxsID8gLjUgOiBnbG93Lm9wYWNpdHksXG4gICAgICAgICAgICBvZmZzZXR4OiBnbG93Lm9mZnNldHggfHwgMCxcbiAgICAgICAgICAgIG9mZnNldHk6IGdsb3cub2Zmc2V0eSB8fCAwLFxuICAgICAgICAgICAgY29sb3I6IGdsb3cuY29sb3IgfHwgXCIjMDAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGMgPSBzLndpZHRoIC8gMixcbiAgICAgICAgICAgIHIgPSB0aGlzLnBhcGVyLFxuICAgICAgICAgICAgb3V0ID0gci5zZXQoKSxcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLnJlYWxQYXRoIHx8IGdldFBhdGhbdGhpcy50eXBlXSh0aGlzKTtcbiAgICAgICAgcGF0aCA9IHRoaXMubWF0cml4ID8gbWFwUGF0aChwYXRoLCB0aGlzLm1hdHJpeCkgOiBwYXRoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGMgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHIucGF0aChwYXRoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IHMuY29sb3IsXG4gICAgICAgICAgICAgICAgZmlsbDogcy5maWxsID8gcy5jb2xvciA6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiArKHMud2lkdGggLyBjICogaSkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiArKHMub3BhY2l0eSAvIGMpLnRvRml4ZWQoMylcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Lmluc2VydEJlZm9yZSh0aGlzKS50cmFuc2xhdGUocy5vZmZzZXR4LCBzLm9mZnNldHkpO1xuICAgIH07XG4gICAgdmFyIGN1cnZlc2xlbmd0aHMgPSB7fSxcbiAgICBnZXRQb2ludEF0U2VnbWVudExlbmd0aCA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlemxlbihwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUi5maW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSwgZ2V0VGF0TGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TGVuZ3RoRmFjdG9yeSA9IGZ1bmN0aW9uIChpc3RvdGFsLCBzdWJwYXRoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoMmN1cnZlKHBhdGgpO1xuICAgICAgICAgICAgdmFyIHgsIHksIHAsIGwsIHNwID0gXCJcIiwgc3VicGF0aHMgPSB7fSwgcG9pbnQsXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiArIGwgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJwYXRoICYmICFzdWJwYXRocy5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCArPSBbXCJDXCIgKyBwb2ludC5zdGFydC54LCBwb2ludC5zdGFydC55LCBwb2ludC5tLngsIHBvaW50Lm0ueSwgcG9pbnQueCwgcG9pbnQueV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcIk1cIiArIHBvaW50LngsIHBvaW50LnkgKyBcIkNcIiArIHBvaW50Lm4ueCwgcG9pbnQubi55LCBwb2ludC5lbmQueCwgcG9pbnQuZW5kLnksIHBbNV0sIHBbNl1dLmpvaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gK3BbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc3RvdGFsICYmICFzdWJwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7eDogcG9pbnQueCwgeTogcG9pbnQueSwgYWxwaGE6IHBvaW50LmFscGhhfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gbDtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbNl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwICs9IHAuc2hpZnQoKSArIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJwYXRocy5lbmQgPSBzcDtcbiAgICAgICAgICAgIHBvaW50ID0gaXN0b3RhbCA/IGxlbiA6IHN1YnBhdGggPyBzdWJwYXRocyA6IFIuZmluZERvdHNBdFNlZ21lbnQoeCwgeSwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgMSk7XG4gICAgICAgICAgICBwb2ludC5hbHBoYSAmJiAocG9pbnQgPSB7eDogcG9pbnQueCwgeTogcG9pbnQueSwgYWxwaGE6IHBvaW50LmFscGhhfSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZ2V0VG90YWxMZW5ndGggPSBnZXRMZW5ndGhGYWN0b3J5KDEpLFxuICAgICAgICBnZXRQb2ludEF0TGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgpLFxuICAgICAgICBnZXRTdWJwYXRoc0F0TGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgwLCAxKTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBsZW5ndGggb2YgdGhlIGdpdmVuIHBhdGggaW4gcGl4ZWxzLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZy5cbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBsZW5ndGguXG4gICAgXFwqL1xuICAgIFIuZ2V0VG90YWxMZW5ndGggPSBnZXRUb3RhbExlbmd0aDtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm4gY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGxvY2F0ZWQgYXQgdGhlIGdpdmVuIGxlbmd0aCBvbiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBsZW5ndGggKG51bWJlcilcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGVcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiBkZXJpdmF0aXZlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBSLmdldFBvaW50QXRMZW5ndGggPSBnZXRQb2ludEF0TGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybiBzdWJwYXRoIG9mIGEgZ2l2ZW4gcGF0aCBmcm9tIGdpdmVuIGxlbmd0aCB0byBnaXZlbiBsZW5ndGguXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nXG4gICAgIC0gZnJvbSAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgLSB0byAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aHN0cmluZyBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgUi5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKHBhdGgsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRvdGFsTGVuZ3RoKHBhdGgpIC0gdG8gPCAxZS02KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3VicGF0aHNBdExlbmd0aChwYXRoLCBmcm9tKS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIHRvLCAxKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPyBnZXRTdWJwYXRoc0F0TGVuZ3RoKGEsIGZyb20pLmVuZCA6IGE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRUb3RhbExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBsZW5ndGggb2YgdGhlIHBhdGggaW4gcGl4ZWxzLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50IG9mIOKAnHBhdGjigJ0gdHlwZS5cbiAgICAgPSAobnVtYmVyKSBsZW5ndGguXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0VG90YWxMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFRvdGFsTGVuZ3RoKHBhdGgpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJuIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBsb2NhdGVkIGF0IHRoZSBnaXZlbiBsZW5ndGggb24gdGhlIGdpdmVuIHBhdGguIE9ubHkgd29ya3MgZm9yIGVsZW1lbnQgb2Yg4oCccGF0aOKAnSB0eXBlLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBsZW5ndGggKG51bWJlcilcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGVcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlXG4gICAgIG8gICAgIGFscGhhOiAobnVtYmVyKSBhbmdsZSBvZiBkZXJpdmF0aXZlXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMZW5ndGgocGF0aCwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgcGF0aCBvZiB0aGUgZWxlbWVudC4gT25seSB3b3JrcyBmb3IgZWxlbWVudHMgb2Yg4oCccGF0aOKAnSB0eXBlIGFuZCBzaW1wbGUgZWxlbWVudHMgbGlrZSBjaXJjbGUuXG4gICAgID0gKG9iamVjdCkgcGF0aFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoLFxuICAgICAgICAgICAgZ2V0UGF0aCA9IFIuX2dldFBhdGhbdGhpcy50eXBlXTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09IFwidGV4dFwiIHx8IHRoaXMudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0UGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IGdldFBhdGgodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFN1YnBhdGhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybiBzdWJwYXRoIG9mIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGdpdmVuIGxlbmd0aCB0byBnaXZlbiBsZW5ndGguIE9ubHkgd29ya3MgZm9yIGVsZW1lbnQgb2Yg4oCccGF0aOKAnSB0eXBlLlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBmcm9tIChudW1iZXIpIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHNlZ21lbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBwYXRoc3RyaW5nIGZvciB0aGUgc2VnbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmdldFN1YnBhdGggPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUi5nZXRTdWJwYXRoKHBhdGgsIGZyb20sIHRvKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmVhc2luZ19mb3JtdWxhc1xuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBPYmplY3QgdGhhdCBjb250YWlucyBlYXNpbmcgZm9ybXVsYXMgZm9yIGFuaW1hdGlvbi4gWW91IGNvdWxkIGV4dGVuZCBpdCB3aXRoIHlvdXIgb3duLiBCeSBkZWZhdWx0IGl0IGhhcyBmb2xsb3dpbmcgbGlzdCBvZiBlYXNpbmc6XG4gICAgICMgPHVsPlxuICAgICAjICAgICA8bGk+4oCcbGluZWFy4oCdPC9saT5cbiAgICAgIyAgICAgPGxpPuKAnCZsdDvigJ0gb3Ig4oCcZWFzZUlu4oCdIG9yIOKAnGVhc2UtaW7igJ08L2xpPlxuICAgICAjICAgICA8bGk+4oCcPuKAnSBvciDigJxlYXNlT3V04oCdIG9yIOKAnGVhc2Utb3V04oCdPC9saT5cbiAgICAgIyAgICAgPGxpPuKAnCZsdDs+4oCdIG9yIOKAnGVhc2VJbk91dOKAnSBvciDigJxlYXNlLWluLW91dOKAnTwvbGk+XG4gICAgICMgICAgIDxsaT7igJxiYWNrSW7igJ0gb3Ig4oCcYmFjay1pbuKAnTwvbGk+XG4gICAgICMgICAgIDxsaT7igJxiYWNrT3V04oCdIG9yIOKAnGJhY2stb3V04oCdPC9saT5cbiAgICAgIyAgICAgPGxpPuKAnGVsYXN0aWPigJ08L2xpPlxuICAgICAjICAgICA8bGk+4oCcYm91bmNl4oCdPC9saT5cbiAgICAgIyA8L3VsPlxuICAgICAjIDxwPlNlZSBhbHNvIDxhIGhyZWY9XCJodHRwOi8vcmFwaGFlbGpzLmNvbS9lYXNpbmcuaHRtbFwiPkVhc2luZyBkZW1vPC9hPi48L3A+XG4gICAgXFwqL1xuICAgIHZhciBlZiA9IFIuZWFzaW5nX2Zvcm11bGFzID0ge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSxcbiAgICAgICAgXCI8XCI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcG93KG4sIDEuNyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiPlwiOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIHBvdyhuLCAuNDgpO1xuICAgICAgICB9LFxuICAgICAgICBcIjw+XCI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgcSA9IC40OCAtIG4gLyAxLjA0LFxuICAgICAgICAgICAgICAgIFEgPSBtYXRoLnNxcnQoLjE3MzQgKyBxICogcSksXG4gICAgICAgICAgICAgICAgeCA9IFEgLSBxLFxuICAgICAgICAgICAgICAgIFggPSBwb3coYWJzKHgpLCAxIC8gMykgKiAoeCA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgICAgIHkgPSAtUSAtIHEsXG4gICAgICAgICAgICAgICAgWSA9IHBvdyhhYnMoeSksIDEgLyAzKSAqICh5IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICAgICAgdCA9IFggKyBZICsgLjU7XG4gICAgICAgICAgICByZXR1cm4gKDEgLSB0KSAqIDMgKiB0ICogdCArIHQgKiB0ICogdDtcbiAgICAgICAgfSxcbiAgICAgICAgYmFja0luOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIG4gKiBuICogKChzICsgMSkgKiBuIC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tPdXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBuID0gbiAtIDE7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gbiAqIG4gKiAoKHMgKyAxKSAqIG4gKyBzKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVsYXN0aWM6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAobiA9PSAhIW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3coMiwgLTEwICogbikgKiBtYXRoLnNpbigobiAtIC4wNzUpICogKDIgKiBQSSkgLyAuMykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBib3VuY2U6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDcuNTYyNSxcbiAgICAgICAgICAgICAgICBwID0gMi43NSxcbiAgICAgICAgICAgICAgICBsO1xuICAgICAgICAgICAgaWYgKG4gPCAoMSAvIHApKSB7XG4gICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPCAoMiAvIHApKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gKDEuNSAvIHApO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuIDwgKDIuNSAvIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuIC09ICgyLjI1IC8gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjkzNzU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuIC09ICgyLjYyNSAvIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45ODQzNzU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZWYuZWFzZUluID0gZWZbXCJlYXNlLWluXCJdID0gZWZbXCI8XCJdO1xuICAgIGVmLmVhc2VPdXQgPSBlZltcImVhc2Utb3V0XCJdID0gZWZbXCI+XCJdO1xuICAgIGVmLmVhc2VJbk91dCA9IGVmW1wiZWFzZS1pbi1vdXRcIl0gPSBlZltcIjw+XCJdO1xuICAgIGVmW1wiYmFjay1pblwiXSA9IGVmLmJhY2tJbjtcbiAgICBlZltcImJhY2stb3V0XCJdID0gZWYuYmFja091dDtcblxuICAgIHZhciBhbmltYXRpb25FbGVtZW50cyA9IFtdLFxuICAgICAgICByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIE5vdyA9ICtuZXcgRGF0ZSxcbiAgICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBsIDwgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGFuaW1hdGlvbkVsZW1lbnRzW2xdO1xuICAgICAgICAgICAgICAgIGlmIChlLmVsLnJlbW92ZWQgfHwgZS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gTm93IC0gZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgbXMgPSBlLm1zLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmcgPSBlLmVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGUuZGlmZixcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBlLnRvLFxuICAgICAgICAgICAgICAgICAgICB0ID0gZS50LFxuICAgICAgICAgICAgICAgICAgICB0aGF0ID0gZS5lbCxcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0ge30sXG4gICAgICAgICAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKGUuaW5pdHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB0aW1lID0gKGUuaW5pdHN0YXR1cyAqIGUuYW5pbS50b3AgLSBlLnByZXYpIC8gKGUucGVyY2VudCAtIGUucHJldikgKiBtcztcbiAgICAgICAgICAgICAgICAgICAgZS5zdGF0dXMgPSBlLmluaXRzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmluaXRzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcCAmJiBhbmltYXRpb25FbGVtZW50cy5zcGxpY2UobC0tLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXR1cyA9IChlLnByZXYgKyAoZS5wZXJjZW50IC0gZS5wcmV2KSAqICh0aW1lIC8gbXMpKSAvIGUuYW5pbS50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZWFzaW5nKHRpbWUgLyBtcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gZnJvbSkgaWYgKGZyb21baGFzXShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhdmFpbGFibGVBbmltQXR0cnNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG51OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSArZnJvbVthdHRyXSArIHBvcyAqIG1zICogZGlmZlthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbG91clwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBcInJnYihcIiArIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8yNTUocm91bmQoZnJvbVthdHRyXS5yICsgcG9zICogbXMgKiBkaWZmW2F0dHJdLnIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8yNTUocm91bmQoZnJvbVthdHRyXS5nICsgcG9zICogbXMgKiBkaWZmW2F0dHJdLmcpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8yNTUocm91bmQoZnJvbVthdHRyXS5iICsgcG9zICogbXMgKiBkaWZmW2F0dHJdLmIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmcm9tW2F0dHJdLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXSA9IFtmcm9tW2F0dHJdW2ldWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IGZyb21bYXR0cl1baV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXVtqXSA9ICtmcm9tW2F0dHJdW2ldW2pdICsgcG9zICogbXMgKiBkaWZmW2F0dHJdW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93W2ldID0gbm93W2ldLmpvaW4oUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gbm93LmpvaW4oUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZbYXR0cl0ucmVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGZyb21bYXR0cl0ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXSA9IFtmcm9tW2F0dHJdW2ldWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IGZyb21bYXR0cl1baV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dbaV1bal0gPSBmcm9tW2F0dHJdW2ldW2pdICsgcG9zICogbXMgKiBkaWZmW2F0dHJdW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArZnJvbVthdHRyXVtpXSArIHBvcyAqIG1zICogZGlmZlthdHRyXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgPSBbW1wiclwiLCBnZXQoMiksIDAsIDBdLCBbXCJ0XCIsIGdldCgzKSwgZ2V0KDQpXSwgW1wic1wiLCBnZXQoMCksIGdldCgxKSwgMCwgMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gW1tcIm1cIiwgZ2V0KDApLCBnZXQoMSksIGdldCgyKSwgZ2V0KDMpLCBnZXQoNCksIGdldCg1KV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjc3ZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGlwLXJlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dbaV0gPSArZnJvbVthdHRyXVtpXSArIHBvcyAqIG1zICogZGlmZlthdHRyXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbTIgPSBbXVtjb25jYXRdKGZyb21bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRoYXQucGFwZXIuY3VzdG9tQXR0cmlidXRlc1thdHRyXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1tpXSA9ICtmcm9tMltpXSArIHBvcyAqIG1zICogZGlmZlthdHRyXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFthdHRyXSA9IG5vdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0LmF0dHIoc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpZCwgdGhhdCwgYW5pbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiICsgaWQsIHRoYXQsIGFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKHRoYXQuaWQsIHRoYXQsIGUuYW5pbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGYsIGVsLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZShcInJhcGhhZWwuYW5pbS5mcmFtZS5cIiArIGVsLmlkLCBlbCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwicmFwaGFlbC5hbmltLmZpbmlzaC5cIiArIGVsLmlkLCBlbCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5pcyhmLCBcImZ1bmN0aW9uXCIpICYmIGYuY2FsbChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkoZS5jYWxsYmFjaywgdGhhdCwgZS5hbmltKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hdHRyKHRvKTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMuc3BsaWNlKGwtLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlcGVhdCA+IDEgJiYgIWUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdG8pIGlmICh0b1toYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0W2tleV0gPSBlLnRvdGFsT3JpZ2luW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmVsLmF0dHIoaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5BbmltYXRpb24oZS5hbmltLCBlLmVsLCBlLmFuaW0ucGVyY2VudHNbMF0sIG51bGwsIGUudG90YWxPcmlnaW4sIGUucmVwZWF0IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmV4dCAmJiAhZS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5BbmltYXRpb24oZS5hbmltLCBlLmVsLCBlLm5leHQsIG51bGwsIGUudG90YWxPcmlnaW4sIGUucmVwZWF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aCAmJiByZXF1ZXN0QW5pbUZyYW1lKGFuaW1hdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIHVwdG8yNTUgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvciA+IDI1NSA/IDI1NSA6IGNvbG9yIDwgMCA/IDAgOiBjb2xvcjtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlV2l0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWN0cyBzaW1pbGFyIHRvIEBFbGVtZW50LmFuaW1hdGUsIGJ1dCBlbnN1cmUgdGhhdCBnaXZlbiBhbmltYXRpb24gcnVucyBpbiBzeW5jIHdpdGggYW5vdGhlciBnaXZlbiBlbGVtZW50LlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBlbCAob2JqZWN0KSBlbGVtZW50IHRvIHN5bmMgd2l0aFxuICAgICAtIGFuaW0gKG9iamVjdCkgYW5pbWF0aW9uIHRvIHN5bmMgd2l0aFxuICAgICAtIHBhcmFtcyAob2JqZWN0KSAjb3B0aW9uYWwgZmluYWwgYXR0cmlidXRlcyBmb3IgdGhlIGVsZW1lbnQsIHNlZSBhbHNvIEBFbGVtZW50LmF0dHJcbiAgICAgLSBtcyAobnVtYmVyKSAjb3B0aW9uYWwgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0aW9uIHRvIHJ1blxuICAgICAtIGVhc2luZyAoc3RyaW5nKSAjb3B0aW9uYWwgZWFzaW5nIHR5cGUuIEFjY2VwdCBvbiBvZiBAUmFwaGFlbC5lYXNpbmdfZm9ybXVsYXMgb3IgQ1NTIGZvcm1hdDogYGN1YmljJiN4MjAxMDtiZXppZXIoWFgsJiMxNjA7WFgsJiMxNjA7WFgsJiMxNjA7WFgpYFxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uLiBXaWxsIGJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuaW1hdGlvbi5cbiAgICAgKiBvclxuICAgICAtIGVsZW1lbnQgKG9iamVjdCkgZWxlbWVudCB0byBzeW5jIHdpdGhcbiAgICAgLSBhbmltIChvYmplY3QpIGFuaW1hdGlvbiB0byBzeW5jIHdpdGhcbiAgICAgLSBhbmltYXRpb24gKG9iamVjdCkgI29wdGlvbmFsIGFuaW1hdGlvbiBvYmplY3QsIHNlZSBAUmFwaGFlbC5hbmltYXRpb25cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZVdpdGggPSBmdW5jdGlvbiAoZWwsIGFuaW0sIHBhcmFtcywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBwYXJhbXMgaW5zdGFuY2VvZiBBbmltYXRpb24gPyBwYXJhbXMgOiBSLmFuaW1hdGlvbihwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgIHgsIHk7XG4gICAgICAgIHJ1bkFuaW1hdGlvbihhLCBlbGVtZW50LCBhLnBlcmNlbnRzWzBdLCBudWxsLCBlbGVtZW50LmF0dHIoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25FbGVtZW50c1tpXS5hbmltID09IGFuaW0gJiYgYW5pbWF0aW9uRWxlbWVudHNbaV0uZWwgPT0gZWwpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbGVtZW50c1tpaSAtIDFdLnN0YXJ0ID0gYW5pbWF0aW9uRWxlbWVudHNbaV0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIC8vXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHZhciBhID0gcGFyYW1zID8gUi5hbmltYXRpb24ocGFyYW1zLCBtcywgZWFzaW5nLCBjYWxsYmFjaykgOiBhbmltLFxuICAgICAgICAvLyAgICAgc3RhdHVzID0gZWxlbWVudC5zdGF0dXMoYW5pbSk7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLmFuaW1hdGUoYSkuc3RhdHVzKGEsIHN0YXR1cyAqIGFuaW0ubXMgLyBhLm1zKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEN1YmljQmV6aWVyQXRUaW1lKHQsIHAxeCwgcDF5LCBwMngsIHAyeSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGN4ID0gMyAqIHAxeCxcbiAgICAgICAgICAgIGJ4ID0gMyAqIChwMnggLSBwMXgpIC0gY3gsXG4gICAgICAgICAgICBheCA9IDEgLSBjeCAtIGJ4LFxuICAgICAgICAgICAgY3kgPSAzICogcDF5LFxuICAgICAgICAgICAgYnkgPSAzICogKHAyeSAtIHAxeSkgLSBjeSxcbiAgICAgICAgICAgIGF5ID0gMSAtIGN5IC0gYnk7XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZUN1cnZlWCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb2x2ZSh4LCBlcHNpbG9uKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHNvbHZlQ3VydmVYKHgsIGVwc2lsb24pO1xuICAgICAgICAgICAgcmV0dXJuICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbikge1xuICAgICAgICAgICAgdmFyIHQwLCB0MSwgdDIsIHgyLCBkMiwgaTtcbiAgICAgICAgICAgIGZvcih0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeDIgPSBzYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHgyKSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkMiA9ICgzICogYXggKiB0MiArIDIgKiBieCkgKiB0MiArIGN4O1xuICAgICAgICAgICAgICAgIGlmIChhYnMoZDIpIDwgMWUtNikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MCA9IDA7XG4gICAgICAgICAgICB0MSA9IDE7XG4gICAgICAgICAgICB0MiA9IHg7XG4gICAgICAgICAgICBpZiAodDIgPCB0MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+IHQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHQwIDwgdDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgICAgICAgICAgaWYgKGFicyh4MiAtIHgpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSB0MjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0MiA9ICh0MSAtIHQwKSAvIDIgKyB0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29sdmUodCwgMSAvICgyMDAgKiBkdXJhdGlvbikpO1xuICAgIH1cbiAgICBlbHByb3RvLm9uQW5pbWF0aW9uID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZiA/IGV2ZS5vbihcInJhcGhhZWwuYW5pbS5mcmFtZS5cIiArIHRoaXMuaWQsIGYpIDogZXZlLnVuYmluZChcInJhcGhhZWwuYW5pbS5mcmFtZS5cIiArIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihhbmltLCBtcykge1xuICAgICAgICB2YXIgcGVyY2VudHMgPSBbXSxcbiAgICAgICAgICAgIG5ld0FuaW0gPSB7fTtcbiAgICAgICAgdGhpcy5tcyA9IG1zO1xuICAgICAgICB0aGlzLnRpbWVzID0gMTtcbiAgICAgICAgaWYgKGFuaW0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gYW5pbSkgaWYgKGFuaW1baGFzXShhdHRyKSkge1xuICAgICAgICAgICAgICAgIG5ld0FuaW1bdG9GbG9hdChhdHRyKV0gPSBhbmltW2F0dHJdO1xuICAgICAgICAgICAgICAgIHBlcmNlbnRzLnB1c2godG9GbG9hdChhdHRyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJjZW50cy5zb3J0KHNvcnRCeU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltID0gbmV3QW5pbTtcbiAgICAgICAgdGhpcy50b3AgPSBwZXJjZW50c1twZXJjZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5wZXJjZW50cyA9IHBlcmNlbnRzO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogQW5pbWF0aW9uLmRlbGF5XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiBleGlzdGluZyBhbmltYXRpb24gb2JqZWN0IHdpdGggZ2l2ZW4gZGVsYXkuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGRlbGF5IChudW1iZXIpIG51bWJlciBvZiBtcyB0byBwYXNzIGJldHdlZW4gYW5pbWF0aW9uIHN0YXJ0IGFuZCBhY3R1YWwgYW5pbWF0aW9uXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgbmV3IGFsdGVyZWQgQW5pbWF0aW9uIG9iamVjdFxuICAgICB8IHZhciBhbmltID0gUmFwaGFlbC5hbmltYXRpb24oe2N4OiAxMCwgY3k6IDIwfSwgMmUzKTtcbiAgICAgfCBjaXJjbGUxLmFuaW1hdGUoYW5pbSk7IC8vIHJ1biB0aGUgZ2l2ZW4gYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgIHwgY2lyY2xlMi5hbmltYXRlKGFuaW0uZGVsYXkoNTAwKSk7IC8vIHJ1biB0aGUgZ2l2ZW4gYW5pbWF0aW9uIGFmdGVyIDUwMCBtc1xuICAgIFxcKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHZhciBhID0gbmV3IEFuaW1hdGlvbih0aGlzLmFuaW0sIHRoaXMubXMpO1xuICAgICAgICBhLnRpbWVzID0gdGhpcy50aW1lcztcbiAgICAgICAgYS5kZWwgPSArZGVsYXkgfHwgMDtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogQW5pbWF0aW9uLnJlcGVhdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgZXhpc3RpbmcgYW5pbWF0aW9uIG9iamVjdCB3aXRoIGdpdmVuIHJlcGV0aXRpb24uXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHJlcGVhdCAobnVtYmVyKSBudW1iZXIgaXRlcmF0aW9ucyBvZiBhbmltYXRpb24uIEZvciBpbmZpbml0ZSBhbmltYXRpb24gcGFzcyBgSW5maW5pdHlgXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgbmV3IGFsdGVyZWQgQW5pbWF0aW9uIG9iamVjdFxuICAgIFxcKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICB2YXIgYSA9IG5ldyBBbmltYXRpb24odGhpcy5hbmltLCB0aGlzLm1zKTtcbiAgICAgICAgYS5kZWwgPSB0aGlzLmRlbDtcbiAgICAgICAgYS50aW1lcyA9IG1hdGguZmxvb3IobW1heCh0aW1lcywgMCkpIHx8IDE7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcnVuQW5pbWF0aW9uKGFuaW0sIGVsZW1lbnQsIHBlcmNlbnQsIHN0YXR1cywgdG90YWxPcmlnaW4sIHRpbWVzKSB7XG4gICAgICAgIHBlcmNlbnQgPSB0b0Zsb2F0KHBlcmNlbnQpO1xuICAgICAgICB2YXIgcGFyYW1zLFxuICAgICAgICAgICAgaXNJbkFuaW0sXG4gICAgICAgICAgICBpc0luQW5pbVNldCxcbiAgICAgICAgICAgIHBlcmNlbnRzID0gW10sXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIG1zID0gYW5pbS5tcyxcbiAgICAgICAgICAgIGZyb20gPSB7fSxcbiAgICAgICAgICAgIHRvID0ge30sXG4gICAgICAgICAgICBkaWZmID0ge307XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gYW5pbWF0aW9uRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGUuZWwuaWQgPT0gZWxlbWVudC5pZCAmJiBlLmFuaW0gPT0gYW5pbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wZXJjZW50ICE9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5BbmltU2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5BbmltID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoZS50b3RhbE9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICt0bzsgLy8gTmFOXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYW5pbS5wZXJjZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYW5pbS5wZXJjZW50c1tpXSA9PSBwZXJjZW50IHx8IGFuaW0ucGVyY2VudHNbaV0gPiBzdGF0dXMgKiBhbmltLnRvcCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBhbmltLnBlcmNlbnRzW2ldO1xuICAgICAgICAgICAgICAgIHByZXYgPSBhbmltLnBlcmNlbnRzW2kgLSAxXSB8fCAwO1xuICAgICAgICAgICAgICAgIG1zID0gbXMgLyBhbmltLnRvcCAqIChwZXJjZW50IC0gcHJldik7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGFuaW0ucGVyY2VudHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFuaW0uYW5pbVtwZXJjZW50XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKGFuaW0uYW5pbVthbmltLnBlcmNlbnRzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5BbmltKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIHBhcmFtcykgaWYgKHBhcmFtc1toYXNdKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZUFuaW1BdHRyc1toYXNdKGF0dHIpIHx8IGVsZW1lbnQucGFwZXIuY3VzdG9tQXR0cmlidXRlc1toYXNdKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21bYXR0cl0gPSBlbGVtZW50LmF0dHIoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIChmcm9tW2F0dHJdID09IG51bGwpICYmIChmcm9tW2F0dHJdID0gYXZhaWxhYmxlQXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICB0b1thdHRyXSA9IHBhcmFtc1thdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhdmFpbGFibGVBbmltQXR0cnNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbnU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXSA9ICh0b1thdHRyXSAtIGZyb21bYXR0cl0pIC8gbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29sb3VyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVthdHRyXSA9IFIuZ2V0UkdCKGZyb21bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0NvbG91ciA9IFIuZ2V0UkdCKHRvW2F0dHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiAodG9Db2xvdXIuciAtIGZyb21bYXR0cl0ucikgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZzogKHRvQ29sb3VyLmcgLSBmcm9tW2F0dHJdLmcpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6ICh0b0NvbG91ci5iIC0gZnJvbVthdHRyXS5iKSAvIG1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhlcyA9IHBhdGgyY3VydmUoZnJvbVthdHRyXSwgdG9bYXR0cl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1BhdGggPSBwYXRoZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVthdHRyXSA9IHBhdGhlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBmcm9tW2F0dHJdLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXVtpXSA9IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gZnJvbVthdHRyXVtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdW2ldW2pdID0gKHRvUGF0aFtpXVtqXSAtIGZyb21bYXR0cl1baV1bal0pIC8gbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF8gPSBlbGVtZW50Ll8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxID0gZXF1YWxpc2VUcmFuc2Zvcm0oX1thdHRyXSwgdG9bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2F0dHJdID0gZXEuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9bYXR0cl0gPSBlcS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdLnJlYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGZyb21bYXR0cl0ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXVtpXSA9IFtmcm9tW2F0dHJdW2ldWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gZnJvbVthdHRyXVtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZlthdHRyXVtpXVtqXSA9ICh0b1thdHRyXVtpXVtqXSAtIGZyb21bYXR0cl1baV1bal0pIC8gbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IChlbGVtZW50Lm1hdHJpeCB8fCBuZXcgTWF0cml4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvMiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfOiB7dHJhbnNmb3JtOiBfLnRyYW5zZm9ybX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QkJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRCQm94KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21bYXR0cl0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZm9ybSh0bzIsIHRvW2F0dHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9bYXR0cl0gPSB0bzIuXy50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG8yLm1hdHJpeC5hIC0gbS5hKSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvMi5tYXRyaXguYiAtIG0uYikgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0bzIubWF0cml4LmMgLSBtLmMpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG8yLm1hdHJpeC5kIC0gbS5kKSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvMi5tYXRyaXguZSAtIG0uZSkgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0bzIubWF0cml4LmYgLSBtLmYpIC8gbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbVthdHRyXSA9IFtfLnN4LCBfLnN5LCBfLmRlZywgXy5keCwgXy5keV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciB0bzIgPSB7Xzp7fSwgZ2V0QkJveDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudC5nZXRCQm94KCk7IH19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHRyYWN0VHJhbnNmb3JtKHRvMiwgdG9bYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmW2F0dHJdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgKHRvMi5fLnN4IC0gXy5zeCkgLyBtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICh0bzIuXy5zeSAtIF8uc3kpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAodG8yLl8uZGVnIC0gXy5kZWcpIC8gbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAodG8yLl8uZHggLSBfLmR4KSAvIG1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgKHRvMi5fLmR5IC0gXy5keSkgLyBtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjc3ZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gU3RyKHBhcmFtc1thdHRyXSlbc3BsaXRdKHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20yID0gU3RyKGZyb21bYXR0cl0pW3NwbGl0XShzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xpcC1yZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVthdHRyXSA9IGZyb20yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBmcm9tMi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbYXR0cl1baV0gPSAodmFsdWVzW2ldIC0gZnJvbVthdHRyXVtpXSkgLyBtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1thdHRyXSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW11bY29uY2F0XShwYXJhbXNbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20yID0gW11bY29uY2F0XShmcm9tW2F0dHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGVsZW1lbnQucGFwZXIuY3VzdG9tQXR0cmlidXRlc1thdHRyXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmW2F0dHJdW2ldID0gKCh2YWx1ZXNbaV0gfHwgMCkgLSAoZnJvbTJbaV0gfHwgMCkpIC8gbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgZWFzeWVhc3kgPSBSLmVhc2luZ19mb3JtdWxhc1tlYXNpbmddO1xuICAgICAgICAgICAgaWYgKCFlYXN5ZWFzeSkge1xuICAgICAgICAgICAgICAgIGVhc3llYXN5ID0gU3RyKGVhc2luZykubWF0Y2goYmV6aWVycmcpO1xuICAgICAgICAgICAgICAgIGlmIChlYXN5ZWFzeSAmJiBlYXN5ZWFzeS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSBlYXN5ZWFzeTtcbiAgICAgICAgICAgICAgICAgICAgZWFzeWVhc3kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEN1YmljQmV6aWVyQXRUaW1lKHQsICtjdXJ2ZVsxXSwgK2N1cnZlWzJdLCArY3VydmVbM10sICtjdXJ2ZVs0XSwgbXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVhc3llYXN5ID0gcGlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJhbXMuc3RhcnQgfHwgYW5pbS5zdGFydCB8fCArbmV3IERhdGU7XG4gICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgIGFuaW06IGFuaW0sXG4gICAgICAgICAgICAgICAgcGVyY2VudDogcGVyY2VudCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBzdGFydDogdGltZXN0YW1wICsgKGFuaW0uZGVsIHx8IDApLFxuICAgICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgICBpbml0c3RhdHVzOiBzdGF0dXMgfHwgMCxcbiAgICAgICAgICAgICAgICBzdG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtczogbXMsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBlYXN5ZWFzeSxcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgIGVsOiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBwYXJhbXMuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgcHJldjogcHJldixcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0LFxuICAgICAgICAgICAgICAgIHJlcGVhdDogdGltZXMgfHwgYW5pbS50aW1lcyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGVsZW1lbnQuYXR0cigpLFxuICAgICAgICAgICAgICAgIHRvdGFsT3JpZ2luOiB0b3RhbE9yaWdpblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzICYmICFpc0luQW5pbSAmJiAhaXNJbkFuaW1TZXQpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGUuc3RhcnQgPSBuZXcgRGF0ZSAtIG1zICogc3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25FbGVtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5BbmltU2V0KSB7XG4gICAgICAgICAgICAgICAgZS5zdGFydCA9IG5ldyBEYXRlIC0gZS5tcyAqIHN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aCA9PSAxICYmIHJlcXVlc3RBbmltRnJhbWUoYW5pbWF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzSW5BbmltLmluaXRzdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICBpc0luQW5pbS5zdGFydCA9IG5ldyBEYXRlIC0gaXNJbkFuaW0ubXMgKiBzdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgZXZlKFwicmFwaGFlbC5hbmltLnN0YXJ0LlwiICsgZWxlbWVudC5pZCwgZWxlbWVudCwgYW5pbSk7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmFuaW1hdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhbiBhbmltYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgQEVsZW1lbnQuYW5pbWF0ZSBvciBARWxlbWVudC5hbmltYXRlV2l0aCBtZXRob2RzLlxuICAgICAqIFNlZSBhbHNvIEBBbmltYXRpb24uZGVsYXkgYW5kIEBBbmltYXRpb24ucmVwZWF0IG1ldGhvZHMuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHBhcmFtcyAob2JqZWN0KSBmaW5hbCBhdHRyaWJ1dGVzIGZvciB0aGUgZWxlbWVudCwgc2VlIGFsc28gQEVsZW1lbnQuYXR0clxuICAgICAtIG1zIChudW1iZXIpIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZm9yIGFuaW1hdGlvbiB0byBydW5cbiAgICAgLSBlYXNpbmcgKHN0cmluZykgI29wdGlvbmFsIGVhc2luZyB0eXBlLiBBY2NlcHQgb25lIG9mIEBSYXBoYWVsLmVhc2luZ19mb3JtdWxhcyBvciBDU1MgZm9ybWF0OiBgY3ViaWMmI3gyMDEwO2JlemllcihYWCwmIzE2MDtYWCwmIzE2MDtYWCwmIzE2MDtYWClgXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uIFdpbGwgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIEBBbmltYXRpb25cbiAgICBcXCovXG4gICAgUi5hbmltYXRpb24gPSBmdW5jdGlvbiAocGFyYW1zLCBtcywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAocGFyYW1zIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSLmlzKGVhc2luZywgXCJmdW5jdGlvblwiKSB8fCAhZWFzaW5nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGVhc2luZyB8fCBudWxsO1xuICAgICAgICAgICAgZWFzaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBPYmplY3QocGFyYW1zKTtcbiAgICAgICAgbXMgPSArbXMgfHwgMDtcbiAgICAgICAgdmFyIHAgPSB7fSxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICBhdHRyO1xuICAgICAgICBmb3IgKGF0dHIgaW4gcGFyYW1zKSBpZiAocGFyYW1zW2hhc10oYXR0cikgJiYgdG9GbG9hdChhdHRyKSAhPSBhdHRyICYmIHRvRmxvYXQoYXR0cikgKyBcIiVcIiAhPSBhdHRyKSB7XG4gICAgICAgICAgICBqc29uID0gdHJ1ZTtcbiAgICAgICAgICAgIHBbYXR0cl0gPSBwYXJhbXNbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICAvLyBpZiBwZXJjZW50LWxpa2Ugc3ludGF4IGlzIHVzZWQgYW5kIGVuZC1vZi1hbGwgYW5pbWF0aW9uIGNhbGxiYWNrIHVzZWRcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKXtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgIHZhciBsYXN0S2V5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gcGFyYW1zKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0b0ludChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocGFyYW1zW2hhc10oaSkgJiYgcGVyY2VudCA+IGxhc3RLZXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtleSA9IHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdEtleSArPSAnJSc7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBkZWZpbmVkIGNhbGxiYWNrIGluIHRoZSBsYXN0IGtleWZyYW1lLCBza2lwXG4gICAgICAgICAgICAgICAgIXBhcmFtc1tsYXN0S2V5XS5jYWxsYmFjayAmJiAocGFyYW1zW2xhc3RLZXldLmNhbGxiYWNrID0gY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKHBhcmFtcywgbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFzaW5nICYmIChwLmVhc2luZyA9IGVhc2luZyk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiAocC5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKHsxMDA6IHB9LCBtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYW5kIHN0YXJ0cyBhbmltYXRpb24gZm9yIGdpdmVuIGVsZW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHBhcmFtcyAob2JqZWN0KSBmaW5hbCBhdHRyaWJ1dGVzIGZvciB0aGUgZWxlbWVudCwgc2VlIGFsc28gQEVsZW1lbnQuYXR0clxuICAgICAtIG1zIChudW1iZXIpIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZm9yIGFuaW1hdGlvbiB0byBydW5cbiAgICAgLSBlYXNpbmcgKHN0cmluZykgI29wdGlvbmFsIGVhc2luZyB0eXBlLiBBY2NlcHQgb25lIG9mIEBSYXBoYWVsLmVhc2luZ19mb3JtdWxhcyBvciBDU1MgZm9ybWF0OiBgY3ViaWMmI3gyMDEwO2JlemllcihYWCwmIzE2MDtYWCwmIzE2MDtYWCwmIzE2MDtYWClgXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uIFdpbGwgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uLlxuICAgICAqIG9yXG4gICAgIC0gYW5pbWF0aW9uIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QsIHNlZSBAUmFwaGFlbC5hbmltYXRpb25cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmltID0gcGFyYW1zIGluc3RhbmNlb2YgQW5pbWF0aW9uID8gcGFyYW1zIDogUi5hbmltYXRpb24ocGFyYW1zLCBtcywgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgIHJ1bkFuaW1hdGlvbihhbmltLCBlbGVtZW50LCBhbmltLnBlcmNlbnRzWzBdLCBudWxsLCBlbGVtZW50LmF0dHIoKSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2V0VGltZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2V0cyB0aGUgc3RhdHVzIG9mIGFuaW1hdGlvbiBvZiB0aGUgZWxlbWVudCBpbiBtaWxsaXNlY29uZHMuIFNpbWlsYXIgdG8gQEVsZW1lbnQuc3RhdHVzIG1ldGhvZC5cbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gYW5pbSAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0XG4gICAgIC0gdmFsdWUgKG51bWJlcikgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFuaW1hdGlvblxuICAgICAqKlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnQgaWYgYHZhbHVlYCBpcyBzcGVjaWZpZWRcbiAgICAgKiBOb3RlLCB0aGF0IGR1cmluZyBhbmltYXRpb24gZm9sbG93aW5nIGV2ZW50cyBhcmUgdHJpZ2dlcmVkOlxuICAgICAqXG4gICAgICogT24gZWFjaCBhbmltYXRpb24gZnJhbWUgZXZlbnQgYGFuaW0uZnJhbWUuPGlkPmAsIG9uIHN0YXJ0IGBhbmltLnN0YXJ0LjxpZD5gIGFuZCBvbiBlbmQgYGFuaW0uZmluaXNoLjxpZD5gLlxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNldFRpbWUgPSBmdW5jdGlvbiAoYW5pbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFuaW0gJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMoYW5pbSwgbW1pbih2YWx1ZSwgYW5pbS5tcykgLyBhbmltLm1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnN0YXR1c1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBhbmltIChvYmplY3QpICNvcHRpb25hbCBhbmltYXRpb24gb2JqZWN0XG4gICAgIC0gdmFsdWUgKG51bWJlcikgI29wdGlvbmFsIDAg4oCTIDEuIElmIHNwZWNpZmllZCwgbWV0aG9kIHdvcmtzIGxpa2UgYSBzZXR0ZXIgYW5kIHNldHMgdGhlIHN0YXR1cyBvZiBhIGdpdmVuIGFuaW1hdGlvbiB0byB0aGUgdmFsdWUuIFRoaXMgd2lsbCBjYXVzZSBhbmltYXRpb24gdG8ganVtcCB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICoqXG4gICAgID0gKG51bWJlcikgc3RhdHVzXG4gICAgICogb3JcbiAgICAgPSAoYXJyYXkpIHN0YXR1cyBpZiBgYW5pbWAgaXMgbm90IHNwZWNpZmllZC4gQXJyYXkgb2Ygb2JqZWN0cyBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBhbmltOiAob2JqZWN0KSBhbmltYXRpb24gb2JqZWN0XG4gICAgIG8gICAgIHN0YXR1czogKG51bWJlcikgc3RhdHVzXG4gICAgIG8gfVxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudCBpZiBgdmFsdWVgIGlzIHNwZWNpZmllZFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnN0YXR1cyA9IGZ1bmN0aW9uIChhbmltLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIGU7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBydW5BbmltYXRpb24oYW5pbSwgdGhpcywgLTEsIG1taW4odmFsdWUsIDEpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGUgPSBhbmltYXRpb25FbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZS5lbC5pZCA9PSB0aGlzLmlkICYmICghYW5pbSB8fCBlLmFuaW0gPT0gYW5pbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltOiBlLmFuaW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGUuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wYXVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IHdpdGggYWJpbGl0eSB0byByZXN1bWUgaXQgbGF0ZXIgb24uXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGFuaW0gKG9iamVjdCkgI29wdGlvbmFsIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucGF1c2UgPSBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aDsgaSsrKSBpZiAoYW5pbWF0aW9uRWxlbWVudHNbaV0uZWwuaWQgPT0gdGhpcy5pZCAmJiAoIWFuaW0gfHwgYW5pbWF0aW9uRWxlbWVudHNbaV0uYW5pbSA9PSBhbmltKSkge1xuICAgICAgICAgICAgaWYgKGV2ZShcInJhcGhhZWwuYW5pbS5wYXVzZS5cIiArIHRoaXMuaWQsIHRoaXMsIGFuaW1hdGlvbkVsZW1lbnRzW2ldLmFuaW0pICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVsZW1lbnRzW2ldLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZXN1bWVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlc3VtZXMgYW5pbWF0aW9uIGlmIGl0IHdhcyBwYXVzZWQgd2l0aCBARWxlbWVudC5wYXVzZSBtZXRob2QuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGFuaW0gKG9iamVjdCkgI29wdGlvbmFsIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBvcmlnaW5hbCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVzdW1lID0gZnVuY3Rpb24gKGFuaW0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25FbGVtZW50cy5sZW5ndGg7IGkrKykgaWYgKGFuaW1hdGlvbkVsZW1lbnRzW2ldLmVsLmlkID09IHRoaXMuaWQgJiYgKCFhbmltIHx8IGFuaW1hdGlvbkVsZW1lbnRzW2ldLmFuaW0gPT0gYW5pbSkpIHtcbiAgICAgICAgICAgIHZhciBlID0gYW5pbWF0aW9uRWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZXZlKFwicmFwaGFlbC5hbmltLnJlc3VtZS5cIiArIHRoaXMuaWQsIHRoaXMsIGUuYW5pbSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGUucGF1c2VkO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzKGUuYW5pbSwgZS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBhbmltIChvYmplY3QpICNvcHRpb25hbCBhbmltYXRpb24gb2JqZWN0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnN0b3AgPSBmdW5jdGlvbiAoYW5pbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aDsgaSsrKSBpZiAoYW5pbWF0aW9uRWxlbWVudHNbaV0uZWwuaWQgPT0gdGhpcy5pZCAmJiAoIWFuaW0gfHwgYW5pbWF0aW9uRWxlbWVudHNbaV0uYW5pbSA9PSBhbmltKSkge1xuICAgICAgICAgICAgaWYgKGV2ZShcInJhcGhhZWwuYW5pbS5zdG9wLlwiICsgdGhpcy5pZCwgdGhpcywgYW5pbWF0aW9uRWxlbWVudHNbaV0uYW5pbSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uKHBhcGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uRWxlbWVudHMubGVuZ3RoOyBpKyspIGlmIChhbmltYXRpb25FbGVtZW50c1tpXS5lbC5wYXBlciA9PSBwYXBlcikge1xuICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZlLm9uKFwicmFwaGFlbC5yZW1vdmVcIiwgc3RvcEFuaW1hdGlvbik7XG4gICAgZXZlLm9uKFwicmFwaGFlbC5jbGVhclwiLCBzdG9wQW5pbWF0aW9uKTtcbiAgICBlbHByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSYXBoYVxceGVibFxcdTIwMTlzIG9iamVjdFwiO1xuICAgIH07XG5cbiAgICAvLyBTZXRcbiAgICB2YXIgU2V0ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInNldFwiO1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbaV0gJiYgKGl0ZW1zW2ldLmNvbnN0cnVjdG9yID09IGVscHJvdG8uY29uc3RydWN0b3IgfHwgaXRlbXNbaV0uY29uc3RydWN0b3IgPT0gU2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRwcm90byA9IFNldC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIFNldC5wdXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGVhY2ggYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2V0LlxuICAgICA9IChvYmplY3QpIG9yaWdpbmFsIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW0sXG4gICAgICAgICAgICBsZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgKGl0ZW0uY29uc3RydWN0b3IgPT0gZWxwcm90by5jb25zdHJ1Y3RvciB8fCBpdGVtLmNvbnN0cnVjdG9yID09IFNldCkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzW2xlbl0gPSB0aGlzLml0ZW1zW2xlbl0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnBvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBsYXN0IGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAgID0gKG9iamVjdCkgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICYmIGRlbGV0ZSB0aGlzW3RoaXMubGVuZ3RoLS1dO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5wb3AoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuZm9yRWFjaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LlxuICAgICAqXG4gICAgICogSWYgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIGl0IHdpbGwgc3RvcCBsb29wIHJ1bm5pbmcuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgIC0gdGhpc0FyZyAob2JqZWN0KSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrXG4gICAgID0gKG9iamVjdCkgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5pdGVtc1tpXSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gZWxwcm90bykgaWYgKGVscHJvdG9baGFzXShtZXRob2QpKSB7XG4gICAgICAgIHNldHByb3RvW21ldGhvZF0gPSAoZnVuY3Rpb24gKG1ldGhvZG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbFttZXRob2RuYW1lXVthcHBseV0oZWwsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShtZXRob2QpO1xuICAgIH1cbiAgICBzZXRwcm90by5hdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lICYmIFIuaXMobmFtZSwgYXJyYXkpICYmIFIuaXMobmFtZVswXSwgXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IG5hbWUubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbal0uYXR0cihuYW1lW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uYXR0cihuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmNsZWFyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5zcGxpY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgICoqXG4gICAgIC0gaW5kZXggKG51bWJlcikgcG9zaXRpb24gb2YgdGhlIGRlbGV0aW9uXG4gICAgIC0gY291bnQgKG51bWJlcikgbnVtYmVyIG9mIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgIC0gaW5zZXJ0aW9u4oCmIChvYmplY3QpICNvcHRpb25hbCBlbGVtZW50cyB0byBpbnNlcnRcbiAgICAgPSAob2JqZWN0KSBzZXQgZWxlbWVudHMgdGhhdCB3ZXJlIGRlbGV0ZWRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uc3BsaWNlID0gZnVuY3Rpb24gKGluZGV4LCBjb3VudCwgaW5zZXJ0aW9uKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbW1heCh0aGlzLmxlbmd0aCArIGluZGV4LCAwKSA6IGluZGV4O1xuICAgICAgICBjb3VudCA9IG1tYXgoMCwgbW1pbih0aGlzLmxlbmd0aCAtIGluZGV4LCBjb3VudCkpO1xuICAgICAgICB2YXIgdGFpbCA9IFtdLFxuICAgICAgICAgICAgdG9kZWwgPSBbXSxcbiAgICAgICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b2RlbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHRhaWwucHVzaCh0aGlzW2luZGV4ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2xlbiArIHRhaWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaW5kZXggKyBpXSA9IHRoaXNbaW5kZXggKyBpXSA9IGkgPCBhcmdsZW4gPyBhcmdzW2ldIDogdGFpbFtpIC0gYXJnbGVuXTtcbiAgICAgICAgfVxuICAgICAgICBpID0gdGhpcy5pdGVtcy5sZW5ndGggPSB0aGlzLmxlbmd0aCAtPSBjb3VudCAtIGFyZ2xlbjtcbiAgICAgICAgd2hpbGUgKHRoaXNbaV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2krK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodG9kZWwpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5leGNsdWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGVsZW1lbnQgKG9iamVjdCkgZWxlbWVudCB0byByZW1vdmVcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIG9iamVjdCB3YXMgZm91bmQgJiByZW1vdmVkIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5leGNsdWRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXNbaV0gPT0gZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNldHByb3RvLmFuaW1hdGUgPSBmdW5jdGlvbiAocGFyYW1zLCBtcywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAoUi5pcyhlYXNpbmcsIFwiZnVuY3Rpb25cIikgfHwgIWVhc2luZykgJiYgKGNhbGxiYWNrID0gZWFzaW5nIHx8IG51bGwpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpID0gbGVuLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHNldCA9IHRoaXMsXG4gICAgICAgICAgICBjb2xsZWN0b3I7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayAmJiAoY29sbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIS0tbGVuICYmIGNhbGxiYWNrLmNhbGwoc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhc2luZyA9IFIuaXMoZWFzaW5nLCBzdHJpbmcpID8gZWFzaW5nIDogY29sbGVjdG9yO1xuICAgICAgICB2YXIgYW5pbSA9IFIuYW5pbWF0aW9uKHBhcmFtcywgbXMsIGVhc2luZywgY29sbGVjdG9yKTtcbiAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbLS1pXS5hbmltYXRlKGFuaW0pO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldICYmICF0aGlzLml0ZW1zW2ldLnJlbW92ZWQgJiYgdGhpcy5pdGVtc1tpXS5hbmltYXRlV2l0aChpdGVtLCBhbmltLCBhbmltKTtcbiAgICAgICAgICAgICh0aGlzLml0ZW1zW2ldICYmICF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHx8IGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgc2V0cHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5pbnNlcnRBZnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBzZXRwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IFtdLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgeDIgPSBbXSxcbiAgICAgICAgICAgIHkyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykgaWYgKCF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLml0ZW1zW2ldLmdldEJCb3goKTtcbiAgICAgICAgICAgIHgucHVzaChib3gueCk7XG4gICAgICAgICAgICB5LnB1c2goYm94LnkpO1xuICAgICAgICAgICAgeDIucHVzaChib3gueCArIGJveC53aWR0aCk7XG4gICAgICAgICAgICB5Mi5wdXNoKGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IG1taW5bYXBwbHldKDAsIHgpO1xuICAgICAgICB5ID0gbW1pblthcHBseV0oMCwgeSk7XG4gICAgICAgIHgyID0gbW1heFthcHBseV0oMCwgeDIpO1xuICAgICAgICB5MiA9IG1tYXhbYXBwbHldKDAsIHkyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgd2lkdGg6IHgyIC0geCxcbiAgICAgICAgICAgIGhlaWdodDogeTIgLSB5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBzZXRwcm90by5jbG9uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMgPSB0aGlzLnBhcGVyLnNldCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHMucHVzaCh0aGlzLml0ZW1zW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgc2V0cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJhcGhhXFx4ZWJsXFx1MjAxOHMgc2V0XCI7XG4gICAgfTtcblxuICAgIHNldHByb3RvLmdsb3cgPSBmdW5jdGlvbihnbG93Q29uZmlnKSB7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLnBhcGVyLnNldCgpO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oc2hhcGUsIGluZGV4KXtcbiAgICAgICAgICAgIHZhciBnID0gc2hhcGUuZ2xvdyhnbG93Q29uZmlnKTtcbiAgICAgICAgICAgIGlmKGcgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgZy5mb3JFYWNoKGZ1bmN0aW9uKHNoYXBlMiwgaW5kZXgyKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG4gICAgLypcXFxuICAgICAqIFNldC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoaXMgc2V04oCZcyBlbGVtZW50c1xuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSBhbnkgb2YgdGhlIHNldCdzIGVsZW1lbnRzXG4gICAgIFxcKi9cbiAgICBzZXRwcm90by5pc1BvaW50SW5zaWRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGlzUG9pbnRJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLmlzUG9pbnRJbnNpZGUoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBpc1BvaW50SW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHN0b3AgbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzUG9pbnRJbnNpZGU7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLnJlZ2lzdGVyRm9udFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBnaXZlbiBmb250IHRvIHRoZSByZWdpc3RlcmVkIHNldCBvZiBmb250cyBmb3IgUmFwaGHDq2wuIFNob3VsZCBiZSB1c2VkIGFzIGFuIGludGVybmFsIGNhbGwgZnJvbSB3aXRoaW4gQ3Vmw7Nu4oCZcyBmb250IGZpbGUuXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBwYXJhbWV0ZXIsIHNvIGl0IGNvdWxkIGJlIHVzZWQgd2l0aCBjaGFpbmluZy5cbiAgICAgIyA8YSBocmVmPVwiaHR0cDovL3dpa2kuZ2l0aHViLmNvbS9zb3JjY3UvY3Vmb24vYWJvdXRcIj5Nb3JlIGFib3V0IEN1ZsOzbiBhbmQgaG93IHRvIGNvbnZlcnQgeW91ciBmb250IGZvcm0gVFRGLCBPVEYsIGV0YyB0byBKYXZhU2NyaXB0IGZpbGUuPC9hPlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSBmb250IChvYmplY3QpIHRoZSBmb250IHRvIHJlZ2lzdGVyXG4gICAgID0gKG9iamVjdCkgdGhlIGZvbnQgeW91IHBhc3NlZCBpblxuICAgICA+IFVzYWdlXG4gICAgIHwgQ3Vmb24ucmVnaXN0ZXJGb250KFJhcGhhZWwucmVnaXN0ZXJGb250KHvigKZ9KSk7XG4gICAgXFwqL1xuICAgIFIucmVnaXN0ZXJGb250ID0gZnVuY3Rpb24gKGZvbnQpIHtcbiAgICAgICAgaWYgKCFmb250LmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmb250O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9udHMgPSB0aGlzLmZvbnRzIHx8IHt9O1xuICAgICAgICB2YXIgZm9udGNvcHkgPSB7XG4gICAgICAgICAgICAgICAgdzogZm9udC53LFxuICAgICAgICAgICAgICAgIGZhY2U6IHt9LFxuICAgICAgICAgICAgICAgIGdseXBoczoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYW1pbHkgPSBmb250LmZhY2VbXCJmb250LWZhbWlseVwiXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmb250LmZhY2UpIGlmIChmb250LmZhY2VbaGFzXShwcm9wKSkge1xuICAgICAgICAgICAgZm9udGNvcHkuZmFjZVtwcm9wXSA9IGZvbnQuZmFjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250c1tmYW1pbHldKSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ZhbWlseV0ucHVzaChmb250Y29weSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ZhbWlseV0gPSBbZm9udGNvcHldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9udC5zdmcpIHtcbiAgICAgICAgICAgIGZvbnRjb3B5LmZhY2VbXCJ1bml0cy1wZXItZW1cIl0gPSB0b0ludChmb250LmZhY2VbXCJ1bml0cy1wZXItZW1cIl0sIDEwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGdseXBoIGluIGZvbnQuZ2x5cGhzKSBpZiAoZm9udC5nbHlwaHNbaGFzXShnbHlwaCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGZvbnQuZ2x5cGhzW2dseXBoXTtcbiAgICAgICAgICAgICAgICBmb250Y29weS5nbHlwaHNbZ2x5cGhdID0ge1xuICAgICAgICAgICAgICAgICAgICB3OiBwYXRoLncsXG4gICAgICAgICAgICAgICAgICAgIGs6IHt9LFxuICAgICAgICAgICAgICAgICAgICBkOiBwYXRoLmQgJiYgXCJNXCIgKyBwYXRoLmQucmVwbGFjZSgvW21sY3h0cnZdL2csIGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtsOiBcIkxcIiwgYzogXCJDXCIsIHg6IFwielwiLCB0OiBcIm1cIiwgcjogXCJsXCIsIHY6IFwiY1wifVtjb21tYW5kXSB8fCBcIk1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICsgXCJ6XCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBwYXRoLmspIGlmIChwYXRoW2hhc10oaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRjb3B5LmdseXBoc1tnbHlwaF0ua1trXSA9IHBhdGgua1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nZXRGb250XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBGaW5kcyBmb250IG9iamVjdCBpbiB0aGUgcmVnaXN0ZXJlZCBmb250cyBieSBnaXZlbiBwYXJhbWV0ZXJzLiBZb3UgY291bGQgc3BlY2lmeSBvbmx5IG9uZSB3b3JkIGZyb20gdGhlIGZvbnQgbmFtZSwgbGlrZSDigJxNeXJpYWTigJ0gZm9yIOKAnE15cmlhZCBQcm/igJ0uXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGZhbWlseSAoc3RyaW5nKSBmb250IGZhbWlseSBuYW1lIG9yIGFueSB3b3JkIGZyb20gaXRcbiAgICAgLSB3ZWlnaHQgKHN0cmluZykgI29wdGlvbmFsIGZvbnQgd2VpZ2h0XG4gICAgIC0gc3R5bGUgKHN0cmluZykgI29wdGlvbmFsIGZvbnQgc3R5bGVcbiAgICAgLSBzdHJldGNoIChzdHJpbmcpICNvcHRpb25hbCBmb250IHN0cmV0Y2hcbiAgICAgPSAob2JqZWN0KSB0aGUgZm9udCBvYmplY3RcbiAgICAgPiBVc2FnZVxuICAgICB8IHBhcGVyLnByaW50KDEwMCwgMTAwLCBcIlRlc3Qgc3RyaW5nXCIsIHBhcGVyLmdldEZvbnQoXCJUaW1lc1wiLCA4MDApLCAzMCk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uZ2V0Rm9udCA9IGZ1bmN0aW9uIChmYW1pbHksIHdlaWdodCwgc3R5bGUsIHN0cmV0Y2gpIHtcbiAgICAgICAgc3RyZXRjaCA9IHN0cmV0Y2ggfHwgXCJub3JtYWxcIjtcbiAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCBcIm5vcm1hbFwiO1xuICAgICAgICB3ZWlnaHQgPSArd2VpZ2h0IHx8IHtub3JtYWw6IDQwMCwgYm9sZDogNzAwLCBsaWdodGVyOiAzMDAsIGJvbGRlcjogODAwfVt3ZWlnaHRdIHx8IDQwMDtcbiAgICAgICAgaWYgKCFSLmZvbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnQgPSBSLmZvbnRzW2ZhbWlseV07XG4gICAgICAgIGlmICghZm9udCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBmYW1pbHkucmVwbGFjZSgvW15cXHdcXGRcXHMrIX4uOl8tXS9nLCBFKSArIFwiKFxcXFxzfCQpXCIsIFwiaVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGZvbnROYW1lIGluIFIuZm9udHMpIGlmIChSLmZvbnRzW2hhc10oZm9udE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUudGVzdChmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IFIuZm9udHNbZm9udE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoZWZvbnQ7XG4gICAgICAgIGlmIChmb250KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmb250Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGVmb250ID0gZm9udFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhlZm9udC5mYWNlW1wiZm9udC13ZWlnaHRcIl0gPT0gd2VpZ2h0ICYmICh0aGVmb250LmZhY2VbXCJmb250LXN0eWxlXCJdID09IHN0eWxlIHx8ICF0aGVmb250LmZhY2VbXCJmb250LXN0eWxlXCJdKSAmJiB0aGVmb250LmZhY2VbXCJmb250LXN0cmV0Y2hcIl0gPT0gc3RyZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZWZvbnQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucHJpbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgcGF0aCB0aGF0IHJlcHJlc2VudCBnaXZlbiB0ZXh0IHdyaXR0ZW4gdXNpbmcgZ2l2ZW4gZm9udCBhdCBnaXZlbiBwb3NpdGlvbiB3aXRoIGdpdmVuIHNpemUuXG4gICAgICogUmVzdWx0IG9mIHRoZSBtZXRob2QgaXMgcGF0aCBlbGVtZW50IHRoYXQgY29udGFpbnMgd2hvbGUgdGV4dCBhcyBhIHNlcGFyYXRlIHBhdGguXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBwb3NpdGlvbiBvZiB0aGUgdGV4dFxuICAgICAtIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgdGV4dFxuICAgICAtIHN0cmluZyAoc3RyaW5nKSB0ZXh0IHRvIHByaW50XG4gICAgIC0gZm9udCAob2JqZWN0KSBmb250IG9iamVjdCwgc2VlIEBQYXBlci5nZXRGb250XG4gICAgIC0gc2l6ZSAobnVtYmVyKSAjb3B0aW9uYWwgc2l6ZSBvZiB0aGUgZm9udCwgZGVmYXVsdCBpcyBgMTZgXG4gICAgIC0gb3JpZ2luIChzdHJpbmcpICNvcHRpb25hbCBjb3VsZCBiZSBgXCJiYXNlbGluZVwiYCBvciBgXCJtaWRkbGVcImAsIGRlZmF1bHQgaXMgYFwibWlkZGxlXCJgXG4gICAgIC0gbGV0dGVyX3NwYWNpbmcgKG51bWJlcikgI29wdGlvbmFsIG51bWJlciBpbiByYW5nZSBgLTEuLjFgLCBkZWZhdWx0IGlzIGAwYFxuICAgICAtIGxpbmVfc3BhY2luZyAobnVtYmVyKSAjb3B0aW9uYWwgbnVtYmVyIGluIHJhbmdlIGAxLi4zYCwgZGVmYXVsdCBpcyBgMWBcbiAgICAgPSAob2JqZWN0KSByZXN1bHRpbmcgcGF0aCBlbGVtZW50LCB3aGljaCBjb25zaXN0IG9mIGFsbCBsZXR0ZXJzXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdHh0ID0gci5wcmludCgxMCwgNTAsIFwicHJpbnRcIiwgci5nZXRGb250KFwiTXVzZW9cIiksIDMwKS5hdHRyKHtmaWxsOiBcIiNmZmZcIn0pO1xuICAgIFxcKi9cbiAgICBwYXBlcnByb3RvLnByaW50ID0gZnVuY3Rpb24gKHgsIHksIHN0cmluZywgZm9udCwgc2l6ZSwgb3JpZ2luLCBsZXR0ZXJfc3BhY2luZywgbGluZV9zcGFjaW5nKSB7XG4gICAgICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBcIm1pZGRsZVwiOyAvLyBiYXNlbGluZXxtaWRkbGVcbiAgICAgICAgbGV0dGVyX3NwYWNpbmcgPSBtbWF4KG1taW4obGV0dGVyX3NwYWNpbmcgfHwgMCwgMSksIC0xKTtcbiAgICAgICAgbGluZV9zcGFjaW5nID0gbW1heChtbWluKGxpbmVfc3BhY2luZyB8fCAxLCAzKSwgMSk7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gU3RyKHN0cmluZylbc3BsaXRdKEUpLFxuICAgICAgICAgICAgc2hpZnQgPSAwLFxuICAgICAgICAgICAgbm90Zmlyc3QgPSAwLFxuICAgICAgICAgICAgcGF0aCA9IEUsXG4gICAgICAgICAgICBzY2FsZTtcbiAgICAgICAgUi5pcyhmb250LCBcInN0cmluZ1wiKSAmJiAoZm9udCA9IHRoaXMuZ2V0Rm9udChmb250KSk7XG4gICAgICAgIGlmIChmb250KSB7XG4gICAgICAgICAgICBzY2FsZSA9IChzaXplIHx8IDE2KSAvIGZvbnQuZmFjZVtcInVuaXRzLXBlci1lbVwiXTtcbiAgICAgICAgICAgIHZhciBiYiA9IGZvbnQuZmFjZS5iYm94W3NwbGl0XShzZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgIHRvcCA9ICtiYlswXSxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gYmJbM10gLSBiYlsxXSxcbiAgICAgICAgICAgICAgICBzaGlmdHkgPSAwLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9ICtiYlsxXSArIChvcmlnaW4gPT0gXCJiYXNlbGluZVwiID8gbGluZUhlaWdodCArICgrZm9udC5mYWNlLmRlc2NlbnQpIDogbGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGV0dGVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldHRlcnNbaV0gPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBub3RmaXJzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0eSArPSBsaW5lSGVpZ2h0ICogbGluZV9zcGFjaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gbm90Zmlyc3QgJiYgZm9udC5nbHlwaHNbbGV0dGVyc1tpIC0gMV1dIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGZvbnQuZ2x5cGhzW2xldHRlcnNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCArPSBub3RmaXJzdCA/IChwcmV2LncgfHwgZm9udC53KSArIChwcmV2LmsgJiYgcHJldi5rW2xldHRlcnNbaV1dIHx8IDApICsgKGZvbnQudyAqIGxldHRlcl9zcGFjaW5nKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIG5vdGZpcnN0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIgJiYgY3Vyci5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gUi50cmFuc2Zvcm1QYXRoKGN1cnIuZCwgW1widFwiLCBzaGlmdCAqIHNjYWxlLCBzaGlmdHkgKiBzY2FsZSwgXCJzXCIsIHNjYWxlLCBzY2FsZSwgdG9wLCBoZWlnaHQsIFwidFwiLCAoeCAtIHRvcCkgLyBzY2FsZSwgKHkgLSBoZWlnaHQpIC8gc2NhbGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aChwYXRoKS5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IFwiIzAwMFwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmFkZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW1wb3J0cyBlbGVtZW50cyBpbiBKU09OIGFycmF5IGluIGZvcm1hdCBge3R5cGU6IHR5cGUsIDxhdHRyaWJ1dGVzPn1gXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIGpzb24gKGFycmF5KVxuICAgICA9IChvYmplY3QpIHJlc3VsdGluZyBzZXQgb2YgaW1wb3J0ZWQgZWxlbWVudHNcbiAgICAgPiBVc2FnZVxuICAgICB8IHBhcGVyLmFkZChbXG4gICAgIHwgICAgIHtcbiAgICAgfCAgICAgICAgIHR5cGU6IFwiY2lyY2xlXCIsXG4gICAgIHwgICAgICAgICBjeDogMTAsXG4gICAgIHwgICAgICAgICBjeTogMTAsXG4gICAgIHwgICAgICAgICByOiA1XG4gICAgIHwgICAgIH0sXG4gICAgIHwgICAgIHtcbiAgICAgfCAgICAgICAgIHR5cGU6IFwicmVjdFwiLFxuICAgICB8ICAgICAgICAgeDogMTAsXG4gICAgIHwgICAgICAgICB5OiAxMCxcbiAgICAgfCAgICAgICAgIHdpZHRoOiAxMCxcbiAgICAgfCAgICAgICAgIGhlaWdodDogMTAsXG4gICAgIHwgICAgICAgICBmaWxsOiBcIiNmYzBcIlxuICAgICB8ICAgICB9XG4gICAgIHwgXSk7XG4gICAgXFwqL1xuICAgIHBhcGVycHJvdG8uYWRkID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgaWYgKFIuaXMoanNvbiwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2V0KCksXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgaWkgPSBqc29uLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaiA9IGpzb25baV0gfHwge307XG4gICAgICAgICAgICAgICAgZWxlbWVudHNbaGFzXShqLnR5cGUpICYmIHJlcy5wdXNoKHRoaXNbai50eXBlXSgpLmF0dHIoaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmZvcm1hdFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2ltcGxlIGZvcm1hdCBmdW5jdGlvbi4gUmVwbGFjZXMgY29uc3RydWN0aW9uIG9mIHR5cGUg4oCcYHs8bnVtYmVyPn1g4oCdIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50LlxuICAgICAqKlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgKipcbiAgICAgLSB0b2tlbiAoc3RyaW5nKSBzdHJpbmcgdG8gZm9ybWF0XG4gICAgIC0g4oCmIChzdHJpbmcpIHJlc3Qgb2YgYXJndW1lbnRzIHdpbGwgYmUgdHJlYXRlZCBhcyBwYXJhbWV0ZXJzIGZvciByZXBsYWNlbWVudFxuICAgICA9IChzdHJpbmcpIGZvcm1hdGVkIHN0cmluZ1xuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHggPSAxMCxcbiAgICAgfCAgICAgeSA9IDIwLFxuICAgICB8ICAgICB3aWR0aCA9IDQwLFxuICAgICB8ICAgICBoZWlnaHQgPSA1MDtcbiAgICAgfCAvLyB0aGlzIHdpbGwgZHJhdyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gICAgIHwgcGFwZXIucGF0aChSYXBoYWVsLmZvcm1hdChcIk17MH0sezF9aHsyfXZ7M31oezR9elwiLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAtd2lkdGgpKTtcbiAgICBcXCovXG4gICAgUi5mb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4sIHBhcmFtcykge1xuICAgICAgICB2YXIgYXJncyA9IFIuaXMocGFyYW1zLCBhcnJheSkgPyBbMF1bY29uY2F0XShwYXJhbXMpIDogYXJndW1lbnRzO1xuICAgICAgICB0b2tlbiAmJiBSLmlzKHRva2VuLCBzdHJpbmcpICYmIGFyZ3MubGVuZ3RoIC0gMSAmJiAodG9rZW4gPSB0b2tlbi5yZXBsYWNlKGZvcm1hdHJnLCBmdW5jdGlvbiAoc3RyLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1srK2ldID09IG51bGwgPyBFIDogYXJnc1tpXTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdG9rZW4gfHwgRTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBSYXBoYWVsLmZ1bGxmaWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBIGxpdHRsZSBiaXQgbW9yZSBhZHZhbmNlZCBmb3JtYXQgZnVuY3Rpb24gdGhhbiBAUmFwaGFlbC5mb3JtYXQuIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIOKAnGB7PG5hbWU+fWDigJ0gdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQuXG4gICAgICoqXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAqKlxuICAgICAtIHRva2VuIChzdHJpbmcpIHN0cmluZyB0byBmb3JtYXRcbiAgICAgLSBqc29uIChvYmplY3QpIG9iamVjdCB3aGljaCBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gICAgID0gKHN0cmluZykgZm9ybWF0ZWQgc3RyaW5nXG4gICAgID4gVXNhZ2VcbiAgICAgfCAvLyB0aGlzIHdpbGwgZHJhdyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gICAgIHwgcGFwZXIucGF0aChSYXBoYWVsLmZ1bGxmaWxsKFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gICAgIHwgICAgIHg6IDEwLFxuICAgICB8ICAgICB5OiAyMCxcbiAgICAgfCAgICAgZGltOiB7XG4gICAgIHwgICAgICAgICB3aWR0aDogNDAsXG4gICAgIHwgICAgICAgICBoZWlnaHQ6IDUwLFxuICAgICB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiAgICAgfCAgICAgfVxuICAgICB8IH0pKTtcbiAgICBcXCovXG4gICAgUi5mdWxsZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlblJlZ2V4ID0gL1xceyhbXlxcfV0rKVxcfS9nLFxuICAgICAgICAgICAgb2JqTm90YXRpb25SZWdleCA9IC8oPzooPzpefFxcLikoLis/KSg/PVxcW3xcXC58JHxcXCgpfFxcWygnfFwiKSguKz8pXFwyXFxdKShcXChcXCkpPy9nLCAvLyBtYXRjaGVzIC54eHh4eCBvciBbXCJ4eHh4eFwiXSB0byBydW4gb3ZlciBvYmplY3QgcHJvcGVydGllc1xuICAgICAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBvYmo7XG4gICAgICAgICAgICAgICAga2V5LnJlcGxhY2Uob2JqTm90YXRpb25SZWdleCwgZnVuY3Rpb24gKGFsbCwgbmFtZSwgcXVvdGUsIHF1b3RlZE5hbWUsIGlzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzID09IFwiZnVuY3Rpb25cIiAmJiBpc0Z1bmMgJiYgKHJlcyA9IHJlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcyA9IChyZXMgPT0gbnVsbCB8fCByZXMgPT0gb2JqID8gYWxsIDogcmVzKSArIFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihhbGwsIGtleSwgb2JqKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLypcXFxuICAgICAqIFJhcGhhZWwubmluamFcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIElmIHlvdSB3YW50IHRvIGxlYXZlIG5vIHRyYWNlIG9mIFJhcGhhw6tsIChXZWxsLCBSYXBoYcOrbCBjcmVhdGVzIG9ubHkgb25lIGdsb2JhbCB2YXJpYWJsZSBgUmFwaGFlbGAsIGJ1dCBhbnl3YXkuKSBZb3UgY2FuIHVzZSBgbmluamFgIG1ldGhvZC5cbiAgICAgKiBCZXdhcmUsIHRoYXQgaW4gdGhpcyBjYXNlIHBsdWdpbnMgY291bGQgc3RvcCB3b3JraW5nLCBiZWNhdXNlIHRoZXkgYXJlIGRlcGVuZGluZyBvbiBnbG9iYWwgdmFyaWFibGUgZXhpc3RlbmNlLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIFJhcGhhZWwgb2JqZWN0XG4gICAgID4gVXNhZ2VcbiAgICAgfCAoZnVuY3Rpb24gKGxvY2FsX3JhcGhhZWwpIHtcbiAgICAgfCAgICAgdmFyIHBhcGVyID0gbG9jYWxfcmFwaGFlbCgxMCwgMTAsIDMyMCwgMjAwKTtcbiAgICAgfCAgICAg4oCmXG4gICAgIHwgfSkoUmFwaGFlbC5uaW5qYSgpKTtcbiAgICBcXCovXG4gICAgUi5uaW5qYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9sZFJhcGhhZWwud2FzKSB7XG4gICAgICAgICAgICBnLndpbi5SYXBoYWVsID0gb2xkUmFwaGFlbC5pcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElFOCByYWlzZXMgYW4gZXJyb3Igd2hlbiBkZWxldGluZyB3aW5kb3cgcHJvcGVydHlcbiAgICAgICAgICAgIHdpbmRvdy5SYXBoYWVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93LlJhcGhhZWw7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFI7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUmFwaGFlbC5zdFxuICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgKipcbiAgICAgKiBZb3UgY2FuIGFkZCB5b3VyIG93biBtZXRob2QgdG8gZWxlbWVudHMgYW5kIHNldHMuIEl0IGlzIHdpc2UgdG8gYWRkIGEgc2V0IG1ldGhvZCBmb3IgZWFjaCBlbGVtZW50IG1ldGhvZFxuICAgICAqIHlvdSBhZGRlZCwgc28geW91IHdpbGwgYmUgYWJsZSB0byBjYWxsIHRoZSBzYW1lIG1ldGhvZCBvbiBzZXRzIHRvby5cbiAgICAgKipcbiAgICAgKiBTZWUgYWxzbyBAUmFwaGFlbC5lbC5cbiAgICAgPiBVc2FnZVxuICAgICB8IFJhcGhhZWwuZWwucmVkID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICB0aGlzLmF0dHIoe2ZpbGw6IFwiI2YwMFwifSk7XG4gICAgIHwgfTtcbiAgICAgfCBSYXBoYWVsLnN0LnJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICB8ICAgICAgICAgZWwucmVkKCk7XG4gICAgIHwgICAgIH0pO1xuICAgICB8IH07XG4gICAgIHwgLy8gdGhlbiB1c2UgaXRcbiAgICAgfCBwYXBlci5zZXQocGFwZXIuY2lyY2xlKDEwMCwgMTAwLCAyMCksIHBhcGVyLmNpcmNsZSgxMTAsIDEwMCwgMjApKS5yZWQoKTtcbiAgICBcXCovXG4gICAgUi5zdCA9IHNldHByb3RvO1xuXG4gICAgZXZlLm9uKFwicmFwaGFlbC5ET01sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIEZpcmVmb3ggPDMuNiBmaXg6IGh0dHA6Ly93ZWJyZWZsZWN0aW9uLmJsb2dzcG90LmNvbS8yMDA5LzExLzE5NS1jaGFycy10by1oZWxwLWxhenktbG9hZGluZy5odG1sXG4gICAgKGZ1bmN0aW9uIChkb2MsIGxvYWRlZCwgZikge1xuICAgICAgICBpZiAoZG9jLnJlYWR5U3RhdGUgPT0gbnVsbCAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihsb2FkZWQsIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIobG9hZGVkLCBmLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZG9jLnJlYWR5U3RhdGUgPSBcImNvbXBsZXRlXCI7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICBkb2MucmVhZHlTdGF0ZSA9IFwibG9hZGluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTG9hZGVkKCkge1xuICAgICAgICAgICAgKC9pbi8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpID8gc2V0VGltZW91dChpc0xvYWRlZCwgOSkgOiBSLmV2ZShcInJhcGhhZWwuRE9NbG9hZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpc0xvYWRlZCgpO1xuICAgIH0pKGRvY3VtZW50LCBcIkRPTUNvbnRlbnRMb2FkZWRcIik7XG5cbiAgICByZXR1cm4gUjtcbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9kZXYvcmFwaGFlbC5zdmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9kZXYvcmFwaGFlbC5zdmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhcGhhZWwuY29yZSAqLyBcIi4vZGV2L3JhcGhhZWwuY29yZS5qc1wiKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKFIpIHtcbiAgICBpZiAoUiAmJiAhUi5zdmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgdG9GbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICAgIHRvSW50ID0gcGFyc2VJbnQsXG4gICAgICAgIG1hdGggPSBNYXRoLFxuICAgICAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgICAgIGFicyA9IG1hdGguYWJzLFxuICAgICAgICBwb3cgPSBtYXRoLnBvdyxcbiAgICAgICAgc2VwYXJhdG9yID0gL1ssIF0rLyxcbiAgICAgICAgZXZlID0gUi5ldmUsXG4gICAgICAgIEUgPSBcIlwiLFxuICAgICAgICBTID0gXCIgXCI7XG4gICAgdmFyIHhsaW5rID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgICAgIG1hcmtlcnMgPSB7XG4gICAgICAgICAgICBibG9jazogXCJNNSwwIDAsMi41IDUsNXpcIixcbiAgICAgICAgICAgIGNsYXNzaWM6IFwiTTUsMCAwLDIuNSA1LDUgMy41LDMgMy41LDJ6XCIsXG4gICAgICAgICAgICBkaWFtb25kOiBcIk0yLjUsMCA1LDIuNSAyLjUsNSAwLDIuNXpcIixcbiAgICAgICAgICAgIG9wZW46IFwiTTYsMSAxLDMuNSA2LDZcIixcbiAgICAgICAgICAgIG92YWw6IFwiTTIuNSwwQTIuNSwyLjUsMCwwLDEsMi41LDUgMi41LDIuNSwwLDAsMSwyLjUsMHpcIlxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJDb3VudGVyID0ge307XG4gICAgUi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICBcIllvdXIgYnJvd3NlciBzdXBwb3J0cyBTVkcuXFxuWW91IGFyZSBydW5uaW5nIFJhcGhhXFx4ZWJsIFwiICsgdGhpcy52ZXJzaW9uO1xuICAgIH07XG4gICAgdmFyICQgPSBmdW5jdGlvbiAoZWwsIGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGVsID0gJChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cikgaWYgKGF0dHJbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgNikgPT0gXCJ4bGluazpcIikge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGluaywga2V5LnN1YnN0cmluZyg2KSwgU3RyKGF0dHJba2V5XSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIFN0cihhdHRyW2tleV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbCA9IFIuX2cuZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGVsKTtcbiAgICAgICAgICAgIGVsLnN0eWxlICYmIChlbC5zdHlsZS53ZWJraXRUYXBIaWdobGlnaHRDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcbiAgICBhZGRHcmFkaWVudEZpbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgZ3JhZGllbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBcImxpbmVhclwiLFxuICAgICAgICAgICAgaWQgPSBlbGVtZW50LmlkICsgZ3JhZGllbnQsXG4gICAgICAgICAgICBmeCA9IC41LCBmeSA9IC41LFxuICAgICAgICAgICAgbyA9IGVsZW1lbnQubm9kZSxcbiAgICAgICAgICAgIFNWRyA9IGVsZW1lbnQucGFwZXIsXG4gICAgICAgICAgICBzID0gby5zdHlsZSxcbiAgICAgICAgICAgIGVsID0gUi5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBncmFkaWVudCA9IFN0cihncmFkaWVudCkucmVwbGFjZShSLl9yYWRpYWxfZ3JhZGllbnQsIGZ1bmN0aW9uIChhbGwsIF9meCwgX2Z5KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwicmFkaWFsXCI7XG4gICAgICAgICAgICAgICAgaWYgKF9meCAmJiBfZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnggPSB0b0Zsb2F0KF9meCk7XG4gICAgICAgICAgICAgICAgICAgIGZ5ID0gdG9GbG9hdChfZnkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gKChmeSA+IC41KSAqIDIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG93KGZ4IC0gLjUsIDIpICsgcG93KGZ5IC0gLjUsIDIpID4gLjI1ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnkgPSBtYXRoLnNxcnQoLjI1IC0gcG93KGZ4IC0gLjUsIDIpKSAqIGRpciArIC41KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZnkgIT0gLjUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChmeSA9IGZ5LnRvRml4ZWQoNSkgLSAxZS01ICogZGlyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQuc3BsaXQoL1xccypcXC1cXHMqLyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcImxpbmVhclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gZ3JhZGllbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IC10b0Zsb2F0KGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gWzAsIDAsIG1hdGguY29zKFIucmFkKGFuZ2xlKSksIG1hdGguc2luKFIucmFkKGFuZ2xlKSldLFxuICAgICAgICAgICAgICAgICAgICBtYXggPSAxIC8gKG1tYXgoYWJzKHZlY3RvclsyXSksIGFicyh2ZWN0b3JbM10pKSB8fCAxKTtcbiAgICAgICAgICAgICAgICB2ZWN0b3JbMl0gKj0gbWF4O1xuICAgICAgICAgICAgICAgIHZlY3RvclszXSAqPSBtYXg7XG4gICAgICAgICAgICAgICAgaWYgKHZlY3RvclsyXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yWzBdID0gLXZlY3RvclsyXTtcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yWzJdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZlY3RvclszXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yWzFdID0gLXZlY3RvclszXTtcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yWzNdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG90cyA9IFIuX3BhcnNlRG90cyhncmFkaWVudCk7XG4gICAgICAgICAgICBpZiAoIWRvdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSgvW1xcKFxcKVxccyxcXHhiMCNdL2csIFwiX1wiKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ3JhZGllbnQgJiYgaWQgIT0gZWxlbWVudC5ncmFkaWVudC5pZCkge1xuICAgICAgICAgICAgICAgIFNWRy5kZWZzLnJlbW92ZUNoaWxkKGVsZW1lbnQuZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmdyYWRpZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuZ3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBlbCA9ICQodHlwZSArIFwiR3JhZGllbnRcIiwge2lkOiBpZH0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZ3JhZGllbnQgPSBlbDtcbiAgICAgICAgICAgICAgICAkKGVsLCB0eXBlID09IFwicmFkaWFsXCIgPyB7XG4gICAgICAgICAgICAgICAgICAgIGZ4OiBmeCxcbiAgICAgICAgICAgICAgICAgICAgZnk6IGZ5XG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHZlY3RvclswXSxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHZlY3RvclsxXSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHZlY3RvclsyXSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHZlY3RvclszXSxcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IGVsZW1lbnQubWF0cml4LmludmVydCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgU1ZHLmRlZnMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGRvdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZCgkKFwic3RvcFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGRvdHNbaV0ub2Zmc2V0ID8gZG90c1tpXS5vZmZzZXQgOiBpID8gXCIxMDAlXCIgOiBcIjAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0b3AtY29sb3JcIjogZG90c1tpXS5jb2xvciB8fCBcIiNmZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RvcC1vcGFjaXR5XCI6IGlzRmluaXRlKGRvdHNbaV0ub3BhY2l0eSkgPyBkb3RzW2ldLm9wYWNpdHkgOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJChvLCB7XG4gICAgICAgICAgICBmaWxsOiBmaWxsdXJsKGlkKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBzLmZpbGwgPSBFO1xuICAgICAgICBzLm9wYWNpdHkgPSAxO1xuICAgICAgICBzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBpc0lFOW9yMTAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICAgIHJldHVybiBtb2RlICYmIChtb2RlID09PSA5IHx8IG1vZGUgPT09IDEwKTtcbiAgICB9LFxuICAgIGZpbGx1cmwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpc0lFOW9yMTAoKSkge1xuICAgICAgICAgIHJldHVybiBcInVybCgnI1wiICsgaWQgKyBcIicpXCI7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYXRpb24gPSBkb2N1bWVudC5sb2NhdGlvbjtcbiAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IChcbiAgICAgICAgICBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgK1xuICAgICAgICAgIGxvY2F0aW9uLmhvc3QgK1xuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICAgICBsb2NhdGlvbi5zZWFyY2hcbiAgICAgICk7XG4gICAgICByZXR1cm4gXCJ1cmwoJ1wiICsgbG9jYXRpb25TdHJpbmcgKyBcIiNcIiArIGlkICsgXCInKVwiO1xuICAgIH0sXG4gICAgdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgYmJveCA9IG8uZ2V0QkJveCgxKTtcbiAgICAgICAgJChvLnBhdHRlcm4sIHtwYXR0ZXJuVHJhbnNmb3JtOiBvLm1hdHJpeC5pbnZlcnQoKSArIFwiIHRyYW5zbGF0ZShcIiArIGJib3gueCArIFwiLFwiICsgYmJveC55ICsgXCIpXCJ9KTtcbiAgICB9LFxuICAgIGFkZEFycm93ID0gZnVuY3Rpb24gKG8sIHZhbHVlLCBpc0VuZCkge1xuICAgICAgICBpZiAoby50eXBlID09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gU3RyKHZhbHVlKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLVwiKSxcbiAgICAgICAgICAgICAgICBwID0gby5wYXBlcixcbiAgICAgICAgICAgICAgICBzZSA9IGlzRW5kID8gXCJlbmRcIiA6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICBub2RlID0gby5ub2RlLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gby5hdHRycyxcbiAgICAgICAgICAgICAgICBzdHJva2UgPSBhdHRyc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgICAgICAgICAgICBpID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJjbGFzc2ljXCIsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBkeCxcbiAgICAgICAgICAgICAgICByZWZYLFxuICAgICAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICAgICAgdyA9IDMsXG4gICAgICAgICAgICAgICAgaCA9IDMsXG4gICAgICAgICAgICAgICAgdCA9IDU7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc2ljXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3aWRlXCI6IGggPSA1OyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hcnJvd1wiOiBoID0gMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb25nXCI6IHcgPSA1OyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNob3J0XCI6IHcgPSAyOyBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgICAgIHcgKz0gMjtcbiAgICAgICAgICAgICAgICBoICs9IDI7XG4gICAgICAgICAgICAgICAgdCArPSAyO1xuICAgICAgICAgICAgICAgIGR4ID0gMTtcbiAgICAgICAgICAgICAgICByZWZYID0gaXNFbmQgPyA0IDogMTtcbiAgICAgICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBhdHRycy5zdHJva2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZYID0gZHggPSB3IC8gMjtcbiAgICAgICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBhdHRycy5zdHJva2UsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG8uXy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgby5fLmFycm93cy5lbmRQYXRoICYmIG1hcmtlckNvdW50ZXJbby5fLmFycm93cy5lbmRQYXRoXS0tO1xuICAgICAgICAgICAgICAgICAgICBvLl8uYXJyb3dzLmVuZE1hcmtlciAmJiBtYXJrZXJDb3VudGVyW28uXy5hcnJvd3MuZW5kTWFya2VyXS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Muc3RhcnRQYXRoICYmIG1hcmtlckNvdW50ZXJbby5fLmFycm93cy5zdGFydFBhdGhdLS07XG4gICAgICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Muc3RhcnRNYXJrZXIgJiYgbWFya2VyQ291bnRlcltvLl8uYXJyb3dzLnN0YXJ0TWFya2VyXS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgby5fLmFycm93cyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aElkID0gXCJyYXBoYWVsLW1hcmtlci1cIiArIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcklkID0gXCJyYXBoYWVsLW1hcmtlci1cIiArIHNlICsgdHlwZSArIHcgKyBoICsgXCItb2JqXCIgKyBvLmlkO1xuICAgICAgICAgICAgICAgIGlmICghUi5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQocGF0aElkKSkge1xuICAgICAgICAgICAgICAgICAgICBwLmRlZnMuYXBwZW5kQ2hpbGQoJCgkKFwicGF0aFwiKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkOiBtYXJrZXJzW3R5cGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBhdGhJZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNvdW50ZXJbcGF0aElkXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlcltwYXRoSWRdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSBSLl9nLmRvYy5nZXRFbGVtZW50QnlJZChtYXJrZXJJZCksXG4gICAgICAgICAgICAgICAgICAgIHVzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSAkKCQoXCJtYXJrZXJcIiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtYXJrZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcldpZHRoOiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlg6IHJlZlgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZZOiBoIC8gMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXNlID0gJCgkKFwidXNlXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBwYXRoSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IChpc0VuZCA/IFwicm90YXRlKDE4MCBcIiArIHcgLyAyICsgXCIgXCIgKyBoIC8gMiArIFwiKSBcIiA6IEUpICsgXCJzY2FsZShcIiArIHcgLyB0ICsgXCIsXCIgKyBoIC8gdCArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogKDEgLyAoKHcgLyB0ICsgaCAvIHQpIC8gMikpLnRvRml4ZWQoNClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5hcHBlbmRDaGlsZCh1c2UpO1xuICAgICAgICAgICAgICAgICAgICBwLmRlZnMuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlclttYXJrZXJJZF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNvdW50ZXJbbWFya2VySWRdKys7XG4gICAgICAgICAgICAgICAgICAgIHVzZSA9IG1hcmtlci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInVzZVwiKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCh1c2UsIGF0dHIpO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGR4ICogKHR5cGUgIT0gXCJkaWFtb25kXCIgJiYgdHlwZSAhPSBcIm92YWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBvLl8uYXJyb3dzLnN0YXJ0ZHggKiBzdHJva2UgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBSLmdldFRvdGFsTGVuZ3RoKGF0dHJzLnBhdGgpIC0gZGVsdGEgKiBzdHJva2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGRlbHRhICogc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFIuZ2V0VG90YWxMZW5ndGgoYXR0cnMucGF0aCkgLSAoby5fLmFycm93cy5lbmRkeCAqIHN0cm9rZSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgIGF0dHJbXCJtYXJrZXItXCIgKyBzZV0gPSBcInVybCgjXCIgKyBtYXJrZXJJZCArIFwiKVwiO1xuICAgICAgICAgICAgICAgIGlmICh0byB8fCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIuZCA9IFIuZ2V0U3VicGF0aChhdHRycy5wYXRoLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQobm9kZSwgYXR0cik7XG4gICAgICAgICAgICAgICAgby5fLmFycm93c1tzZSArIFwiUGF0aFwiXSA9IHBhdGhJZDtcbiAgICAgICAgICAgICAgICBvLl8uYXJyb3dzW3NlICsgXCJNYXJrZXJcIl0gPSBtYXJrZXJJZDtcbiAgICAgICAgICAgICAgICBvLl8uYXJyb3dzW3NlICsgXCJkeFwiXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Nbc2UgKyBcIlR5cGVcIl0gPSB0eXBlO1xuICAgICAgICAgICAgICAgIG8uXy5hcnJvd3Nbc2UgKyBcIlN0cmluZ1wiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IG8uXy5hcnJvd3Muc3RhcnRkeCAqIHN0cm9rZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFIuZ2V0VG90YWxMZW5ndGgoYXR0cnMucGF0aCkgLSBmcm9tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFIuZ2V0VG90YWxMZW5ndGgoYXR0cnMucGF0aCkgLSAoby5fLmFycm93cy5lbmRkeCAqIHN0cm9rZSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgby5fLmFycm93c1tzZSArIFwiUGF0aFwiXSAmJiAkKG5vZGUsIHtkOiBSLmdldFN1YnBhdGgoYXR0cnMucGF0aCwgZnJvbSwgdG8pfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uXy5hcnJvd3Nbc2UgKyBcIlBhdGhcIl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uXy5hcnJvd3Nbc2UgKyBcIk1hcmtlclwiXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgby5fLmFycm93c1tzZSArIFwiZHhcIl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uXy5hcnJvd3Nbc2UgKyBcIlR5cGVcIl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uXy5hcnJvd3Nbc2UgKyBcIlN0cmluZ1wiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoYXR0ciBpbiBtYXJrZXJDb3VudGVyKSBpZiAobWFya2VyQ291bnRlcltoYXNdKGF0dHIpICYmICFtYXJrZXJDb3VudGVyW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBSLl9nLmRvYy5nZXRFbGVtZW50QnlJZChhdHRyKTtcbiAgICAgICAgICAgICAgICBpdGVtICYmIGl0ZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGFzaGFycmF5ID0ge1xuICAgICAgICBcIi1cIjogWzMsIDFdLFxuICAgICAgICBcIi5cIjogWzEsIDFdLFxuICAgICAgICBcIi0uXCI6IFszLCAxLCAxLCAxXSxcbiAgICAgICAgXCItLi5cIjogWzMsIDEsIDEsIDEsIDEsIDFdLFxuICAgICAgICBcIi4gXCI6IFsxLCAzXSxcbiAgICAgICAgXCItIFwiOiBbNCwgM10sXG4gICAgICAgIFwiLS1cIjogWzgsIDNdLFxuICAgICAgICBcIi0gLlwiOiBbNCwgMywgMSwgM10sXG4gICAgICAgIFwiLS0uXCI6IFs4LCAzLCAxLCAzXSxcbiAgICAgICAgXCItLS4uXCI6IFs4LCAzLCAxLCAzLCAxLCAzXVxuICAgIH0sXG4gICAgYWRkRGFzaGVzID0gZnVuY3Rpb24gKG8sIHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFsdWUgPSBkYXNoYXJyYXlbU3RyKHZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBvLmF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdIHx8IFwiMVwiLFxuICAgICAgICAgICAgICAgIGJ1dHQgPSB7cm91bmQ6IHdpZHRoLCBzcXVhcmU6IHdpZHRoLCBidXR0OiAwfVtvLmF0dHJzW1wic3Ryb2tlLWxpbmVjYXBcIl0gfHwgcGFyYW1zW1wic3Ryb2tlLWxpbmVjYXBcIl1dIHx8IDAsXG4gICAgICAgICAgICAgICAgZGFzaGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBkYXNoZXNbaV0gPSB2YWx1ZVtpXSAqIHdpZHRoICsgKChpICUgMikgPyAxIDogLTEpICogYnV0dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoby5ub2RlLCB7XCJzdHJva2UtZGFzaGFycmF5XCI6IGRhc2hlcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICQoby5ub2RlLCB7XCJzdHJva2UtZGFzaGFycmF5XCI6IFwibm9uZVwifSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldEZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAobywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBub2RlID0gby5ub2RlLFxuICAgICAgICAgICAgYXR0cnMgPSBvLmF0dHJzLFxuICAgICAgICAgICAgdmlzID0gbm9kZS5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICBub2RlLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICBmb3IgKHZhciBhdHQgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW2hhc10oYXR0KSkge1xuICAgICAgICAgICAgICAgIGlmICghUi5fYXZhaWxhYmxlQXR0cnNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbYXR0XTtcbiAgICAgICAgICAgICAgICBhdHRyc1thdHRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uYmx1cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZXhpc3RpbmcgPHRpdGxlPi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aXRsZS5sZW5ndGggJiYgKHRpdGxlID0gdGl0bGVbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICQoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFIuX2cuZG9jLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUuYXBwZW5kQ2hpbGQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBuID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBuLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPSBcImFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBobCA9ICQoXCJhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBuLmluc2VydEJlZm9yZShobCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG4gPSBobDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHQgPT0gXCJ0YXJnZXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBuLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBcInNob3dcIiwgdmFsdWUgPT0gXCJibGFua1wiID8gXCJuZXdcIiA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG4uc2V0QXR0cmlidXRlTlMoeGxpbmssIGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjdXJzb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgby50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcnJvdy1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQXJyb3cobywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcnJvdy1lbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEFycm93KG8sIHZhbHVlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xpcC1yZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IFN0cih2YWx1ZSkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN0Lmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5jbGlwICYmIG8uY2xpcC5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoby5jbGlwLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9ICQoXCJjbGlwUGF0aFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmMgPSAkKFwicmVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5pZCA9IFIuY3JlYXRlVVVJRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQocmMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcmVjdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3RbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdFszXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHJjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQobm9kZSwge1wiY2xpcC1wYXRoXCI6IFwidXJsKCNcIiArIGVsLmlkICsgXCIpXCJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmNsaXAgPSByYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwID0gUi5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQocGF0aC5yZXBsYWNlKC8oXnVybFxcKCN8XFwpJCkvZywgRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwICYmIGNsaXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7XCJjbGlwLXBhdGhcIjogRX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgby5jbGlwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50eXBlID09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7ZDogdmFsdWUgPyBhdHRycy5wYXRoID0gUi5fcGF0aFRvQWJzb2x1dGUodmFsdWUpIDogXCJNMCwwXCJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLl8uYXJyb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRTdHJpbmdcIiBpbiBvLl8uYXJyb3dzICYmIGFkZEFycm93KG8sIG8uXy5hcnJvd3Muc3RhcnRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFN0cmluZ1wiIGluIG8uXy5hcnJvd3MgJiYgYWRkQXJyb3cobywgby5fLmFycm93cy5lbmRTdHJpbmcsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5meCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dCA9IFwieFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cnMueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IC1hdHRycy54IC0gKGF0dHJzLndpZHRoIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHQgPT0gXCJyeFwiICYmIG8udHlwZSA9PSBcInJlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY3hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXR0ZXJuICYmIHVwZGF0ZVBvc2l0aW9uKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHQgPSBcInlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF0dHJzLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLmZ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAtYXR0cnMueSAtIChhdHRycy5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dCA9PSBcInJ5XCIgJiYgby50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnBhdHRlcm4gJiYgdXBkYXRlUG9zaXRpb24obyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7cng6IHZhbHVlLCByeTogdmFsdWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvLl8uZGlydHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnR5cGUgPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyh4bGluaywgXCJocmVmXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3Ryb2tlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5fLnN4ICE9IDEgfHwgby5fLnN5ICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAvPSBtbWF4KGFicyhvLl8uc3gpLCBhYnMoby5fLnN5KSkgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzW1wic3Ryb2tlLWRhc2hhcnJheVwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZERhc2hlcyhvLCBhdHRyc1tcInN0cm9rZS1kYXNoYXJyYXlcIl0sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5fLmFycm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRTdHJpbmdcIiBpbiBvLl8uYXJyb3dzICYmIGFkZEFycm93KG8sIG8uXy5hcnJvd3Muc3RhcnRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5kU3RyaW5nXCIgaW4gby5fLmFycm93cyAmJiBhZGRBcnJvdyhvLCBvLl8uYXJyb3dzLmVuZFN0cmluZywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cm9rZS1kYXNoYXJyYXlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERhc2hlcyhvLCB2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzVVJMID0gU3RyKHZhbHVlKS5tYXRjaChSLl9JU1VSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9ICQoXCJwYXR0ZXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZyA9ICQoXCJpbWFnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5pZCA9IFIuY3JlYXRlVVVJRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZWwsIHt4OiAwLCB5OiAwLCBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiwgaGVpZ2h0OiAxLCB3aWR0aDogMX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoaWcsIHt4OiAwLCB5OiAwLCBcInhsaW5rOmhyZWZcIjogaXNVUkxbMV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuX3ByZWxvYWQoaXNVUkxbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gdGhpcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVsLCB7d2lkdGg6IHcsIGhlaWdodDogaH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChpZywge3dpZHRoOiB3LCBoZWlnaHQ6IGh9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGFwZXIuZGVmcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChub2RlLCB7ZmlsbDogXCJ1cmwoI1wiICsgZWwuaWQgKyBcIilcIn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0dGVybiA9IGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0dGVybiAmJiB1cGRhdGVQb3NpdGlvbihvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbHIgPSBSLmdldFJHQih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzLmdyYWRpZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFSLmlzKGF0dHJzLm9wYWNpdHksIFwidW5kZWZpbmVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuaXMocGFyYW1zLm9wYWNpdHksIFwidW5kZWZpbmVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQobm9kZSwge29wYWNpdHk6IGF0dHJzLm9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhUi5pcyhhdHRyc1tcImZpbGwtb3BhY2l0eVwiXSwgXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5pcyhwYXJhbXNbXCJmaWxsLW9wYWNpdHlcIl0sIFwidW5kZWZpbmVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQobm9kZSwge1wiZmlsbC1vcGFjaXR5XCI6IGF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvLnR5cGUgPT0gXCJjaXJjbGVcIiB8fCBvLnR5cGUgPT0gXCJlbGxpcHNlXCIgfHwgU3RyKHZhbHVlKS5jaGFyQXQoKSAhPSBcInJcIikgJiYgYWRkR3JhZGllbnRGaWxsKG8sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9wYWNpdHlcIiBpbiBhdHRycyB8fCBcImZpbGwtb3BhY2l0eVwiIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IFIuX2cuZG9jLmdldEVsZW1lbnRCeUlkKG5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKS5yZXBsYWNlKC9edXJsXFwoI3xcXCkkL2csIEUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcHMgPSBncmFkaWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLCB7XCJzdG9wLW9wYWNpdHlcIjogKFwib3BhY2l0eVwiIGluIGF0dHJzID8gYXR0cnMub3BhY2l0eSA6IDEpICogKFwiZmlsbC1vcGFjaXR5XCIgaW4gYXR0cnMgPyBhdHRyc1tcImZpbGwtb3BhY2l0eVwiXSA6IDEpfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuZ3JhZGllbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5maWxsID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHJbaGFzXShcIm9wYWNpdHlcIikgJiYgJChub2RlLCB7XCJmaWxsLW9wYWNpdHlcIjogY2xyLm9wYWNpdHkgPiAxID8gY2xyLm9wYWNpdHkgLyAxMDAgOiBjbHIub3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3Ryb2tlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHIgPSBSLmdldFJHQih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHQsIGNsci5oZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ID09IFwic3Ryb2tlXCIgJiYgY2xyW2hhc10oXCJvcGFjaXR5XCIpICYmICQobm9kZSwge1wic3Ryb2tlLW9wYWNpdHlcIjogY2xyLm9wYWNpdHkgPiAxID8gY2xyLm9wYWNpdHkgLyAxMDAgOiBjbHIub3BhY2l0eX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dCA9PSBcInN0cm9rZVwiICYmIG8uXy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJ0U3RyaW5nXCIgaW4gby5fLmFycm93cyAmJiBhZGRBcnJvdyhvLCBvLl8uYXJyb3dzLnN0YXJ0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFN0cmluZ1wiIGluIG8uXy5hcnJvd3MgJiYgYWRkQXJyb3cobywgby5fLmFycm93cy5lbmRTdHJpbmcsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJncmFkaWVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgKG8udHlwZSA9PSBcImNpcmNsZVwiIHx8IG8udHlwZSA9PSBcImVsbGlwc2VcIiB8fCBTdHIodmFsdWUpLmNoYXJBdCgpICE9IFwiclwiKSAmJiBhZGRHcmFkaWVudEZpbGwobywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGFjaXR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZ3JhZGllbnQgJiYgIWF0dHJzW2hhc10oXCJzdHJva2Utb3BhY2l0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQobm9kZSwge1wic3Ryb2tlLW9wYWNpdHlcIjogdmFsdWUgPiAxID8gdmFsdWUgLyAxMDAgOiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsbC1vcGFjaXR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZ3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudCA9IFIuX2cuZG9jLmdldEVsZW1lbnRCeUlkKG5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKS5yZXBsYWNlKC9edXJsXFwoI3xcXCkkL2csIEUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHMgPSBncmFkaWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0sIHtcInN0b3Atb3BhY2l0eVwiOiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dCA9PSBcImZvbnQtc2l6ZVwiICYmICh2YWx1ZSA9IHRvSW50KHZhbHVlLCAxMCkgKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc3J1bGUgPSBhdHQucmVwbGFjZSgvKFxcLS4pL2csIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHcuc3Vic3RyaW5nKDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbY3NzcnVsZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR1bmVUZXh0KG8sIHBhcmFtcyk7XG4gICAgICAgIG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9IHZpcztcbiAgICB9LFxuICAgIGxlYWRpbmcgPSAxLjIsXG4gICAgdHVuZVRleHQgPSBmdW5jdGlvbiAoZWwsIHBhcmFtcykge1xuICAgICAgICBpZiAoZWwudHlwZSAhPSBcInRleHRcIiB8fCAhKHBhcmFtc1toYXNdKFwidGV4dFwiKSB8fCBwYXJhbXNbaGFzXShcImZvbnRcIikgfHwgcGFyYW1zW2hhc10oXCJmb250LXNpemVcIikgfHwgcGFyYW1zW2hhc10oXCJ4XCIpIHx8IHBhcmFtc1toYXNdKFwieVwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGVsLmF0dHJzLFxuICAgICAgICAgICAgbm9kZSA9IGVsLm5vZGUsXG4gICAgICAgICAgICBmb250U2l6ZSA9IG5vZGUuZmlyc3RDaGlsZCA/IHRvSW50KFIuX2cuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZS5maXJzdENoaWxkLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zaXplXCIpLCAxMCkgOiAxMDtcblxuICAgICAgICBpZiAocGFyYW1zW2hhc10oXCJ0ZXh0XCIpKSB7XG4gICAgICAgICAgICBhLnRleHQgPSBwYXJhbXMudGV4dDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4dHMgPSBTdHIocGFyYW1zLnRleHQpLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgICAgIHRzcGFucyA9IFtdLFxuICAgICAgICAgICAgICAgIHRzcGFuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGV4dHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRzcGFuID0gJChcInRzcGFuXCIpO1xuICAgICAgICAgICAgICAgIGkgJiYgJCh0c3Bhbiwge2R5OiBmb250U2l6ZSAqIGxlYWRpbmcsIHg6IGEueH0pO1xuICAgICAgICAgICAgICAgIHRzcGFuLmFwcGVuZENoaWxkKFIuX2cuZG9jLmNyZWF0ZVRleHROb2RlKHRleHRzW2ldKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0c3Bhbik7XG4gICAgICAgICAgICAgICAgdHNwYW5zW2ldID0gdHNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0c3BhbnMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHRzcGFucy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoaSkge1xuICAgICAgICAgICAgICAgICQodHNwYW5zW2ldLCB7ZHk6IGZvbnRTaXplICogbGVhZGluZywgeDogYS54fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodHNwYW5zWzBdLCB7ZHk6IDB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkKG5vZGUsIHt4OiBhLngsIHk6IGEueX0pO1xuICAgICAgICBlbC5fLmRpcnR5ID0gMTtcbiAgICAgICAgdmFyIGJiID0gZWwuX2dldEJCb3goKSxcbiAgICAgICAgICAgIGRpZiA9IGEueSAtIChiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgIGRpZiAmJiBSLmlzKGRpZiwgXCJmaW5pdGVcIikgJiYgJCh0c3BhbnNbMF0sIHtkeTogZGlmfSk7XG4gICAgfSxcbiAgICBnZXRSZWFsTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdmcpIHtcbiAgICAgICAgdmFyIFggPSAwLFxuICAgICAgICAgICAgWSA9IDA7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogRWxlbWVudC5ub2RlXG4gICAgICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIEdpdmVzIHlvdSBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG9iamVjdCwgc28geW91IGNhbiBhc3NpZ24gZXZlbnQgaGFuZGxlcnMgb3IganVzdCBtZXNzIGFyb3VuZC5cbiAgICAgICAgICoqXG4gICAgICAgICAqIE5vdGU6IERvbuKAmXQgbWVzcyB3aXRoIGl0LlxuICAgICAgICAgPiBVc2FnZVxuICAgICAgICAgfCAvLyBkcmF3IGEgY2lyY2xlIGF0IGNvb3JkaW5hdGUgMTAsMTAgd2l0aCByYWRpdXMgb2YgMTBcbiAgICAgICAgIHwgdmFyIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCk7XG4gICAgICAgICB8IGMubm9kZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgfCAgICAgYy5hdHRyKFwiZmlsbFwiLCBcInJlZFwiKTtcbiAgICAgICAgIHwgfTtcbiAgICAgICAgXFwqL1xuICAgICAgICB0aGlzWzBdID0gdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBFbGVtZW50LnJhcGhhZWxcbiAgICAgICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAgICAgKipcbiAgICAgICAgICogSW50ZXJuYWwgcmVmZXJlbmNlIHRvIEBSYXBoYWVsIG9iamVjdC4gSW4gY2FzZSBpdCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAgPiBVc2FnZVxuICAgICAgICAgfCBSYXBoYWVsLmVsLnJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHwgICAgIHZhciBoc2IgPSB0aGlzLnBhcGVyLnJhcGhhZWwucmdiMmhzYih0aGlzLmF0dHIoXCJmaWxsXCIpKTtcbiAgICAgICAgIHwgICAgIGhzYi5oID0gMTtcbiAgICAgICAgIHwgICAgIHRoaXMuYXR0cih7ZmlsbDogdGhpcy5wYXBlci5yYXBoYWVsLmhzYjJyZ2IoaHNiKS5oZXh9KTtcbiAgICAgICAgIHwgfVxuICAgICAgICBcXCovXG4gICAgICAgIG5vZGUucmFwaGFlbCA9IHRydWU7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogRWxlbWVudC5pZFxuICAgICAgICAgWyBwcm9wZXJ0eSAobnVtYmVyKSBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBVbmlxdWUgaWQgb2YgdGhlIGVsZW1lbnQuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gbGlzdGVuIHRvIGV2ZW50cyBvZiB0aGUgZWxlbWVudCxcbiAgICAgICAgICogYmVjYXVzZSBhbGwgZXZlbnRzIGFyZSBmaXJlZCBpbiBmb3JtYXQgYDxtb2R1bGU+LjxhY3Rpb24+LjxpZD5gLiBBbHNvIHVzZWZ1bCBmb3IgQFBhcGVyLmdldEJ5SWQgbWV0aG9kLlxuICAgICAgICBcXCovXG4gICAgICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgICAgIG5vZGUucmFwaGFlbGlkID0gdGhpcy5pZDtcblxuICAgICAgICAvKipcbiAgICAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGEgNSBsZXR0ZXIvZGlnaXQgaWQsIGVub3VnaCBmb3IgMzZeNSA9IDYwNDY2MTc2IGVsZW1lbnRzXG4gICAgICAgICogQHJldHVybnMge3N0cmluZ30gaWRcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIwMDAwXCIgKyAoTWF0aC5yYW5kb20oKSpNYXRoLnBvdygzNiw1KSA8PCAwKS50b1N0cmluZygzNikpLnNsaWNlKC01KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF0cml4ID0gUi5tYXRyaXgoKTtcbiAgICAgICAgdGhpcy5yZWFsUGF0aCA9IG51bGw7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogRWxlbWVudC5wYXBlclxuICAgICAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBJbnRlcm5hbCByZWZlcmVuY2UgdG8g4oCccGFwZXLigJ0gd2hlcmUgb2JqZWN0IGRyYXduLiBNYWlubHkgZm9yIHVzZSBpbiBwbHVnaW5zIGFuZCBlbGVtZW50IGV4dGVuc2lvbnMuXG4gICAgICAgICA+IFVzYWdlXG4gICAgICAgICB8IFJhcGhhZWwuZWwuY3Jvc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICB8ICAgICB0aGlzLmF0dHIoe2ZpbGw6IFwicmVkXCJ9KTtcbiAgICAgICAgIHwgICAgIHRoaXMucGFwZXIucGF0aChcIk0xMCwxMEw1MCw1ME01MCwxMEwxMCw1MFwiKVxuICAgICAgICAgfCAgICAgICAgIC5hdHRyKHtzdHJva2U6IFwicmVkXCJ9KTtcbiAgICAgICAgIHwgfVxuICAgICAgICBcXCovXG4gICAgICAgIHRoaXMucGFwZXIgPSBzdmc7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB0aGlzLmF0dHJzIHx8IHt9O1xuICAgICAgICB0aGlzLl8gPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFtdLFxuICAgICAgICAgICAgc3g6IDEsXG4gICAgICAgICAgICBzeTogMSxcbiAgICAgICAgICAgIGRlZzogMCxcbiAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgZHk6IDAsXG4gICAgICAgICAgICBkaXJ0eTogMVxuICAgICAgICB9O1xuICAgICAgICAhc3ZnLmJvdHRvbSAmJiAoc3ZnLmJvdHRvbSA9IHRoaXMpO1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQucHJldlxuICAgICAgICAgWyBwcm9wZXJ0eSAob2JqZWN0KSBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIGVsZW1lbnQgaW4gdGhlIGhpZXJhcmNoeS5cbiAgICAgICAgXFwqL1xuICAgICAgICB0aGlzLnByZXYgPSBzdmcudG9wO1xuICAgICAgICBzdmcudG9wICYmIChzdmcudG9wLm5leHQgPSB0aGlzKTtcbiAgICAgICAgc3ZnLnRvcCA9IHRoaXM7XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogRWxlbWVudC5uZXh0XG4gICAgICAgICBbIHByb3BlcnR5IChvYmplY3QpIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBoaWVyYXJjaHkuXG4gICAgICAgIFxcKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9LFxuICAgIGVscHJvdG8gPSBSLmVsO1xuXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSBlbHByb3RvO1xuICAgIGVscHJvdG8uY29uc3RydWN0b3IgPSBFbGVtZW50O1xuXG4gICAgUi5fZW5naW5lLnBhdGggPSBmdW5jdGlvbiAocGF0aFN0cmluZywgU1ZHKSB7XG4gICAgICAgIHZhciBlbCA9ICQoXCJwYXRoXCIpO1xuICAgICAgICBTVkcuY2FudmFzICYmIFNWRy5jYW52YXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgcCA9IG5ldyBFbGVtZW50KGVsLCBTVkcpO1xuICAgICAgICBwLnR5cGUgPSBcInBhdGhcIjtcbiAgICAgICAgc2V0RmlsbEFuZFN0cm9rZShwLCB7XG4gICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwXCIsXG4gICAgICAgICAgICBwYXRoOiBwYXRoU3RyaW5nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnJvdGF0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRGVwcmVjYXRlZCEgVXNlIEBFbGVtZW50LnRyYW5zZm9ybSBpbnN0ZWFkLlxuICAgICAqIEFkZHMgcm90YXRpb24gYnkgZ2l2ZW4gYW5nbGUgYXJvdW5kIGdpdmVuIHBvaW50IHRvIHRoZSBsaXN0IG9mXG4gICAgICogdHJhbnNmb3JtYXRpb25zIG9mIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBkZWcgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuICAgICAtIGN4IChudW1iZXIpICNvcHRpb25hbCB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiByb3RhdGlvblxuICAgICAtIGN5IChudW1iZXIpICNvcHRpb25hbCB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiByb3RhdGlvblxuICAgICAqIElmIGN4ICYgY3kgYXJlbuKAmXQgc3BlY2lmaWVkIGNlbnRyZSBvZiB0aGUgc2hhcGUgaXMgdXNlZCBhcyBhIHBvaW50IG9mIHJvdGF0aW9uLlxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucm90YXRlID0gZnVuY3Rpb24gKGRlZywgY3gsIGN5KSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRlZyA9IFN0cihkZWcpLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChkZWcubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY3ggPSB0b0Zsb2F0KGRlZ1sxXSk7XG4gICAgICAgICAgICBjeSA9IHRvRmxvYXQoZGVnWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWcgPSB0b0Zsb2F0KGRlZ1swXSk7XG4gICAgICAgIChjeSA9PSBudWxsKSAmJiAoY3ggPSBjeSk7XG4gICAgICAgIGlmIChjeCA9PSBudWxsIHx8IGN5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KDEpO1xuICAgICAgICAgICAgY3ggPSBiYm94LnggKyBiYm94LndpZHRoIC8gMjtcbiAgICAgICAgICAgIGN5ID0gYmJveC55ICsgYmJveC5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJyXCIsIGRlZywgY3gsIGN5XV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRGVwcmVjYXRlZCEgVXNlIEBFbGVtZW50LnRyYW5zZm9ybSBpbnN0ZWFkLlxuICAgICAqIEFkZHMgc2NhbGUgYnkgZ2l2ZW4gYW1vdW50IHJlbGF0aXZlIHRvIGdpdmVuIHBvaW50IHRvIHRoZSBsaXN0IG9mXG4gICAgICogdHJhbnNmb3JtYXRpb25zIG9mIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBzeCAobnVtYmVyKSBob3Jpc29udGFsIHNjYWxlIGFtb3VudFxuICAgICAtIHN5IChudW1iZXIpIHZlcnRpY2FsIHNjYWxlIGFtb3VudFxuICAgICAtIGN4IChudW1iZXIpICNvcHRpb25hbCB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiBzY2FsZVxuICAgICAtIGN5IChudW1iZXIpICNvcHRpb25hbCB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiBzY2FsZVxuICAgICAqIElmIGN4ICYgY3kgYXJlbuKAmXQgc3BlY2lmaWVkIGNlbnRyZSBvZiB0aGUgc2hhcGUgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoc3gsIHN5LCBjeCwgY3kpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSBTdHIoc3gpLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChzeC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzeSA9IHRvRmxvYXQoc3hbMV0pO1xuICAgICAgICAgICAgY3ggPSB0b0Zsb2F0KHN4WzJdKTtcbiAgICAgICAgICAgIGN5ID0gdG9GbG9hdChzeFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0b0Zsb2F0KHN4WzBdKTtcbiAgICAgICAgKHN5ID09IG51bGwpICYmIChzeSA9IHN4KTtcbiAgICAgICAgKGN5ID09IG51bGwpICYmIChjeCA9IGN5KTtcbiAgICAgICAgaWYgKGN4ID09IG51bGwgfHwgY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3ggPSBjeCA9PSBudWxsID8gYmJveC54ICsgYmJveC53aWR0aCAvIDIgOiBjeDtcbiAgICAgICAgY3kgPSBjeSA9PSBudWxsID8gYmJveC55ICsgYmJveC5oZWlnaHQgLyAyIDogY3k7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJzXCIsIHN4LCBzeSwgY3gsIGN5XV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50cmFuc2xhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERlcHJlY2F0ZWQhIFVzZSBARWxlbWVudC50cmFuc2Zvcm0gaW5zdGVhZC5cbiAgICAgKiBBZGRzIHRyYW5zbGF0aW9uIGJ5IGdpdmVuIGFtb3VudCB0byB0aGUgbGlzdCBvZiB0cmFuc2Zvcm1hdGlvbnMgb2YgdGhlIGVsZW1lbnQuXG4gICAgID4gUGFyYW1ldGVyc1xuICAgICAtIGR4IChudW1iZXIpIGhvcmlzb250YWwgc2hpZnRcbiAgICAgLSBkeSAobnVtYmVyKSB2ZXJ0aWNhbCBzaGlmdFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkeCA9IFN0cihkeCkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGR4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGR5ID0gdG9GbG9hdChkeFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB0b0Zsb2F0KGR4WzBdKSB8fCAwO1xuICAgICAgICBkeSA9ICtkeSB8fCAwO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSh0aGlzLl8udHJhbnNmb3JtLmNvbmNhdChbW1widFwiLCBkeCwgZHldXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRyYW5zZm9ybVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgZWxlbWVudCB3aGljaCBpcyBzZXBhcmF0ZSB0byBvdGhlciBhdHRyaWJ1dGVzLFxuICAgICAqIGkuZS4gdHJhbnNsYXRpb24gZG9lc27igJl0IGNoYW5nZSBgeGAgb3IgYHlgIG9mIHRoZSByZWN0YW5nZS4gVGhlIGZvcm1hdFxuICAgICAqIG9mIHRyYW5zZm9ybWF0aW9uIHN0cmluZyBpcyBzaW1pbGFyIHRvIHRoZSBwYXRoIHN0cmluZyBzeW50YXg6XG4gICAgIHwgXCJ0MTAwLDEwMHIzMCwxMDAsMTAwczIsMiwxMDAsMTAwcjQ1czEuNVwiXG4gICAgICogRWFjaCBsZXR0ZXIgaXMgYSBjb21tYW5kLiBUaGVyZSBhcmUgZm91ciBjb21tYW5kczogYHRgIGlzIGZvciB0cmFuc2xhdGUsIGByYCBpcyBmb3Igcm90YXRlLCBgc2AgaXMgZm9yXG4gICAgICogc2NhbGUgYW5kIGBtYCBpcyBmb3IgbWF0cml4LlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIGFsc28gYWx0ZXJuYXRpdmUg4oCcYWJzb2x1dGXigJ0gdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsZTogYFRgLCBgUmAgYW5kIGBTYC4gVGhleSB3aWxsIG5vdCB0YWtlIHByZXZpb3VzIHRyYW5zZm9ybWF0aW9uIGludG8gYWNjb3VudC4gRm9yIGV4YW1wbGUsIGAuLi5UMTAwLDBgIHdpbGwgYWx3YXlzIG1vdmUgZWxlbWVudCAxMDAgcHggaG9yaXNvbnRhbGx5LCB3aGlsZSBgLi4udDEwMCwwYCBjb3VsZCBtb3ZlIGl0IHZlcnRpY2FsbHkgaWYgdGhlcmUgaXMgYHI5MGAgYmVmb3JlLiBKdXN0IGNvbXBhcmUgcmVzdWx0cyBvZiBgcjkwdDEwMCwwYCBhbmQgYHI5MFQxMDAsMGAuXG4gICAgICpcbiAgICAgKiBTbywgdGhlIGV4YW1wbGUgbGluZSBhYm92ZSBjb3VsZCBiZSByZWFkIGxpa2Ug4oCcdHJhbnNsYXRlIGJ5IDEwMCwgMTAwOyByb3RhdGUgMzDCsCBhcm91bmQgMTAwLCAxMDA7IHNjYWxlIHR3aWNlIGFyb3VuZCAxMDAsIDEwMDtcbiAgICAgKiByb3RhdGUgNDXCsCBhcm91bmQgY2VudHJlOyBzY2FsZSAxLjUgdGltZXMgcmVsYXRpdmUgdG8gY2VudHJl4oCdLiBBcyB5b3UgY2FuIHNlZSByb3RhdGUgYW5kIHNjYWxlIGNvbW1hbmRzIGhhdmUgb3JpZ2luXG4gICAgICogY29vcmRpbmF0ZXMgYXMgb3B0aW9uYWwgcGFyYW1ldGVycywgdGhlIGRlZmF1bHQgaXMgdGhlIGNlbnRyZSBwb2ludCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBNYXRyaXggYWNjZXB0cyBzaXggcGFyYW1ldGVycy5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBlbCA9IHBhcGVyLnJlY3QoMTAsIDIwLCAzMDAsIDIwMCk7XG4gICAgIHwgLy8gdHJhbnNsYXRlIDEwMCwgMTAwLCByb3RhdGUgNDXCsCwgdHJhbnNsYXRlIC0xMDAsIDBcbiAgICAgfCBlbC50cmFuc2Zvcm0oXCJ0MTAwLDEwMHI0NXQtMTAwLDBcIik7XG4gICAgIHwgLy8gaWYgeW91IHdhbnQgeW91IGNhbiBhcHBlbmQgb3IgcHJlcGVuZCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgfCBlbC50cmFuc2Zvcm0oXCIuLi50NTAsNTBcIik7XG4gICAgIHwgZWwudHJhbnNmb3JtKFwiczIuLi5cIik7XG4gICAgIHwgLy8gb3IgZXZlbiB3cmFwXG4gICAgIHwgZWwudHJhbnNmb3JtKFwidDUwLDUwLi4udC01MC01MFwiKTtcbiAgICAgfCAvLyB0byByZXNldCB0cmFuc2Zvcm1hdGlvbiBjYWxsIG1ldGhvZCB3aXRoIGVtcHR5IHN0cmluZ1xuICAgICB8IGVsLnRyYW5zZm9ybShcIlwiKTtcbiAgICAgfCAvLyB0byBnZXQgY3VycmVudCB2YWx1ZSBjYWxsIGl0IHdpdGhvdXQgcGFyYW1ldGVyc1xuICAgICB8IGNvbnNvbGUubG9nKGVsLnRyYW5zZm9ybSgpKTtcbiAgICAgPiBQYXJhbWV0ZXJzXG4gICAgIC0gdHN0ciAoc3RyaW5nKSAjb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgICogSWYgdHN0ciBpc27igJl0IHNwZWNpZmllZFxuICAgICA9IChzdHJpbmcpIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgICogZWxzZVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gKHRzdHIpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLl87XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfLnRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBSLl9leHRyYWN0VHJhbnNmb3JtKHRoaXMsIHRzdHIpO1xuXG4gICAgICAgIHRoaXMuY2xpcCAmJiAkKHRoaXMuY2xpcCwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXguaW52ZXJ0KCl9KTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuICYmIHVwZGF0ZVBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUgJiYgJCh0aGlzLm5vZGUsIHt0cmFuc2Zvcm06IHRoaXMubWF0cml4fSk7XG5cbiAgICAgICAgaWYgKF8uc3ggIT0gMSB8fCBfLnN5ICE9IDEpIHtcbiAgICAgICAgICAgIHZhciBzdyA9IHRoaXMuYXR0cnNbaGFzXShcInN0cm9rZS13aWR0aFwiKSA/IHRoaXMuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gOiAxO1xuICAgICAgICAgICAgdGhpcy5hdHRyKHtcInN0cm9rZS13aWR0aFwiOiBzd30pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5oaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IGludmlzaWJsZS4gU2VlIEBFbGVtZW50LnNob3cuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5yZW1vdmVkKSB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnNob3dcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgdmlzaWJsZS4gU2VlIEBFbGVtZW50LmhpZGUuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5yZW1vdmVkKSB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucmVtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnQgZnJvbSB0aGUgcGFwZXIuXG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldFJlYWxOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQgfHwgIW5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHBhcGVyLl9fc2V0X18gJiYgcGFwZXIuX19zZXRfXy5leGNsdWRlKHRoaXMpO1xuICAgICAgICBldmUudW5iaW5kKFwicmFwaGFlbC4qLiouXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnQpIHtcbiAgICAgICAgICAgIHBhcGVyLmRlZnMucmVtb3ZlQ2hpbGQodGhpcy5ncmFkaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgUi5fdGVhcih0aGlzLCBwYXBlcik7XG5cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBjdXN0b20gZGF0YSBmb3IgZWxlbWVudFxuICAgICAgICB0aGlzLnJlbW92ZURhdGEoKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB0eXBlb2YgdGhpc1tpXSA9PSBcImZ1bmN0aW9uXCIgPyBSLl9yZW1vdmVkRmFjdG9yeShpKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGVscHJvdG8uX2dldEJCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB2YXIgaGlkZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbnZhc0hpZGRlbiA9IGZhbHNlLFxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGU7XG4gICAgICAgIGlmICh0aGlzLnBhcGVyLmNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyU3R5bGUgPSB0aGlzLnBhcGVyLmNhbnZhcy5wYXJlbnRFbGVtZW50LnN0eWxlO1xuICAgICAgICB9IC8vSUUxMCsgY2FuJ3QgZmluZCBwYXJlbnRFbGVtZW50XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb250YWluZXJTdHlsZSA9IHRoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb250YWluZXJTdHlsZSAmJiBjb250YWluZXJTdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgY2FudmFzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBjb250YWluZXJTdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmJveCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmJveCA9IHRoaXMubm9kZS5nZXRCQm94KCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCAzLjAueCwgMjUuMC4xIChwcm9iYWJseSBtb3JlIHZlcnNpb25zIGFmZmVjdGVkKSBwbGF5IGJhZGx5IGhlcmUgLSBwb3NzaWJsZSBmaXhcbiAgICAgICAgICAgIGJib3ggPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5ub2RlLmNsaWVudExlZnQsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5ub2RlLmNsaWVudFRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5ub2RlLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5ub2RlLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgYmJveCA9IGJib3ggfHwge307XG4gICAgICAgICAgICBpZihjYW52YXNIaWRkZW4pe1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSAmJiB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZXRzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50LlxuICAgICA+IFBhcmFtZXRlcnNcbiAgICAgLSBhdHRyTmFtZSAoc3RyaW5nKSBhdHRyaWJ1dGXigJlzIG5hbWVcbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSB2YWx1ZVxuICAgICAqIG9yXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIG9iamVjdCBvZiBuYW1lL3ZhbHVlIHBhaXJzXG4gICAgICogb3JcbiAgICAgLSBhdHRyTmFtZSAoc3RyaW5nKSBhdHRyaWJ1dGXigJlzIG5hbWVcbiAgICAgKiBvclxuICAgICAtIGF0dHJOYW1lcyAoYXJyYXkpIGluIHRoaXMgY2FzZSBtZXRob2QgcmV0dXJucyBhcnJheSBvZiBjdXJyZW50IHZhbHVlcyBmb3IgZ2l2ZW4gYXR0cmlidXRlIG5hbWVzXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnQgaWYgYXR0cnNOYW1lICYgdmFsdWUgb3IgcGFyYW1zIGFyZSBwYXNzZWQgaW4uXG4gICAgID0gKC4uLikgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBpZiBvbmx5IGF0dHJzTmFtZSBpcyBwYXNzZWQgaW4uXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiB2YWx1ZXMgb2YgdGhlIGF0dHJpYnV0ZSBpZiBhdHRyc05hbWVzIGlzIHBhc3NlZCBpbi5cbiAgICAgPSAob2JqZWN0KSBvYmplY3Qgb2YgYXR0cmlidXRlcyBpZiBub3RoaW5nIGlzIHBhc3NlZCBpbi5cbiAgICAgPiBQb3NzaWJsZSBwYXJhbWV0ZXJzXG4gICAgICMgPHA+UGxlYXNlIHJlZmVyIHRvIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL1wiIHRpdGxlPVwiVGhlIFczQyBSZWNvbW1lbmRhdGlvbiBmb3IgdGhlIFNWRyBsYW5ndWFnZSBkZXNjcmliZXMgdGhlc2UgcHJvcGVydGllcyBpbiBkZXRhaWwuXCI+U1ZHIHNwZWNpZmljYXRpb248L2E+IGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGVzZSBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgbyBhcnJvdy1lbmQgKHN0cmluZykgYXJyb3doZWFkIG9uIHRoZSBlbmQgb2YgdGhlIHBhdGguIFRoZSBmb3JtYXQgZm9yIHN0cmluZyBpcyBgPHR5cGU+Wy08d2lkdGg+Wy08bGVuZ3RoPl1dYC4gUG9zc2libGUgdHlwZXM6IGBjbGFzc2ljYCwgYGJsb2NrYCwgYG9wZW5gLCBgb3ZhbGAsIGBkaWFtb25kYCwgYG5vbmVgLCB3aWR0aDogYHdpZGVgLCBgbmFycm93YCwgYG1lZGl1bWAsIGxlbmd0aDogYGxvbmdgLCBgc2hvcnRgLCBgbWlkaXVtYC5cbiAgICAgbyBjbGlwLXJlY3QgKHN0cmluZykgY29tbWEgb3Igc3BhY2Ugc2VwYXJhdGVkIHZhbHVlczogeCwgeSwgd2lkdGggYW5kIGhlaWdodFxuICAgICBvIGN1cnNvciAoc3RyaW5nKSBDU1MgdHlwZSBvZiB0aGUgY3Vyc29yXG4gICAgIG8gY3ggKG51bWJlcikgdGhlIHgtYXhpcyBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSwgb3IgZWxsaXBzZVxuICAgICBvIGN5IChudW1iZXIpIHRoZSB5LWF4aXMgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsIG9yIGVsbGlwc2VcbiAgICAgbyBmaWxsIChzdHJpbmcpIGNvbG91ciwgZ3JhZGllbnQgb3IgaW1hZ2VcbiAgICAgbyBmaWxsLW9wYWNpdHkgKG51bWJlcilcbiAgICAgbyBmb250IChzdHJpbmcpXG4gICAgIG8gZm9udC1mYW1pbHkgKHN0cmluZylcbiAgICAgbyBmb250LXNpemUgKG51bWJlcikgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICBvIGZvbnQtd2VpZ2h0IChzdHJpbmcpXG4gICAgIG8gaGVpZ2h0IChudW1iZXIpXG4gICAgIG8gaHJlZiAoc3RyaW5nKSBVUkwsIGlmIHNwZWNpZmllZCBlbGVtZW50IGJlaGF2ZXMgYXMgaHlwZXJsaW5rXG4gICAgIG8gb3BhY2l0eSAobnVtYmVyKVxuICAgICBvIHBhdGggKHN0cmluZykgU1ZHIHBhdGggc3RyaW5nIGZvcm1hdFxuICAgICBvIHIgKG51bWJlcikgcmFkaXVzIG9mIHRoZSBjaXJjbGUsIGVsbGlwc2Ugb3Igcm91bmRlZCBjb3JuZXIgb24gdGhlIHJlY3RcbiAgICAgbyByeCAobnVtYmVyKSBob3Jpc29udGFsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZVxuICAgICBvIHJ5IChudW1iZXIpIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZVxuICAgICBvIHNyYyAoc3RyaW5nKSBpbWFnZSBVUkwsIG9ubHkgd29ya3MgZm9yIEBFbGVtZW50LmltYWdlIGVsZW1lbnRcbiAgICAgbyBzdHJva2UgKHN0cmluZykgc3Ryb2tlIGNvbG91clxuICAgICBvIHN0cm9rZS1kYXNoYXJyYXkgKHN0cmluZykgW+KAnOKAnSwg4oCcbm9uZeKAnSwg4oCcYC1g4oCdLCDigJxgLmDigJ0sIOKAnGAtLmDigJ0sIOKAnGAtLi5g4oCdLCDigJxgLiBg4oCdLCDigJxgLSBg4oCdLCDigJxgLS1g4oCdLCDigJxgLSAuYOKAnSwg4oCcYC0tLmDigJ0sIOKAnGAtLS4uYOKAnV1cbiAgICAgbyBzdHJva2UtbGluZWNhcCAoc3RyaW5nKSBb4oCcYGJ1dHRg4oCdLCDigJxgc3F1YXJlYOKAnSwg4oCcYHJvdW5kYOKAnV1cbiAgICAgbyBzdHJva2UtbGluZWpvaW4gKHN0cmluZykgW+KAnGBiZXZlbGDigJ0sIOKAnGByb3VuZGDigJ0sIOKAnGBtaXRlcmDigJ1dXG4gICAgIG8gc3Ryb2tlLW1pdGVybGltaXQgKG51bWJlcilcbiAgICAgbyBzdHJva2Utb3BhY2l0eSAobnVtYmVyKVxuICAgICBvIHN0cm9rZS13aWR0aCAobnVtYmVyKSBzdHJva2Ugd2lkdGggaW4gcGl4ZWxzLCBkZWZhdWx0IGlzICcxJ1xuICAgICBvIHRhcmdldCAoc3RyaW5nKSB1c2VkIHdpdGggaHJlZlxuICAgICBvIHRleHQgKHN0cmluZykgY29udGVudHMgb2YgdGhlIHRleHQgZWxlbWVudC4gVXNlIGBcXG5gIGZvciBtdWx0aWxpbmUgdGV4dFxuICAgICBvIHRleHQtYW5jaG9yIChzdHJpbmcpIFvigJxgc3RhcnRg4oCdLCDigJxgbWlkZGxlYOKAnSwg4oCcYGVuZGDigJ1dLCBkZWZhdWx0IGlzIOKAnGBtaWRkbGVg4oCdXG4gICAgIG8gdGl0bGUgKHN0cmluZykgd2lsbCBjcmVhdGUgdG9vbHRpcCB3aXRoIGEgZ2l2ZW4gdGV4dFxuICAgICBvIHRyYW5zZm9ybSAoc3RyaW5nKSBzZWUgQEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIG8gd2lkdGggKG51bWJlcilcbiAgICAgbyB4IChudW1iZXIpXG4gICAgIG8geSAobnVtYmVyKVxuICAgICA+IEdyYWRpZW50c1xuICAgICAqIExpbmVhciBncmFkaWVudCBmb3JtYXQ6IOKAnGDigLlhbmdsZeKAui3igLljb2xvdXLigLpbLeKAuWNvbG91cuKAuls64oC5b2Zmc2V04oC6XV0qLeKAuWNvbG91cuKAumDigJ0sIGV4YW1wbGU6IOKAnGA5MC0jZmZmLSMwMDBg4oCdIOKAkyA5MMKwXG4gICAgICogZ3JhZGllbnQgZnJvbSB3aGl0ZSB0byBibGFjayBvciDigJxgMC0jZmZmLSNmMDA6MjAtIzAwMGDigJ0g4oCTIDDCsCBncmFkaWVudCBmcm9tIHdoaXRlIHZpYSByZWQgKGF0IDIwJSkgdG8gYmxhY2suXG4gICAgICpcbiAgICAgKiByYWRpYWwgZ3JhZGllbnQ6IOKAnGByWyjigLlmeOKAuiwg4oC5ZnnigLopXeKAuWNvbG91cuKAulst4oC5Y29sb3Vy4oC6WzrigLlvZmZzZXTigLpdXSot4oC5Y29sb3Vy4oC6YOKAnSwgZXhhbXBsZTog4oCcYHIjZmZmLSMwMDBg4oCdIOKAk1xuICAgICAqIGdyYWRpZW50IGZyb20gd2hpdGUgdG8gYmxhY2sgb3Ig4oCcYHIoMC4yNSwgMC43NSkjZmZmLSMwMDBg4oCdIOKAkyBncmFkaWVudCBmcm9tIHdoaXRlIHRvIGJsYWNrIHdpdGggZm9jdXMgcG9pbnRcbiAgICAgKiBhdCAwLjI1LCAwLjc1LiBGb2N1cyBwb2ludCBjb29yZGluYXRlcyBhcmUgaW4gMC4uMSByYW5nZS4gUmFkaWFsIGdyYWRpZW50cyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGNpcmNsZXMgYW5kIGVsbGlwc2VzLlxuICAgICA+IFBhdGggU3RyaW5nXG4gICAgICMgPHA+UGxlYXNlIHJlZmVyIHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVwiIHRpdGxlPVwiRGV0YWlscyBvZiBhIHBhdGjigJlzIGRhdGEgYXR0cmlidXRl4oCZcyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIGRvY3VtZW50YXRpb24gcmVnYXJkaW5nIHBhdGggc3RyaW5nPC9hPi4gUmFwaGHDq2wgZnVsbHkgc3VwcG9ydHMgaXQuPC9wPlxuICAgICA+IENvbG91ciBQYXJzaW5nXG4gICAgICMgPHVsPlxuICAgICAjICAgICA8bGk+Q29sb3VyIG5hbWUgKOKAnDxjb2RlPnJlZDwvY29kZT7igJ0sIOKAnDxjb2RlPmdyZWVuPC9jb2RlPuKAnSwg4oCcPGNvZGU+Y29ybmZsb3dlcmJsdWU8L2NvZGU+4oCdLCBldGMpPC9saT5cbiAgICAgIyAgICAgPGxpPiPigKLigKLigKIg4oCUIHNob3J0ZW5lZCBIVE1MIGNvbG91cjogKOKAnDxjb2RlPiMwMDA8L2NvZGU+4oCdLCDigJw8Y29kZT4jZmMwPC9jb2RlPuKAnSwgZXRjKTwvbGk+XG4gICAgICMgICAgIDxsaT4j4oCi4oCi4oCi4oCi4oCi4oCiIOKAlCBmdWxsIGxlbmd0aCBIVE1MIGNvbG91cjogKOKAnDxjb2RlPiMwMDAwMDA8L2NvZGU+4oCdLCDigJw8Y29kZT4jYmQyMzAwPC9jb2RlPuKAnSk8L2xpPlxuICAgICAjICAgICA8bGk+cmdiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxz4oCZIHZhbHVlczogKOKAnDxjb2RlPnJnYigyMDAsJm5ic3A7MTAwLCZuYnNwOzApPC9jb2RlPuKAnSk8L2xpPlxuICAgICAjICAgICA8bGk+cmdiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKOKAnDxjb2RlPnJnYigxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUpPC9jb2RlPuKAnSk8L2xpPlxuICAgICAjICAgICA8bGk+cmdiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxz4oCZIHZhbHVlczogKOKAnDxjb2RlPnJnYmEoMjAwLCZuYnNwOzEwMCwmbmJzcDswLCAuNSk8L2NvZGU+4oCdKTwvbGk+XG4gICAgICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKOKAnDxjb2RlPnJnYmEoMTAwJSwmbmJzcDsxNzUlLCZuYnNwOzAlLCA1MCUpPC9jb2RlPuKAnSk8L2xpPlxuICAgICAjICAgICA8bGk+aHNiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBodWUsIHNhdHVyYXRpb24gYW5kIGJyaWdodG5lc3MgdmFsdWVzOiAo4oCcPGNvZGU+aHNiKDAuNSwmbmJzcDswLjI1LCZuYnNwOzEpPC9jb2RlPuKAnSk8L2xpPlxuICAgICAjICAgICA8bGk+aHNiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCB3aXRoIG9wYWNpdHk8L2xpPlxuICAgICAjICAgICA8bGk+aHNsKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbG1vc3QgdGhlIHNhbWUgYXMgaHNiLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcIiB0aXRsZT1cIkhTTCBhbmQgSFNWIC0gV2lraXBlZGlhLCB0aGUgZnJlZSBlbmN5Y2xvcGVkaWFcIj5XaWtpcGVkaWEgcGFnZTwvYT48L2xpPlxuICAgICAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gICAgICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIHNhbWUgYXMgYWJvdmUsIGJ1dCB3aXRoIG9wYWNpdHk8L2xpPlxuICAgICAjICAgICA8bGk+T3B0aW9uYWxseSBmb3IgaHNiIGFuZCBoc2wgeW91IGNvdWxkIHNwZWNpZnkgaHVlIGFzIGEgZGVncmVlOiDigJw8Y29kZT5oc2woMjQwZGVnLCZuYnNwOzEsJm5ic3A7LjUpPC9jb2RlPuKAnSBvciwgaWYgeW91IHdhbnQgdG8gZ28gZmFuY3ksIOKAnDxjb2RlPmhzbCgyNDDCsCwmbmJzcDsxLCZuYnNwOy41KTwvY29kZT7igJ08L2xpPlxuICAgICAjIDwvdWw+XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBhIGluIHRoaXMuYXR0cnMpIGlmICh0aGlzLmF0dHJzW2hhc10oYSkpIHtcbiAgICAgICAgICAgICAgICByZXNbYV0gPSB0aGlzLmF0dHJzW2FdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLmdyYWRpZW50ICYmIHJlcy5maWxsID09IFwibm9uZVwiICYmIChyZXMuZmlsbCA9IHJlcy5ncmFkaWVudCkgJiYgZGVsZXRlIHJlcy5ncmFkaWVudDtcbiAgICAgICAgICAgIHJlcy50cmFuc2Zvcm0gPSB0aGlzLl8udHJhbnNmb3JtO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBSLmlzKG5hbWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImZpbGxcIiAmJiB0aGlzLmF0dHJzLmZpbGwgPT0gXCJub25lXCIgJiYgdGhpcy5hdHRycy5ncmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8udHJhbnNmb3JtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChzZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHRoaXMuYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChSLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tuYW1lXSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbbmFtZV0uZGVmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IFIuX2F2YWlsYWJsZUF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpaSAtIDEgPyBvdXQgOiBvdXRbbmFtZXNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIFIuaXMobmFtZSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtuYW1lW2ldXSA9IHRoaXMuYXR0cihuYW1lW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgIT0gbnVsbCAmJiBSLmlzKG5hbWUsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGV2ZShcInJhcGhhZWwuYXR0ci5cIiArIGtleSArIFwiLlwiICsgdGhpcy5pZCwgdGhpcywgcGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlcykgaWYgKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1toYXNdKGtleSkgJiYgcGFyYW1zW2hhc10oa2V5KSAmJiBSLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1trZXldLCBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICB2YXIgcGFyID0gdGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2tleV0uYXBwbHkodGhpcywgW10uY29uY2F0KHBhcmFtc1trZXldKSk7XG4gICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGZvciAodmFyIHN1YmtleSBpbiBwYXIpIGlmIChwYXJbaGFzXShzdWJrZXkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3N1YmtleV0gPSBwYXJbc3Via2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9Gcm9udFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTW92ZXMgdGhlIGVsZW1lbnQgc28gaXQgaXMgdGhlIGNsb3Nlc3QgdG8gdGhlIHZpZXdlcuKAmXMgZXllcywgb24gdG9wIG9mIG90aGVyIGVsZW1lbnRzLlxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9Gcm9udCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBnZXRSZWFsTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnBhcGVyO1xuICAgICAgICBzdmcudG9wICE9IHRoaXMgJiYgUi5fdG9mcm9udCh0aGlzLCBzdmcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvQmFja1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTW92ZXMgdGhlIGVsZW1lbnQgc28gaXQgaXMgdGhlIGZ1cnRoZXN0IGZyb20gdGhlIHZpZXdlcuKAmXMgZXllcywgYmVoaW5kIG90aGVyIGVsZW1lbnRzLlxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9CYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGdldFJlYWxOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBSLl90b2JhY2sodGhpcywgdGhpcy5wYXBlcik7XG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmluc2VydEFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGN1cnJlbnQgb2JqZWN0IGFmdGVyIHRoZSBnaXZlbiBvbmUuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBnZXRSZWFsTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICB2YXIgYWZ0ZXJOb2RlID0gZ2V0UmVhbE5vZGUoZWxlbWVudC5ub2RlIHx8IGVsZW1lbnRbZWxlbWVudC5sZW5ndGggLSAxXS5ub2RlKTtcbiAgICAgICAgaWYgKGFmdGVyTm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgYWZ0ZXJOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGFmdGVyTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlck5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBSLl9pbnNlcnRhZnRlcih0aGlzLCBlbGVtZW50LCB0aGlzLnBhcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRCZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgY3VycmVudCBvYmplY3QgYmVmb3JlIHRoZSBnaXZlbiBvbmUuXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmVkIHx8ICFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gZ2V0UmVhbE5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgdmFyIGJlZm9yZU5vZGUgPSBnZXRSZWFsTm9kZShlbGVtZW50Lm5vZGUgfHwgZWxlbWVudFswXS5ub2RlKTtcbiAgICAgICAgYmVmb3JlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmVOb2RlKTtcbiAgICAgICAgUi5faW5zZXJ0YmVmb3JlKHRoaXMsIGVsZW1lbnQsIHRoaXMucGFwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uYmx1ciA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIC8vIEV4cGVyaW1lbnRhbC4gTm8gU2FmYXJpIHN1cHBvcnQuIFVzZSBpdCBvbiB5b3VyIG93biByaXNrLlxuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIGlmICgrc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGZsdHIgPSAkKFwiZmlsdGVyXCIpLFxuICAgICAgICAgICAgICAgIGJsdXIgPSAkKFwiZmVHYXVzc2lhbkJsdXJcIik7XG4gICAgICAgICAgICB0LmF0dHJzLmJsdXIgPSBzaXplO1xuICAgICAgICAgICAgZmx0ci5pZCA9IFIuY3JlYXRlVVVJRCgpO1xuICAgICAgICAgICAgJChibHVyLCB7c3RkRGV2aWF0aW9uOiArc2l6ZSB8fCAxLjV9KTtcbiAgICAgICAgICAgIGZsdHIuYXBwZW5kQ2hpbGQoYmx1cik7XG4gICAgICAgICAgICB0LnBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQoZmx0cik7XG4gICAgICAgICAgICB0Ll9ibHVyID0gZmx0cjtcbiAgICAgICAgICAgICQodC5ub2RlLCB7ZmlsdGVyOiBcInVybCgjXCIgKyBmbHRyLmlkICsgXCIpXCJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0Ll9ibHVyKSB7XG4gICAgICAgICAgICAgICAgdC5fYmx1ci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQuX2JsdXIpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0Ll9ibHVyO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0LmF0dHJzLmJsdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Lm5vZGUucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgUi5fZW5naW5lLmNpcmNsZSA9IGZ1bmN0aW9uIChzdmcsIHgsIHksIHIpIHtcbiAgICAgICAgdmFyIGVsID0gJChcImNpcmNsZVwiKTtcbiAgICAgICAgc3ZnLmNhbnZhcyAmJiBzdmcuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBFbGVtZW50KGVsLCBzdmcpO1xuICAgICAgICByZXMuYXR0cnMgPSB7Y3g6IHgsIGN5OiB5LCByOiByLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDBcIn07XG4gICAgICAgIHJlcy50eXBlID0gXCJjaXJjbGVcIjtcbiAgICAgICAgJChlbCwgcmVzLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5yZWN0ID0gZnVuY3Rpb24gKHN2ZywgeCwgeSwgdywgaCwgcikge1xuICAgICAgICB2YXIgZWwgPSAkKFwicmVjdFwiKTtcbiAgICAgICAgc3ZnLmNhbnZhcyAmJiBzdmcuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBFbGVtZW50KGVsLCBzdmcpO1xuICAgICAgICByZXMuYXR0cnMgPSB7eDogeCwgeTogeSwgd2lkdGg6IHcsIGhlaWdodDogaCwgcng6IHIgfHwgMCwgcnk6IHIgfHwgMCwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwXCJ9O1xuICAgICAgICByZXMudHlwZSA9IFwicmVjdFwiO1xuICAgICAgICAkKGVsLCByZXMuYXR0cnMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLmVsbGlwc2UgPSBmdW5jdGlvbiAoc3ZnLCB4LCB5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIGVsID0gJChcImVsbGlwc2VcIik7XG4gICAgICAgIHN2Zy5jYW52YXMgJiYgc3ZnLmNhbnZhcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRWxlbWVudChlbCwgc3ZnKTtcbiAgICAgICAgcmVzLmF0dHJzID0ge2N4OiB4LCBjeTogeSwgcng6IHJ4LCByeTogcnksIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMFwifTtcbiAgICAgICAgcmVzLnR5cGUgPSBcImVsbGlwc2VcIjtcbiAgICAgICAgJChlbCwgcmVzLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5pbWFnZSA9IGZ1bmN0aW9uIChzdmcsIHNyYywgeCwgeSwgdywgaCkge1xuICAgICAgICB2YXIgZWwgPSAkKFwiaW1hZ2VcIik7XG4gICAgICAgICQoZWwsIHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIn0pO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGluaywgXCJocmVmXCIsIHNyYyk7XG4gICAgICAgIHN2Zy5jYW52YXMgJiYgc3ZnLmNhbnZhcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRWxlbWVudChlbCwgc3ZnKTtcbiAgICAgICAgcmVzLmF0dHJzID0ge3g6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsIHNyYzogc3JjfTtcbiAgICAgICAgcmVzLnR5cGUgPSBcImltYWdlXCI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUudGV4dCA9IGZ1bmN0aW9uIChzdmcsIHgsIHksIHRleHQpIHtcbiAgICAgICAgdmFyIGVsID0gJChcInRleHRcIik7XG4gICAgICAgIHN2Zy5jYW52YXMgJiYgc3ZnLmNhbnZhcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRWxlbWVudChlbCwgc3ZnKTtcbiAgICAgICAgcmVzLmF0dHJzID0ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwibWlkZGxlXCIsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgXCJmb250LWZhbWlseVwiOiBSLl9hdmFpbGFibGVBdHRyc1tcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogUi5fYXZhaWxhYmxlQXR0cnNbXCJmb250LXNpemVcIl0sXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICAgICAgZmlsbDogXCIjMDAwXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgc2V0RmlsbEFuZFN0cm9rZShyZXMsIHJlcy5hdHRycyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLl92aWV3Qm94KSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpZXdCb3guYXBwbHkodGhpcywgdGhpcy5fdmlld0JveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uID0gUi5fZ2V0Q29udGFpbmVyLmFwcGx5KDAsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb24gJiYgY29uLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNWRyBjb250YWluZXIgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGNvbi54LFxuICAgICAgICAgICAgeSA9IGNvbi55LFxuICAgICAgICAgICAgd2lkdGggPSBjb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb24uaGVpZ2h0LFxuICAgICAgICAgICAgY252cyA9ICQoXCJzdmdcIiksXG4gICAgICAgICAgICBjc3MgPSBcIm92ZXJmbG93OmhpZGRlbjtcIixcbiAgICAgICAgICAgIGlzRmxvYXRpbmc7XG4gICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgIHkgPSB5IHx8IDA7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgNTEyO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMzQyO1xuICAgICAgICAkKGNudnMsIHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgdmVyc2lvbjogMS4xLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgIFwieG1sbnM6eGxpbmtcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT0gMSkge1xuICAgICAgICAgICAgY252cy5zdHlsZS5jc3NUZXh0ID0gY3NzICsgXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OlwiICsgeCArIFwicHg7dG9wOlwiICsgeSArIFwicHhcIjtcbiAgICAgICAgICAgIFIuX2cuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY252cyk7XG4gICAgICAgICAgICBpc0Zsb2F0aW5nID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNudnMuc3R5bGUuY3NzVGV4dCA9IGNzcyArIFwicG9zaXRpb246cmVsYXRpdmVcIjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY252cywgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY252cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gbmV3IFIuX1BhcGVyO1xuICAgICAgICBjb250YWluZXIud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY29udGFpbmVyLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY29udGFpbmVyLmNhbnZhcyA9IGNudnM7XG4gICAgICAgIGNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICBjb250YWluZXIuX2xlZnQgPSBjb250YWluZXIuX3RvcCA9IDA7XG4gICAgICAgIGlzRmxvYXRpbmcgJiYgKGNvbnRhaW5lci5yZW5kZXJmaXggPSBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgIGNvbnRhaW5lci5yZW5kZXJmaXgoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5zZXRWaWV3Qm94ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIGZpdCkge1xuICAgICAgICBldmUoXCJyYXBoYWVsLnNldFZpZXdCb3hcIiwgdGhpcywgdGhpcy5fdmlld0JveCwgW3gsIHksIHcsIGgsIGZpdF0pO1xuICAgICAgICB2YXIgcGFwZXJTaXplID0gdGhpcy5nZXRTaXplKCksXG4gICAgICAgICAgICBzaXplID0gbW1heCh3IC8gcGFwZXJTaXplLndpZHRoLCBoIC8gcGFwZXJTaXplLmhlaWdodCksXG4gICAgICAgICAgICB0b3AgPSB0aGlzLnRvcCxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gZml0ID8gXCJ4TWlkWU1pZCBtZWV0XCIgOiBcInhNaW5ZTWluXCIsXG4gICAgICAgICAgICB2YixcbiAgICAgICAgICAgIHN3O1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmJTaXplKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmJTaXplO1xuICAgICAgICAgICAgdmIgPSBcIjAgMCBcIiArIHRoaXMud2lkdGggKyBTICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YlNpemUgPSBzaXplO1xuICAgICAgICAgICAgdmIgPSB4ICsgUyArIHkgKyBTICsgdyArIFMgKyBoO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgIHZpZXdCb3g6IHZiLFxuICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogYXNwZWN0UmF0aW9cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChzaXplICYmIHRvcCkge1xuICAgICAgICAgICAgc3cgPSBcInN0cm9rZS13aWR0aFwiIGluIHRvcC5hdHRycyA/IHRvcC5hdHRyc1tcInN0cm9rZS13aWR0aFwiXSA6IDE7XG4gICAgICAgICAgICB0b3AuYXR0cih7XCJzdHJva2Utd2lkdGhcIjogc3d9KTtcbiAgICAgICAgICAgIHRvcC5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgIHRvcC5fLmRpcnR5VCA9IDE7XG4gICAgICAgICAgICB0b3AgPSB0b3AucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3Qm94ID0gW3gsIHksIHcsIGgsICEhZml0XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmVuZGVyZml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBGaXhlcyB0aGUgaXNzdWUgb2YgRmlyZWZveCBhbmQgSUU5IHJlZ2FyZGluZyBzdWJwaXhlbCByZW5kZXJpbmcuIElmIHBhcGVyIGlzIGRlcGVuZGVudFxuICAgICAqIG9uIG90aGVyIGVsZW1lbnRzIGFmdGVyIHJlZmxvdyBpdCBjb3VsZCBzaGlmdCBoYWxmIHBpeGVsIHdoaWNoIGNhdXNlIGZvciBsaW5lcyB0byBsb3N0IHRoZWlyIGNyaXNwbmVzcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBmaXhlcyB0aGUgaXNzdWUuXG4gICAgICoqXG4gICAgICAgU3BlY2lhbCB0aGFua3MgdG8gTWFyaXVzeiBOb3dhayAoaHR0cDovL3d3dy5tZWRpa29vLmNvbS8pIGZvciB0aGlzIG1ldGhvZC5cbiAgICBcXCovXG4gICAgUi5wcm90b3R5cGUucmVuZGVyZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY252cyA9IHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgcyA9IGNudnMuc3R5bGUsXG4gICAgICAgICAgICBwb3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwb3MgPSBjbnZzLmdldFNjcmVlbkNUTSgpIHx8IGNudnMuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHBvcyA9IGNudnMuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSAtcG9zLmUgJSAxLFxuICAgICAgICAgICAgdG9wID0gLXBvcy5mICUgMTtcbiAgICAgICAgaWYgKGxlZnQgfHwgdG9wKSB7XG4gICAgICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSAodGhpcy5fbGVmdCArIGxlZnQpICUgMTtcbiAgICAgICAgICAgICAgICBzLmxlZnQgPSB0aGlzLl9sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvcCA9ICh0aGlzLl90b3AgKyB0b3ApICUgMTtcbiAgICAgICAgICAgICAgICBzLnRvcCA9IHRoaXMuX3RvcCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNsZWFyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDbGVhcnMgdGhlIHBhcGVyLCBpLmUuIHJlbW92ZXMgYWxsIHRoZSBlbGVtZW50cy5cbiAgICBcXCovXG4gICAgUi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFIuZXZlKFwicmFwaGFlbC5jbGVhclwiLCB0aGlzKTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgd2hpbGUgKGMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgYy5yZW1vdmVDaGlsZChjLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm90dG9tID0gdGhpcy50b3AgPSBudWxsO1xuICAgICAgICAodGhpcy5kZXNjID0gJChcImRlc2NcIikpLmFwcGVuZENoaWxkKFIuX2cuZG9jLmNyZWF0ZVRleHROb2RlKFwiQ3JlYXRlZCB3aXRoIFJhcGhhXFx4ZWJsIFwiICsgUi52ZXJzaW9uKSk7XG4gICAgICAgIGMuYXBwZW5kQ2hpbGQodGhpcy5kZXNjKTtcbiAgICAgICAgYy5hcHBlbmRDaGlsZCh0aGlzLmRlZnMgPSAkKFwiZGVmc1wiKSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIucmVtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwYXBlciBmcm9tIHRoZSBET00uXG4gICAgXFwqL1xuICAgIFIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXZlKFwicmFwaGFlbC5yZW1vdmVcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHR5cGVvZiB0aGlzW2ldID09IFwiZnVuY3Rpb25cIiA/IFIuX3JlbW92ZWRGYWN0b3J5KGkpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNldHByb3RvID0gUi5zdDtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gZWxwcm90bykgaWYgKGVscHJvdG9baGFzXShtZXRob2QpICYmICFzZXRwcm90b1toYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgc2V0cHJvdG9bbWV0aG9kXSA9IChmdW5jdGlvbiAobWV0aG9kbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsW21ldGhvZG5hbWVdLmFwcGx5KGVsLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobWV0aG9kKTtcbiAgICB9XG59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vZGV2L3JhcGhhZWwudm1sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vZGV2L3JhcGhhZWwudm1sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYXBoYWVsLmNvcmUgKi8gXCIuL2Rldi9yYXBoYWVsLmNvcmUuanNcIildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihSKSB7XG4gICAgaWYgKFIgJiYgIVIudm1sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgcm91bmQgPSBtYXRoLnJvdW5kLFxuICAgICAgICBtbWF4ID0gbWF0aC5tYXgsXG4gICAgICAgIG1taW4gPSBtYXRoLm1pbixcbiAgICAgICAgYWJzID0gbWF0aC5hYnMsXG4gICAgICAgIGZpbGxTdHJpbmcgPSBcImZpbGxcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1ssIF0rLyxcbiAgICAgICAgZXZlID0gUi5ldmUsXG4gICAgICAgIG1zID0gXCIgcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0XCIsXG4gICAgICAgIFMgPSBcIiBcIixcbiAgICAgICAgRSA9IFwiXCIsXG4gICAgICAgIG1hcCA9IHtNOiBcIm1cIiwgTDogXCJsXCIsIEM6IFwiY1wiLCBaOiBcInhcIiwgbTogXCJ0XCIsIGw6IFwiclwiLCBjOiBcInZcIiwgejogXCJ4XCJ9LFxuICAgICAgICBiaXRlcyA9IC8oW2NsbXpdKSw/KFteY2xtel0qKS9naSxcbiAgICAgICAgYmx1cnJlZ2V4cCA9IC8gcHJvZ2lkOlxcUytCbHVyXFwoW15cXCldK1xcKS9nLFxuICAgICAgICB2YWwgPSAvLT9bXixcXHMtXSsvZyxcbiAgICAgICAgY3NzRG90ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTClcIixcbiAgICAgICAgem9vbSA9IDIxNjAwLFxuICAgICAgICBwYXRoVHlwZXMgPSB7cGF0aDogMSwgcmVjdDogMSwgaW1hZ2U6IDF9LFxuICAgICAgICBvdmFsVHlwZXMgPSB7Y2lyY2xlOiAxLCBlbGxpcHNlOiAxfSxcbiAgICAgICAgcGF0aDJ2bWwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gIC9bYWhxc3R2XS9pZyxcbiAgICAgICAgICAgICAgICBjb21tYW5kID0gUi5fcGF0aFRvQWJzb2x1dGU7XG4gICAgICAgICAgICBTdHIocGF0aCkubWF0Y2godG90YWwpICYmIChjb21tYW5kID0gUi5fcGF0aDJjdXJ2ZSk7XG4gICAgICAgICAgICB0b3RhbCA9IC9bY2xtel0vZztcbiAgICAgICAgICAgIGlmIChjb21tYW5kID09IFIuX3BhdGhUb0Fic29sdXRlICYmICFTdHIocGF0aCkubWF0Y2godG90YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFN0cihwYXRoKS5yZXBsYWNlKGJpdGVzLCBmdW5jdGlvbiAoYWxsLCBjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vdmUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCkgPT0gXCJtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBtYXBbY29tbWFuZF07XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucmVwbGFjZSh2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW92ZSAmJiB2YWxzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IHZhbHMgKyBtYXBbY29tbWFuZCA9PSBcIm1cIiA/IFwibFwiIDogXCJMXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMucHVzaChyb3VuZCh2YWx1ZSAqIHpvb20pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMgKyB2YWxzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGEgPSBjb21tYW5kKHBhdGgpLCBwLCByO1xuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhW2ldO1xuICAgICAgICAgICAgICAgIHIgPSBwYVtpXVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHIgPT0gXCJ6XCIgJiYgKHIgPSBcInhcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDEsIGpqID0gcC5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgKz0gcm91bmQocFtqXSAqIHpvb20pICsgKGogIT0gamogLSAxID8gXCIsXCIgOiBFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpvaW4oUyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBlbnNhdGlvbiA9IGZ1bmN0aW9uIChkZWcsIGR4LCBkeSkge1xuICAgICAgICAgICAgdmFyIG0gPSBSLm1hdHJpeCgpO1xuICAgICAgICAgICAgbS5yb3RhdGUoLWRlZywgLjUsIC41KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHg6IG0ueChkeCwgZHkpLFxuICAgICAgICAgICAgICAgIGR5OiBtLnkoZHgsIGR5KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29vcmRzID0gZnVuY3Rpb24gKHAsIHN4LCBzeSwgZHgsIGR5LCBkZWcpIHtcbiAgICAgICAgICAgIHZhciBfID0gcC5fLFxuICAgICAgICAgICAgICAgIG0gPSBwLm1hdHJpeCxcbiAgICAgICAgICAgICAgICBmaWxscG9zID0gXy5maWxscG9zLFxuICAgICAgICAgICAgICAgIG8gPSBwLm5vZGUsXG4gICAgICAgICAgICAgICAgcyA9IG8uc3R5bGUsXG4gICAgICAgICAgICAgICAgeSA9IDEsXG4gICAgICAgICAgICAgICAgZmxpcCA9IFwiXCIsXG4gICAgICAgICAgICAgICAgZHhkeSxcbiAgICAgICAgICAgICAgICBreCA9IHpvb20gLyBzeCxcbiAgICAgICAgICAgICAgICBreSA9IHpvb20gLyBzeTtcbiAgICAgICAgICAgIHMudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAoIXN4IHx8ICFzeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8uY29vcmRzaXplID0gYWJzKGt4KSArIFMgKyBhYnMoa3kpO1xuICAgICAgICAgICAgcy5yb3RhdGlvbiA9IGRlZyAqIChzeCAqIHN5IDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBpZiAoZGVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjb21wZW5zYXRpb24oZGVnLCBkeCwgZHkpO1xuICAgICAgICAgICAgICAgIGR4ID0gYy5keDtcbiAgICAgICAgICAgICAgICBkeSA9IGMuZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeCA8IDAgJiYgKGZsaXAgKz0gXCJ4XCIpO1xuICAgICAgICAgICAgc3kgPCAwICYmIChmbGlwICs9IFwiIHlcIikgJiYgKHkgPSAtMSk7XG4gICAgICAgICAgICBzLmZsaXAgPSBmbGlwO1xuICAgICAgICAgICAgby5jb29yZG9yaWdpbiA9IChkeCAqIC1reCkgKyBTICsgKGR5ICogLWt5KTtcbiAgICAgICAgICAgIGlmIChmaWxscG9zIHx8IF8uZmlsbHNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsbCA9IG8uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZmlsbFN0cmluZyk7XG4gICAgICAgICAgICAgICAgZmlsbCA9IGZpbGwgJiYgZmlsbFswXTtcbiAgICAgICAgICAgICAgICBvLnJlbW92ZUNoaWxkKGZpbGwpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxscG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjb21wZW5zYXRpb24oZGVnLCBtLngoZmlsbHBvc1swXSwgZmlsbHBvc1sxXSksIG0ueShmaWxscG9zWzBdLCBmaWxscG9zWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwucG9zaXRpb24gPSBjLmR4ICogeSArIFMgKyBjLmR5ICogeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uZmlsbHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5zaXplID0gXy5maWxsc2l6ZVswXSAqIGFicyhzeCkgKyBTICsgXy5maWxsc2l6ZVsxXSAqIGFicyhzeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG8uYXBwZW5kQ2hpbGQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgfTtcbiAgICBSLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIFwiWW91ciBicm93c2VyIGRvZXNuXFx1MjAxOXQgc3VwcG9ydCBTVkcuIEZhbGxpbmcgZG93biB0byBWTUwuXFxuWW91IGFyZSBydW5uaW5nIFJhcGhhXFx4ZWJsIFwiICsgdGhpcy52ZXJzaW9uO1xuICAgIH07XG4gICAgdmFyIGFkZEFycm93ID0gZnVuY3Rpb24gKG8sIHZhbHVlLCBpc0VuZCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gU3RyKHZhbHVlKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLVwiKSxcbiAgICAgICAgICAgIHNlID0gaXNFbmQgPyBcImVuZFwiIDogXCJzdGFydFwiLFxuICAgICAgICAgICAgaSA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlID0gXCJjbGFzc2ljXCIsXG4gICAgICAgICAgICB3ID0gXCJtZWRpdW1cIixcbiAgICAgICAgICAgIGggPSBcIm1lZGl1bVwiO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc2ljXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm92YWxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIndpZGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibmFycm93XCI6IGggPSB2YWx1ZXNbaV07IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3J0XCI6IHcgPSB2YWx1ZXNbaV07IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJva2UgPSBvLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIilbMF07XG4gICAgICAgIHN0cm9rZVtzZSArIFwiYXJyb3dcIl0gPSB0eXBlO1xuICAgICAgICBzdHJva2Vbc2UgKyBcImFycm93bGVuZ3RoXCJdID0gdztcbiAgICAgICAgc3Ryb2tlW3NlICsgXCJhcnJvd3dpZHRoXCJdID0gaDtcbiAgICB9LFxuICAgIHNldEZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAobywgcGFyYW1zKSB7XG4gICAgICAgIC8vIG8ucGFwZXIuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgby5hdHRycyA9IG8uYXR0cnMgfHwge307XG4gICAgICAgIHZhciBub2RlID0gby5ub2RlLFxuICAgICAgICAgICAgYSA9IG8uYXR0cnMsXG4gICAgICAgICAgICBzID0gbm9kZS5zdHlsZSxcbiAgICAgICAgICAgIHh5LFxuICAgICAgICAgICAgbmV3cGF0aCA9IHBhdGhUeXBlc1tvLnR5cGVdICYmIChwYXJhbXMueCAhPSBhLnggfHwgcGFyYW1zLnkgIT0gYS55IHx8IHBhcmFtcy53aWR0aCAhPSBhLndpZHRoIHx8IHBhcmFtcy5oZWlnaHQgIT0gYS5oZWlnaHQgfHwgcGFyYW1zLmN4ICE9IGEuY3ggfHwgcGFyYW1zLmN5ICE9IGEuY3kgfHwgcGFyYW1zLnJ4ICE9IGEucnggfHwgcGFyYW1zLnJ5ICE9IGEucnkgfHwgcGFyYW1zLnIgIT0gYS5yKSxcbiAgICAgICAgICAgIGlzT3ZhbCA9IG92YWxUeXBlc1tvLnR5cGVdICYmIChhLmN4ICE9IHBhcmFtcy5jeCB8fCBhLmN5ICE9IHBhcmFtcy5jeSB8fCBhLnIgIT0gcGFyYW1zLnIgfHwgYS5yeCAhPSBwYXJhbXMucnggfHwgYS5yeSAhPSBwYXJhbXMucnkpLFxuICAgICAgICAgICAgcmVzID0gbztcblxuXG4gICAgICAgIGZvciAodmFyIHBhciBpbiBwYXJhbXMpIGlmIChwYXJhbXNbaGFzXShwYXIpKSB7XG4gICAgICAgICAgICBhW3Bhcl0gPSBwYXJhbXNbcGFyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3cGF0aCkge1xuICAgICAgICAgICAgYS5wYXRoID0gUi5fZ2V0UGF0aFtvLnR5cGVdKG8pO1xuICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaHJlZiAmJiAobm9kZS5ocmVmID0gcGFyYW1zLmhyZWYpO1xuICAgICAgICBwYXJhbXMudGl0bGUgJiYgKG5vZGUudGl0bGUgPSBwYXJhbXMudGl0bGUpO1xuICAgICAgICBwYXJhbXMudGFyZ2V0ICYmIChub2RlLnRhcmdldCA9IHBhcmFtcy50YXJnZXQpO1xuICAgICAgICBwYXJhbXMuY3Vyc29yICYmIChzLmN1cnNvciA9IHBhcmFtcy5jdXJzb3IpO1xuICAgICAgICBcImJsdXJcIiBpbiBwYXJhbXMgJiYgby5ibHVyKHBhcmFtcy5ibHVyKTtcbiAgICAgICAgaWYgKHBhcmFtcy5wYXRoICYmIG8udHlwZSA9PSBcInBhdGhcIiB8fCBuZXdwYXRoKSB7XG4gICAgICAgICAgICBub2RlLnBhdGggPSBwYXRoMnZtbCh+U3RyKGEucGF0aCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiclwiKSA/IFIuX3BhdGhUb0Fic29sdXRlKGEucGF0aCkgOiBhLnBhdGgpO1xuICAgICAgICAgICAgby5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgIGlmIChvLnR5cGUgPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgICAgICAgby5fLmZpbGxwb3MgPSBbYS54LCBhLnldO1xuICAgICAgICAgICAgICAgIG8uXy5maWxsc2l6ZSA9IFthLndpZHRoLCBhLmhlaWdodF07XG4gICAgICAgICAgICAgICAgc2V0Q29vcmRzKG8sIDEsIDEsIDAsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFwidHJhbnNmb3JtXCIgaW4gcGFyYW1zICYmIG8udHJhbnNmb3JtKHBhcmFtcy50cmFuc2Zvcm0pO1xuICAgICAgICBpZiAoaXNPdmFsKSB7XG4gICAgICAgICAgICB2YXIgY3ggPSArYS5jeCxcbiAgICAgICAgICAgICAgICBjeSA9ICthLmN5LFxuICAgICAgICAgICAgICAgIHJ4ID0gK2EucnggfHwgK2EuciB8fCAwLFxuICAgICAgICAgICAgICAgIHJ5ID0gK2EucnkgfHwgK2EuciB8fCAwO1xuICAgICAgICAgICAgbm9kZS5wYXRoID0gUi5mb3JtYXQoXCJhcnswfSx7MX0sezJ9LHszfSx7NH0sezF9LHs0fSx7MX14XCIsIHJvdW5kKChjeCAtIHJ4KSAqIHpvb20pLCByb3VuZCgoY3kgLSByeSkgKiB6b29tKSwgcm91bmQoKGN4ICsgcngpICogem9vbSksIHJvdW5kKChjeSArIHJ5KSAqIHpvb20pLCByb3VuZChjeCAqIHpvb20pKTtcbiAgICAgICAgICAgIG8uXy5kaXJ0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY2xpcC1yZWN0XCIgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFN0cihwYXJhbXNbXCJjbGlwLXJlY3RcIl0pLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICBpZiAocmVjdC5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgICAgIHJlY3RbMl0gPSArcmVjdFsyXSArICgrcmVjdFswXSk7XG4gICAgICAgICAgICAgICAgcmVjdFszXSA9ICtyZWN0WzNdICsgKCtyZWN0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gbm9kZS5jbGlwUmVjdCB8fCBSLl9nLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgICAgICAgICBkc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgICAgICAgICAgICAgZHN0eWxlLmNsaXAgPSBSLmZvcm1hdChcInJlY3QoezF9cHggezJ9cHggezN9cHggezB9cHgpXCIsIHJlY3QpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5jbGlwUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkc3R5bGUubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZS53aWR0aCA9IG8ucGFwZXIud2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGRzdHlsZS5oZWlnaHQgPSBvLnBhcGVyLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkaXYsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xpcFJlY3QgPSBkaXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJhbXNbXCJjbGlwLXJlY3RcIl0pIHtcbiAgICAgICAgICAgICAgICBub2RlLmNsaXBSZWN0ICYmIChub2RlLmNsaXBSZWN0LnN0eWxlLmNsaXAgPSBcImF1dG9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8udGV4dHBhdGgpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0cGF0aFN0eWxlID0gby50ZXh0cGF0aC5zdHlsZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb250ICYmICh0ZXh0cGF0aFN0eWxlLmZvbnQgPSBwYXJhbXMuZm9udCk7XG4gICAgICAgICAgICBwYXJhbXNbXCJmb250LWZhbWlseVwiXSAmJiAodGV4dHBhdGhTdHlsZS5mb250RmFtaWx5ID0gJ1wiJyArIHBhcmFtc1tcImZvbnQtZmFtaWx5XCJdLnNwbGl0KFwiLFwiKVswXS5yZXBsYWNlKC9eWydcIl0rfFsnXCJdKyQvZywgRSkgKyAnXCInKTtcbiAgICAgICAgICAgIHBhcmFtc1tcImZvbnQtc2l6ZVwiXSAmJiAodGV4dHBhdGhTdHlsZS5mb250U2l6ZSA9IHBhcmFtc1tcImZvbnQtc2l6ZVwiXSk7XG4gICAgICAgICAgICBwYXJhbXNbXCJmb250LXdlaWdodFwiXSAmJiAodGV4dHBhdGhTdHlsZS5mb250V2VpZ2h0ID0gcGFyYW1zW1wiZm9udC13ZWlnaHRcIl0pO1xuICAgICAgICAgICAgcGFyYW1zW1wiZm9udC1zdHlsZVwiXSAmJiAodGV4dHBhdGhTdHlsZS5mb250U3R5bGUgPSBwYXJhbXNbXCJmb250LXN0eWxlXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJhcnJvdy1zdGFydFwiIGluIHBhcmFtcykge1xuICAgICAgICAgICAgYWRkQXJyb3cocmVzLCBwYXJhbXNbXCJhcnJvdy1zdGFydFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiYXJyb3ctZW5kXCIgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBhZGRBcnJvdyhyZXMsIHBhcmFtc1tcImFycm93LWVuZFwiXSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5vcGFjaXR5ICE9IG51bGwgfHxcbiAgICAgICAgICAgIHBhcmFtcy5maWxsICE9IG51bGwgfHxcbiAgICAgICAgICAgIHBhcmFtcy5zcmMgIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zLnN0cm9rZSAhPSBudWxsIHx8XG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2Utd2lkdGhcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLW9wYWNpdHlcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wiZmlsbC1vcGFjaXR5XCJdICE9IG51bGwgfHxcbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1kYXNoYXJyYXlcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLW1pdGVybGltaXRcIl0gIT0gbnVsbCB8fFxuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLWxpbmVqb2luXCJdICE9IG51bGwgfHxcbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1saW5lY2FwXCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShmaWxsU3RyaW5nKSxcbiAgICAgICAgICAgICAgICBuZXdmaWxsID0gZmFsc2U7XG4gICAgICAgICAgICBmaWxsID0gZmlsbCAmJiBmaWxsWzBdO1xuICAgICAgICAgICAgIWZpbGwgJiYgKG5ld2ZpbGwgPSBmaWxsID0gY3JlYXRlTm9kZShmaWxsU3RyaW5nKSk7XG4gICAgICAgICAgICBpZiAoby50eXBlID09IFwiaW1hZ2VcIiAmJiBwYXJhbXMuc3JjKSB7XG4gICAgICAgICAgICAgICAgZmlsbC5zcmMgPSBwYXJhbXMuc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLmZpbGwgJiYgKGZpbGwub24gPSB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmaWxsLm9uID09IG51bGwgfHwgcGFyYW1zLmZpbGwgPT0gXCJub25lXCIgfHwgcGFyYW1zLmZpbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWxsLm9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsbC5vbiAmJiBwYXJhbXMuZmlsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1VSTCA9IFN0cihwYXJhbXMuZmlsbCkubWF0Y2goUi5fSVNVUkwpO1xuICAgICAgICAgICAgICAgIGlmIChpc1VSTCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnBhcmVudE5vZGUgPT0gbm9kZSAmJiBub2RlLnJlbW92ZUNoaWxkKGZpbGwpO1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnJvdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwuc3JjID0gaXNVUkxbMV07XG4gICAgICAgICAgICAgICAgICAgIGZpbGwudHlwZSA9IFwidGlsZVwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmJveCA9IG8uZ2V0QkJveCgxKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5wb3NpdGlvbiA9IGJib3gueCArIFMgKyBiYm94Lnk7XG4gICAgICAgICAgICAgICAgICAgIG8uXy5maWxscG9zID0gW2Jib3gueCwgYmJveC55XTtcblxuICAgICAgICAgICAgICAgICAgICBSLl9wcmVsb2FkKGlzVVJMWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLl8uZmlsbHNpemUgPSBbdGhpcy5vZmZzZXRXaWR0aCwgdGhpcy5vZmZzZXRIZWlnaHRdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWxsLmNvbG9yID0gUi5nZXRSR0IocGFyYW1zLmZpbGwpLmhleDtcbiAgICAgICAgICAgICAgICAgICAgZmlsbC5zcmMgPSBFO1xuICAgICAgICAgICAgICAgICAgICBmaWxsLnR5cGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSLmdldFJHQihwYXJhbXMuZmlsbCkuZXJyb3IgJiYgKHJlcy50eXBlIGluIHtjaXJjbGU6IDEsIGVsbGlwc2U6IDF9IHx8IFN0cihwYXJhbXMuZmlsbCkuY2hhckF0KCkgIT0gXCJyXCIpICYmIGFkZEdyYWRpZW50RmlsbChyZXMsIHBhcmFtcy5maWxsLCBmaWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5maWxsID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmdyYWRpZW50ID0gcGFyYW1zLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsLnJvdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiZmlsbC1vcGFjaXR5XCIgaW4gcGFyYW1zIHx8IFwib3BhY2l0eVwiIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gKCgrYVtcImZpbGwtb3BhY2l0eVwiXSArIDEgfHwgMikgLSAxKSAqICgoK2Eub3BhY2l0eSArIDEgfHwgMikgLSAxKSAqICgoK1IuZ2V0UkdCKHBhcmFtcy5maWxsKS5vICsgMSB8fCAyKSAtIDEpO1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBtbWluKG1tYXgob3BhY2l0eSwgMCksIDEpO1xuICAgICAgICAgICAgICAgIGZpbGwub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGwuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwuY29sb3IgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGZpbGwpO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IChub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3Ryb2tlXCIpICYmIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIilbMF0pLFxuICAgICAgICAgICAgbmV3c3Ryb2tlID0gZmFsc2U7XG4gICAgICAgICAgICAhc3Ryb2tlICYmIChuZXdzdHJva2UgPSBzdHJva2UgPSBjcmVhdGVOb2RlKFwic3Ryb2tlXCIpKTtcbiAgICAgICAgICAgIGlmICgocGFyYW1zLnN0cm9rZSAmJiBwYXJhbXMuc3Ryb2tlICE9IFwibm9uZVwiKSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS13aWR0aFwiXSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1vcGFjaXR5XCJdICE9IG51bGwgfHxcbiAgICAgICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtZGFzaGFycmF5XCJdIHx8XG4gICAgICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLW1pdGVybGltaXRcIl0gfHxcbiAgICAgICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbGluZWpvaW5cIl0gfHxcbiAgICAgICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbGluZWNhcFwiXSkge1xuICAgICAgICAgICAgICAgIHN0cm9rZS5vbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAocGFyYW1zLnN0cm9rZSA9PSBcIm5vbmVcIiB8fCBwYXJhbXMuc3Ryb2tlID09PSBudWxsIHx8IHN0cm9rZS5vbiA9PSBudWxsIHx8IHBhcmFtcy5zdHJva2UgPT0gMCB8fCBwYXJhbXNbXCJzdHJva2Utd2lkdGhcIl0gPT0gMCkgJiYgKHN0cm9rZS5vbiA9IGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBzdHJva2VDb2xvciA9IFIuZ2V0UkdCKHBhcmFtcy5zdHJva2UpO1xuICAgICAgICAgICAgc3Ryb2tlLm9uICYmIHBhcmFtcy5zdHJva2UgJiYgKHN0cm9rZS5jb2xvciA9IHN0cm9rZUNvbG9yLmhleCk7XG4gICAgICAgICAgICBvcGFjaXR5ID0gKCgrYVtcInN0cm9rZS1vcGFjaXR5XCJdICsgMSB8fCAyKSAtIDEpICogKCgrYS5vcGFjaXR5ICsgMSB8fCAyKSAtIDEpICogKCgrc3Ryb2tlQ29sb3IubyArIDEgfHwgMikgLSAxKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9ICh0b0Zsb2F0KHBhcmFtc1tcInN0cm9rZS13aWR0aFwiXSkgfHwgMSkgKiAuNzU7XG4gICAgICAgICAgICBvcGFjaXR5ID0gbW1pbihtbWF4KG9wYWNpdHksIDApLCAxKTtcbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS13aWR0aFwiXSA9PSBudWxsICYmICh3aWR0aCA9IGFbXCJzdHJva2Utd2lkdGhcIl0pO1xuICAgICAgICAgICAgcGFyYW1zW1wic3Ryb2tlLXdpZHRoXCJdICYmIChzdHJva2Uud2VpZ2h0ID0gd2lkdGgpO1xuICAgICAgICAgICAgd2lkdGggJiYgd2lkdGggPCAxICYmIChvcGFjaXR5ICo9IHdpZHRoKSAmJiAoc3Ryb2tlLndlaWdodCA9IDEpO1xuICAgICAgICAgICAgc3Ryb2tlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgICAgICAgICBwYXJhbXNbXCJzdHJva2UtbGluZWpvaW5cIl0gJiYgKHN0cm9rZS5qb2luc3R5bGUgPSBwYXJhbXNbXCJzdHJva2UtbGluZWpvaW5cIl0gfHwgXCJtaXRlclwiKTtcbiAgICAgICAgICAgIHN0cm9rZS5taXRlcmxpbWl0ID0gcGFyYW1zW1wic3Ryb2tlLW1pdGVybGltaXRcIl0gfHwgODtcbiAgICAgICAgICAgIHBhcmFtc1tcInN0cm9rZS1saW5lY2FwXCJdICYmIChzdHJva2UuZW5kY2FwID0gcGFyYW1zW1wic3Ryb2tlLWxpbmVjYXBcIl0gPT0gXCJidXR0XCIgPyBcImZsYXRcIiA6IHBhcmFtc1tcInN0cm9rZS1saW5lY2FwXCJdID09IFwic3F1YXJlXCIgPyBcInNxdWFyZVwiIDogXCJyb3VuZFwiKTtcbiAgICAgICAgICAgIGlmIChcInN0cm9rZS1kYXNoYXJyYXlcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGFzaGFycmF5ID0ge1xuICAgICAgICAgICAgICAgICAgICBcIi1cIjogXCJzaG9ydGRhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgXCIuXCI6IFwic2hvcnRkb3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCItLlwiOiBcInNob3J0ZGFzaGRvdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0uLlwiOiBcInNob3J0ZGFzaGRvdGRvdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi4gXCI6IFwiZG90XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLSBcIjogXCJkYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLS1cIjogXCJsb25nZGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0gLlwiOiBcImRhc2hkb3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCItLS5cIjogXCJsb25nZGFzaGRvdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0tLi5cIjogXCJsb25nZGFzaGRvdGRvdFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdHJva2UuZGFzaHN0eWxlID0gZGFzaGFycmF5W2hhc10ocGFyYW1zW1wic3Ryb2tlLWRhc2hhcnJheVwiXSkgPyBkYXNoYXJyYXlbcGFyYW1zW1wic3Ryb2tlLWRhc2hhcnJheVwiXV0gOiBFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3c3Ryb2tlICYmIG5vZGUuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJlcy5wYXBlci5jYW52YXMuc3R5bGUuZGlzcGxheSA9IEU7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHJlcy5wYXBlci5zcGFuLFxuICAgICAgICAgICAgICAgIG0gPSAxMDAsXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBhLmZvbnQgJiYgYS5mb250Lm1hdGNoKC9cXGQrKD86XFwuXFxkKik/KD89cHgpLyk7XG4gICAgICAgICAgICBzID0gc3Bhbi5zdHlsZTtcbiAgICAgICAgICAgIGEuZm9udCAmJiAocy5mb250ID0gYS5mb250KTtcbiAgICAgICAgICAgIGFbXCJmb250LWZhbWlseVwiXSAmJiAocy5mb250RmFtaWx5ID0gYVtcImZvbnQtZmFtaWx5XCJdKTtcbiAgICAgICAgICAgIGFbXCJmb250LXdlaWdodFwiXSAmJiAocy5mb250V2VpZ2h0ID0gYVtcImZvbnQtd2VpZ2h0XCJdKTtcbiAgICAgICAgICAgIGFbXCJmb250LXN0eWxlXCJdICYmIChzLmZvbnRTdHlsZSA9IGFbXCJmb250LXN0eWxlXCJdKTtcbiAgICAgICAgICAgIGZvbnRTaXplID0gdG9GbG9hdChhW1wiZm9udC1zaXplXCJdIHx8IGZvbnRTaXplICYmIGZvbnRTaXplWzBdKSB8fCAxMDtcbiAgICAgICAgICAgIHMuZm9udFNpemUgPSBmb250U2l6ZSAqIG0gKyBcInB4XCI7XG4gICAgICAgICAgICByZXMudGV4dHBhdGguc3RyaW5nICYmIChzcGFuLmlubmVySFRNTCA9IFN0cihyZXMudGV4dHBhdGguc3RyaW5nKS5yZXBsYWNlKC88L2csIFwiJiM2MDtcIikucmVwbGFjZSgvJi9nLCBcIiYjMzg7XCIpLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikpO1xuICAgICAgICAgICAgdmFyIGJyZWN0ID0gc3Bhbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJlcy5XID0gYS53ID0gKGJyZWN0LnJpZ2h0IC0gYnJlY3QubGVmdCkgLyBtO1xuICAgICAgICAgICAgcmVzLkggPSBhLmggPSAoYnJlY3QuYm90dG9tIC0gYnJlY3QudG9wKSAvIG07XG4gICAgICAgICAgICAvLyByZXMucGFwZXIuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJlcy5YID0gYS54O1xuICAgICAgICAgICAgcmVzLlkgPSBhLnkgKyByZXMuSCAvIDI7XG5cbiAgICAgICAgICAgIChcInhcIiBpbiBwYXJhbXMgfHwgXCJ5XCIgaW4gcGFyYW1zKSAmJiAocmVzLnBhdGgudiA9IFIuZm9ybWF0KFwibXswfSx7MX1sezJ9LHsxfVwiLCByb3VuZChhLnggKiB6b29tKSwgcm91bmQoYS55ICogem9vbSksIHJvdW5kKGEueCAqIHpvb20pICsgMSkpO1xuICAgICAgICAgICAgdmFyIGRpcnR5YXR0cnMgPSBbXCJ4XCIsIFwieVwiLCBcInRleHRcIiwgXCJmb250XCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXdlaWdodFwiLCBcImZvbnQtc3R5bGVcIiwgXCJmb250LXNpemVcIl07XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMCwgZGQgPSBkaXJ0eWF0dHJzLmxlbmd0aDsgZCA8IGRkOyBkKyspIGlmIChkaXJ0eWF0dHJzW2RdIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJlcy5fLmRpcnR5ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGV4dC1hbmNob3IgZW11bGF0aW9uXG4gICAgICAgICAgICBzd2l0Y2ggKGFbXCJ0ZXh0LWFuY2hvclwiXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICByZXMudGV4dHBhdGguc3R5bGVbXCJ2LXRleHQtYWxpZ25cIl0gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmJieCA9IHJlcy5XIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlcy50ZXh0cGF0aC5zdHlsZVtcInYtdGV4dC1hbGlnblwiXSA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmJieCA9IC1yZXMuVyAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzLnRleHRwYXRoLnN0eWxlW1widi10ZXh0LWFsaWduXCJdID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmJieCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMudGV4dHBhdGguc3R5bGVbXCJ2LXRleHQta2VyblwiXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzLnBhcGVyLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gRTtcbiAgICB9LFxuICAgIGFkZEdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uIChvLCBncmFkaWVudCwgZmlsbCkge1xuICAgICAgICBvLmF0dHJzID0gby5hdHRycyB8fCB7fTtcbiAgICAgICAgdmFyIGF0dHJzID0gby5hdHRycyxcbiAgICAgICAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgIG9pbmRleCxcbiAgICAgICAgICAgIHR5cGUgPSBcImxpbmVhclwiLFxuICAgICAgICAgICAgZnhmeSA9IFwiLjUgLjVcIjtcbiAgICAgICAgby5hdHRycy5ncmFkaWVudCA9IGdyYWRpZW50O1xuICAgICAgICBncmFkaWVudCA9IFN0cihncmFkaWVudCkucmVwbGFjZShSLl9yYWRpYWxfZ3JhZGllbnQsIGZ1bmN0aW9uIChhbGwsIGZ4LCBmeSkge1xuICAgICAgICAgICAgdHlwZSA9IFwicmFkaWFsXCI7XG4gICAgICAgICAgICBpZiAoZnggJiYgZnkpIHtcbiAgICAgICAgICAgICAgICBmeCA9IHRvRmxvYXQoZngpO1xuICAgICAgICAgICAgICAgIGZ5ID0gdG9GbG9hdChmeSk7XG4gICAgICAgICAgICAgICAgcG93KGZ4IC0gLjUsIDIpICsgcG93KGZ5IC0gLjUsIDIpID4gLjI1ICYmIChmeSA9IG1hdGguc3FydCguMjUgLSBwb3coZnggLSAuNSwgMikpICogKChmeSA+IC41KSAqIDIgLSAxKSArIC41KTtcbiAgICAgICAgICAgICAgICBmeGZ5ID0gZnggKyBTICsgZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQuc3BsaXQoL1xccypcXC1cXHMqLyk7XG4gICAgICAgIGlmICh0eXBlID09IFwibGluZWFyXCIpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGdyYWRpZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICBhbmdsZSA9IC10b0Zsb2F0KGFuZ2xlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZG90cyA9IFIuX3BhcnNlRG90cyhncmFkaWVudCk7XG4gICAgICAgIGlmICghZG90cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbyA9IG8uc2hhcGUgfHwgby5ub2RlO1xuICAgICAgICBpZiAoZG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG8ucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gICAgICAgICAgICBmaWxsLm9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpbGwubWV0aG9kID0gXCJub25lXCI7XG4gICAgICAgICAgICBmaWxsLmNvbG9yID0gZG90c1swXS5jb2xvcjtcbiAgICAgICAgICAgIGZpbGwuY29sb3IyID0gZG90c1tkb3RzLmxlbmd0aCAtIDFdLmNvbG9yO1xuICAgICAgICAgICAgdmFyIGNscnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGRvdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGRvdHNbaV0ub2Zmc2V0ICYmIGNscnMucHVzaChkb3RzW2ldLm9mZnNldCArIFMgKyBkb3RzW2ldLmNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGwuY29sb3JzID0gY2xycy5sZW5ndGggPyBjbHJzLmpvaW4oKSA6IFwiMCUgXCIgKyBmaWxsLmNvbG9yO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJyYWRpYWxcIikge1xuICAgICAgICAgICAgICAgIGZpbGwudHlwZSA9IFwiZ3JhZGllbnRUaXRsZVwiO1xuICAgICAgICAgICAgICAgIGZpbGwuZm9jdXMgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgICAgICBmaWxsLmZvY3Vzc2l6ZSA9IFwiMCAwXCI7XG4gICAgICAgICAgICAgICAgZmlsbC5mb2N1c3Bvc2l0aW9uID0gZnhmeTtcbiAgICAgICAgICAgICAgICBmaWxsLmFuZ2xlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsbC5yb3RhdGU9IHRydWU7XG4gICAgICAgICAgICAgICAgZmlsbC50eXBlID0gXCJncmFkaWVudFwiO1xuICAgICAgICAgICAgICAgIGZpbGwuYW5nbGUgPSAoMjcwIC0gYW5nbGUpICUgMzYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5hcHBlbmRDaGlsZChmaWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgdm1sKSB7XG4gICAgICAgIHRoaXNbMF0gPSB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICBub2RlLnJhcGhhZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmlkID0gUi5fb2lkKys7XG4gICAgICAgIG5vZGUucmFwaGFlbGlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5YID0gMDtcbiAgICAgICAgdGhpcy5ZID0gMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICB0aGlzLnBhcGVyID0gdm1sO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFIubWF0cml4KCk7XG4gICAgICAgIHRoaXMuXyA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogW10sXG4gICAgICAgICAgICBzeDogMSxcbiAgICAgICAgICAgIHN5OiAxLFxuICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICBkeTogMCxcbiAgICAgICAgICAgIGRlZzogMCxcbiAgICAgICAgICAgIGRpcnR5OiAxLFxuICAgICAgICAgICAgZGlydHlUOiAxXG4gICAgICAgIH07XG4gICAgICAgICF2bWwuYm90dG9tICYmICh2bWwuYm90dG9tID0gdGhpcyk7XG4gICAgICAgIHRoaXMucHJldiA9IHZtbC50b3A7XG4gICAgICAgIHZtbC50b3AgJiYgKHZtbC50b3AubmV4dCA9IHRoaXMpO1xuICAgICAgICB2bWwudG9wID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBlbHByb3RvID0gUi5lbDtcblxuICAgIEVsZW1lbnQucHJvdG90eXBlID0gZWxwcm90bztcbiAgICBlbHByb3RvLmNvbnN0cnVjdG9yID0gRWxlbWVudDtcbiAgICBlbHByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0c3RyKSB7XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl8udHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YnMgPSB0aGlzLnBhcGVyLl92aWV3Qm94U2hpZnQsXG4gICAgICAgICAgICB2YnQgPSB2YnMgPyBcInNcIiArIFt2YnMuc2NhbGUsIHZicy5zY2FsZV0gKyBcIi0xLTF0XCIgKyBbdmJzLmR4LCB2YnMuZHldIDogRSxcbiAgICAgICAgICAgIG9sZHQ7XG4gICAgICAgIGlmICh2YnMpIHtcbiAgICAgICAgICAgIG9sZHQgPSB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIHRoaXMuXy50cmFuc2Zvcm0gfHwgRSk7XG4gICAgICAgIH1cbiAgICAgICAgUi5fZXh0cmFjdFRyYW5zZm9ybSh0aGlzLCB2YnQgKyB0c3RyKTtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4LmNsb25lKCksXG4gICAgICAgICAgICBza2V3ID0gdGhpcy5za2V3LFxuICAgICAgICAgICAgbyA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIHNwbGl0LFxuICAgICAgICAgICAgaXNHcmFkID0gflN0cih0aGlzLmF0dHJzLmZpbGwpLmluZGV4T2YoXCItXCIpLFxuICAgICAgICAgICAgaXNQYXR0ID0gIVN0cih0aGlzLmF0dHJzLmZpbGwpLmluZGV4T2YoXCJ1cmwoXCIpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKDEsIDEpO1xuICAgICAgICBpZiAoaXNQYXR0IHx8IGlzR3JhZCB8fCB0aGlzLnR5cGUgPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgICBza2V3Lm1hdHJpeCA9IFwiMSAwIDAgMVwiO1xuICAgICAgICAgICAgc2tldy5vZmZzZXQgPSBcIjAgMFwiO1xuICAgICAgICAgICAgc3BsaXQgPSBtYXRyaXguc3BsaXQoKTtcbiAgICAgICAgICAgIGlmICgoaXNHcmFkICYmIHNwbGl0Lm5vUm90YXRpb24pIHx8ICFzcGxpdC5pc1NpbXBsZSkge1xuICAgICAgICAgICAgICAgIG8uc3R5bGUuZmlsdGVyID0gbWF0cml4LnRvRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgICAgIGJidCA9IHRoaXMuZ2V0QkJveCgxKSxcbiAgICAgICAgICAgICAgICAgICAgZHggPSBiYi54IC0gYmJ0LngsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gYmIueSAtIGJidC55O1xuICAgICAgICAgICAgICAgIG8uY29vcmRvcmlnaW4gPSAoZHggKiAtem9vbSkgKyBTICsgKGR5ICogLXpvb20pO1xuICAgICAgICAgICAgICAgIHNldENvb3Jkcyh0aGlzLCAxLCAxLCBkeCwgZHksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvLnN0eWxlLmZpbHRlciA9IEU7XG4gICAgICAgICAgICAgICAgc2V0Q29vcmRzKHRoaXMsIHNwbGl0LnNjYWxleCwgc3BsaXQuc2NhbGV5LCBzcGxpdC5keCwgc3BsaXQuZHksIHNwbGl0LnJvdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLnN0eWxlLmZpbHRlciA9IEU7XG4gICAgICAgICAgICBza2V3Lm1hdHJpeCA9IFN0cihtYXRyaXgpO1xuICAgICAgICAgICAgc2tldy5vZmZzZXQgPSBtYXRyaXgub2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZHQgIT09IG51bGwpIHsgLy8gZW1wdHkgc3RyaW5nIHZhbHVlIGlzIHRydWUgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5fLnRyYW5zZm9ybSA9IG9sZHQ7XG4gICAgICAgICAgICBSLl9leHRyYWN0VHJhbnNmb3JtKHRoaXMsIG9sZHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZWxwcm90by5yb3RhdGUgPSBmdW5jdGlvbiAoZGVnLCBjeCwgY3kpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVnID0gU3RyKGRlZykuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGRlZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjeCA9IHRvRmxvYXQoZGVnWzFdKTtcbiAgICAgICAgICAgIGN5ID0gdG9GbG9hdChkZWdbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZyA9IHRvRmxvYXQoZGVnWzBdKTtcbiAgICAgICAgKGN5ID09IG51bGwpICYmIChjeCA9IGN5KTtcbiAgICAgICAgaWYgKGN4ID09IG51bGwgfHwgY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goMSk7XG4gICAgICAgICAgICBjeCA9IGJib3gueCArIGJib3gud2lkdGggLyAyO1xuICAgICAgICAgICAgY3kgPSBiYm94LnkgKyBiYm94LmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fLmRpcnR5VCA9IDE7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJyXCIsIGRlZywgY3gsIGN5XV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSBTdHIoZHgpLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChkeC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBkeSA9IHRvRmxvYXQoZHhbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0gdG9GbG9hdChkeFswXSkgfHwgMDtcbiAgICAgICAgZHkgPSArZHkgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMuXy5iYm94KSB7XG4gICAgICAgICAgICB0aGlzLl8uYmJveC54ICs9IGR4O1xuICAgICAgICAgICAgdGhpcy5fLmJib3gueSArPSBkeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSh0aGlzLl8udHJhbnNmb3JtLmNvbmNhdChbW1widFwiLCBkeCwgZHldXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoc3gsIHN5LCBjeCwgY3kpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSBTdHIoc3gpLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChzeC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzeSA9IHRvRmxvYXQoc3hbMV0pO1xuICAgICAgICAgICAgY3ggPSB0b0Zsb2F0KHN4WzJdKTtcbiAgICAgICAgICAgIGN5ID0gdG9GbG9hdChzeFszXSk7XG4gICAgICAgICAgICBpc05hTihjeCkgJiYgKGN4ID0gbnVsbCk7XG4gICAgICAgICAgICBpc05hTihjeSkgJiYgKGN5ID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSB0b0Zsb2F0KHN4WzBdKTtcbiAgICAgICAgKHN5ID09IG51bGwpICYmIChzeSA9IHN4KTtcbiAgICAgICAgKGN5ID09IG51bGwpICYmIChjeCA9IGN5KTtcbiAgICAgICAgaWYgKGN4ID09IG51bGwgfHwgY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3ggPSBjeCA9PSBudWxsID8gYmJveC54ICsgYmJveC53aWR0aCAvIDIgOiBjeDtcbiAgICAgICAgY3kgPSBjeSA9PSBudWxsID8gYmJveC55ICsgYmJveC5oZWlnaHQgLyAyIDogY3k7XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odGhpcy5fLnRyYW5zZm9ybS5jb25jYXQoW1tcInNcIiwgc3gsIHN5LCBjeCwgY3ldXSkpO1xuICAgICAgICB0aGlzLl8uZGlydHlUID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICF0aGlzLnJlbW92ZWQgJiYgKHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGVscHJvdG8uc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIXRoaXMucmVtb3ZlZCAmJiAodGhpcy5ub2RlLnN0eWxlLmRpc3BsYXkgPSBFKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBOZWVkZWQgdG8gZml4IHRoZSB2bWwgc2V0Vmlld0JveCBpc3N1ZXNcbiAgICBlbHByb3RvLmF1eEdldEJCb3ggPSBSLmVsLmdldEJCb3g7XG4gICAgZWxwcm90by5nZXRCQm94ID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBiID0gdGhpcy5hdXhHZXRCQm94KCk7XG4gICAgICBpZiAodGhpcy5wYXBlciAmJiB0aGlzLnBhcGVyLl92aWV3Qm94U2hpZnQpXG4gICAgICB7XG4gICAgICAgIHZhciBjID0ge307XG4gICAgICAgIHZhciB6ID0gMS90aGlzLnBhcGVyLl92aWV3Qm94U2hpZnQuc2NhbGU7XG4gICAgICAgIGMueCA9IGIueCAtIHRoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdC5keDtcbiAgICAgICAgYy54ICo9IHo7XG4gICAgICAgIGMueSA9IGIueSAtIHRoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdC5keTtcbiAgICAgICAgYy55ICo9IHo7XG4gICAgICAgIGMud2lkdGggID0gYi53aWR0aCAgKiB6O1xuICAgICAgICBjLmhlaWdodCA9IGIuaGVpZ2h0ICogejtcbiAgICAgICAgYy54MiA9IGMueCArIGMud2lkdGg7XG4gICAgICAgIGMueTIgPSBjLnkgKyBjLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gYjtcbiAgICB9O1xuICAgIGVscHJvdG8uX2dldEJCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy5YICsgKHRoaXMuYmJ4IHx8IDApIC0gdGhpcy5XIC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMuWSAtIHRoaXMuSCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLlcsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuSFxuICAgICAgICB9O1xuICAgIH07XG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQgfHwgIXRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXBlci5fX3NldF9fICYmIHRoaXMucGFwZXIuX19zZXRfXy5leGNsdWRlKHRoaXMpO1xuICAgICAgICBSLmV2ZS51bmJpbmQoXCJyYXBoYWVsLiouKi5cIiArIHRoaXMuaWQpO1xuICAgICAgICBSLl90ZWFyKHRoaXMsIHRoaXMucGFwZXIpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICB0aGlzLnNoYXBlICYmIHRoaXMuc2hhcGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdHlwZW9mIHRoaXNbaV0gPT0gXCJmdW5jdGlvblwiID8gUi5fcmVtb3ZlZEZhY3RvcnkoaSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgfTtcbiAgICBlbHByb3RvLmF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLmF0dHJzKSBpZiAodGhpcy5hdHRyc1toYXNdKGEpKSB7XG4gICAgICAgICAgICAgICAgcmVzW2FdID0gdGhpcy5hdHRyc1thXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5ncmFkaWVudCAmJiByZXMuZmlsbCA9PSBcIm5vbmVcIiAmJiAocmVzLmZpbGwgPSByZXMuZ3JhZGllbnQpICYmIGRlbGV0ZSByZXMuZ3JhZGllbnQ7XG4gICAgICAgICAgICByZXMudHJhbnNmb3JtID0gdGhpcy5fLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgUi5pcyhuYW1lLCBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gZmlsbFN0cmluZyAmJiB0aGlzLmF0dHJzLmZpbGwgPT0gXCJub25lXCIgJiYgdGhpcy5hdHRycy5ncmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChzZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHRoaXMuYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChSLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tuYW1lXSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbbmFtZV0uZGVmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IFIuX2F2YWlsYWJsZUF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpaSAtIDEgPyBvdXQgOiBvdXRbbmFtZXNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzICYmIHZhbHVlID09IG51bGwgJiYgUi5pcyhuYW1lLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBvdXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W25hbWVbaV1dID0gdGhpcy5hdHRyKG5hbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9PSBudWxsICYmIFIuaXMobmFtZSwgXCJvYmplY3RcIikgJiYgKHBhcmFtcyA9IG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBldmUoXCJyYXBoYWVsLmF0dHIuXCIgKyBrZXkgKyBcIi5cIiArIHRoaXMuaWQsIHRoaXMsIHBhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXMpIGlmICh0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbaGFzXShrZXkpICYmIHBhcmFtc1toYXNdKGtleSkgJiYgUi5pcyh0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNba2V5XSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXIgPSB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNba2V5XS5hcHBseSh0aGlzLCBbXS5jb25jYXQocGFyYW1zW2tleV0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzdWJrZXkgaW4gcGFyKSBpZiAocGFyW2hhc10oc3Via2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc3Via2V5XSA9IHBhcltzdWJrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMucGFwZXIuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudGV4dCAmJiB0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRwYXRoLnN0cmluZyA9IHBhcmFtcy50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RmlsbEFuZFN0cm9rZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy8gdGhpcy5wYXBlci5jYW52YXMuc3R5bGUuZGlzcGxheSA9IEU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLnRvRnJvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICF0aGlzLnJlbW92ZWQgJiYgdGhpcy5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgdGhpcy5wYXBlciAmJiB0aGlzLnBhcGVyLnRvcCAhPSB0aGlzICYmIFIuX3RvZnJvbnQodGhpcywgdGhpcy5wYXBlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZWxwcm90by50b0JhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkICE9IHRoaXMubm9kZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgdGhpcy5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICBSLl90b2JhY2sodGhpcywgdGhpcy5wYXBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuY29uc3RydWN0b3IgPT0gUi5zdC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRbZWxlbWVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5ub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbGVtZW50Lm5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBSLl9pbnNlcnRhZnRlcih0aGlzLCBlbGVtZW50LCB0aGlzLnBhcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmNvbnN0cnVjdG9yID09IFIuc3QuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIGVsZW1lbnQubm9kZSk7XG4gICAgICAgIFIuX2luc2VydGJlZm9yZSh0aGlzLCBlbGVtZW50LCB0aGlzLnBhcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBlbHByb3RvLmJsdXIgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMubm9kZS5ydW50aW1lU3R5bGUsXG4gICAgICAgICAgICBmID0gcy5maWx0ZXI7XG4gICAgICAgIGYgPSBmLnJlcGxhY2UoYmx1cnJlZ2V4cCwgRSk7XG4gICAgICAgIGlmICgrc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hdHRycy5ibHVyID0gc2l6ZTtcbiAgICAgICAgICAgIHMuZmlsdGVyID0gZiArIFMgKyBtcyArIFwiLkJsdXIocGl4ZWxyYWRpdXM9XCIgKyAoK3NpemUgfHwgMS41KSArIFwiKVwiO1xuICAgICAgICAgICAgcy5tYXJnaW4gPSBSLmZvcm1hdChcIi17MH1weCAwIDAgLXswfXB4XCIsIHJvdW5kKCtzaXplIHx8IDEuNSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcy5maWx0ZXIgPSBmO1xuICAgICAgICAgICAgcy5tYXJnaW4gPSAwO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cnMuYmx1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUi5fZW5naW5lLnBhdGggPSBmdW5jdGlvbiAocGF0aFN0cmluZywgdm1sKSB7XG4gICAgICAgIHZhciBlbCA9IGNyZWF0ZU5vZGUoXCJzaGFwZVwiKTtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IGNzc0RvdDtcbiAgICAgICAgZWwuY29vcmRzaXplID0gem9vbSArIFMgKyB6b29tO1xuICAgICAgICBlbC5jb29yZG9yaWdpbiA9IHZtbC5jb29yZG9yaWdpbjtcbiAgICAgICAgdmFyIHAgPSBuZXcgRWxlbWVudChlbCwgdm1sKSxcbiAgICAgICAgICAgIGF0dHIgPSB7ZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwXCJ9O1xuICAgICAgICBwYXRoU3RyaW5nICYmIChhdHRyLnBhdGggPSBwYXRoU3RyaW5nKTtcbiAgICAgICAgcC50eXBlID0gXCJwYXRoXCI7XG4gICAgICAgIHAucGF0aCA9IFtdO1xuICAgICAgICBwLlBhdGggPSBFO1xuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHAsIGF0dHIpO1xuICAgICAgICB2bWwuY2FudmFzICYmIHZtbC5jYW52YXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgc2tldyA9IGNyZWF0ZU5vZGUoXCJza2V3XCIpO1xuICAgICAgICBza2V3Lm9uID0gdHJ1ZTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoc2tldyk7XG4gICAgICAgIHAuc2tldyA9IHNrZXc7XG4gICAgICAgIHAudHJhbnNmb3JtKEUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5yZWN0ID0gZnVuY3Rpb24gKHZtbCwgeCwgeSwgdywgaCwgcikge1xuICAgICAgICB2YXIgcGF0aCA9IFIuX3JlY3RQYXRoKHgsIHksIHcsIGgsIHIpLFxuICAgICAgICAgICAgcmVzID0gdm1sLnBhdGgocGF0aCksXG4gICAgICAgICAgICBhID0gcmVzLmF0dHJzO1xuICAgICAgICByZXMuWCA9IGEueCA9IHg7XG4gICAgICAgIHJlcy5ZID0gYS55ID0geTtcbiAgICAgICAgcmVzLlcgPSBhLndpZHRoID0gdztcbiAgICAgICAgcmVzLkggPSBhLmhlaWdodCA9IGg7XG4gICAgICAgIGEuciA9IHI7XG4gICAgICAgIGEucGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcy50eXBlID0gXCJyZWN0XCI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuZWxsaXBzZSA9IGZ1bmN0aW9uICh2bWwsIHgsIHksIHJ4LCByeSkge1xuICAgICAgICB2YXIgcmVzID0gdm1sLnBhdGgoKSxcbiAgICAgICAgICAgIGEgPSByZXMuYXR0cnM7XG4gICAgICAgIHJlcy5YID0geCAtIHJ4O1xuICAgICAgICByZXMuWSA9IHkgLSByeTtcbiAgICAgICAgcmVzLlcgPSByeCAqIDI7XG4gICAgICAgIHJlcy5IID0gcnkgKiAyO1xuICAgICAgICByZXMudHlwZSA9IFwiZWxsaXBzZVwiO1xuICAgICAgICBzZXRGaWxsQW5kU3Ryb2tlKHJlcywge1xuICAgICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgICBjeTogeSxcbiAgICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICAgIHJ5OiByeVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5jaXJjbGUgPSBmdW5jdGlvbiAodm1sLCB4LCB5LCByKSB7XG4gICAgICAgIHZhciByZXMgPSB2bWwucGF0aCgpLFxuICAgICAgICAgICAgYSA9IHJlcy5hdHRycztcbiAgICAgICAgcmVzLlggPSB4IC0gcjtcbiAgICAgICAgcmVzLlkgPSB5IC0gcjtcbiAgICAgICAgcmVzLlcgPSByZXMuSCA9IHIgKiAyO1xuICAgICAgICByZXMudHlwZSA9IFwiY2lyY2xlXCI7XG4gICAgICAgIHNldEZpbGxBbmRTdHJva2UocmVzLCB7XG4gICAgICAgICAgICBjeDogeCxcbiAgICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgICAgcjogclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS5pbWFnZSA9IGZ1bmN0aW9uICh2bWwsIHNyYywgeCwgeSwgdywgaCkge1xuICAgICAgICB2YXIgcGF0aCA9IFIuX3JlY3RQYXRoKHgsIHksIHcsIGgpLFxuICAgICAgICAgICAgcmVzID0gdm1sLnBhdGgocGF0aCkuYXR0cih7c3Ryb2tlOiBcIm5vbmVcIn0pLFxuICAgICAgICAgICAgYSA9IHJlcy5hdHRycyxcbiAgICAgICAgICAgIG5vZGUgPSByZXMubm9kZSxcbiAgICAgICAgICAgIGZpbGwgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKGZpbGxTdHJpbmcpWzBdO1xuICAgICAgICBhLnNyYyA9IHNyYztcbiAgICAgICAgcmVzLlggPSBhLnggPSB4O1xuICAgICAgICByZXMuWSA9IGEueSA9IHk7XG4gICAgICAgIHJlcy5XID0gYS53aWR0aCA9IHc7XG4gICAgICAgIHJlcy5IID0gYS5oZWlnaHQgPSBoO1xuICAgICAgICBhLnBhdGggPSBwYXRoO1xuICAgICAgICByZXMudHlwZSA9IFwiaW1hZ2VcIjtcbiAgICAgICAgZmlsbC5wYXJlbnROb2RlID09IG5vZGUgJiYgbm9kZS5yZW1vdmVDaGlsZChmaWxsKTtcbiAgICAgICAgZmlsbC5yb3RhdGUgPSB0cnVlO1xuICAgICAgICBmaWxsLnNyYyA9IHNyYztcbiAgICAgICAgZmlsbC50eXBlID0gXCJ0aWxlXCI7XG4gICAgICAgIHJlcy5fLmZpbGxwb3MgPSBbeCwgeV07XG4gICAgICAgIHJlcy5fLmZpbGxzaXplID0gW3csIGhdO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGZpbGwpO1xuICAgICAgICBzZXRDb29yZHMocmVzLCAxLCAxLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFIuX2VuZ2luZS50ZXh0ID0gZnVuY3Rpb24gKHZtbCwgeCwgeSwgdGV4dCkge1xuICAgICAgICB2YXIgZWwgPSBjcmVhdGVOb2RlKFwic2hhcGVcIiksXG4gICAgICAgICAgICBwYXRoID0gY3JlYXRlTm9kZShcInBhdGhcIiksXG4gICAgICAgICAgICBvID0gY3JlYXRlTm9kZShcInRleHRwYXRoXCIpO1xuICAgICAgICB4ID0geCB8fCAwO1xuICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICB0ZXh0ID0gdGV4dCB8fCBcIlwiO1xuICAgICAgICBwYXRoLnYgPSBSLmZvcm1hdChcIm17MH0sezF9bHsyfSx7MX1cIiwgcm91bmQoeCAqIHpvb20pLCByb3VuZCh5ICogem9vbSksIHJvdW5kKHggKiB6b29tKSArIDEpO1xuICAgICAgICBwYXRoLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgICBvLnN0cmluZyA9IFN0cih0ZXh0KTtcbiAgICAgICAgby5vbiA9IHRydWU7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBjc3NEb3Q7XG4gICAgICAgIGVsLmNvb3Jkc2l6ZSA9IHpvb20gKyBTICsgem9vbTtcbiAgICAgICAgZWwuY29vcmRvcmlnaW4gPSBcIjAgMFwiO1xuICAgICAgICB2YXIgcCA9IG5ldyBFbGVtZW50KGVsLCB2bWwpLFxuICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiMwMDBcIixcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIGZvbnQ6IFIuX2F2YWlsYWJsZUF0dHJzLmZvbnQsXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgcC5zaGFwZSA9IGVsO1xuICAgICAgICBwLnBhdGggPSBwYXRoO1xuICAgICAgICBwLnRleHRwYXRoID0gbztcbiAgICAgICAgcC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIHAuYXR0cnMudGV4dCA9IFN0cih0ZXh0KTtcbiAgICAgICAgcC5hdHRycy54ID0geDtcbiAgICAgICAgcC5hdHRycy55ID0geTtcbiAgICAgICAgcC5hdHRycy53ID0gMTtcbiAgICAgICAgcC5hdHRycy5oID0gMTtcbiAgICAgICAgc2V0RmlsbEFuZFN0cm9rZShwLCBhdHRyKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQobyk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICB2bWwuY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgdmFyIHNrZXcgPSBjcmVhdGVOb2RlKFwic2tld1wiKTtcbiAgICAgICAgc2tldy5vbiA9IHRydWU7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHNrZXcpO1xuICAgICAgICBwLnNrZXcgPSBza2V3O1xuICAgICAgICBwLnRyYW5zZm9ybShFKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICBSLl9lbmdpbmUuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjcyA9IHRoaXMuY2FudmFzLnN0eWxlO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9PSArd2lkdGggJiYgKHdpZHRoICs9IFwicHhcIik7XG4gICAgICAgIGhlaWdodCA9PSAraGVpZ2h0ICYmIChoZWlnaHQgKz0gXCJweFwiKTtcbiAgICAgICAgY3Mud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY3MuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjcy5jbGlwID0gXCJyZWN0KDAgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0ICsgXCIgMClcIjtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdCb3gpIHtcbiAgICAgICAgICAgIFIuX2VuZ2luZS5zZXRWaWV3Qm94LmFwcGx5KHRoaXMsIHRoaXMuX3ZpZXdCb3gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUi5fZW5naW5lLnNldFZpZXdCb3ggPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgZml0KSB7XG4gICAgICAgIFIuZXZlKFwicmFwaGFlbC5zZXRWaWV3Qm94XCIsIHRoaXMsIHRoaXMuX3ZpZXdCb3gsIFt4LCB5LCB3LCBoLCBmaXRdKTtcbiAgICAgICAgdmFyIHBhcGVyU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxuICAgICAgICAgICAgd2lkdGggPSBwYXBlclNpemUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBwYXBlclNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgSCwgVztcbiAgICAgICAgaWYgKGZpdCkge1xuICAgICAgICAgICAgSCA9IGhlaWdodCAvIGg7XG4gICAgICAgICAgICBXID0gd2lkdGggLyB3O1xuICAgICAgICAgICAgaWYgKHcgKiBIIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4IC09ICh3aWR0aCAtIHcgKiBIKSAvIDIgLyBIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGggKiBXIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSAtPSAoaGVpZ2h0IC0gaCAqIFcpIC8gMiAvIFc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld0JveCA9IFt4LCB5LCB3LCBoLCAhIWZpdF07XG4gICAgICAgIHRoaXMuX3ZpZXdCb3hTaGlmdCA9IHtcbiAgICAgICAgICAgIGR4OiAteCxcbiAgICAgICAgICAgIGR5OiAteSxcbiAgICAgICAgICAgIHNjYWxlOiBwYXBlclNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwudHJhbnNmb3JtKFwiLi4uXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlTm9kZTtcbiAgICBSLl9lbmdpbmUuaW5pdFdpbiA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoZG9jLnN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKFwiLnJ2bWxcIiwgXCJiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbW9yZSByb29tLCBhZGQgdG8gdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTE5NCUyOFZTLjg1JTI5LmFzcHhcbiAgICAgICAgICAgICAgICBkb2Muc3R5bGVTaGVldHNbMF0uYWRkUnVsZShcIi5ydm1sXCIsIFwiYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICFkb2MubmFtZXNwYWNlcy5ydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZChcInJ2bWxcIiwgXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XCJydm1sXCI+Jyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cInJ2bWxcIj4nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFIuX2VuZ2luZS5pbml0V2luKFIuX2cud2luKTtcbiAgICBSLl9lbmdpbmUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uID0gUi5fZ2V0Q29udGFpbmVyLmFwcGx5KDAsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb24uY29udGFpbmVyLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uLmhlaWdodCxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB3aWR0aCA9IGNvbi53aWR0aCxcbiAgICAgICAgICAgIHggPSBjb24ueCxcbiAgICAgICAgICAgIHkgPSBjb24ueTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZNTCBjb250YWluZXIgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gbmV3IFIuX1BhcGVyLFxuICAgICAgICAgICAgYyA9IHJlcy5jYW52YXMgPSBSLl9nLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgY3MgPSBjLnN0eWxlO1xuICAgICAgICB4ID0geCB8fCAwO1xuICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IDUxMjtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDM0MjtcbiAgICAgICAgcmVzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID09ICt3aWR0aCAmJiAod2lkdGggKz0gXCJweFwiKTtcbiAgICAgICAgaGVpZ2h0ID09ICtoZWlnaHQgJiYgKGhlaWdodCArPSBcInB4XCIpO1xuICAgICAgICByZXMuY29vcmRzaXplID0gem9vbSAqIDFlMyArIFMgKyB6b29tICogMWUzO1xuICAgICAgICByZXMuY29vcmRvcmlnaW4gPSBcIjAgMFwiO1xuICAgICAgICByZXMuc3BhbiA9IFIuX2cuZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICByZXMuc3Bhbi5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW07cGFkZGluZzowO21hcmdpbjowO2xpbmUtaGVpZ2h0OjE7XCI7XG4gICAgICAgIGMuYXBwZW5kQ2hpbGQocmVzLnNwYW4pO1xuICAgICAgICBjcy5jc3NUZXh0ID0gUi5mb3JtYXQoXCJ0b3A6MDtsZWZ0OjA7d2lkdGg6ezB9O2hlaWdodDp7MX07ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7Y2xpcDpyZWN0KDAgezB9IHsxfSAwKTtvdmVyZmxvdzpoaWRkZW5cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT0gMSkge1xuICAgICAgICAgICAgUi5fZy5kb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgIGNzLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgICAgICAgY3MudG9wID0geSArIFwicHhcIjtcbiAgICAgICAgICAgIGNzLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMucmVuZGVyZml4ID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUi5ldmUoXCJyYXBoYWVsLmNsZWFyXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLmNhbnZhcy5pbm5lckhUTUwgPSBFO1xuICAgICAgICB0aGlzLnNwYW4gPSBSLl9nLmRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGhpcy5zcGFuLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTk5OTllbTt0b3A6LTk5OTllbTtwYWRkaW5nOjA7bWFyZ2luOjA7bGluZS1oZWlnaHQ6MTtkaXNwbGF5OmlubGluZTtcIjtcbiAgICAgICAgdGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5zcGFuKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCA9IG51bGw7XG4gICAgfTtcbiAgICBSLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFIuZXZlKFwicmFwaGFlbC5yZW1vdmVcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB0eXBlb2YgdGhpc1tpXSA9PSBcImZ1bmN0aW9uXCIgPyBSLl9yZW1vdmVkRmFjdG9yeShpKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBzZXRwcm90byA9IFIuc3Q7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGVscHJvdG8pIGlmIChlbHByb3RvW2hhc10obWV0aG9kKSAmJiAhc2V0cHJvdG9baGFzXShtZXRob2QpKSB7XG4gICAgICAgIHNldHByb3RvW21ldGhvZF0gPSAoZnVuY3Rpb24gKG1ldGhvZG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbFttZXRob2RuYW1lXS5hcHBseShlbCwgYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG1ldGhvZCk7XG4gICAgfVxufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJldmVcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwgXCJldmVcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZXZlX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZXZlX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18iLCJSIiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJldmUiLCJmaXJzdCIsImlzIiwibG9hZGVkIiwib24iLCJhcnJheSIsIl9lbmdpbmUiLCJzcGxpY2UiLCJudSIsImFkZCIsImFyZ3MiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZiIsInBvcCIsInZlcnNpb24iLCJzZXBhcmF0b3IiLCJlbGVtZW50cyIsImNpcmNsZSIsInJlY3QiLCJwYXRoIiwiZWxsaXBzZSIsInRleHQiLCJpbWFnZSIsImZvcm1hdHJnIiwicHJvdG8iLCJoYXMiLCJnIiwiZG9jIiwiZG9jdW1lbnQiLCJ3aW4iLCJvbGRSYXBoYWVsIiwid2FzIiwiUmFwaGFlbCIsIlBhcGVyIiwiY2EiLCJjdXN0b21BdHRyaWJ1dGVzIiwicGFwZXJwcm90byIsImFwcGVuZENoaWxkIiwiY29uY2F0Iiwic3VwcG9ydHNUb3VjaCIsIlRvdWNoRXZlbnQiLCJEb2N1bWVudFRvdWNoIiwiRSIsIlMiLCJTdHIiLCJTdHJpbmciLCJzcGxpdCIsImV2ZW50cyIsInRvdWNoTWFwIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImxvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwibWF0aCIsIk1hdGgiLCJtbWF4IiwibWF4IiwibW1pbiIsIm1pbiIsImFicyIsInBvdyIsIlBJIiwic3RyaW5nIiwidG9TdHJpbmciLCJmaWxsU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJwYXBlciIsInB1c2giLCJJU1VSTCIsIl9JU1VSTCIsImNvbG91clJlZ0V4cCIsImlzbmFuIiwiYmV6aWVycmciLCJyb3VuZCIsInNldEF0dHJpYnV0ZSIsInRvRmxvYXQiLCJwYXJzZUZsb2F0IiwidG9JbnQiLCJwYXJzZUludCIsInVwcGVyQ2FzZSIsInRvVXBwZXJDYXNlIiwiYXZhaWxhYmxlQXR0cnMiLCJfYXZhaWxhYmxlQXR0cnMiLCJibHVyIiwiY3Vyc29yIiwiY3giLCJjeSIsImZpbGwiLCJmb250IiwiZ3JhZGllbnQiLCJoZWlnaHQiLCJocmVmIiwib3BhY2l0eSIsInJ4IiwicnkiLCJzcmMiLCJzdHJva2UiLCJ0YXJnZXQiLCJ0aXRsZSIsInRyYW5zZm9ybSIsIndpZHRoIiwieCIsInkiLCJhdmFpbGFibGVBbmltQXR0cnMiLCJfYXZhaWxhYmxlQW5pbUF0dHJzIiwid2hpdGVzcGFjZSIsImNvbW1hU3BhY2VzIiwiaHNyZyIsImhzIiwicmciLCJwMnMiLCJwYXRoQ29tbWFuZCIsInRDb21tYW5kIiwicGF0aFZhbHVlcyIsInJhZGlhbF9ncmFkaWVudCIsIl9yYWRpYWxfZ3JhZGllbnQiLCJlbGRhdGEiLCJzb3J0QnlLZXkiLCJhIiwiYiIsInNvcnRCeU51bWJlciIsImZ1biIsInBpcGUiLCJyZWN0UGF0aCIsIl9yZWN0UGF0aCIsInciLCJoIiwiZWxsaXBzZVBhdGgiLCJnZXRQYXRoIiwiX2dldFBhdGgiLCJlbCIsImF0dHIiLCJhdHRycyIsImJib3giLCJfZ2V0QkJveCIsInNldCIsIm1hcFBhdGgiLCJtYXRyaXgiLCJqIiwiaWkiLCJqaiIsInBhdGhpIiwicGF0aDJjdXJ2ZSIsIl9nIiwidHlwZSIsIlNWR0FuZ2xlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJzdHlsZSIsImJlaGF2aW9yIiwiYWRqIiwic3ZnIiwidm1sIiwiX1BhcGVyIiwiZm4iLCJfaWQiLCJpc0FycmF5IiwiY2xvbmUiLCJvYmoiLCJyZXMiLCJjb25zdHJ1Y3RvciIsImFuZ2xlIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwiYXRhbjIiLCJyYWQiLCJkZWciLCJzbmFwVG8iLCJ2YWx1ZXMiLCJ0b2xlcmFuY2UiLCJyZW0iLCJjcmVhdGVVVUlEIiwidXVpZFJlZ0V4IiwidXVpZFJlcGxhY2VyIiwicmVwbGFjZSIsInJhbmRvbSIsInYiLCJzZXRXaW5kb3ciLCJuZXd3aW4iLCJpbml0V2luIiwidG9IZXgiLCJjb2xvciIsInRyaW0iLCJib2QiLCJkb2N1bSIsIkFjdGl2ZVhPYmplY3QiLCJ3cml0ZSIsImNsb3NlIiwiYm9keSIsImUiLCJjcmVhdGVQb3B1cCIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY2FjaGVyIiwicXVlcnlDb21tYW5kVmFsdWUiLCJkaXNwbGF5IiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImhzYnRvU3RyaW5nIiwiaHNsdG9TdHJpbmciLCJyZ2J0b1N0cmluZyIsImhleCIsInByZXBhcmVSR0IiLCJjbHIiLCJnZXRSR0IiLCJwYWNrYWdlUkdCIiwicmdiIiwiaHNiMnJnYiIsImhzbDJyZ2IiLCJyZ2IyaHNsIiwicmdiMmhzYiIsIkciLCJCIiwiWCIsIkMiLCJIIiwiViIsIkwiLCJNIiwiX3BhdGgyc3RyaW5nIiwiam9pbiIsInJlcHVzaCIsIml0ZW0iLCJzY29wZSIsInBvc3Rwcm9jZXNzb3IiLCJuZXdmIiwiYXJnIiwiY2FjaGUiLCJjb3VudCIsInNoaWZ0IiwicHJlbG9hZCIsIl9wcmVsb2FkIiwiaW1nIiwiY3NzVGV4dCIsIm9ubG9hZCIsInJlbW92ZUNoaWxkIiwib25lcnJvciIsImNsclRvU3RyaW5nIiwiY29sb3VyIiwiaW5kZXhPZiIsImVycm9yIiwic3Vic3RyaW5nIiwiY2hhckF0IiwicmVkIiwiZ3JlZW4iLCJibHVlIiwibWF0Y2giLCJoc2IiLCJoc2wiLCJnZXRDb2xvciIsInN0YXJ0IiwicmVzZXQiLCJjYXRtdWxsUm9tMmJlemllciIsImNycCIsInoiLCJpTGVuIiwicGFyc2VQYXRoU3RyaW5nIiwicGF0aFN0cmluZyIsInB0aCIsInBhdGhzIiwiYXJyIiwicGF0aENsb25lIiwicGFyYW1Db3VudHMiLCJxIiwiZGF0YSIsInBhcmFtcyIsInBhcnNlVHJhbnNmb3JtU3RyaW5nIiwiVFN0cmluZyIsImVsZW0iLCJuZXdEYXRhIiwibmV3TGV2ZWwiLCJwcyIsInNsZWVwIiwic2V0VGltZW91dCIsImZpbmREb3RzQXRTZWdtZW50IiwicDF4IiwicDF5IiwiYzF4IiwiYzF5IiwiYzJ4IiwiYzJ5IiwicDJ4IiwicDJ5IiwidDEiLCJ0MTMiLCJ0MTIiLCJ0MiIsInQzIiwibXgiLCJteSIsIm54IiwibnkiLCJheCIsImF5IiwiYWxwaGEiLCJlbmQiLCJiZXppZXJCQm94IiwiY3VydmVEaW0iLCJpc1BvaW50SW5zaWRlQkJveCIsImlzQkJveEludGVyc2VjdCIsImJib3gxIiwiYmJveDIiLCJiYXNlMyIsInAxIiwicDIiLCJwMyIsInA0IiwiYmV6bGVuIiwieDQiLCJ5NCIsInoyIiwiVHZhbHVlcyIsIkN2YWx1ZXMiLCJzdW0iLCJjdCIsInhiYXNlIiwieWJhc2UiLCJjb21iIiwic3FydCIsImdldFRhdExlbiIsImxsIiwic3RlcCIsImludGVyc2VjdCIsImRlbm9taW5hdG9yIiwicHgiLCJweSIsInB4MiIsInRvRml4ZWQiLCJweTIiLCJpbnRlciIsImJlejEiLCJiZXoyIiwiaW50ZXJIZWxwZXIiLCJpbnRlckNvdW50IiwianVzdENvdW50IiwibDEiLCJsMiIsIm4xIiwibjIiLCJkb3RzMSIsImRvdHMyIiwieHkiLCJkaSIsImRpMSIsImRqIiwiZGoxIiwiY2kiLCJjaiIsInBhdGhJbnRlcnNlY3Rpb24iLCJwYXRoMSIsInBhdGgyIiwiaW50ZXJQYXRoSGVscGVyIiwicGF0aEludGVyc2VjdGlvbk51bWJlciIsIl9wYXRoMmN1cnZlIiwieDFtIiwieTFtIiwieDJtIiwieTJtIiwicGkiLCJwaiIsImludHIiLCJrIiwia2siLCJzZWdtZW50MSIsInNlZ21lbnQyIiwiaXNQb2ludEluc2lkZVBhdGgiLCJwYXRoQkJveCIsIl9yZW1vdmVkRmFjdG9yeSIsIm1ldGhvZG5hbWUiLCJwYXRoRGltZW5zaW9ucyIsIlkiLCJkaW0iLCJ4bWluIiwieW1pbiIsInhtYXgiLCJ5bWF4IiwiYmIiLCJwYXRoQXJyYXkiLCJwYXRoVG9SZWxhdGl2ZSIsIl9wYXRoVG9SZWxhdGl2ZSIsInJlbCIsInBhIiwibGVuIiwicGF0aFRvQWJzb2x1dGUiLCJfcGF0aFRvQWJzb2x1dGUiLCJjcnoiLCJkb3RzIiwibDJjIiwicTJjIiwiXzEzIiwiXzIzIiwiYTJjIiwibGFyZ2VfYXJjX2ZsYWciLCJzd2VlcF9mbGFnIiwicmVjdXJzaXZlIiwiXzEyMCIsInJvdGF0ZSIsImNvcyIsInNpbiIsInJ4MiIsInJ5MiIsImYxIiwiYXNpbiIsImYyIiwiZGYiLCJmMm9sZCIsIngyb2xkIiwieTJvbGQiLCJjMSIsInMxIiwiYzIiLCJzMiIsInRhbiIsImh4IiwiaHkiLCJtMSIsIm0yIiwibTMiLCJtNCIsIm5ld3JlcyIsImZpbmREb3RBdFNlZ21lbnQiLCJkb3QiLCJjdXJ2ZSIsImJ4IiwiYnkiLCJxeCIsInF5IiwiYXR0cnMyIiwicHJvY2Vzc1BhdGgiLCJwY29tIiwidHEiLCJUIiwiUSIsImZpeEFyYyIsInBwIiwicGNvbXMxIiwicGNvbXMyIiwiZml4TSIsImExIiwiYTIiLCJwZmlyc3QiLCJzZWciLCJzZWcyIiwic2VnbGVuIiwic2VnMmxlbiIsInBhcnNlRG90cyIsIl9wYXJzZURvdHMiLCJwYXIiLCJvZmZzZXQiLCJ0ZWFyIiwiX3RlYXIiLCJ0b3AiLCJwcmV2IiwiYm90dG9tIiwibmV4dCIsInRvZnJvbnQiLCJfdG9mcm9udCIsInRvYmFjayIsIl90b2JhY2siLCJpbnNlcnRhZnRlciIsIl9pbnNlcnRhZnRlciIsImVsMiIsImluc2VydGJlZm9yZSIsIl9pbnNlcnRiZWZvcmUiLCJ0b01hdHJpeCIsIl8iLCJnZXRCQm94IiwiZXh0cmFjdFRyYW5zZm9ybSIsInRyYW5zZm9ybVBhdGgiLCJfZXh0cmFjdFRyYW5zZm9ybSIsInRzdHIiLCJ0ZGF0YSIsImR4IiwiZHkiLCJzeCIsInN5IiwiTWF0cml4IiwidGxlbiIsImNvbW1hbmQiLCJhYnNvbHV0ZSIsImludmVyIiwiaW52ZXJ0IiwidHJhbnNsYXRlIiwic2NhbGUiLCJkaXJ0eVQiLCJnZXRFbXB0eSIsImVxdWFsaXNlVHJhbnNmb3JtIiwiX2VxdWFsaXNlVHJhbnNmb3JtIiwibWF4bGVuZ3RoIiwiZnJvbSIsInRvIiwidHQxIiwidHQyIiwiX2dldENvbnRhaW5lciIsImNvbnRhaW5lciIsImdldEVsZW1lbnRCeUlkIiwidGFnTmFtZSIsInBpeGVsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInBpeGVsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwibWF0cml4cHJvdG8iLCJvdXQiLCJtZSIsImZyb21DaGFyQ29kZSIsInRvRmlsdGVyIiwibm9ybSIsIm5vcm1hbGl6ZSIsIm1hZyIsInJvdyIsInNjYWxleCIsInNoZWFyIiwic2NhbGV5IiwiYWNvcyIsImlzU2ltcGxlIiwiaXNTdXBlclNpbXBsZSIsIm5vUm90YXRpb24iLCJ0b1RyYW5zZm9ybVN0cmluZyIsInNob3J0ZXIiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwicHJldmVudFRvdWNoIiwib3JpZ2luYWxFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsInN0b3BUb3VjaCIsImdldEV2ZW50UG9zaXRpb24iLCJzY3JvbGxZIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWCIsInNjcm9sbExlZnQiLCJjbGllbnRYIiwiY2xpZW50WSIsImFkZEV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImVsZW1lbnQiLCJwb3MiLCJfZiIsIm9sZGUiLCJ0YXJnZXRUb3VjaGVzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiZXZlbnQiLCJkZXRhY2hlciIsImRldGFjaEV2ZW50IiwiZHJhZyIsImRyYWdNb3ZlIiwiZHJhZ2kiLCJ0b3VjaGVzIiwidG91Y2giLCJpZGVudGlmaWVyIiwiX2RyYWciLCJpZCIsIm5vZGUiLCJuZXh0U2libGluZyIsInBhcmVudCIsInBhcmVudE5vZGUiLCJvcGVyYSIsImdldEVsZW1lbnRCeVBvaW50IiwiaW5zZXJ0QmVmb3JlIiwibW92ZV9zY29wZSIsImRyYWdVcCIsInVubW91c2Vtb3ZlIiwidW5tb3VzZXVwIiwiZW5kX3Njb3BlIiwic3RhcnRfc2NvcGUiLCJlbHByb3RvIiwiZXZlbnROYW1lIiwidW5iaW5kIiwic2hhcGUiLCJyZW1vdmVEYXRhIiwiZ2V0RGF0YSIsImhvdmVyIiwiZl9pbiIsImZfb3V0Iiwic2NvcGVfaW4iLCJzY29wZV9vdXQiLCJtb3VzZW92ZXIiLCJtb3VzZW91dCIsInVuaG92ZXIiLCJ1bm1vdXNlb3ZlciIsInVubW91c2VvdXQiLCJkcmFnZ2FibGUiLCJvbm1vdmUiLCJvbnN0YXJ0Iiwib25lbmQiLCJvbkRyYWdPdmVyIiwidW5kcmFnIiwidW5tb3VzZWRvd24iLCJfX3NldF9fIiwiZm9ybWF0IiwiaXRlbXNBcnJheSIsIlNldCIsInNldFN0YXJ0Iiwic2V0RmluaXNoIiwiZ2V0U2l6ZSIsImNhbnZhcyIsInNldFNpemUiLCJzZXRWaWV3Qm94IiwiZml0IiwicmFwaGFlbCIsImdldE9mZnNldCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm93bmVyRG9jdW1lbnQiLCJkb2NFbGVtIiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsInBhZ2VZT2Zmc2V0IiwibGVmdCIsInBhZ2VYT2Zmc2V0IiwiZWxlbWVudEZyb21Qb2ludCIsInNvIiwic3IiLCJjcmVhdGVTVkdSZWN0IiwiaGl0cyIsImdldEludGVyc2VjdGlvbkxpc3QiLCJnZXRCeUlkIiwicmFwaGFlbGlkIiwiZ2V0RWxlbWVudHNCeUJCb3giLCJmb3JFYWNoIiwiYm90IiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiZ2V0RWxlbWVudHNCeVBvaW50IiwiaXNQb2ludEluc2lkZSIsInhfeSIsInhfeV93X2giLCJycCIsInJlYWxQYXRoIiwiaXNXaXRob3V0VHJhbnNmb3JtIiwicmVtb3ZlZCIsImRpcnR5IiwiYmJveHd0IiwiZ2xvdyIsIm9mZnNldHgiLCJvZmZzZXR5IiwiY3VydmVzbGVuZ3RocyIsImdldFBvaW50QXRTZWdtZW50TGVuZ3RoIiwiZ2V0TGVuZ3RoRmFjdG9yeSIsImlzdG90YWwiLCJzdWJwYXRoIiwib25seXN0YXJ0Iiwic3AiLCJzdWJwYXRocyIsInBvaW50IiwiZ2V0VG90YWxMZW5ndGgiLCJnZXRQb2ludEF0TGVuZ3RoIiwiZ2V0U3VicGF0aHNBdExlbmd0aCIsImdldFN1YnBhdGgiLCJlZiIsImVhc2luZ19mb3JtdWxhcyIsImxpbmVhciIsImJhY2tJbiIsImJhY2tPdXQiLCJlbGFzdGljIiwiYm91bmNlIiwiZWFzZUluIiwiZWFzZU91dCIsImVhc2VJbk91dCIsImFuaW1hdGlvbkVsZW1lbnRzIiwicmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbiIsIk5vdyIsIkRhdGUiLCJwYXVzZWQiLCJ0aW1lIiwibXMiLCJlYXNpbmciLCJkaWZmIiwidGhhdCIsIm5vdyIsImluaXQiLCJpbml0c3RhdHVzIiwiYW5pbSIsInBlcmNlbnQiLCJzdGF0dXMiLCJzdG9wIiwidXB0bzI1NSIsInJlYWwiLCJmcm9tMiIsInJlcGVhdCIsInRvdGFsT3JpZ2luIiwicnVuQW5pbWF0aW9uIiwicGVyY2VudHMiLCJhbmltYXRlV2l0aCIsIkFuaW1hdGlvbiIsIkN1YmljQmV6aWVyQXRUaW1lIiwiZHVyYXRpb24iLCJzYW1wbGVDdXJ2ZVgiLCJzb2x2ZSIsImVwc2lsb24iLCJzb2x2ZUN1cnZlWCIsInQwIiwiZDIiLCJvbkFuaW1hdGlvbiIsIm5ld0FuaW0iLCJ0aW1lcyIsInNvcnQiLCJkZWxheSIsImRlbCIsImZsb29yIiwiaXNJbkFuaW0iLCJpc0luQW5pbVNldCIsInRpbWVzdGFtcCIsInRvQ29sb3VyIiwicGF0aGVzIiwidG9QYXRoIiwiZXEiLCJ0bzIiLCJlYXN5ZWFzeSIsIm9yaWdpbiIsImpzb24iLCJsYXN0S2V5IiwiYW5pbWF0ZSIsInNldFRpbWUiLCJwYXVzZSIsInJlc3VtZSIsInN0b3BBbmltYXRpb24iLCJpdGVtcyIsInNldHByb3RvIiwibWV0aG9kIiwiY2xlYXIiLCJpbmRleCIsImluc2VydGlvbiIsInRhaWwiLCJ0b2RlbCIsImFyZ2xlbiIsImV4Y2x1ZGUiLCJjb2xsZWN0b3IiLCJpbnNlcnRBZnRlciIsImdsb3dDb25maWciLCJyZXQiLCJzaGFwZTIiLCJpbmRleDIiLCJyZWdpc3RlckZvbnQiLCJmYWNlIiwiZm9udHMiLCJmb250Y29weSIsImdseXBocyIsImZhbWlseSIsInByb3AiLCJnbHlwaCIsImdldEZvbnQiLCJ3ZWlnaHQiLCJzdHJldGNoIiwibm9ybWFsIiwiYm9sZCIsImxpZ2h0ZXIiLCJib2xkZXIiLCJSZWdFeHAiLCJmb250TmFtZSIsInRlc3QiLCJ0aGVmb250IiwicHJpbnQiLCJzaXplIiwibGV0dGVyX3NwYWNpbmciLCJsaW5lX3NwYWNpbmciLCJsZXR0ZXJzIiwibm90Zmlyc3QiLCJsaW5lSGVpZ2h0Iiwic2hpZnR5IiwiZGVzY2VudCIsImN1cnIiLCJ0b2tlbiIsInN0ciIsImZ1bGxmaWxsIiwidG9rZW5SZWdleCIsIm9iak5vdGF0aW9uUmVnZXgiLCJyZXBsYWNlciIsImFsbCIsInF1b3RlIiwicXVvdGVkTmFtZSIsImlzRnVuYyIsIm5pbmphIiwic3QiLCJyZWFkeVN0YXRlIiwiaXNMb2FkZWQiLCJ4bGluayIsIm1hcmtlcnMiLCJibG9jayIsImNsYXNzaWMiLCJkaWFtb25kIiwib3BlbiIsIm92YWwiLCJtYXJrZXJDb3VudGVyIiwiJCIsInNldEF0dHJpYnV0ZU5TIiwiY3JlYXRlRWxlbWVudE5TIiwid2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IiLCJhZGRHcmFkaWVudEZpbGwiLCJmeCIsImZ5IiwiU1ZHIiwiX2Z4IiwiX2Z5IiwiZGlyIiwiaXNOYU4iLCJ2ZWN0b3IiLCJkZWZzIiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJpc0Zpbml0ZSIsImZpbGx1cmwiLCJmaWxsT3BhY2l0eSIsImlzSUU5b3IxMCIsImRvY3VtZW50TW9kZSIsImxvY2F0aW9uIiwibG9jYXRpb25TdHJpbmciLCJwcm90b2NvbCIsImhvc3QiLCJwYXRobmFtZSIsInNlYXJjaCIsInVwZGF0ZVBvc2l0aW9uIiwicGF0dGVybiIsInBhdHRlcm5UcmFuc2Zvcm0iLCJhZGRBcnJvdyIsImlzRW5kIiwic2UiLCJyZWZYIiwiYXJyb3dzIiwiZW5kUGF0aCIsImVuZE1hcmtlciIsInN0YXJ0UGF0aCIsInN0YXJ0TWFya2VyIiwicGF0aElkIiwibWFya2VySWQiLCJtYXJrZXIiLCJ1c2UiLCJtYXJrZXJIZWlnaHQiLCJtYXJrZXJXaWR0aCIsIm9yaWVudCIsInJlZlkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImRlbHRhIiwic3RhcnRkeCIsImVuZGR4IiwiZGFzaGFycmF5IiwiYWRkRGFzaGVzIiwiYnV0dCIsInNxdWFyZSIsImRhc2hlcyIsInNldEZpbGxBbmRTdHJva2UiLCJ2aXMiLCJ2aXNpYmlsaXR5IiwiYXR0Iiwibm9kZVZhbHVlIiwidmFsIiwiY3JlYXRlVGV4dE5vZGUiLCJwbiIsImhsIiwiY2xpcCIsInJjIiwiZ2V0QXR0cmlidXRlIiwic3RhcnRTdHJpbmciLCJlbmRTdHJpbmciLCJpc1VSTCIsImlnIiwicGF0dGVyblVuaXRzIiwic3RvcHMiLCJjc3NydWxlIiwidHVuZVRleHQiLCJsZWFkaW5nIiwiZm9udFNpemUiLCJ0ZXh0cyIsInRzcGFucyIsInRzcGFuIiwiZGlmIiwiZ2V0UmVhbE5vZGUiLCJFbGVtZW50IiwiZ3VpZCIsInN3IiwiaGlkZSIsInNob3ciLCJyZW1vdmUiLCJjYW52YXNIaWRkZW4iLCJjb250YWluZXJTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIm5hbWVzIiwiZGVmIiwic3Via2V5IiwidG9Gcm9udCIsInRvQmFjayIsImFmdGVyTm9kZSIsImJlZm9yZU5vZGUiLCJmbHRyIiwic3RkRGV2aWF0aW9uIiwiX2JsdXIiLCJmaWx0ZXIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiX3ZpZXdCb3giLCJjb24iLCJFcnJvciIsImNudnMiLCJjc3MiLCJpc0Zsb2F0aW5nIiwieG1sbnMiLCJfbGVmdCIsIl90b3AiLCJyZW5kZXJmaXgiLCJwYXBlclNpemUiLCJhc3BlY3RSYXRpbyIsInZiIiwiX3ZiU2l6ZSIsInZpZXdCb3giLCJnZXRTY3JlZW5DVE0iLCJjcmVhdGVTVkdNYXRyaXgiLCJkZXNjIiwibWFwIiwiWiIsImJpdGVzIiwiYmx1cnJlZ2V4cCIsImNzc0RvdCIsInpvb20iLCJwYXRoVHlwZXMiLCJvdmFsVHlwZXMiLCJwYXRoMnZtbCIsInRvdGFsIiwidmFscyIsImlzTW92ZSIsImNvbXBlbnNhdGlvbiIsInNldENvb3JkcyIsImZpbGxwb3MiLCJmbGlwIiwiZHhkeSIsImt4Iiwia3kiLCJjb29yZHNpemUiLCJyb3RhdGlvbiIsImNvb3Jkb3JpZ2luIiwiZmlsbHNpemUiLCJwb3NpdGlvbiIsIm5ld3BhdGgiLCJpc092YWwiLCJkaXYiLCJjbGlwUmVjdCIsImRzdHlsZSIsInRleHRwYXRoIiwidGV4dHBhdGhTdHlsZSIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwibmV3ZmlsbCIsImNyZWF0ZU5vZGUiLCJuZXdzdHJva2UiLCJzdHJva2VDb2xvciIsImpvaW5zdHlsZSIsIm1pdGVybGltaXQiLCJlbmRjYXAiLCJkYXNoc3R5bGUiLCJzcGFuIiwiYnJlY3QiLCJXIiwicmlnaHQiLCJkaXJ0eWF0dHJzIiwiZGQiLCJiYngiLCJvaW5kZXgiLCJmeGZ5IiwiY29sb3IyIiwiY2xycyIsImNvbG9ycyIsImZvY3VzIiwiZm9jdXNzaXplIiwiZm9jdXNwb3NpdGlvbiIsIl9vaWQiLCJ2YnMiLCJfdmlld0JveFNoaWZ0IiwidmJ0Iiwib2xkdCIsInNrZXciLCJpc0dyYWQiLCJpc1BhdHQiLCJiYnQiLCJhdXhHZXRCQm94IiwicnVudGltZVN0eWxlIiwibWFyZ2luIiwiUGF0aCIsInRleHRwYXRob2siLCJjcyIsInN0eWxlU2hlZXRzIiwiY3JlYXRlU3R5bGVTaGVldCIsImFkZFJ1bGUiLCJuYW1lc3BhY2VzIiwicnZtbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/vendor/libs/raphael/raphael.no-deps.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/vendor/libs/raphael/raphael.no-deps.js");
/******/ 	
/******/ })()
;